/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 166);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/sanitize-html/dist/sanitize-html.js":
/*!**********************************************************!*\
  !*** ./node_modules/sanitize-html/dist/sanitize-html.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;function _createForOfIteratorHelper(o,allowArrayLike){var it;if(typeof Symbol===\"undefined\"||o[Symbol.iterator]==null){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=o[Symbol.iterator]();},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _iterableToArray(iter){if(typeof Symbol!==\"undefined\"&&Symbol.iterator in Object(iter))return Array.from(iter);}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _typeof(obj){\"@babel/helpers - typeof\";if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};}return _typeof(obj);}(function(f){if(( false?undefined:_typeof(exports))===\"object\"&&typeof module!==\"undefined\"){module.exports=f();}else if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else{ var g; }})(function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a;}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r);},p,p.exports,r,e,n,t);}return n[i].exports;}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++){o(t[i]);}return o;}return r;}()({1:[function(require,module,exports){'use strict';exports.byteLength=byteLength;exports.toByteArray=toByteArray;exports.fromByteArray=fromByteArray;var lookup=[];var revLookup=[];var Arr=typeof Uint8Array!=='undefined'?Uint8Array:Array;var code='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';for(var i=0,len=code.length;i<len;++i){lookup[i]=code[i];revLookup[code.charCodeAt(i)]=i;}// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)]=62;revLookup['_'.charCodeAt(0)]=63;function getLens(b64){var len=b64.length;if(len%4>0){throw new Error('Invalid string. Length must be a multiple of 4');}// Trim off extra bytes after placeholder bytes are found\n// See: https://github.com/beatgammit/base64-js/issues/42\nvar validLen=b64.indexOf('=');if(validLen===-1)validLen=len;var placeHoldersLen=validLen===len?0:4-validLen%4;return[validLen,placeHoldersLen];}// base64 is 4/3 + up to two characters of the original data\nfunction byteLength(b64){var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function _byteLength(b64,validLen,placeHoldersLen){return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function toByteArray(b64){var tmp;var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];var arr=new Arr(_byteLength(b64,validLen,placeHoldersLen));var curByte=0;// if there are placeholders, only get up to the last complete 4 chars\nvar len=placeHoldersLen>0?validLen-4:validLen;var i;for(i=0;i<len;i+=4){tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)];arr[curByte++]=tmp>>16&0xFF;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===2){tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===1){tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}return arr;}function tripletToBase64(num){return lookup[num>>18&0x3F]+lookup[num>>12&0x3F]+lookup[num>>6&0x3F]+lookup[num&0x3F];}function encodeChunk(uint8,start,end){var tmp;var output=[];for(var i=start;i<end;i+=3){tmp=(uint8[i]<<16&0xFF0000)+(uint8[i+1]<<8&0xFF00)+(uint8[i+2]&0xFF);output.push(tripletToBase64(tmp));}return output.join('');}function fromByteArray(uint8){var tmp;var len=uint8.length;var extraBytes=len%3;// if we have 1 byte left, pad 2 bytes\nvar parts=[];var maxChunkLength=16383;// must be multiple of 3\n// go through the array every three bytes, we'll deal with trailing stuff later\nfor(var i=0,len2=len-extraBytes;i<len2;i+=maxChunkLength){parts.push(encodeChunk(uint8,i,i+maxChunkLength>len2?len2:i+maxChunkLength));}// pad the end with zeros, but make sure to not forget the extra bytes\nif(extraBytes===1){tmp=uint8[len-1];parts.push(lookup[tmp>>2]+lookup[tmp<<4&0x3F]+'==');}else if(extraBytes===2){tmp=(uint8[len-2]<<8)+uint8[len-1];parts.push(lookup[tmp>>10]+lookup[tmp>>4&0x3F]+lookup[tmp<<2&0x3F]+'=');}return parts.join('');}},{}],2:[function(require,module,exports){},{}],3:[function(require,module,exports){(function(Buffer){/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ /* eslint-disable no-proto */'use strict';var base64=require('base64-js');var ieee754=require('ieee754');exports.Buffer=Buffer;exports.SlowBuffer=SlowBuffer;exports.INSPECT_MAX_BYTES=50;var K_MAX_LENGTH=0x7fffffff;exports.kMaxLength=K_MAX_LENGTH;/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!=='undefined'&&typeof console.error==='function'){console.error('This browser lacks typed array (Uint8Array) support which is required by '+'`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');}function typedArraySupport(){// Can typed array instances can be augmented?\ntry{var arr=new Uint8Array(1);arr.__proto__={__proto__:Uint8Array.prototype,foo:function foo(){return 42;}};return arr.foo()===42;}catch(e){return false;}}Object.defineProperty(Buffer.prototype,'parent',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.buffer;}});Object.defineProperty(Buffer.prototype,'offset',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset;}});function createBuffer(length){if(length>K_MAX_LENGTH){throw new RangeError('The value \"'+length+'\" is invalid for option \"size\"');}// Return an augmented `Uint8Array` instance\nvar buf=new Uint8Array(length);buf.__proto__=Buffer.prototype;return buf;}/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */function Buffer(arg,encodingOrOffset,length){// Common case.\nif(typeof arg==='number'){if(typeof encodingOrOffset==='string'){throw new TypeError('The \"string\" argument must be of type string. Received type number');}return allocUnsafe(arg);}return from(arg,encodingOrOffset,length);}// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif(typeof Symbol!=='undefined'&&Symbol.species!=null&&Buffer[Symbol.species]===Buffer){Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:true,enumerable:false,writable:false});}Buffer.poolSize=8192;// not used by this implementation\nfunction from(value,encodingOrOffset,length){if(typeof value==='string'){return fromString(value,encodingOrOffset);}if(ArrayBuffer.isView(value)){return fromArrayLike(value);}if(value==null){throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}if(isInstance(value,ArrayBuffer)||value&&isInstance(value.buffer,ArrayBuffer)){return fromArrayBuffer(value,encodingOrOffset,length);}if(typeof value==='number'){throw new TypeError('The \"value\" argument must not be of type number. Received type number');}var valueOf=value.valueOf&&value.valueOf();if(valueOf!=null&&valueOf!==value){return Buffer.from(valueOf,encodingOrOffset,length);}var b=fromObject(value);if(b)return b;if(typeof Symbol!=='undefined'&&Symbol.toPrimitive!=null&&typeof value[Symbol.toPrimitive]==='function'){return Buffer.from(value[Symbol.toPrimitive]('string'),encodingOrOffset,length);}throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/Buffer.from=function(value,encodingOrOffset,length){return from(value,encodingOrOffset,length);};// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__=Uint8Array.prototype;Buffer.__proto__=Uint8Array;function assertSize(size){if(typeof size!=='number'){throw new TypeError('\"size\" argument must be of type number');}else if(size<0){throw new RangeError('The value \"'+size+'\" is invalid for option \"size\"');}}function alloc(size,fill,encoding){assertSize(size);if(size<=0){return createBuffer(size);}if(fill!==undefined){// Only pay attention to encoding if it's a string. This\n// prevents accidentally sending in a number that would\n// be interpretted as a start offset.\nreturn typeof encoding==='string'?createBuffer(size).fill(fill,encoding):createBuffer(size).fill(fill);}return createBuffer(size);}/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/Buffer.alloc=function(size,fill,encoding){return alloc(size,fill,encoding);};function allocUnsafe(size){assertSize(size);return createBuffer(size<0?0:checked(size)|0);}/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */Buffer.allocUnsafe=function(size){return allocUnsafe(size);};/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */Buffer.allocUnsafeSlow=function(size){return allocUnsafe(size);};function fromString(string,encoding){if(typeof encoding!=='string'||encoding===''){encoding='utf8';}if(!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}var length=byteLength(string,encoding)|0;var buf=createBuffer(length);var actual=buf.write(string,encoding);if(actual!==length){// Writing a hex string, for example, that contains invalid characters will\n// cause everything after the first invalid character to be ignored. (e.g.\n// 'abxxcd' will be treated as 'ab')\nbuf=buf.slice(0,actual);}return buf;}function fromArrayLike(array){var length=array.length<0?0:checked(array.length)|0;var buf=createBuffer(length);for(var i=0;i<length;i+=1){buf[i]=array[i]&255;}return buf;}function fromArrayBuffer(array,byteOffset,length){if(byteOffset<0||array.byteLength<byteOffset){throw new RangeError('\"offset\" is outside of buffer bounds');}if(array.byteLength<byteOffset+(length||0)){throw new RangeError('\"length\" is outside of buffer bounds');}var buf;if(byteOffset===undefined&&length===undefined){buf=new Uint8Array(array);}else if(length===undefined){buf=new Uint8Array(array,byteOffset);}else{buf=new Uint8Array(array,byteOffset,length);}// Return an augmented `Uint8Array` instance\nbuf.__proto__=Buffer.prototype;return buf;}function fromObject(obj){if(Buffer.isBuffer(obj)){var len=checked(obj.length)|0;var buf=createBuffer(len);if(buf.length===0){return buf;}obj.copy(buf,0,0,len);return buf;}if(obj.length!==undefined){if(typeof obj.length!=='number'||numberIsNaN(obj.length)){return createBuffer(0);}return fromArrayLike(obj);}if(obj.type==='Buffer'&&Array.isArray(obj.data)){return fromArrayLike(obj.data);}}function checked(length){// Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n// length is NaN (which is otherwise coerced to zero.)\nif(length>=K_MAX_LENGTH){throw new RangeError('Attempt to allocate Buffer larger than maximum '+'size: 0x'+K_MAX_LENGTH.toString(16)+' bytes');}return length|0;}function SlowBuffer(length){if(+length!=length){// eslint-disable-line eqeqeq\nlength=0;}return Buffer.alloc(+length);}Buffer.isBuffer=function isBuffer(b){return b!=null&&b._isBuffer===true&&b!==Buffer.prototype;// so Buffer.isBuffer(Buffer.prototype) will be false\n};Buffer.compare=function compare(a,b){if(isInstance(a,Uint8Array))a=Buffer.from(a,a.offset,a.byteLength);if(isInstance(b,Uint8Array))b=Buffer.from(b,b.offset,b.byteLength);if(!Buffer.isBuffer(a)||!Buffer.isBuffer(b)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');}if(a===b)return 0;var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len;++i){if(a[i]!==b[i]){x=a[i];y=b[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};Buffer.isEncoding=function isEncoding(encoding){switch(String(encoding).toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return true;default:return false;}};Buffer.concat=function concat(list,length){if(!Array.isArray(list)){throw new TypeError('\"list\" argument must be an Array of Buffers');}if(list.length===0){return Buffer.alloc(0);}var i;if(length===undefined){length=0;for(i=0;i<list.length;++i){length+=list[i].length;}}var buffer=Buffer.allocUnsafe(length);var pos=0;for(i=0;i<list.length;++i){var buf=list[i];if(isInstance(buf,Uint8Array)){buf=Buffer.from(buf);}if(!Buffer.isBuffer(buf)){throw new TypeError('\"list\" argument must be an Array of Buffers');}buf.copy(buffer,pos);pos+=buf.length;}return buffer;};function byteLength(string,encoding){if(Buffer.isBuffer(string)){return string.length;}if(ArrayBuffer.isView(string)||isInstance(string,ArrayBuffer)){return string.byteLength;}if(typeof string!=='string'){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+'Received type '+_typeof(string));}var len=string.length;var mustMatch=arguments.length>2&&arguments[2]===true;if(!mustMatch&&len===0)return 0;// Use a for loop to avoid recursion\nvar loweredCase=false;for(;;){switch(encoding){case'ascii':case'latin1':case'binary':return len;case'utf8':case'utf-8':return utf8ToBytes(string).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return len*2;case'hex':return len>>>1;case'base64':return base64ToBytes(string).length;default:if(loweredCase){return mustMatch?-1:utf8ToBytes(string).length;// assume utf8\n}encoding=(''+encoding).toLowerCase();loweredCase=true;}}}Buffer.byteLength=byteLength;function slowToString(encoding,start,end){var loweredCase=false;// No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\n// undefined is handled specially as per ECMA-262 6th Edition,\n// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\nif(start===undefined||start<0){start=0;}// Return early if start > this.length. Done here to prevent potential uint32\n// coercion fail below.\nif(start>this.length){return'';}if(end===undefined||end>this.length){end=this.length;}if(end<=0){return'';}// Force coersion to uint32. This will also coerce falsey/NaN values to 0.\nend>>>=0;start>>>=0;if(end<=start){return'';}if(!encoding)encoding='utf8';while(true){switch(encoding){case'hex':return hexSlice(this,start,end);case'utf8':case'utf-8':return utf8Slice(this,start,end);case'ascii':return asciiSlice(this,start,end);case'latin1':case'binary':return latin1Slice(this,start,end);case'base64':return base64Slice(this,start,end);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return utf16leSlice(this,start,end);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(encoding+'').toLowerCase();loweredCase=true;}}}// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer=true;function swap(b,n,m){var i=b[n];b[n]=b[m];b[m]=i;}Buffer.prototype.swap16=function swap16(){var len=this.length;if(len%2!==0){throw new RangeError('Buffer size must be a multiple of 16-bits');}for(var i=0;i<len;i+=2){swap(this,i,i+1);}return this;};Buffer.prototype.swap32=function swap32(){var len=this.length;if(len%4!==0){throw new RangeError('Buffer size must be a multiple of 32-bits');}for(var i=0;i<len;i+=4){swap(this,i,i+3);swap(this,i+1,i+2);}return this;};Buffer.prototype.swap64=function swap64(){var len=this.length;if(len%8!==0){throw new RangeError('Buffer size must be a multiple of 64-bits');}for(var i=0;i<len;i+=8){swap(this,i,i+7);swap(this,i+1,i+6);swap(this,i+2,i+5);swap(this,i+3,i+4);}return this;};Buffer.prototype.toString=function toString(){var length=this.length;if(length===0)return'';if(arguments.length===0)return utf8Slice(this,0,length);return slowToString.apply(this,arguments);};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(b){if(!Buffer.isBuffer(b))throw new TypeError('Argument must be a Buffer');if(this===b)return true;return Buffer.compare(this,b)===0;};Buffer.prototype.inspect=function inspect(){var str='';var max=exports.INSPECT_MAX_BYTES;str=this.toString('hex',0,max).replace(/(.{2})/g,'$1 ').trim();if(this.length>max)str+=' ... ';return'<Buffer '+str+'>';};Buffer.prototype.compare=function compare(target,start,end,thisStart,thisEnd){if(isInstance(target,Uint8Array)){target=Buffer.from(target,target.offset,target.byteLength);}if(!Buffer.isBuffer(target)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+'Received type '+_typeof(target));}if(start===undefined){start=0;}if(end===undefined){end=target?target.length:0;}if(thisStart===undefined){thisStart=0;}if(thisEnd===undefined){thisEnd=this.length;}if(start<0||end>target.length||thisStart<0||thisEnd>this.length){throw new RangeError('out of range index');}if(thisStart>=thisEnd&&start>=end){return 0;}if(thisStart>=thisEnd){return-1;}if(start>=end){return 1;}start>>>=0;end>>>=0;thisStart>>>=0;thisEnd>>>=0;if(this===target)return 0;var x=thisEnd-thisStart;var y=end-start;var len=Math.min(x,y);var thisCopy=this.slice(thisStart,thisEnd);var targetCopy=target.slice(start,end);for(var i=0;i<len;++i){if(thisCopy[i]!==targetCopy[i]){x=thisCopy[i];y=targetCopy[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){// Empty buffer means no match\nif(buffer.length===0)return-1;// Normalize byteOffset\nif(typeof byteOffset==='string'){encoding=byteOffset;byteOffset=0;}else if(byteOffset>0x7fffffff){byteOffset=0x7fffffff;}else if(byteOffset<-0x80000000){byteOffset=-0x80000000;}byteOffset=+byteOffset;// Coerce to Number.\nif(numberIsNaN(byteOffset)){// byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\nbyteOffset=dir?0:buffer.length-1;}// Normalize byteOffset: negative offsets start from the end of the buffer\nif(byteOffset<0)byteOffset=buffer.length+byteOffset;if(byteOffset>=buffer.length){if(dir)return-1;else byteOffset=buffer.length-1;}else if(byteOffset<0){if(dir)byteOffset=0;else return-1;}// Normalize val\nif(typeof val==='string'){val=Buffer.from(val,encoding);}// Finally, search either indexOf (if dir is true) or lastIndexOf\nif(Buffer.isBuffer(val)){// Special case: looking for empty string/buffer always fails\nif(val.length===0){return-1;}return arrayIndexOf(buffer,val,byteOffset,encoding,dir);}else if(typeof val==='number'){val=val&0xFF;// Search for a byte value [0-255]\nif(typeof Uint8Array.prototype.indexOf==='function'){if(dir){return Uint8Array.prototype.indexOf.call(buffer,val,byteOffset);}else{return Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset);}}return arrayIndexOf(buffer,[val],byteOffset,encoding,dir);}throw new TypeError('val must be string, number or Buffer');}function arrayIndexOf(arr,val,byteOffset,encoding,dir){var indexSize=1;var arrLength=arr.length;var valLength=val.length;if(encoding!==undefined){encoding=String(encoding).toLowerCase();if(encoding==='ucs2'||encoding==='ucs-2'||encoding==='utf16le'||encoding==='utf-16le'){if(arr.length<2||val.length<2){return-1;}indexSize=2;arrLength/=2;valLength/=2;byteOffset/=2;}}function read(buf,i){if(indexSize===1){return buf[i];}else{return buf.readUInt16BE(i*indexSize);}}var i;if(dir){var foundIndex=-1;for(i=byteOffset;i<arrLength;i++){if(read(arr,i)===read(val,foundIndex===-1?0:i-foundIndex)){if(foundIndex===-1)foundIndex=i;if(i-foundIndex+1===valLength)return foundIndex*indexSize;}else{if(foundIndex!==-1)i-=i-foundIndex;foundIndex=-1;}}}else{if(byteOffset+valLength>arrLength)byteOffset=arrLength-valLength;for(i=byteOffset;i>=0;i--){var found=true;for(var j=0;j<valLength;j++){if(read(arr,i+j)!==read(val,j)){found=false;break;}}if(found)return i;}}return-1;}Buffer.prototype.includes=function includes(val,byteOffset,encoding){return this.indexOf(val,byteOffset,encoding)!==-1;};Buffer.prototype.indexOf=function indexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,true);};Buffer.prototype.lastIndexOf=function lastIndexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,false);};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining;}else{length=Number(length);if(length>remaining){length=remaining;}}var strLen=string.length;if(length>strLen/2){length=strLen/2;}for(var i=0;i<length;++i){var parsed=parseInt(string.substr(i*2,2),16);if(numberIsNaN(parsed))return i;buf[offset+i]=parsed;}return i;}function utf8Write(buf,string,offset,length){return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length);}function asciiWrite(buf,string,offset,length){return blitBuffer(asciiToBytes(string),buf,offset,length);}function latin1Write(buf,string,offset,length){return asciiWrite(buf,string,offset,length);}function base64Write(buf,string,offset,length){return blitBuffer(base64ToBytes(string),buf,offset,length);}function ucs2Write(buf,string,offset,length){return blitBuffer(utf16leToBytes(string,buf.length-offset),buf,offset,length);}Buffer.prototype.write=function write(string,offset,length,encoding){// Buffer#write(string)\nif(offset===undefined){encoding='utf8';length=this.length;offset=0;// Buffer#write(string, encoding)\n}else if(length===undefined&&typeof offset==='string'){encoding=offset;length=this.length;offset=0;// Buffer#write(string, offset[, length][, encoding])\n}else if(isFinite(offset)){offset=offset>>>0;if(isFinite(length)){length=length>>>0;if(encoding===undefined)encoding='utf8';}else{encoding=length;length=undefined;}}else{throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');}var remaining=this.length-offset;if(length===undefined||length>remaining)length=remaining;if(string.length>0&&(length<0||offset<0)||offset>this.length){throw new RangeError('Attempt to write outside buffer bounds');}if(!encoding)encoding='utf8';var loweredCase=false;for(;;){switch(encoding){case'hex':return hexWrite(this,string,offset,length);case'utf8':case'utf-8':return utf8Write(this,string,offset,length);case'ascii':return asciiWrite(this,string,offset,length);case'latin1':case'binary':return latin1Write(this,string,offset,length);case'base64':// Warning: maxLength not taken into account in base64Write\nreturn base64Write(this,string,offset,length);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return ucs2Write(this,string,offset,length);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(''+encoding).toLowerCase();loweredCase=true;}}};Buffer.prototype.toJSON=function toJSON(){return{type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)};};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return base64.fromByteArray(buf);}else{return base64.fromByteArray(buf.slice(start,end));}}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);var res=[];var i=start;while(i<end){var firstByte=buf[i];var codePoint=null;var bytesPerSequence=firstByte>0xEF?4:firstByte>0xDF?3:firstByte>0xBF?2:1;if(i+bytesPerSequence<=end){var secondByte,thirdByte,fourthByte,tempCodePoint;switch(bytesPerSequence){case 1:if(firstByte<0x80){codePoint=firstByte;}break;case 2:secondByte=buf[i+1];if((secondByte&0xC0)===0x80){tempCodePoint=(firstByte&0x1F)<<0x6|secondByte&0x3F;if(tempCodePoint>0x7F){codePoint=tempCodePoint;}}break;case 3:secondByte=buf[i+1];thirdByte=buf[i+2];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0xC|(secondByte&0x3F)<<0x6|thirdByte&0x3F;if(tempCodePoint>0x7FF&&(tempCodePoint<0xD800||tempCodePoint>0xDFFF)){codePoint=tempCodePoint;}}break;case 4:secondByte=buf[i+1];thirdByte=buf[i+2];fourthByte=buf[i+3];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80&&(fourthByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0x12|(secondByte&0x3F)<<0xC|(thirdByte&0x3F)<<0x6|fourthByte&0x3F;if(tempCodePoint>0xFFFF&&tempCodePoint<0x110000){codePoint=tempCodePoint;}}}}if(codePoint===null){// we did not generate a valid codePoint so insert a\n// replacement char (U+FFFD) and advance only 1 byte\ncodePoint=0xFFFD;bytesPerSequence=1;}else if(codePoint>0xFFFF){// encode to utf16 (surrogate pair dance)\ncodePoint-=0x10000;res.push(codePoint>>>10&0x3FF|0xD800);codePoint=0xDC00|codePoint&0x3FF;}res.push(codePoint);i+=bytesPerSequence;}return decodeCodePointsArray(res);}// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH=0x1000;function decodeCodePointsArray(codePoints){var len=codePoints.length;if(len<=MAX_ARGUMENTS_LENGTH){return String.fromCharCode.apply(String,codePoints);// avoid extra slice()\n}// Decode in chunks to avoid \"call stack size exceeded\".\nvar res='';var i=0;while(i<len){res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH));}return res;}function asciiSlice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]&0x7F);}return ret;}function latin1Slice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]);}return ret;}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out='';for(var i=start;i<end;++i){out+=toHex(buf[i]);}return out;}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res='';for(var i=0;i<bytes.length;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256);}return res;}Buffer.prototype.slice=function slice(start,end){var len=this.length;start=~~start;end=end===undefined?len:~~end;if(start<0){start+=len;if(start<0)start=0;}else if(start>len){start=len;}if(end<0){end+=len;if(end<0)end=0;}else if(end>len){end=len;}if(end<start)end=start;var newBuf=this.subarray(start,end);// Return an augmented `Uint8Array` instance\nnewBuf.__proto__=Buffer.prototype;return newBuf;};/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */function checkOffset(offset,ext,length){if(offset%1!==0||offset<0)throw new RangeError('offset is not uint');if(offset+ext>length)throw new RangeError('Trying to access beyond buffer length');}Buffer.prototype.readUIntLE=function readUIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}return val;};Buffer.prototype.readUIntBE=function readUIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){checkOffset(offset,byteLength,this.length);}var val=this[offset+--byteLength];var mul=1;while(byteLength>0&&(mul*=0x100)){val+=this[offset+--byteLength]*mul;}return val;};Buffer.prototype.readUInt8=function readUInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);return this[offset];};Buffer.prototype.readUInt16LE=function readUInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]|this[offset+1]<<8;};Buffer.prototype.readUInt16BE=function readUInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]<<8|this[offset+1];};Buffer.prototype.readUInt32LE=function readUInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return(this[offset]|this[offset+1]<<8|this[offset+2]<<16)+this[offset+3]*0x1000000;};Buffer.prototype.readUInt32BE=function readUInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]*0x1000000+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3]);};Buffer.prototype.readIntLE=function readIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readIntBE=function readIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var i=byteLength;var mul=1;var val=this[offset+--i];while(i>0&&(mul*=0x100)){val+=this[offset+--i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readInt8=function readInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);if(!(this[offset]&0x80))return this[offset];return(0xff-this[offset]+1)*-1;};Buffer.prototype.readInt16LE=function readInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset]|this[offset+1]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt16BE=function readInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset+1]|this[offset]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt32LE=function readInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24;};Buffer.prototype.readInt32BE=function readInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3];};Buffer.prototype.readFloatLE=function readFloatLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,true,23,4);};Buffer.prototype.readFloatBE=function readFloatBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,false,23,4);};Buffer.prototype.readDoubleLE=function readDoubleLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,true,52,8);};Buffer.prototype.readDoubleBE=function readDoubleBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,false,52,8);};function checkInt(buf,value,offset,ext,max,min){if(!Buffer.isBuffer(buf))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(value>max||value<min)throw new RangeError('\"value\" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError('Index out of range');}Buffer.prototype.writeUIntLE=function writeUIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var mul=1;var i=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUIntBE=function writeUIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var i=byteLength-1;var mul=1;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUInt8=function writeUInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0xff,0);this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeUInt16LE=function writeUInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeUInt16BE=function writeUInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeUInt32LE=function writeUInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset+3]=value>>>24;this[offset+2]=value>>>16;this[offset+1]=value>>>8;this[offset]=value&0xff;return offset+4;};Buffer.prototype.writeUInt32BE=function writeUInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};Buffer.prototype.writeIntLE=function writeIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=0;var mul=1;var sub=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i-1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeIntBE=function writeIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=byteLength-1;var mul=1;var sub=0;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i+1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeInt8=function writeInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0x7f,-0x80);if(value<0)value=0xff+value+1;this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeInt16LE=function writeInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeInt16BE=function writeInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeInt32LE=function writeInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);this[offset]=value&0xff;this[offset+1]=value>>>8;this[offset+2]=value>>>16;this[offset+3]=value>>>24;return offset+4;};Buffer.prototype.writeInt32BE=function writeInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);if(value<0)value=0xffffffff+value+1;this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError('Index out of range');if(offset<0)throw new RangeError('Index out of range');}function writeFloat(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,4,3.4028234663852886e+38,-3.4028234663852886e+38);}ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4;}Buffer.prototype.writeFloatLE=function writeFloatLE(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert);};Buffer.prototype.writeFloatBE=function writeFloatBE(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert);};function writeDouble(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,8,1.7976931348623157E+308,-1.7976931348623157E+308);}ieee754.write(buf,value,offset,littleEndian,52,8);return offset+8;}Buffer.prototype.writeDoubleLE=function writeDoubleLE(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert);};Buffer.prototype.writeDoubleBE=function writeDoubleBE(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert);};// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy=function copy(target,targetStart,start,end){if(!Buffer.isBuffer(target))throw new TypeError('argument should be a Buffer');if(!start)start=0;if(!end&&end!==0)end=this.length;if(targetStart>=target.length)targetStart=target.length;if(!targetStart)targetStart=0;if(end>0&&end<start)end=start;// Copy 0 bytes; we're done\nif(end===start)return 0;if(target.length===0||this.length===0)return 0;// Fatal error conditions\nif(targetStart<0){throw new RangeError('targetStart out of bounds');}if(start<0||start>=this.length)throw new RangeError('Index out of range');if(end<0)throw new RangeError('sourceEnd out of bounds');// Are we oob?\nif(end>this.length)end=this.length;if(target.length-targetStart<end-start){end=target.length-targetStart+start;}var len=end-start;if(this===target&&typeof Uint8Array.prototype.copyWithin==='function'){// Use built-in when available, missing from IE11\nthis.copyWithin(targetStart,start,end);}else if(this===target&&start<targetStart&&targetStart<end){// descending copy from end\nfor(var i=len-1;i>=0;--i){target[i+targetStart]=this[i+start];}}else{Uint8Array.prototype.set.call(target,this.subarray(start,end),targetStart);}return len;};// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill=function fill(val,start,end,encoding){// Handle string cases:\nif(typeof val==='string'){if(typeof start==='string'){encoding=start;start=0;end=this.length;}else if(typeof end==='string'){encoding=end;end=this.length;}if(encoding!==undefined&&typeof encoding!=='string'){throw new TypeError('encoding must be a string');}if(typeof encoding==='string'&&!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}if(val.length===1){var code=val.charCodeAt(0);if(encoding==='utf8'&&code<128||encoding==='latin1'){// Fast path: If `val` fits into a single byte, use that numeric value.\nval=code;}}}else if(typeof val==='number'){val=val&255;}// Invalid ranges are not set to a default, so can range check early.\nif(start<0||this.length<start||this.length<end){throw new RangeError('Out of range index');}if(end<=start){return this;}start=start>>>0;end=end===undefined?this.length:end>>>0;if(!val)val=0;var i;if(typeof val==='number'){for(i=start;i<end;++i){this[i]=val;}}else{var bytes=Buffer.isBuffer(val)?val:Buffer.from(val,encoding);var len=bytes.length;if(len===0){throw new TypeError('The value \"'+val+'\" is invalid for argument \"value\"');}for(i=0;i<end-start;++i){this[i+start]=bytes[i%len];}}return this;};// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g;function base64clean(str){// Node takes equal signs as end of the Base64 encoding\nstr=str.split('=')[0];// Node strips out invalid characters like \\n and \\t from the string, base64-js does not\nstr=str.trim().replace(INVALID_BASE64_RE,'');// Node converts strings with length < 2 to ''\nif(str.length<2)return'';// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\nwhile(str.length%4!==0){str=str+'=';}return str;}function toHex(n){if(n<16)return'0'+n.toString(16);return n.toString(16);}function utf8ToBytes(string,units){units=units||Infinity;var codePoint;var length=string.length;var leadSurrogate=null;var bytes=[];for(var i=0;i<length;++i){codePoint=string.charCodeAt(i);// is surrogate component\nif(codePoint>0xD7FF&&codePoint<0xE000){// last char was a lead\nif(!leadSurrogate){// no lead yet\nif(codePoint>0xDBFF){// unexpected trail\nif((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}else if(i+1===length){// unpaired lead\nif((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}// valid lead\nleadSurrogate=codePoint;continue;}// 2 leads in a row\nif(codePoint<0xDC00){if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);leadSurrogate=codePoint;continue;}// valid surrogate pair\ncodePoint=(leadSurrogate-0xD800<<10|codePoint-0xDC00)+0x10000;}else if(leadSurrogate){// valid bmp char, but last char was a lead\nif((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);}leadSurrogate=null;// encode utf8\nif(codePoint<0x80){if((units-=1)<0)break;bytes.push(codePoint);}else if(codePoint<0x800){if((units-=2)<0)break;bytes.push(codePoint>>0x6|0xC0,codePoint&0x3F|0x80);}else if(codePoint<0x10000){if((units-=3)<0)break;bytes.push(codePoint>>0xC|0xE0,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else if(codePoint<0x110000){if((units-=4)<0)break;bytes.push(codePoint>>0x12|0xF0,codePoint>>0xC&0x3F|0x80,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else{throw new Error('Invalid code point');}}return bytes;}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;++i){// Node's code seems to be doing this and not & 0x7F..\nbyteArray.push(str.charCodeAt(i)&0xFF);}return byteArray;}function utf16leToBytes(str,units){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;++i){if((units-=2)<0)break;c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi);}return byteArray;}function base64ToBytes(str){return base64.toByteArray(base64clean(str));}function blitBuffer(src,dst,offset,length){for(var i=0;i<length;++i){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i];}return i;}// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance(obj,type){return obj instanceof type||obj!=null&&obj.constructor!=null&&obj.constructor.name!=null&&obj.constructor.name===type.name;}function numberIsNaN(obj){// For IE11 support\nreturn obj!==obj;// eslint-disable-line no-self-compare\n}}).call(this,require(\"buffer\").Buffer);},{\"base64-js\":1,\"buffer\":3,\"ieee754\":32}],4:[function(require,module,exports){module.exports={\"elementNames\":{\"altglyph\":\"altGlyph\",\"altglyphdef\":\"altGlyphDef\",\"altglyphitem\":\"altGlyphItem\",\"animatecolor\":\"animateColor\",\"animatemotion\":\"animateMotion\",\"animatetransform\":\"animateTransform\",\"clippath\":\"clipPath\",\"feblend\":\"feBlend\",\"fecolormatrix\":\"feColorMatrix\",\"fecomponenttransfer\":\"feComponentTransfer\",\"fecomposite\":\"feComposite\",\"feconvolvematrix\":\"feConvolveMatrix\",\"fediffuselighting\":\"feDiffuseLighting\",\"fedisplacementmap\":\"feDisplacementMap\",\"fedistantlight\":\"feDistantLight\",\"fedropshadow\":\"feDropShadow\",\"feflood\":\"feFlood\",\"fefunca\":\"feFuncA\",\"fefuncb\":\"feFuncB\",\"fefuncg\":\"feFuncG\",\"fefuncr\":\"feFuncR\",\"fegaussianblur\":\"feGaussianBlur\",\"feimage\":\"feImage\",\"femerge\":\"feMerge\",\"femergenode\":\"feMergeNode\",\"femorphology\":\"feMorphology\",\"feoffset\":\"feOffset\",\"fepointlight\":\"fePointLight\",\"fespecularlighting\":\"feSpecularLighting\",\"fespotlight\":\"feSpotLight\",\"fetile\":\"feTile\",\"feturbulence\":\"feTurbulence\",\"foreignobject\":\"foreignObject\",\"glyphref\":\"glyphRef\",\"lineargradient\":\"linearGradient\",\"radialgradient\":\"radialGradient\",\"textpath\":\"textPath\"},\"attributeNames\":{\"definitionurl\":\"definitionURL\",\"attributename\":\"attributeName\",\"attributetype\":\"attributeType\",\"basefrequency\":\"baseFrequency\",\"baseprofile\":\"baseProfile\",\"calcmode\":\"calcMode\",\"clippathunits\":\"clipPathUnits\",\"diffuseconstant\":\"diffuseConstant\",\"edgemode\":\"edgeMode\",\"filterunits\":\"filterUnits\",\"glyphref\":\"glyphRef\",\"gradienttransform\":\"gradientTransform\",\"gradientunits\":\"gradientUnits\",\"kernelmatrix\":\"kernelMatrix\",\"kernelunitlength\":\"kernelUnitLength\",\"keypoints\":\"keyPoints\",\"keysplines\":\"keySplines\",\"keytimes\":\"keyTimes\",\"lengthadjust\":\"lengthAdjust\",\"limitingconeangle\":\"limitingConeAngle\",\"markerheight\":\"markerHeight\",\"markerunits\":\"markerUnits\",\"markerwidth\":\"markerWidth\",\"maskcontentunits\":\"maskContentUnits\",\"maskunits\":\"maskUnits\",\"numoctaves\":\"numOctaves\",\"pathlength\":\"pathLength\",\"patterncontentunits\":\"patternContentUnits\",\"patterntransform\":\"patternTransform\",\"patternunits\":\"patternUnits\",\"pointsatx\":\"pointsAtX\",\"pointsaty\":\"pointsAtY\",\"pointsatz\":\"pointsAtZ\",\"preservealpha\":\"preserveAlpha\",\"preserveaspectratio\":\"preserveAspectRatio\",\"primitiveunits\":\"primitiveUnits\",\"refx\":\"refX\",\"refy\":\"refY\",\"repeatcount\":\"repeatCount\",\"repeatdur\":\"repeatDur\",\"requiredextensions\":\"requiredExtensions\",\"requiredfeatures\":\"requiredFeatures\",\"specularconstant\":\"specularConstant\",\"specularexponent\":\"specularExponent\",\"spreadmethod\":\"spreadMethod\",\"startoffset\":\"startOffset\",\"stddeviation\":\"stdDeviation\",\"stitchtiles\":\"stitchTiles\",\"surfacescale\":\"surfaceScale\",\"systemlanguage\":\"systemLanguage\",\"tablevalues\":\"tableValues\",\"targetx\":\"targetX\",\"targety\":\"targetY\",\"textlength\":\"textLength\",\"viewbox\":\"viewBox\",\"viewtarget\":\"viewTarget\",\"xchannelselector\":\"xChannelSelector\",\"ychannelselector\":\"yChannelSelector\",\"zoomandpan\":\"zoomAndPan\"}};},{}],5:[function(require,module,exports){/*\n  Module dependencies\n*/var ElementType=require('domelementtype');var entities=require('entities');/* mixed-case SVG and MathML tags & attributes\n   recognized by the HTML parser, see\n   https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign\n*/var foreignNames=require('./foreignNames.json');foreignNames.elementNames.__proto__=null;/* use as a simple dictionary */foreignNames.attributeNames.__proto__=null;var unencodedElements={__proto__:null,style:true,script:true,xmp:true,iframe:true,noembed:true,noframes:true,plaintext:true,noscript:true};/*\n  Format attributes\n*/function formatAttrs(attributes,opts){if(!attributes)return;var output='';var value;// Loop through the attributes\nfor(var key in attributes){value=attributes[key];if(output){output+=' ';}if(opts.xmlMode==='foreign'){/* fix up mixed-case attribute names */key=foreignNames.attributeNames[key]||key;}output+=key;if(value!==null&&value!==''||opts.xmlMode){output+='=\"'+(opts.decodeEntities?entities.encodeXML(value):value.replace(/\\\"/g,'&quot;'))+'\"';}}return output;}/*\n  Self-enclosing tags (stolen from node-htmlparser)\n*/var singleTag={__proto__:null,area:true,base:true,basefont:true,br:true,col:true,command:true,embed:true,frame:true,hr:true,img:true,input:true,isindex:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};var render=module.exports=function(dom,opts){if(!Array.isArray(dom)&&!dom.cheerio)dom=[dom];opts=opts||{};var output='';for(var i=0;i<dom.length;i++){var elem=dom[i];if(elem.type==='root')output+=render(elem.children,opts);else if(ElementType.isTag(elem))output+=renderTag(elem,opts);else if(elem.type===ElementType.Directive)output+=renderDirective(elem);else if(elem.type===ElementType.Comment)output+=renderComment(elem);else if(elem.type===ElementType.CDATA)output+=renderCdata(elem);else output+=renderText(elem,opts);}return output;};var foreignModeIntegrationPoints=['mi','mo','mn','ms','mtext','annotation-xml','foreignObject','desc','title'];function renderTag(elem,opts){// Handle SVG / MathML in HTML\nif(opts.xmlMode==='foreign'){/* fix up mixed-case element names */elem.name=foreignNames.elementNames[elem.name]||elem.name;/* exit foreign mode at integration points */if(elem.parent&&foreignModeIntegrationPoints.indexOf(elem.parent.name)>=0)opts=Object.assign({},opts,{xmlMode:false});}if(!opts.xmlMode&&['svg','math'].indexOf(elem.name)>=0){opts=Object.assign({},opts,{xmlMode:'foreign'});}var tag='<'+elem.name;var attribs=formatAttrs(elem.attribs,opts);if(attribs){tag+=' '+attribs;}if(opts.xmlMode&&(!elem.children||elem.children.length===0)){tag+='/>';}else{tag+='>';if(elem.children){tag+=render(elem.children,opts);}if(!singleTag[elem.name]||opts.xmlMode){tag+='</'+elem.name+'>';}}return tag;}function renderDirective(elem){return'<'+elem.data+'>';}function renderText(elem,opts){var data=elem.data||'';// if entities weren't decoded, no need to encode them back\nif(opts.decodeEntities&&!(elem.parent&&elem.parent.name in unencodedElements)){data=entities.encodeXML(data);}return data;}function renderCdata(elem){return'<![CDATA['+elem.children[0].data+']]>';}function renderComment(elem){return'<!--'+elem.data+'-->';}},{\"./foreignNames.json\":4,\"domelementtype\":6,\"entities\":20}],6:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});/**\n * Tests whether an element is a tag or not.\n *\n * @param elem Element to test\n */function isTag(elem){return elem.type===\"tag\"/* Tag */||elem.type===\"script\"/* Script */||elem.type===\"style\"/* Style */;}exports.isTag=isTag;// Exports for backwards compatibility\nexports.Text=\"text\"/* Text */;//Text\nexports.Directive=\"directive\"/* Directive */;//<? ... ?>\nexports.Comment=\"comment\"/* Comment */;//<!-- ... -->\nexports.Script=\"script\"/* Script */;//<script> tags\nexports.Style=\"style\"/* Style */;//<style> tags\nexports.Tag=\"tag\"/* Tag */;//Any tag\nexports.CDATA=\"cdata\"/* CDATA */;//<![CDATA[ ... ]]>\nexports.Doctype=\"doctype\"/* Doctype */;},{}],7:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var node_1=require(\"./node\");exports.Node=node_1.Node;exports.Element=node_1.Element;exports.DataNode=node_1.DataNode;exports.NodeWithChildren=node_1.NodeWithChildren;var reWhitespace=/\\s+/g;// Default options\nvar defaultOpts={normalizeWhitespace:false,withStartIndices:false,withEndIndices:false};var DomHandler=/** @class */function(){/**\n     * Initiate a new DomHandler.\n     *\n     * @param callback Called once parsing has completed.\n     * @param options Settings for the handler.\n     * @param elementCB Callback whenever a tag is closed.\n     */function DomHandler(callback,options,elementCB){/** The constructed DOM */this.dom=[];/** Indicated whether parsing has been completed. */this._done=false;/** Stack of open tags. */this._tagStack=[];/** A data node that is still being written to. */this._lastNode=null;/** Reference to the parser instance. Used for location information. */this._parser=null;// Make it possible to skip arguments, for backwards-compatibility\nif(typeof options===\"function\"){elementCB=options;options=defaultOpts;}if(_typeof(callback)===\"object\"){options=callback;callback=undefined;}this._callback=callback||null;this._options=options||defaultOpts;this._elementCB=elementCB||null;}DomHandler.prototype.onparserinit=function(parser){this._parser=parser;};// Resets the handler back to starting state\nDomHandler.prototype.onreset=function(){this.dom=[];this._done=false;this._tagStack=[];this._lastNode=null;this._parser=this._parser||null;};// Signals the handler that parsing is done\nDomHandler.prototype.onend=function(){if(this._done)return;this._done=true;this._parser=null;this.handleCallback(null);};DomHandler.prototype.onerror=function(error){this.handleCallback(error);};DomHandler.prototype.onclosetag=function(){this._lastNode=null;// If(this._tagStack.pop().name !== name) this.handleCallback(Error(\"Tagname didn't match!\"));\nvar elem=this._tagStack.pop();if(!elem||!this._parser){return;}if(this._options.withEndIndices){elem.endIndex=this._parser.endIndex;}if(this._elementCB)this._elementCB(elem);};DomHandler.prototype.onopentag=function(name,attribs){var element=new node_1.Element(name,attribs);this.addNode(element);this._tagStack.push(element);};DomHandler.prototype.ontext=function(data){var normalize=this._options.normalizeWhitespace;var _lastNode=this._lastNode;if(_lastNode&&_lastNode.type===\"text\"/* Text */){if(normalize){_lastNode.data=(_lastNode.data+data).replace(reWhitespace,\" \");}else{_lastNode.data+=data;}}else{if(normalize){data=data.replace(reWhitespace,\" \");}var node=new node_1.DataNode(\"text\"/* Text */,data);this.addNode(node);this._lastNode=node;}};DomHandler.prototype.oncomment=function(data){if(this._lastNode&&this._lastNode.type===\"comment\"/* Comment */){this._lastNode.data+=data;return;}var node=new node_1.DataNode(\"comment\"/* Comment */,data);this.addNode(node);this._lastNode=node;};DomHandler.prototype.oncommentend=function(){this._lastNode=null;};DomHandler.prototype.oncdatastart=function(){var text=new node_1.DataNode(\"text\"/* Text */,\"\");var node=new node_1.NodeWithChildren(\"cdata\"/* CDATA */,[text]);this.addNode(node);text.parent=node;this._lastNode=text;};DomHandler.prototype.oncdataend=function(){this._lastNode=null;};DomHandler.prototype.onprocessinginstruction=function(name,data){var node=new node_1.ProcessingInstruction(name,data);this.addNode(node);};DomHandler.prototype.handleCallback=function(error){if(typeof this._callback===\"function\"){this._callback(error,this.dom);}else if(error){throw error;}};DomHandler.prototype.addNode=function(node){var parent=this._tagStack[this._tagStack.length-1];var siblings=parent?parent.children:this.dom;var previousSibling=siblings[siblings.length-1];if(this._parser){if(this._options.withStartIndices){node.startIndex=this._parser.startIndex;}if(this._options.withEndIndices){node.endIndex=this._parser.endIndex;}}siblings.push(node);if(previousSibling){node.prev=previousSibling;previousSibling.next=node;}if(parent){node.parent=parent;}this._lastNode=null;};DomHandler.prototype.addDataNode=function(node){this.addNode(node);this._lastNode=node;};return DomHandler;}();exports.DomHandler=DomHandler;exports[\"default\"]=DomHandler;},{\"./node\":8}],8:[function(require,module,exports){\"use strict\";var __extends=this&&this.__extends||function(){var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics(d,b);};return function(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var nodeTypes=new Map([[\"tag\"/* Tag */,1],[\"script\"/* Script */,1],[\"style\"/* Style */,1],[\"directive\"/* Directive */,1],[\"text\"/* Text */,3],[\"cdata\"/* CDATA */,4],[\"comment\"/* Comment */,8]]);// This object will be used as the prototype for Nodes when creating a\n// DOM-Level-1-compliant structure.\nvar Node=/** @class */function(){/**\n     *\n     * @param type The type of the node.\n     */function Node(type){this.type=type;/** Parent of the node */this.parent=null;/** Previous sibling */this.prev=null;/** Next sibling */this.next=null;/** The start index of the node. Requires `withStartIndices` on the handler to be `true. */this.startIndex=null;/** The end index of the node. Requires `withEndIndices` on the handler to be `true. */this.endIndex=null;}Object.defineProperty(Node.prototype,\"nodeType\",{// Read-only aliases\nget:function get(){return nodeTypes.get(this.type)||1;},enumerable:true,configurable:true});Object.defineProperty(Node.prototype,\"parentNode\",{// Read-write aliases for properties\nget:function get(){return this.parent||null;},set:function set(parent){this.parent=parent;},enumerable:true,configurable:true});Object.defineProperty(Node.prototype,\"previousSibling\",{get:function get(){return this.prev||null;},set:function set(prev){this.prev=prev;},enumerable:true,configurable:true});Object.defineProperty(Node.prototype,\"nextSibling\",{get:function get(){return this.next||null;},set:function set(next){this.next=next;},enumerable:true,configurable:true});return Node;}();exports.Node=Node;var DataNode=/** @class */function(_super){__extends(DataNode,_super);/**\n     *\n     * @param type The type of the node\n     * @param data The content of the data node\n     */function DataNode(type,data){var _this=_super.call(this,type)||this;_this.data=data;return _this;}Object.defineProperty(DataNode.prototype,\"nodeValue\",{get:function get(){return this.data;},set:function set(data){this.data=data;},enumerable:true,configurable:true});return DataNode;}(Node);exports.DataNode=DataNode;var ProcessingInstruction=/** @class */function(_super){__extends(ProcessingInstruction,_super);function ProcessingInstruction(name,data){var _this=_super.call(this,\"directive\"/* Directive */,data)||this;_this.name=name;return _this;}return ProcessingInstruction;}(DataNode);exports.ProcessingInstruction=ProcessingInstruction;var NodeWithChildren=/** @class */function(_super){__extends(NodeWithChildren,_super);/**\n     *\n     * @param type Type of the node.\n     * @param children Children of the node. Only certain node types can have children.\n     */function NodeWithChildren(type,children){var _this=_super.call(this,type)||this;_this.children=children;return _this;}Object.defineProperty(NodeWithChildren.prototype,\"firstChild\",{// Aliases\nget:function get(){return this.children[0]||null;},enumerable:true,configurable:true});Object.defineProperty(NodeWithChildren.prototype,\"lastChild\",{get:function get(){return this.children[this.children.length-1]||null;},enumerable:true,configurable:true});Object.defineProperty(NodeWithChildren.prototype,\"childNodes\",{get:function get(){return this.children;},set:function set(children){this.children=children;},enumerable:true,configurable:true});return NodeWithChildren;}(Node);exports.NodeWithChildren=NodeWithChildren;var Element=/** @class */function(_super){__extends(Element,_super);/**\n     *\n     * @param name Name of the tag, eg. `div`, `span`\n     * @param attribs Object mapping attribute names to attribute values\n     */function Element(name,attribs){var _this=_super.call(this,name===\"script\"?\"script\"/* Script */:name===\"style\"?\"style\"/* Style */:\"tag\"/* Tag */,[])||this;_this.name=name;_this.attribs=attribs;_this.attribs=attribs;return _this;}Object.defineProperty(Element.prototype,\"tagName\",{// DOM Level 1 aliases\nget:function get(){return this.name;},set:function set(name){this.name=name;},enumerable:true,configurable:true});return Element;}(NodeWithChildren);exports.Element=Element;},{}],9:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var tagtypes_1=require(\"./tagtypes\");/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @param nodes Nodes to filter.\n */function removeSubsets(nodes){var idx=nodes.length;// Check if each node (or one of its ancestors) is already contained in the\n// array.\nwhile(--idx>=0){var node=nodes[idx];// Remove the node if it is not unique.\n// We are going through the array from the end, so we only\n// have to check nodes that preceed the node under consideration in the array.\nif(idx>0&&nodes.lastIndexOf(node,idx-1)>=0){nodes.splice(idx,1);continue;}for(var ancestor=node.parent;ancestor;ancestor=ancestor.parent){if(nodes.indexOf(ancestor)>-1){nodes.splice(idx,1);break;}}}return nodes;}exports.removeSubsets=removeSubsets;/***\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the following values:\n *\n * document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent./\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n * @param nodaA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n *\n * @return A bitmask describing the input nodes' relative position.\n *\n *        See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n *        a description of these values.\n */function compareDocumentPosition(nodeA,nodeB){var aParents=[];var bParents=[];if(nodeA===nodeB){return 0;}var current=tagtypes_1.hasChildren(nodeA)?nodeA:nodeA.parent;while(current){aParents.unshift(current);current=current.parent;}current=tagtypes_1.hasChildren(nodeB)?nodeB:nodeB.parent;while(current){bParents.unshift(current);current=current.parent;}var idx=0;while(aParents[idx]===bParents[idx]){idx++;}if(idx===0){return 1/* DISCONNECTED */;}var sharedParent=aParents[idx-1];var siblings=sharedParent.children;var aSibling=aParents[idx];var bSibling=bParents[idx];if(siblings.indexOf(aSibling)>siblings.indexOf(bSibling)){if(sharedParent===nodeB){return 4/* FOLLOWING */|16/* CONTAINED_BY */;}return 4/* FOLLOWING */;}else{if(sharedParent===nodeA){return 2/* PRECEDING */|8/* CONTAINS */;}return 2/* PRECEDING */;}}exports.compareDocumentPosition=compareDocumentPosition;/***\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong\n * to the same document, sort order is unspecified.\n *\n * @param nodes Array of DOM nodes\n * @returns collection of unique nodes, sorted in document order\n */function uniqueSort(nodes){nodes=nodes.filter(function(node,i,arr){return!arr.includes(node,i+1);});nodes.sort(function(a,b){var relative=compareDocumentPosition(a,b);if(relative&2/* PRECEDING */){return-1;}else if(relative&4/* FOLLOWING */){return 1;}return 0;});return nodes;}exports.uniqueSort=uniqueSort;},{\"./tagtypes\":15}],10:[function(require,module,exports){\"use strict\";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}}Object.defineProperty(exports,\"__esModule\",{value:true});__export(require(\"./stringify\"));__export(require(\"./traversal\"));__export(require(\"./manipulation\"));__export(require(\"./querying\"));__export(require(\"./legacy\"));__export(require(\"./helpers\"));__export(require(\"./tagtypes\"));},{\"./helpers\":9,\"./legacy\":11,\"./manipulation\":12,\"./querying\":13,\"./stringify\":14,\"./tagtypes\":15,\"./traversal\":16}],11:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var querying_1=require(\"./querying\");var tagtypes_1=require(\"./tagtypes\");function isTextNode(node){return node.type===\"text\"/* Text */;}/* eslint-disable @typescript-eslint/camelcase */var Checks={tag_name:function tag_name(name){if(typeof name===\"function\"){return function(elem){return tagtypes_1.isTag(elem)&&name(elem.name);};}else if(name===\"*\"){return tagtypes_1.isTag;}else{return function(elem){return tagtypes_1.isTag(elem)&&elem.name===name;};}},tag_type:function tag_type(type){if(typeof type===\"function\"){return function(elem){return type(elem.type);};}else{return function(elem){return elem.type===type;};}},tag_contains:function tag_contains(data){if(typeof data===\"function\"){return function(elem){return isTextNode(elem)&&data(elem.data);};}else{return function(elem){return isTextNode(elem)&&elem.data===data;};}}};/* eslint-enable @typescript-eslint/camelcase */function getAttribCheck(attrib,value){if(typeof value===\"function\"){return function(elem){return tagtypes_1.isTag(elem)&&value(elem.attribs[attrib]);};}else{return function(elem){return tagtypes_1.isTag(elem)&&elem.attribs[attrib]===value;};}}function combineFuncs(a,b){return function(elem){return a(elem)||b(elem);};}function compileTest(options){var funcs=Object.keys(options).map(function(key){var value=options[key];return key in Checks?Checks[key](value):getAttribCheck(key,value);});return funcs.length===0?null:funcs.reduce(combineFuncs);}function testElement(options,element){var test=compileTest(options);return test?test(element):true;}exports.testElement=testElement;function getElements(options,element,recurse,limit){if(limit===void 0){limit=Infinity;}var test=compileTest(options);return test?querying_1.filter(test,element,recurse,limit):[];}exports.getElements=getElements;function getElementById(id,element,recurse){if(recurse===void 0){recurse=true;}if(!Array.isArray(element))element=[element];return querying_1.findOne(getAttribCheck(\"id\",id),element,recurse);}exports.getElementById=getElementById;function getElementsByTagName(name,element,recurse,limit){if(limit===void 0){limit=Infinity;}return querying_1.filter(Checks.tag_name(name),element,recurse,limit);}exports.getElementsByTagName=getElementsByTagName;function getElementsByTagType(type,element,recurse,limit){if(recurse===void 0){recurse=true;}if(limit===void 0){limit=Infinity;}return querying_1.filter(Checks.tag_type(type),element,recurse,limit);}exports.getElementsByTagType=getElementsByTagType;},{\"./querying\":13,\"./tagtypes\":15}],12:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});/***\n * Remove an element from the dom\n *\n * @param elem The element to be removed\n */function removeElement(elem){if(elem.prev)elem.prev.next=elem.next;if(elem.next)elem.next.prev=elem.prev;if(elem.parent){var childs=elem.parent.children;childs.splice(childs.lastIndexOf(elem),1);}}exports.removeElement=removeElement;/***\n * Replace an element in the dom\n *\n * @param elem The element to be replaced\n * @param replacement The element to be added\n */function replaceElement(elem,replacement){var prev=replacement.prev=elem.prev;if(prev){prev.next=replacement;}var next=replacement.next=elem.next;if(next){next.prev=replacement;}var parent=replacement.parent=elem.parent;if(parent){var childs=parent.children;childs[childs.lastIndexOf(elem)]=replacement;}}exports.replaceElement=replaceElement;/***\n * Append a child to an element\n *\n * @param elem The element to append to\n * @param child The element to be added as a child\n */function appendChild(elem,child){child.parent=elem;if(elem.children.push(child)!==1){var sibling=elem.children[elem.children.length-2];sibling.next=child;child.prev=sibling;child.next=null;}}exports.appendChild=appendChild;/***\n * Append an element after another\n *\n * @param elem The element to append to\n * @param next The element be added\n */function append(elem,next){var parent=elem.parent;var currNext=elem.next;next.next=currNext;next.prev=elem;elem.next=next;next.parent=parent;if(currNext){currNext.prev=next;if(parent){var childs=parent.children;childs.splice(childs.lastIndexOf(currNext),0,next);}}else if(parent){parent.children.push(next);}}exports.append=append;/***\n * Prepend an element before another\n *\n * @param elem The element to append to\n * @param prev The element be added\n */function prepend(elem,prev){var parent=elem.parent;if(parent){var childs=parent.children;childs.splice(childs.lastIndexOf(elem),0,prev);}if(elem.prev){elem.prev.next=prev;}prev.parent=parent;prev.prev=elem.prev;prev.next=elem;elem.prev=prev;}exports.prepend=prepend;},{}],13:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var tagtypes_1=require(\"./tagtypes\");/**\n * Search a node and its children for nodes passing a test function.\n *\n * @param test Function to test nodes on.\n * @param element Element to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n */function filter(test,node,recurse,limit){if(recurse===void 0){recurse=true;}if(limit===void 0){limit=Infinity;}if(!Array.isArray(node))node=[node];return find(test,node,recurse,limit);}exports.filter=filter;/**\n * Like `filter`, but only works on an array of nodes.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n */function find(test,nodes,recurse,limit){var result=[];for(var _i=0,nodes_1=nodes;_i<nodes_1.length;_i++){var elem=nodes_1[_i];if(test(elem)){result.push(elem);if(--limit<=0)break;}if(recurse&&tagtypes_1.hasChildren(elem)&&elem.children.length>0){var children=find(test,elem.children,recurse,limit);result.push.apply(result,children);limit-=children.length;if(limit<=0)break;}}return result;}exports.find=find;/**\n * Finds the first element inside of an array that matches a test function.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n */function findOneChild(test,nodes){return nodes.find(test);}exports.findOneChild=findOneChild;/**\n * Finds one element in a tree that passes a test.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n */function findOne(test,nodes,recurse){if(recurse===void 0){recurse=true;}var elem=null;for(var i=0;i<nodes.length&&!elem;i++){var checked=nodes[i];if(!tagtypes_1.isTag(checked)){continue;}else if(test(checked)){elem=checked;}else if(recurse&&checked.children.length>0){elem=findOne(test,checked.children);}}return elem;}exports.findOne=findOne;/**\n * Returns whether a tree of nodes contains at least one node passing a test.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n */function existsOne(test,nodes){return nodes.some(function(checked){return tagtypes_1.isTag(checked)&&(test(checked)||checked.children.length>0&&existsOne(test,checked.children));});}exports.existsOne=existsOne;/**\n * Search and array of nodes and its children for nodes passing a test function.\n *\n * Same as `find`, only with less options, leading to reduced complexity.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n */function findAll(test,nodes){var _a;var result=[];var stack=nodes.filter(tagtypes_1.isTag);var elem;while(elem=stack.shift()){var children=(_a=elem.children)===null||_a===void 0?void 0:_a.filter(tagtypes_1.isTag);if(children&&children.length>0){stack.unshift.apply(stack,children);}if(test(elem))result.push(elem);}return result;}exports.findAll=findAll;},{\"./tagtypes\":15}],14:[function(require,module,exports){\"use strict\";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var tagtypes_1=require(\"./tagtypes\");var dom_serializer_1=__importDefault(require(\"dom-serializer\"));function getOuterHTML(node,options){return dom_serializer_1[\"default\"](node,options);}exports.getOuterHTML=getOuterHTML;function getInnerHTML(node,options){return tagtypes_1.hasChildren(node)?node.children.map(function(node){return getOuterHTML(node,options);}).join(\"\"):\"\";}exports.getInnerHTML=getInnerHTML;function getText(node){if(Array.isArray(node))return node.map(getText).join(\"\");if(tagtypes_1.isTag(node))return node.name===\"br\"?\"\\n\":getText(node.children);if(tagtypes_1.isCDATA(node))return getText(node.children);if(tagtypes_1.isText(node))return node.data;return\"\";}exports.getText=getText;},{\"./tagtypes\":15,\"dom-serializer\":5}],15:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var domelementtype_1=require(\"domelementtype\");function isTag(node){return domelementtype_1.isTag(node);}exports.isTag=isTag;function isCDATA(node){return node.type===\"cdata\"/* CDATA */;}exports.isCDATA=isCDATA;function isText(node){return node.type===\"text\"/* Text */;}exports.isText=isText;function isComment(node){return node.type===\"comment\"/* Comment */;}exports.isComment=isComment;function hasChildren(node){return Object.prototype.hasOwnProperty.call(node,\"children\");}exports.hasChildren=hasChildren;},{\"domelementtype\":6}],16:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});function getChildren(elem){return elem.children||null;}exports.getChildren=getChildren;function getParent(elem){return elem.parent||null;}exports.getParent=getParent;function getSiblings(elem){var parent=getParent(elem);return parent?getChildren(parent):[elem];}exports.getSiblings=getSiblings;function getAttributeValue(elem,name){var _a;return(_a=elem.attribs)===null||_a===void 0?void 0:_a[name];}exports.getAttributeValue=getAttributeValue;function hasAttrib(elem,name){return!!elem.attribs&&Object.prototype.hasOwnProperty.call(elem.attribs,name)&&elem.attribs[name]!=null;}exports.hasAttrib=hasAttrib;/***\n * Returns the name property of an element\n *\n * @param elem The element to get the name for\n */function getName(elem){return elem.name;}exports.getName=getName;},{}],17:[function(require,module,exports){\"use strict\";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var entities_json_1=__importDefault(require(\"./maps/entities.json\"));var legacy_json_1=__importDefault(require(\"./maps/legacy.json\"));var xml_json_1=__importDefault(require(\"./maps/xml.json\"));var decode_codepoint_1=__importDefault(require(\"./decode_codepoint\"));exports.decodeXML=getStrictDecoder(xml_json_1[\"default\"]);exports.decodeHTMLStrict=getStrictDecoder(entities_json_1[\"default\"]);function getStrictDecoder(map){var keys=Object.keys(map).join(\"|\");var replace=getReplacer(map);keys+=\"|#[xX][\\\\da-fA-F]+|#\\\\d+\";var re=new RegExp(\"&(?:\"+keys+\");\",\"g\");return function(str){return String(str).replace(re,replace);};}var sorter=function sorter(a,b){return a<b?1:-1;};exports.decodeHTML=function(){var legacy=Object.keys(legacy_json_1[\"default\"]).sort(sorter);var keys=Object.keys(entities_json_1[\"default\"]).sort(sorter);for(var i=0,j=0;i<keys.length;i++){if(legacy[j]===keys[i]){keys[i]+=\";?\";j++;}else{keys[i]+=\";\";}}var re=new RegExp(\"&(?:\"+keys.join(\"|\")+\"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\",\"g\");var replace=getReplacer(entities_json_1[\"default\"]);function replacer(str){if(str.substr(-1)!==\";\")str+=\";\";return replace(str);}//TODO consider creating a merged map\nreturn function(str){return String(str).replace(re,replacer);};}();function getReplacer(map){return function replace(str){if(str.charAt(1)===\"#\"){var secondChar=str.charAt(2);if(secondChar===\"X\"||secondChar===\"x\"){return decode_codepoint_1[\"default\"](parseInt(str.substr(3),16));}return decode_codepoint_1[\"default\"](parseInt(str.substr(2),10));}return map[str.slice(1,-1)];};}},{\"./decode_codepoint\":18,\"./maps/entities.json\":22,\"./maps/legacy.json\":23,\"./maps/xml.json\":24}],18:[function(require,module,exports){\"use strict\";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var decode_json_1=__importDefault(require(\"./maps/decode.json\"));// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nfunction decodeCodePoint(codePoint){if(codePoint>=0xd800&&codePoint<=0xdfff||codePoint>0x10ffff){return\"\\uFFFD\";}if(codePoint in decode_json_1[\"default\"]){codePoint=decode_json_1[\"default\"][codePoint];}var output=\"\";if(codePoint>0xffff){codePoint-=0x10000;output+=String.fromCharCode(codePoint>>>10&0x3ff|0xd800);codePoint=0xdc00|codePoint&0x3ff;}output+=String.fromCharCode(codePoint);return output;}exports[\"default\"]=decodeCodePoint;},{\"./maps/decode.json\":21}],19:[function(require,module,exports){\"use strict\";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var xml_json_1=__importDefault(require(\"./maps/xml.json\"));var inverseXML=getInverseObj(xml_json_1[\"default\"]);var xmlReplacer=getInverseReplacer(inverseXML);exports.encodeXML=getInverse(inverseXML,xmlReplacer);var entities_json_1=__importDefault(require(\"./maps/entities.json\"));var inverseHTML=getInverseObj(entities_json_1[\"default\"]);var htmlReplacer=getInverseReplacer(inverseHTML);exports.encodeHTML=getInverse(inverseHTML,htmlReplacer);function getInverseObj(obj){return Object.keys(obj).sort().reduce(function(inverse,name){inverse[obj[name]]=\"&\"+name+\";\";return inverse;},{});}function getInverseReplacer(inverse){var single=[];var multiple=[];for(var _i=0,_a=Object.keys(inverse);_i<_a.length;_i++){var k=_a[_i];if(k.length===1){// Add value to single array\nsingle.push(\"\\\\\"+k);}else{// Add value to multiple array\nmultiple.push(k);}}// Add ranges to single characters.\nsingle.sort();for(var start=0;start<single.length-1;start++){// Find the end of a run of characters\nvar end=start;while(end<single.length-1&&single[end].charCodeAt(1)+1===single[end+1].charCodeAt(1)){end+=1;}var count=1+end-start;// We want to replace at least three characters\nif(count<3)continue;single.splice(start,count,single[start]+\"-\"+single[end]);}multiple.unshift(\"[\"+single.join(\"\")+\"]\");return new RegExp(multiple.join(\"|\"),\"g\");}var reNonASCII=/(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;function singleCharReplacer(c){// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\nreturn\"&#x\"+c.codePointAt(0).toString(16).toUpperCase()+\";\";}function getInverse(inverse,re){return function(data){return data.replace(re,function(name){return inverse[name];}).replace(reNonASCII,singleCharReplacer);};}var reXmlChars=getInverseReplacer(inverseXML);function escape(data){return data.replace(reXmlChars,singleCharReplacer).replace(reNonASCII,singleCharReplacer);}exports.escape=escape;},{\"./maps/entities.json\":22,\"./maps/xml.json\":24}],20:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var decode_1=require(\"./decode\");var encode_1=require(\"./encode\");/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n */function decode(data,level){return(!level||level<=0?decode_1.decodeXML:decode_1.decodeHTML)(data);}exports.decode=decode;/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n */function decodeStrict(data,level){return(!level||level<=0?decode_1.decodeXML:decode_1.decodeHTMLStrict)(data);}exports.decodeStrict=decodeStrict;/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n */function encode(data,level){return(!level||level<=0?encode_1.encodeXML:encode_1.encodeHTML)(data);}exports.encode=encode;var encode_2=require(\"./encode\");exports.encodeXML=encode_2.encodeXML;exports.encodeHTML=encode_2.encodeHTML;exports.escape=encode_2.escape;// Legacy aliases\nexports.encodeHTML4=encode_2.encodeHTML;exports.encodeHTML5=encode_2.encodeHTML;var decode_2=require(\"./decode\");exports.decodeXML=decode_2.decodeXML;exports.decodeHTML=decode_2.decodeHTML;exports.decodeHTMLStrict=decode_2.decodeHTMLStrict;// Legacy aliases\nexports.decodeHTML4=decode_2.decodeHTML;exports.decodeHTML5=decode_2.decodeHTML;exports.decodeHTML4Strict=decode_2.decodeHTMLStrict;exports.decodeHTML5Strict=decode_2.decodeHTMLStrict;exports.decodeXMLStrict=decode_2.decodeXML;},{\"./decode\":17,\"./encode\":19}],21:[function(require,module,exports){module.exports={\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376};},{}],22:[function(require,module,exports){module.exports={\"Aacute\":\"\\xC1\",\"aacute\":\"\\xE1\",\"Abreve\":\"\\u0102\",\"abreve\":\"\\u0103\",\"ac\":\"\\u223E\",\"acd\":\"\\u223F\",\"acE\":\"\\u223E\\u0333\",\"Acirc\":\"\\xC2\",\"acirc\":\"\\xE2\",\"acute\":\"\\xB4\",\"Acy\":\"\\u0410\",\"acy\":\"\\u0430\",\"AElig\":\"\\xC6\",\"aelig\":\"\\xE6\",\"af\":\"\\u2061\",\"Afr\":\"\\uD835\\uDD04\",\"afr\":\"\\uD835\\uDD1E\",\"Agrave\":\"\\xC0\",\"agrave\":\"\\xE0\",\"alefsym\":\"\\u2135\",\"aleph\":\"\\u2135\",\"Alpha\":\"\\u0391\",\"alpha\":\"\\u03B1\",\"Amacr\":\"\\u0100\",\"amacr\":\"\\u0101\",\"amalg\":\"\\u2A3F\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"\\u2A55\",\"And\":\"\\u2A53\",\"and\":\"\\u2227\",\"andd\":\"\\u2A5C\",\"andslope\":\"\\u2A58\",\"andv\":\"\\u2A5A\",\"ang\":\"\\u2220\",\"ange\":\"\\u29A4\",\"angle\":\"\\u2220\",\"angmsdaa\":\"\\u29A8\",\"angmsdab\":\"\\u29A9\",\"angmsdac\":\"\\u29AA\",\"angmsdad\":\"\\u29AB\",\"angmsdae\":\"\\u29AC\",\"angmsdaf\":\"\\u29AD\",\"angmsdag\":\"\\u29AE\",\"angmsdah\":\"\\u29AF\",\"angmsd\":\"\\u2221\",\"angrt\":\"\\u221F\",\"angrtvb\":\"\\u22BE\",\"angrtvbd\":\"\\u299D\",\"angsph\":\"\\u2222\",\"angst\":\"\\xC5\",\"angzarr\":\"\\u237C\",\"Aogon\":\"\\u0104\",\"aogon\":\"\\u0105\",\"Aopf\":\"\\uD835\\uDD38\",\"aopf\":\"\\uD835\\uDD52\",\"apacir\":\"\\u2A6F\",\"ap\":\"\\u2248\",\"apE\":\"\\u2A70\",\"ape\":\"\\u224A\",\"apid\":\"\\u224B\",\"apos\":\"'\",\"ApplyFunction\":\"\\u2061\",\"approx\":\"\\u2248\",\"approxeq\":\"\\u224A\",\"Aring\":\"\\xC5\",\"aring\":\"\\xE5\",\"Ascr\":\"\\uD835\\uDC9C\",\"ascr\":\"\\uD835\\uDCB6\",\"Assign\":\"\\u2254\",\"ast\":\"*\",\"asymp\":\"\\u2248\",\"asympeq\":\"\\u224D\",\"Atilde\":\"\\xC3\",\"atilde\":\"\\xE3\",\"Auml\":\"\\xC4\",\"auml\":\"\\xE4\",\"awconint\":\"\\u2233\",\"awint\":\"\\u2A11\",\"backcong\":\"\\u224C\",\"backepsilon\":\"\\u03F6\",\"backprime\":\"\\u2035\",\"backsim\":\"\\u223D\",\"backsimeq\":\"\\u22CD\",\"Backslash\":\"\\u2216\",\"Barv\":\"\\u2AE7\",\"barvee\":\"\\u22BD\",\"barwed\":\"\\u2305\",\"Barwed\":\"\\u2306\",\"barwedge\":\"\\u2305\",\"bbrk\":\"\\u23B5\",\"bbrktbrk\":\"\\u23B6\",\"bcong\":\"\\u224C\",\"Bcy\":\"\\u0411\",\"bcy\":\"\\u0431\",\"bdquo\":\"\\u201E\",\"becaus\":\"\\u2235\",\"because\":\"\\u2235\",\"Because\":\"\\u2235\",\"bemptyv\":\"\\u29B0\",\"bepsi\":\"\\u03F6\",\"bernou\":\"\\u212C\",\"Bernoullis\":\"\\u212C\",\"Beta\":\"\\u0392\",\"beta\":\"\\u03B2\",\"beth\":\"\\u2136\",\"between\":\"\\u226C\",\"Bfr\":\"\\uD835\\uDD05\",\"bfr\":\"\\uD835\\uDD1F\",\"bigcap\":\"\\u22C2\",\"bigcirc\":\"\\u25EF\",\"bigcup\":\"\\u22C3\",\"bigodot\":\"\\u2A00\",\"bigoplus\":\"\\u2A01\",\"bigotimes\":\"\\u2A02\",\"bigsqcup\":\"\\u2A06\",\"bigstar\":\"\\u2605\",\"bigtriangledown\":\"\\u25BD\",\"bigtriangleup\":\"\\u25B3\",\"biguplus\":\"\\u2A04\",\"bigvee\":\"\\u22C1\",\"bigwedge\":\"\\u22C0\",\"bkarow\":\"\\u290D\",\"blacklozenge\":\"\\u29EB\",\"blacksquare\":\"\\u25AA\",\"blacktriangle\":\"\\u25B4\",\"blacktriangledown\":\"\\u25BE\",\"blacktriangleleft\":\"\\u25C2\",\"blacktriangleright\":\"\\u25B8\",\"blank\":\"\\u2423\",\"blk12\":\"\\u2592\",\"blk14\":\"\\u2591\",\"blk34\":\"\\u2593\",\"block\":\"\\u2588\",\"bne\":\"=\\u20E5\",\"bnequiv\":\"\\u2261\\u20E5\",\"bNot\":\"\\u2AED\",\"bnot\":\"\\u2310\",\"Bopf\":\"\\uD835\\uDD39\",\"bopf\":\"\\uD835\\uDD53\",\"bot\":\"\\u22A5\",\"bottom\":\"\\u22A5\",\"bowtie\":\"\\u22C8\",\"boxbox\":\"\\u29C9\",\"boxdl\":\"\\u2510\",\"boxdL\":\"\\u2555\",\"boxDl\":\"\\u2556\",\"boxDL\":\"\\u2557\",\"boxdr\":\"\\u250C\",\"boxdR\":\"\\u2552\",\"boxDr\":\"\\u2553\",\"boxDR\":\"\\u2554\",\"boxh\":\"\\u2500\",\"boxH\":\"\\u2550\",\"boxhd\":\"\\u252C\",\"boxHd\":\"\\u2564\",\"boxhD\":\"\\u2565\",\"boxHD\":\"\\u2566\",\"boxhu\":\"\\u2534\",\"boxHu\":\"\\u2567\",\"boxhU\":\"\\u2568\",\"boxHU\":\"\\u2569\",\"boxminus\":\"\\u229F\",\"boxplus\":\"\\u229E\",\"boxtimes\":\"\\u22A0\",\"boxul\":\"\\u2518\",\"boxuL\":\"\\u255B\",\"boxUl\":\"\\u255C\",\"boxUL\":\"\\u255D\",\"boxur\":\"\\u2514\",\"boxuR\":\"\\u2558\",\"boxUr\":\"\\u2559\",\"boxUR\":\"\\u255A\",\"boxv\":\"\\u2502\",\"boxV\":\"\\u2551\",\"boxvh\":\"\\u253C\",\"boxvH\":\"\\u256A\",\"boxVh\":\"\\u256B\",\"boxVH\":\"\\u256C\",\"boxvl\":\"\\u2524\",\"boxvL\":\"\\u2561\",\"boxVl\":\"\\u2562\",\"boxVL\":\"\\u2563\",\"boxvr\":\"\\u251C\",\"boxvR\":\"\\u255E\",\"boxVr\":\"\\u255F\",\"boxVR\":\"\\u2560\",\"bprime\":\"\\u2035\",\"breve\":\"\\u02D8\",\"Breve\":\"\\u02D8\",\"brvbar\":\"\\xA6\",\"bscr\":\"\\uD835\\uDCB7\",\"Bscr\":\"\\u212C\",\"bsemi\":\"\\u204F\",\"bsim\":\"\\u223D\",\"bsime\":\"\\u22CD\",\"bsolb\":\"\\u29C5\",\"bsol\":\"\\\\\",\"bsolhsub\":\"\\u27C8\",\"bull\":\"\\u2022\",\"bullet\":\"\\u2022\",\"bump\":\"\\u224E\",\"bumpE\":\"\\u2AAE\",\"bumpe\":\"\\u224F\",\"Bumpeq\":\"\\u224E\",\"bumpeq\":\"\\u224F\",\"Cacute\":\"\\u0106\",\"cacute\":\"\\u0107\",\"capand\":\"\\u2A44\",\"capbrcup\":\"\\u2A49\",\"capcap\":\"\\u2A4B\",\"cap\":\"\\u2229\",\"Cap\":\"\\u22D2\",\"capcup\":\"\\u2A47\",\"capdot\":\"\\u2A40\",\"CapitalDifferentialD\":\"\\u2145\",\"caps\":\"\\u2229\\uFE00\",\"caret\":\"\\u2041\",\"caron\":\"\\u02C7\",\"Cayleys\":\"\\u212D\",\"ccaps\":\"\\u2A4D\",\"Ccaron\":\"\\u010C\",\"ccaron\":\"\\u010D\",\"Ccedil\":\"\\xC7\",\"ccedil\":\"\\xE7\",\"Ccirc\":\"\\u0108\",\"ccirc\":\"\\u0109\",\"Cconint\":\"\\u2230\",\"ccups\":\"\\u2A4C\",\"ccupssm\":\"\\u2A50\",\"Cdot\":\"\\u010A\",\"cdot\":\"\\u010B\",\"cedil\":\"\\xB8\",\"Cedilla\":\"\\xB8\",\"cemptyv\":\"\\u29B2\",\"cent\":\"\\xA2\",\"centerdot\":\"\\xB7\",\"CenterDot\":\"\\xB7\",\"cfr\":\"\\uD835\\uDD20\",\"Cfr\":\"\\u212D\",\"CHcy\":\"\\u0427\",\"chcy\":\"\\u0447\",\"check\":\"\\u2713\",\"checkmark\":\"\\u2713\",\"Chi\":\"\\u03A7\",\"chi\":\"\\u03C7\",\"circ\":\"\\u02C6\",\"circeq\":\"\\u2257\",\"circlearrowleft\":\"\\u21BA\",\"circlearrowright\":\"\\u21BB\",\"circledast\":\"\\u229B\",\"circledcirc\":\"\\u229A\",\"circleddash\":\"\\u229D\",\"CircleDot\":\"\\u2299\",\"circledR\":\"\\xAE\",\"circledS\":\"\\u24C8\",\"CircleMinus\":\"\\u2296\",\"CirclePlus\":\"\\u2295\",\"CircleTimes\":\"\\u2297\",\"cir\":\"\\u25CB\",\"cirE\":\"\\u29C3\",\"cire\":\"\\u2257\",\"cirfnint\":\"\\u2A10\",\"cirmid\":\"\\u2AEF\",\"cirscir\":\"\\u29C2\",\"ClockwiseContourIntegral\":\"\\u2232\",\"CloseCurlyDoubleQuote\":\"\\u201D\",\"CloseCurlyQuote\":\"\\u2019\",\"clubs\":\"\\u2663\",\"clubsuit\":\"\\u2663\",\"colon\":\":\",\"Colon\":\"\\u2237\",\"Colone\":\"\\u2A74\",\"colone\":\"\\u2254\",\"coloneq\":\"\\u2254\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"\\u2201\",\"compfn\":\"\\u2218\",\"complement\":\"\\u2201\",\"complexes\":\"\\u2102\",\"cong\":\"\\u2245\",\"congdot\":\"\\u2A6D\",\"Congruent\":\"\\u2261\",\"conint\":\"\\u222E\",\"Conint\":\"\\u222F\",\"ContourIntegral\":\"\\u222E\",\"copf\":\"\\uD835\\uDD54\",\"Copf\":\"\\u2102\",\"coprod\":\"\\u2210\",\"Coproduct\":\"\\u2210\",\"copy\":\"\\xA9\",\"COPY\":\"\\xA9\",\"copysr\":\"\\u2117\",\"CounterClockwiseContourIntegral\":\"\\u2233\",\"crarr\":\"\\u21B5\",\"cross\":\"\\u2717\",\"Cross\":\"\\u2A2F\",\"Cscr\":\"\\uD835\\uDC9E\",\"cscr\":\"\\uD835\\uDCB8\",\"csub\":\"\\u2ACF\",\"csube\":\"\\u2AD1\",\"csup\":\"\\u2AD0\",\"csupe\":\"\\u2AD2\",\"ctdot\":\"\\u22EF\",\"cudarrl\":\"\\u2938\",\"cudarrr\":\"\\u2935\",\"cuepr\":\"\\u22DE\",\"cuesc\":\"\\u22DF\",\"cularr\":\"\\u21B6\",\"cularrp\":\"\\u293D\",\"cupbrcap\":\"\\u2A48\",\"cupcap\":\"\\u2A46\",\"CupCap\":\"\\u224D\",\"cup\":\"\\u222A\",\"Cup\":\"\\u22D3\",\"cupcup\":\"\\u2A4A\",\"cupdot\":\"\\u228D\",\"cupor\":\"\\u2A45\",\"cups\":\"\\u222A\\uFE00\",\"curarr\":\"\\u21B7\",\"curarrm\":\"\\u293C\",\"curlyeqprec\":\"\\u22DE\",\"curlyeqsucc\":\"\\u22DF\",\"curlyvee\":\"\\u22CE\",\"curlywedge\":\"\\u22CF\",\"curren\":\"\\xA4\",\"curvearrowleft\":\"\\u21B6\",\"curvearrowright\":\"\\u21B7\",\"cuvee\":\"\\u22CE\",\"cuwed\":\"\\u22CF\",\"cwconint\":\"\\u2232\",\"cwint\":\"\\u2231\",\"cylcty\":\"\\u232D\",\"dagger\":\"\\u2020\",\"Dagger\":\"\\u2021\",\"daleth\":\"\\u2138\",\"darr\":\"\\u2193\",\"Darr\":\"\\u21A1\",\"dArr\":\"\\u21D3\",\"dash\":\"\\u2010\",\"Dashv\":\"\\u2AE4\",\"dashv\":\"\\u22A3\",\"dbkarow\":\"\\u290F\",\"dblac\":\"\\u02DD\",\"Dcaron\":\"\\u010E\",\"dcaron\":\"\\u010F\",\"Dcy\":\"\\u0414\",\"dcy\":\"\\u0434\",\"ddagger\":\"\\u2021\",\"ddarr\":\"\\u21CA\",\"DD\":\"\\u2145\",\"dd\":\"\\u2146\",\"DDotrahd\":\"\\u2911\",\"ddotseq\":\"\\u2A77\",\"deg\":\"\\xB0\",\"Del\":\"\\u2207\",\"Delta\":\"\\u0394\",\"delta\":\"\\u03B4\",\"demptyv\":\"\\u29B1\",\"dfisht\":\"\\u297F\",\"Dfr\":\"\\uD835\\uDD07\",\"dfr\":\"\\uD835\\uDD21\",\"dHar\":\"\\u2965\",\"dharl\":\"\\u21C3\",\"dharr\":\"\\u21C2\",\"DiacriticalAcute\":\"\\xB4\",\"DiacriticalDot\":\"\\u02D9\",\"DiacriticalDoubleAcute\":\"\\u02DD\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"\\u02DC\",\"diam\":\"\\u22C4\",\"diamond\":\"\\u22C4\",\"Diamond\":\"\\u22C4\",\"diamondsuit\":\"\\u2666\",\"diams\":\"\\u2666\",\"die\":\"\\xA8\",\"DifferentialD\":\"\\u2146\",\"digamma\":\"\\u03DD\",\"disin\":\"\\u22F2\",\"div\":\"\\xF7\",\"divide\":\"\\xF7\",\"divideontimes\":\"\\u22C7\",\"divonx\":\"\\u22C7\",\"DJcy\":\"\\u0402\",\"djcy\":\"\\u0452\",\"dlcorn\":\"\\u231E\",\"dlcrop\":\"\\u230D\",\"dollar\":\"$\",\"Dopf\":\"\\uD835\\uDD3B\",\"dopf\":\"\\uD835\\uDD55\",\"Dot\":\"\\xA8\",\"dot\":\"\\u02D9\",\"DotDot\":\"\\u20DC\",\"doteq\":\"\\u2250\",\"doteqdot\":\"\\u2251\",\"DotEqual\":\"\\u2250\",\"dotminus\":\"\\u2238\",\"dotplus\":\"\\u2214\",\"dotsquare\":\"\\u22A1\",\"doublebarwedge\":\"\\u2306\",\"DoubleContourIntegral\":\"\\u222F\",\"DoubleDot\":\"\\xA8\",\"DoubleDownArrow\":\"\\u21D3\",\"DoubleLeftArrow\":\"\\u21D0\",\"DoubleLeftRightArrow\":\"\\u21D4\",\"DoubleLeftTee\":\"\\u2AE4\",\"DoubleLongLeftArrow\":\"\\u27F8\",\"DoubleLongLeftRightArrow\":\"\\u27FA\",\"DoubleLongRightArrow\":\"\\u27F9\",\"DoubleRightArrow\":\"\\u21D2\",\"DoubleRightTee\":\"\\u22A8\",\"DoubleUpArrow\":\"\\u21D1\",\"DoubleUpDownArrow\":\"\\u21D5\",\"DoubleVerticalBar\":\"\\u2225\",\"DownArrowBar\":\"\\u2913\",\"downarrow\":\"\\u2193\",\"DownArrow\":\"\\u2193\",\"Downarrow\":\"\\u21D3\",\"DownArrowUpArrow\":\"\\u21F5\",\"DownBreve\":\"\\u0311\",\"downdownarrows\":\"\\u21CA\",\"downharpoonleft\":\"\\u21C3\",\"downharpoonright\":\"\\u21C2\",\"DownLeftRightVector\":\"\\u2950\",\"DownLeftTeeVector\":\"\\u295E\",\"DownLeftVectorBar\":\"\\u2956\",\"DownLeftVector\":\"\\u21BD\",\"DownRightTeeVector\":\"\\u295F\",\"DownRightVectorBar\":\"\\u2957\",\"DownRightVector\":\"\\u21C1\",\"DownTeeArrow\":\"\\u21A7\",\"DownTee\":\"\\u22A4\",\"drbkarow\":\"\\u2910\",\"drcorn\":\"\\u231F\",\"drcrop\":\"\\u230C\",\"Dscr\":\"\\uD835\\uDC9F\",\"dscr\":\"\\uD835\\uDCB9\",\"DScy\":\"\\u0405\",\"dscy\":\"\\u0455\",\"dsol\":\"\\u29F6\",\"Dstrok\":\"\\u0110\",\"dstrok\":\"\\u0111\",\"dtdot\":\"\\u22F1\",\"dtri\":\"\\u25BF\",\"dtrif\":\"\\u25BE\",\"duarr\":\"\\u21F5\",\"duhar\":\"\\u296F\",\"dwangle\":\"\\u29A6\",\"DZcy\":\"\\u040F\",\"dzcy\":\"\\u045F\",\"dzigrarr\":\"\\u27FF\",\"Eacute\":\"\\xC9\",\"eacute\":\"\\xE9\",\"easter\":\"\\u2A6E\",\"Ecaron\":\"\\u011A\",\"ecaron\":\"\\u011B\",\"Ecirc\":\"\\xCA\",\"ecirc\":\"\\xEA\",\"ecir\":\"\\u2256\",\"ecolon\":\"\\u2255\",\"Ecy\":\"\\u042D\",\"ecy\":\"\\u044D\",\"eDDot\":\"\\u2A77\",\"Edot\":\"\\u0116\",\"edot\":\"\\u0117\",\"eDot\":\"\\u2251\",\"ee\":\"\\u2147\",\"efDot\":\"\\u2252\",\"Efr\":\"\\uD835\\uDD08\",\"efr\":\"\\uD835\\uDD22\",\"eg\":\"\\u2A9A\",\"Egrave\":\"\\xC8\",\"egrave\":\"\\xE8\",\"egs\":\"\\u2A96\",\"egsdot\":\"\\u2A98\",\"el\":\"\\u2A99\",\"Element\":\"\\u2208\",\"elinters\":\"\\u23E7\",\"ell\":\"\\u2113\",\"els\":\"\\u2A95\",\"elsdot\":\"\\u2A97\",\"Emacr\":\"\\u0112\",\"emacr\":\"\\u0113\",\"empty\":\"\\u2205\",\"emptyset\":\"\\u2205\",\"EmptySmallSquare\":\"\\u25FB\",\"emptyv\":\"\\u2205\",\"EmptyVerySmallSquare\":\"\\u25AB\",\"emsp13\":\"\\u2004\",\"emsp14\":\"\\u2005\",\"emsp\":\"\\u2003\",\"ENG\":\"\\u014A\",\"eng\":\"\\u014B\",\"ensp\":\"\\u2002\",\"Eogon\":\"\\u0118\",\"eogon\":\"\\u0119\",\"Eopf\":\"\\uD835\\uDD3C\",\"eopf\":\"\\uD835\\uDD56\",\"epar\":\"\\u22D5\",\"eparsl\":\"\\u29E3\",\"eplus\":\"\\u2A71\",\"epsi\":\"\\u03B5\",\"Epsilon\":\"\\u0395\",\"epsilon\":\"\\u03B5\",\"epsiv\":\"\\u03F5\",\"eqcirc\":\"\\u2256\",\"eqcolon\":\"\\u2255\",\"eqsim\":\"\\u2242\",\"eqslantgtr\":\"\\u2A96\",\"eqslantless\":\"\\u2A95\",\"Equal\":\"\\u2A75\",\"equals\":\"=\",\"EqualTilde\":\"\\u2242\",\"equest\":\"\\u225F\",\"Equilibrium\":\"\\u21CC\",\"equiv\":\"\\u2261\",\"equivDD\":\"\\u2A78\",\"eqvparsl\":\"\\u29E5\",\"erarr\":\"\\u2971\",\"erDot\":\"\\u2253\",\"escr\":\"\\u212F\",\"Escr\":\"\\u2130\",\"esdot\":\"\\u2250\",\"Esim\":\"\\u2A73\",\"esim\":\"\\u2242\",\"Eta\":\"\\u0397\",\"eta\":\"\\u03B7\",\"ETH\":\"\\xD0\",\"eth\":\"\\xF0\",\"Euml\":\"\\xCB\",\"euml\":\"\\xEB\",\"euro\":\"\\u20AC\",\"excl\":\"!\",\"exist\":\"\\u2203\",\"Exists\":\"\\u2203\",\"expectation\":\"\\u2130\",\"exponentiale\":\"\\u2147\",\"ExponentialE\":\"\\u2147\",\"fallingdotseq\":\"\\u2252\",\"Fcy\":\"\\u0424\",\"fcy\":\"\\u0444\",\"female\":\"\\u2640\",\"ffilig\":\"\\uFB03\",\"fflig\":\"\\uFB00\",\"ffllig\":\"\\uFB04\",\"Ffr\":\"\\uD835\\uDD09\",\"ffr\":\"\\uD835\\uDD23\",\"filig\":\"\\uFB01\",\"FilledSmallSquare\":\"\\u25FC\",\"FilledVerySmallSquare\":\"\\u25AA\",\"fjlig\":\"fj\",\"flat\":\"\\u266D\",\"fllig\":\"\\uFB02\",\"fltns\":\"\\u25B1\",\"fnof\":\"\\u0192\",\"Fopf\":\"\\uD835\\uDD3D\",\"fopf\":\"\\uD835\\uDD57\",\"forall\":\"\\u2200\",\"ForAll\":\"\\u2200\",\"fork\":\"\\u22D4\",\"forkv\":\"\\u2AD9\",\"Fouriertrf\":\"\\u2131\",\"fpartint\":\"\\u2A0D\",\"frac12\":\"\\xBD\",\"frac13\":\"\\u2153\",\"frac14\":\"\\xBC\",\"frac15\":\"\\u2155\",\"frac16\":\"\\u2159\",\"frac18\":\"\\u215B\",\"frac23\":\"\\u2154\",\"frac25\":\"\\u2156\",\"frac34\":\"\\xBE\",\"frac35\":\"\\u2157\",\"frac38\":\"\\u215C\",\"frac45\":\"\\u2158\",\"frac56\":\"\\u215A\",\"frac58\":\"\\u215D\",\"frac78\":\"\\u215E\",\"frasl\":\"\\u2044\",\"frown\":\"\\u2322\",\"fscr\":\"\\uD835\\uDCBB\",\"Fscr\":\"\\u2131\",\"gacute\":\"\\u01F5\",\"Gamma\":\"\\u0393\",\"gamma\":\"\\u03B3\",\"Gammad\":\"\\u03DC\",\"gammad\":\"\\u03DD\",\"gap\":\"\\u2A86\",\"Gbreve\":\"\\u011E\",\"gbreve\":\"\\u011F\",\"Gcedil\":\"\\u0122\",\"Gcirc\":\"\\u011C\",\"gcirc\":\"\\u011D\",\"Gcy\":\"\\u0413\",\"gcy\":\"\\u0433\",\"Gdot\":\"\\u0120\",\"gdot\":\"\\u0121\",\"ge\":\"\\u2265\",\"gE\":\"\\u2267\",\"gEl\":\"\\u2A8C\",\"gel\":\"\\u22DB\",\"geq\":\"\\u2265\",\"geqq\":\"\\u2267\",\"geqslant\":\"\\u2A7E\",\"gescc\":\"\\u2AA9\",\"ges\":\"\\u2A7E\",\"gesdot\":\"\\u2A80\",\"gesdoto\":\"\\u2A82\",\"gesdotol\":\"\\u2A84\",\"gesl\":\"\\u22DB\\uFE00\",\"gesles\":\"\\u2A94\",\"Gfr\":\"\\uD835\\uDD0A\",\"gfr\":\"\\uD835\\uDD24\",\"gg\":\"\\u226B\",\"Gg\":\"\\u22D9\",\"ggg\":\"\\u22D9\",\"gimel\":\"\\u2137\",\"GJcy\":\"\\u0403\",\"gjcy\":\"\\u0453\",\"gla\":\"\\u2AA5\",\"gl\":\"\\u2277\",\"glE\":\"\\u2A92\",\"glj\":\"\\u2AA4\",\"gnap\":\"\\u2A8A\",\"gnapprox\":\"\\u2A8A\",\"gne\":\"\\u2A88\",\"gnE\":\"\\u2269\",\"gneq\":\"\\u2A88\",\"gneqq\":\"\\u2269\",\"gnsim\":\"\\u22E7\",\"Gopf\":\"\\uD835\\uDD3E\",\"gopf\":\"\\uD835\\uDD58\",\"grave\":\"`\",\"GreaterEqual\":\"\\u2265\",\"GreaterEqualLess\":\"\\u22DB\",\"GreaterFullEqual\":\"\\u2267\",\"GreaterGreater\":\"\\u2AA2\",\"GreaterLess\":\"\\u2277\",\"GreaterSlantEqual\":\"\\u2A7E\",\"GreaterTilde\":\"\\u2273\",\"Gscr\":\"\\uD835\\uDCA2\",\"gscr\":\"\\u210A\",\"gsim\":\"\\u2273\",\"gsime\":\"\\u2A8E\",\"gsiml\":\"\\u2A90\",\"gtcc\":\"\\u2AA7\",\"gtcir\":\"\\u2A7A\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"\\u226B\",\"gtdot\":\"\\u22D7\",\"gtlPar\":\"\\u2995\",\"gtquest\":\"\\u2A7C\",\"gtrapprox\":\"\\u2A86\",\"gtrarr\":\"\\u2978\",\"gtrdot\":\"\\u22D7\",\"gtreqless\":\"\\u22DB\",\"gtreqqless\":\"\\u2A8C\",\"gtrless\":\"\\u2277\",\"gtrsim\":\"\\u2273\",\"gvertneqq\":\"\\u2269\\uFE00\",\"gvnE\":\"\\u2269\\uFE00\",\"Hacek\":\"\\u02C7\",\"hairsp\":\"\\u200A\",\"half\":\"\\xBD\",\"hamilt\":\"\\u210B\",\"HARDcy\":\"\\u042A\",\"hardcy\":\"\\u044A\",\"harrcir\":\"\\u2948\",\"harr\":\"\\u2194\",\"hArr\":\"\\u21D4\",\"harrw\":\"\\u21AD\",\"Hat\":\"^\",\"hbar\":\"\\u210F\",\"Hcirc\":\"\\u0124\",\"hcirc\":\"\\u0125\",\"hearts\":\"\\u2665\",\"heartsuit\":\"\\u2665\",\"hellip\":\"\\u2026\",\"hercon\":\"\\u22B9\",\"hfr\":\"\\uD835\\uDD25\",\"Hfr\":\"\\u210C\",\"HilbertSpace\":\"\\u210B\",\"hksearow\":\"\\u2925\",\"hkswarow\":\"\\u2926\",\"hoarr\":\"\\u21FF\",\"homtht\":\"\\u223B\",\"hookleftarrow\":\"\\u21A9\",\"hookrightarrow\":\"\\u21AA\",\"hopf\":\"\\uD835\\uDD59\",\"Hopf\":\"\\u210D\",\"horbar\":\"\\u2015\",\"HorizontalLine\":\"\\u2500\",\"hscr\":\"\\uD835\\uDCBD\",\"Hscr\":\"\\u210B\",\"hslash\":\"\\u210F\",\"Hstrok\":\"\\u0126\",\"hstrok\":\"\\u0127\",\"HumpDownHump\":\"\\u224E\",\"HumpEqual\":\"\\u224F\",\"hybull\":\"\\u2043\",\"hyphen\":\"\\u2010\",\"Iacute\":\"\\xCD\",\"iacute\":\"\\xED\",\"ic\":\"\\u2063\",\"Icirc\":\"\\xCE\",\"icirc\":\"\\xEE\",\"Icy\":\"\\u0418\",\"icy\":\"\\u0438\",\"Idot\":\"\\u0130\",\"IEcy\":\"\\u0415\",\"iecy\":\"\\u0435\",\"iexcl\":\"\\xA1\",\"iff\":\"\\u21D4\",\"ifr\":\"\\uD835\\uDD26\",\"Ifr\":\"\\u2111\",\"Igrave\":\"\\xCC\",\"igrave\":\"\\xEC\",\"ii\":\"\\u2148\",\"iiiint\":\"\\u2A0C\",\"iiint\":\"\\u222D\",\"iinfin\":\"\\u29DC\",\"iiota\":\"\\u2129\",\"IJlig\":\"\\u0132\",\"ijlig\":\"\\u0133\",\"Imacr\":\"\\u012A\",\"imacr\":\"\\u012B\",\"image\":\"\\u2111\",\"ImaginaryI\":\"\\u2148\",\"imagline\":\"\\u2110\",\"imagpart\":\"\\u2111\",\"imath\":\"\\u0131\",\"Im\":\"\\u2111\",\"imof\":\"\\u22B7\",\"imped\":\"\\u01B5\",\"Implies\":\"\\u21D2\",\"incare\":\"\\u2105\",\"in\":\"\\u2208\",\"infin\":\"\\u221E\",\"infintie\":\"\\u29DD\",\"inodot\":\"\\u0131\",\"intcal\":\"\\u22BA\",\"int\":\"\\u222B\",\"Int\":\"\\u222C\",\"integers\":\"\\u2124\",\"Integral\":\"\\u222B\",\"intercal\":\"\\u22BA\",\"Intersection\":\"\\u22C2\",\"intlarhk\":\"\\u2A17\",\"intprod\":\"\\u2A3C\",\"InvisibleComma\":\"\\u2063\",\"InvisibleTimes\":\"\\u2062\",\"IOcy\":\"\\u0401\",\"iocy\":\"\\u0451\",\"Iogon\":\"\\u012E\",\"iogon\":\"\\u012F\",\"Iopf\":\"\\uD835\\uDD40\",\"iopf\":\"\\uD835\\uDD5A\",\"Iota\":\"\\u0399\",\"iota\":\"\\u03B9\",\"iprod\":\"\\u2A3C\",\"iquest\":\"\\xBF\",\"iscr\":\"\\uD835\\uDCBE\",\"Iscr\":\"\\u2110\",\"isin\":\"\\u2208\",\"isindot\":\"\\u22F5\",\"isinE\":\"\\u22F9\",\"isins\":\"\\u22F4\",\"isinsv\":\"\\u22F3\",\"isinv\":\"\\u2208\",\"it\":\"\\u2062\",\"Itilde\":\"\\u0128\",\"itilde\":\"\\u0129\",\"Iukcy\":\"\\u0406\",\"iukcy\":\"\\u0456\",\"Iuml\":\"\\xCF\",\"iuml\":\"\\xEF\",\"Jcirc\":\"\\u0134\",\"jcirc\":\"\\u0135\",\"Jcy\":\"\\u0419\",\"jcy\":\"\\u0439\",\"Jfr\":\"\\uD835\\uDD0D\",\"jfr\":\"\\uD835\\uDD27\",\"jmath\":\"\\u0237\",\"Jopf\":\"\\uD835\\uDD41\",\"jopf\":\"\\uD835\\uDD5B\",\"Jscr\":\"\\uD835\\uDCA5\",\"jscr\":\"\\uD835\\uDCBF\",\"Jsercy\":\"\\u0408\",\"jsercy\":\"\\u0458\",\"Jukcy\":\"\\u0404\",\"jukcy\":\"\\u0454\",\"Kappa\":\"\\u039A\",\"kappa\":\"\\u03BA\",\"kappav\":\"\\u03F0\",\"Kcedil\":\"\\u0136\",\"kcedil\":\"\\u0137\",\"Kcy\":\"\\u041A\",\"kcy\":\"\\u043A\",\"Kfr\":\"\\uD835\\uDD0E\",\"kfr\":\"\\uD835\\uDD28\",\"kgreen\":\"\\u0138\",\"KHcy\":\"\\u0425\",\"khcy\":\"\\u0445\",\"KJcy\":\"\\u040C\",\"kjcy\":\"\\u045C\",\"Kopf\":\"\\uD835\\uDD42\",\"kopf\":\"\\uD835\\uDD5C\",\"Kscr\":\"\\uD835\\uDCA6\",\"kscr\":\"\\uD835\\uDCC0\",\"lAarr\":\"\\u21DA\",\"Lacute\":\"\\u0139\",\"lacute\":\"\\u013A\",\"laemptyv\":\"\\u29B4\",\"lagran\":\"\\u2112\",\"Lambda\":\"\\u039B\",\"lambda\":\"\\u03BB\",\"lang\":\"\\u27E8\",\"Lang\":\"\\u27EA\",\"langd\":\"\\u2991\",\"langle\":\"\\u27E8\",\"lap\":\"\\u2A85\",\"Laplacetrf\":\"\\u2112\",\"laquo\":\"\\xAB\",\"larrb\":\"\\u21E4\",\"larrbfs\":\"\\u291F\",\"larr\":\"\\u2190\",\"Larr\":\"\\u219E\",\"lArr\":\"\\u21D0\",\"larrfs\":\"\\u291D\",\"larrhk\":\"\\u21A9\",\"larrlp\":\"\\u21AB\",\"larrpl\":\"\\u2939\",\"larrsim\":\"\\u2973\",\"larrtl\":\"\\u21A2\",\"latail\":\"\\u2919\",\"lAtail\":\"\\u291B\",\"lat\":\"\\u2AAB\",\"late\":\"\\u2AAD\",\"lates\":\"\\u2AAD\\uFE00\",\"lbarr\":\"\\u290C\",\"lBarr\":\"\\u290E\",\"lbbrk\":\"\\u2772\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"\\u298B\",\"lbrksld\":\"\\u298F\",\"lbrkslu\":\"\\u298D\",\"Lcaron\":\"\\u013D\",\"lcaron\":\"\\u013E\",\"Lcedil\":\"\\u013B\",\"lcedil\":\"\\u013C\",\"lceil\":\"\\u2308\",\"lcub\":\"{\",\"Lcy\":\"\\u041B\",\"lcy\":\"\\u043B\",\"ldca\":\"\\u2936\",\"ldquo\":\"\\u201C\",\"ldquor\":\"\\u201E\",\"ldrdhar\":\"\\u2967\",\"ldrushar\":\"\\u294B\",\"ldsh\":\"\\u21B2\",\"le\":\"\\u2264\",\"lE\":\"\\u2266\",\"LeftAngleBracket\":\"\\u27E8\",\"LeftArrowBar\":\"\\u21E4\",\"leftarrow\":\"\\u2190\",\"LeftArrow\":\"\\u2190\",\"Leftarrow\":\"\\u21D0\",\"LeftArrowRightArrow\":\"\\u21C6\",\"leftarrowtail\":\"\\u21A2\",\"LeftCeiling\":\"\\u2308\",\"LeftDoubleBracket\":\"\\u27E6\",\"LeftDownTeeVector\":\"\\u2961\",\"LeftDownVectorBar\":\"\\u2959\",\"LeftDownVector\":\"\\u21C3\",\"LeftFloor\":\"\\u230A\",\"leftharpoondown\":\"\\u21BD\",\"leftharpoonup\":\"\\u21BC\",\"leftleftarrows\":\"\\u21C7\",\"leftrightarrow\":\"\\u2194\",\"LeftRightArrow\":\"\\u2194\",\"Leftrightarrow\":\"\\u21D4\",\"leftrightarrows\":\"\\u21C6\",\"leftrightharpoons\":\"\\u21CB\",\"leftrightsquigarrow\":\"\\u21AD\",\"LeftRightVector\":\"\\u294E\",\"LeftTeeArrow\":\"\\u21A4\",\"LeftTee\":\"\\u22A3\",\"LeftTeeVector\":\"\\u295A\",\"leftthreetimes\":\"\\u22CB\",\"LeftTriangleBar\":\"\\u29CF\",\"LeftTriangle\":\"\\u22B2\",\"LeftTriangleEqual\":\"\\u22B4\",\"LeftUpDownVector\":\"\\u2951\",\"LeftUpTeeVector\":\"\\u2960\",\"LeftUpVectorBar\":\"\\u2958\",\"LeftUpVector\":\"\\u21BF\",\"LeftVectorBar\":\"\\u2952\",\"LeftVector\":\"\\u21BC\",\"lEg\":\"\\u2A8B\",\"leg\":\"\\u22DA\",\"leq\":\"\\u2264\",\"leqq\":\"\\u2266\",\"leqslant\":\"\\u2A7D\",\"lescc\":\"\\u2AA8\",\"les\":\"\\u2A7D\",\"lesdot\":\"\\u2A7F\",\"lesdoto\":\"\\u2A81\",\"lesdotor\":\"\\u2A83\",\"lesg\":\"\\u22DA\\uFE00\",\"lesges\":\"\\u2A93\",\"lessapprox\":\"\\u2A85\",\"lessdot\":\"\\u22D6\",\"lesseqgtr\":\"\\u22DA\",\"lesseqqgtr\":\"\\u2A8B\",\"LessEqualGreater\":\"\\u22DA\",\"LessFullEqual\":\"\\u2266\",\"LessGreater\":\"\\u2276\",\"lessgtr\":\"\\u2276\",\"LessLess\":\"\\u2AA1\",\"lesssim\":\"\\u2272\",\"LessSlantEqual\":\"\\u2A7D\",\"LessTilde\":\"\\u2272\",\"lfisht\":\"\\u297C\",\"lfloor\":\"\\u230A\",\"Lfr\":\"\\uD835\\uDD0F\",\"lfr\":\"\\uD835\\uDD29\",\"lg\":\"\\u2276\",\"lgE\":\"\\u2A91\",\"lHar\":\"\\u2962\",\"lhard\":\"\\u21BD\",\"lharu\":\"\\u21BC\",\"lharul\":\"\\u296A\",\"lhblk\":\"\\u2584\",\"LJcy\":\"\\u0409\",\"ljcy\":\"\\u0459\",\"llarr\":\"\\u21C7\",\"ll\":\"\\u226A\",\"Ll\":\"\\u22D8\",\"llcorner\":\"\\u231E\",\"Lleftarrow\":\"\\u21DA\",\"llhard\":\"\\u296B\",\"lltri\":\"\\u25FA\",\"Lmidot\":\"\\u013F\",\"lmidot\":\"\\u0140\",\"lmoustache\":\"\\u23B0\",\"lmoust\":\"\\u23B0\",\"lnap\":\"\\u2A89\",\"lnapprox\":\"\\u2A89\",\"lne\":\"\\u2A87\",\"lnE\":\"\\u2268\",\"lneq\":\"\\u2A87\",\"lneqq\":\"\\u2268\",\"lnsim\":\"\\u22E6\",\"loang\":\"\\u27EC\",\"loarr\":\"\\u21FD\",\"lobrk\":\"\\u27E6\",\"longleftarrow\":\"\\u27F5\",\"LongLeftArrow\":\"\\u27F5\",\"Longleftarrow\":\"\\u27F8\",\"longleftrightarrow\":\"\\u27F7\",\"LongLeftRightArrow\":\"\\u27F7\",\"Longleftrightarrow\":\"\\u27FA\",\"longmapsto\":\"\\u27FC\",\"longrightarrow\":\"\\u27F6\",\"LongRightArrow\":\"\\u27F6\",\"Longrightarrow\":\"\\u27F9\",\"looparrowleft\":\"\\u21AB\",\"looparrowright\":\"\\u21AC\",\"lopar\":\"\\u2985\",\"Lopf\":\"\\uD835\\uDD43\",\"lopf\":\"\\uD835\\uDD5D\",\"loplus\":\"\\u2A2D\",\"lotimes\":\"\\u2A34\",\"lowast\":\"\\u2217\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"\\u2199\",\"LowerRightArrow\":\"\\u2198\",\"loz\":\"\\u25CA\",\"lozenge\":\"\\u25CA\",\"lozf\":\"\\u29EB\",\"lpar\":\"(\",\"lparlt\":\"\\u2993\",\"lrarr\":\"\\u21C6\",\"lrcorner\":\"\\u231F\",\"lrhar\":\"\\u21CB\",\"lrhard\":\"\\u296D\",\"lrm\":\"\\u200E\",\"lrtri\":\"\\u22BF\",\"lsaquo\":\"\\u2039\",\"lscr\":\"\\uD835\\uDCC1\",\"Lscr\":\"\\u2112\",\"lsh\":\"\\u21B0\",\"Lsh\":\"\\u21B0\",\"lsim\":\"\\u2272\",\"lsime\":\"\\u2A8D\",\"lsimg\":\"\\u2A8F\",\"lsqb\":\"[\",\"lsquo\":\"\\u2018\",\"lsquor\":\"\\u201A\",\"Lstrok\":\"\\u0141\",\"lstrok\":\"\\u0142\",\"ltcc\":\"\\u2AA6\",\"ltcir\":\"\\u2A79\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"\\u226A\",\"ltdot\":\"\\u22D6\",\"lthree\":\"\\u22CB\",\"ltimes\":\"\\u22C9\",\"ltlarr\":\"\\u2976\",\"ltquest\":\"\\u2A7B\",\"ltri\":\"\\u25C3\",\"ltrie\":\"\\u22B4\",\"ltrif\":\"\\u25C2\",\"ltrPar\":\"\\u2996\",\"lurdshar\":\"\\u294A\",\"luruhar\":\"\\u2966\",\"lvertneqq\":\"\\u2268\\uFE00\",\"lvnE\":\"\\u2268\\uFE00\",\"macr\":\"\\xAF\",\"male\":\"\\u2642\",\"malt\":\"\\u2720\",\"maltese\":\"\\u2720\",\"Map\":\"\\u2905\",\"map\":\"\\u21A6\",\"mapsto\":\"\\u21A6\",\"mapstodown\":\"\\u21A7\",\"mapstoleft\":\"\\u21A4\",\"mapstoup\":\"\\u21A5\",\"marker\":\"\\u25AE\",\"mcomma\":\"\\u2A29\",\"Mcy\":\"\\u041C\",\"mcy\":\"\\u043C\",\"mdash\":\"\\u2014\",\"mDDot\":\"\\u223A\",\"measuredangle\":\"\\u2221\",\"MediumSpace\":\"\\u205F\",\"Mellintrf\":\"\\u2133\",\"Mfr\":\"\\uD835\\uDD10\",\"mfr\":\"\\uD835\\uDD2A\",\"mho\":\"\\u2127\",\"micro\":\"\\xB5\",\"midast\":\"*\",\"midcir\":\"\\u2AF0\",\"mid\":\"\\u2223\",\"middot\":\"\\xB7\",\"minusb\":\"\\u229F\",\"minus\":\"\\u2212\",\"minusd\":\"\\u2238\",\"minusdu\":\"\\u2A2A\",\"MinusPlus\":\"\\u2213\",\"mlcp\":\"\\u2ADB\",\"mldr\":\"\\u2026\",\"mnplus\":\"\\u2213\",\"models\":\"\\u22A7\",\"Mopf\":\"\\uD835\\uDD44\",\"mopf\":\"\\uD835\\uDD5E\",\"mp\":\"\\u2213\",\"mscr\":\"\\uD835\\uDCC2\",\"Mscr\":\"\\u2133\",\"mstpos\":\"\\u223E\",\"Mu\":\"\\u039C\",\"mu\":\"\\u03BC\",\"multimap\":\"\\u22B8\",\"mumap\":\"\\u22B8\",\"nabla\":\"\\u2207\",\"Nacute\":\"\\u0143\",\"nacute\":\"\\u0144\",\"nang\":\"\\u2220\\u20D2\",\"nap\":\"\\u2249\",\"napE\":\"\\u2A70\\u0338\",\"napid\":\"\\u224B\\u0338\",\"napos\":\"\\u0149\",\"napprox\":\"\\u2249\",\"natural\":\"\\u266E\",\"naturals\":\"\\u2115\",\"natur\":\"\\u266E\",\"nbsp\":\"\\xA0\",\"nbump\":\"\\u224E\\u0338\",\"nbumpe\":\"\\u224F\\u0338\",\"ncap\":\"\\u2A43\",\"Ncaron\":\"\\u0147\",\"ncaron\":\"\\u0148\",\"Ncedil\":\"\\u0145\",\"ncedil\":\"\\u0146\",\"ncong\":\"\\u2247\",\"ncongdot\":\"\\u2A6D\\u0338\",\"ncup\":\"\\u2A42\",\"Ncy\":\"\\u041D\",\"ncy\":\"\\u043D\",\"ndash\":\"\\u2013\",\"nearhk\":\"\\u2924\",\"nearr\":\"\\u2197\",\"neArr\":\"\\u21D7\",\"nearrow\":\"\\u2197\",\"ne\":\"\\u2260\",\"nedot\":\"\\u2250\\u0338\",\"NegativeMediumSpace\":\"\\u200B\",\"NegativeThickSpace\":\"\\u200B\",\"NegativeThinSpace\":\"\\u200B\",\"NegativeVeryThinSpace\":\"\\u200B\",\"nequiv\":\"\\u2262\",\"nesear\":\"\\u2928\",\"nesim\":\"\\u2242\\u0338\",\"NestedGreaterGreater\":\"\\u226B\",\"NestedLessLess\":\"\\u226A\",\"NewLine\":\"\\n\",\"nexist\":\"\\u2204\",\"nexists\":\"\\u2204\",\"Nfr\":\"\\uD835\\uDD11\",\"nfr\":\"\\uD835\\uDD2B\",\"ngE\":\"\\u2267\\u0338\",\"nge\":\"\\u2271\",\"ngeq\":\"\\u2271\",\"ngeqq\":\"\\u2267\\u0338\",\"ngeqslant\":\"\\u2A7E\\u0338\",\"nges\":\"\\u2A7E\\u0338\",\"nGg\":\"\\u22D9\\u0338\",\"ngsim\":\"\\u2275\",\"nGt\":\"\\u226B\\u20D2\",\"ngt\":\"\\u226F\",\"ngtr\":\"\\u226F\",\"nGtv\":\"\\u226B\\u0338\",\"nharr\":\"\\u21AE\",\"nhArr\":\"\\u21CE\",\"nhpar\":\"\\u2AF2\",\"ni\":\"\\u220B\",\"nis\":\"\\u22FC\",\"nisd\":\"\\u22FA\",\"niv\":\"\\u220B\",\"NJcy\":\"\\u040A\",\"njcy\":\"\\u045A\",\"nlarr\":\"\\u219A\",\"nlArr\":\"\\u21CD\",\"nldr\":\"\\u2025\",\"nlE\":\"\\u2266\\u0338\",\"nle\":\"\\u2270\",\"nleftarrow\":\"\\u219A\",\"nLeftarrow\":\"\\u21CD\",\"nleftrightarrow\":\"\\u21AE\",\"nLeftrightarrow\":\"\\u21CE\",\"nleq\":\"\\u2270\",\"nleqq\":\"\\u2266\\u0338\",\"nleqslant\":\"\\u2A7D\\u0338\",\"nles\":\"\\u2A7D\\u0338\",\"nless\":\"\\u226E\",\"nLl\":\"\\u22D8\\u0338\",\"nlsim\":\"\\u2274\",\"nLt\":\"\\u226A\\u20D2\",\"nlt\":\"\\u226E\",\"nltri\":\"\\u22EA\",\"nltrie\":\"\\u22EC\",\"nLtv\":\"\\u226A\\u0338\",\"nmid\":\"\\u2224\",\"NoBreak\":\"\\u2060\",\"NonBreakingSpace\":\"\\xA0\",\"nopf\":\"\\uD835\\uDD5F\",\"Nopf\":\"\\u2115\",\"Not\":\"\\u2AEC\",\"not\":\"\\xAC\",\"NotCongruent\":\"\\u2262\",\"NotCupCap\":\"\\u226D\",\"NotDoubleVerticalBar\":\"\\u2226\",\"NotElement\":\"\\u2209\",\"NotEqual\":\"\\u2260\",\"NotEqualTilde\":\"\\u2242\\u0338\",\"NotExists\":\"\\u2204\",\"NotGreater\":\"\\u226F\",\"NotGreaterEqual\":\"\\u2271\",\"NotGreaterFullEqual\":\"\\u2267\\u0338\",\"NotGreaterGreater\":\"\\u226B\\u0338\",\"NotGreaterLess\":\"\\u2279\",\"NotGreaterSlantEqual\":\"\\u2A7E\\u0338\",\"NotGreaterTilde\":\"\\u2275\",\"NotHumpDownHump\":\"\\u224E\\u0338\",\"NotHumpEqual\":\"\\u224F\\u0338\",\"notin\":\"\\u2209\",\"notindot\":\"\\u22F5\\u0338\",\"notinE\":\"\\u22F9\\u0338\",\"notinva\":\"\\u2209\",\"notinvb\":\"\\u22F7\",\"notinvc\":\"\\u22F6\",\"NotLeftTriangleBar\":\"\\u29CF\\u0338\",\"NotLeftTriangle\":\"\\u22EA\",\"NotLeftTriangleEqual\":\"\\u22EC\",\"NotLess\":\"\\u226E\",\"NotLessEqual\":\"\\u2270\",\"NotLessGreater\":\"\\u2278\",\"NotLessLess\":\"\\u226A\\u0338\",\"NotLessSlantEqual\":\"\\u2A7D\\u0338\",\"NotLessTilde\":\"\\u2274\",\"NotNestedGreaterGreater\":\"\\u2AA2\\u0338\",\"NotNestedLessLess\":\"\\u2AA1\\u0338\",\"notni\":\"\\u220C\",\"notniva\":\"\\u220C\",\"notnivb\":\"\\u22FE\",\"notnivc\":\"\\u22FD\",\"NotPrecedes\":\"\\u2280\",\"NotPrecedesEqual\":\"\\u2AAF\\u0338\",\"NotPrecedesSlantEqual\":\"\\u22E0\",\"NotReverseElement\":\"\\u220C\",\"NotRightTriangleBar\":\"\\u29D0\\u0338\",\"NotRightTriangle\":\"\\u22EB\",\"NotRightTriangleEqual\":\"\\u22ED\",\"NotSquareSubset\":\"\\u228F\\u0338\",\"NotSquareSubsetEqual\":\"\\u22E2\",\"NotSquareSuperset\":\"\\u2290\\u0338\",\"NotSquareSupersetEqual\":\"\\u22E3\",\"NotSubset\":\"\\u2282\\u20D2\",\"NotSubsetEqual\":\"\\u2288\",\"NotSucceeds\":\"\\u2281\",\"NotSucceedsEqual\":\"\\u2AB0\\u0338\",\"NotSucceedsSlantEqual\":\"\\u22E1\",\"NotSucceedsTilde\":\"\\u227F\\u0338\",\"NotSuperset\":\"\\u2283\\u20D2\",\"NotSupersetEqual\":\"\\u2289\",\"NotTilde\":\"\\u2241\",\"NotTildeEqual\":\"\\u2244\",\"NotTildeFullEqual\":\"\\u2247\",\"NotTildeTilde\":\"\\u2249\",\"NotVerticalBar\":\"\\u2224\",\"nparallel\":\"\\u2226\",\"npar\":\"\\u2226\",\"nparsl\":\"\\u2AFD\\u20E5\",\"npart\":\"\\u2202\\u0338\",\"npolint\":\"\\u2A14\",\"npr\":\"\\u2280\",\"nprcue\":\"\\u22E0\",\"nprec\":\"\\u2280\",\"npreceq\":\"\\u2AAF\\u0338\",\"npre\":\"\\u2AAF\\u0338\",\"nrarrc\":\"\\u2933\\u0338\",\"nrarr\":\"\\u219B\",\"nrArr\":\"\\u21CF\",\"nrarrw\":\"\\u219D\\u0338\",\"nrightarrow\":\"\\u219B\",\"nRightarrow\":\"\\u21CF\",\"nrtri\":\"\\u22EB\",\"nrtrie\":\"\\u22ED\",\"nsc\":\"\\u2281\",\"nsccue\":\"\\u22E1\",\"nsce\":\"\\u2AB0\\u0338\",\"Nscr\":\"\\uD835\\uDCA9\",\"nscr\":\"\\uD835\\uDCC3\",\"nshortmid\":\"\\u2224\",\"nshortparallel\":\"\\u2226\",\"nsim\":\"\\u2241\",\"nsime\":\"\\u2244\",\"nsimeq\":\"\\u2244\",\"nsmid\":\"\\u2224\",\"nspar\":\"\\u2226\",\"nsqsube\":\"\\u22E2\",\"nsqsupe\":\"\\u22E3\",\"nsub\":\"\\u2284\",\"nsubE\":\"\\u2AC5\\u0338\",\"nsube\":\"\\u2288\",\"nsubset\":\"\\u2282\\u20D2\",\"nsubseteq\":\"\\u2288\",\"nsubseteqq\":\"\\u2AC5\\u0338\",\"nsucc\":\"\\u2281\",\"nsucceq\":\"\\u2AB0\\u0338\",\"nsup\":\"\\u2285\",\"nsupE\":\"\\u2AC6\\u0338\",\"nsupe\":\"\\u2289\",\"nsupset\":\"\\u2283\\u20D2\",\"nsupseteq\":\"\\u2289\",\"nsupseteqq\":\"\\u2AC6\\u0338\",\"ntgl\":\"\\u2279\",\"Ntilde\":\"\\xD1\",\"ntilde\":\"\\xF1\",\"ntlg\":\"\\u2278\",\"ntriangleleft\":\"\\u22EA\",\"ntrianglelefteq\":\"\\u22EC\",\"ntriangleright\":\"\\u22EB\",\"ntrianglerighteq\":\"\\u22ED\",\"Nu\":\"\\u039D\",\"nu\":\"\\u03BD\",\"num\":\"#\",\"numero\":\"\\u2116\",\"numsp\":\"\\u2007\",\"nvap\":\"\\u224D\\u20D2\",\"nvdash\":\"\\u22AC\",\"nvDash\":\"\\u22AD\",\"nVdash\":\"\\u22AE\",\"nVDash\":\"\\u22AF\",\"nvge\":\"\\u2265\\u20D2\",\"nvgt\":\">\\u20D2\",\"nvHarr\":\"\\u2904\",\"nvinfin\":\"\\u29DE\",\"nvlArr\":\"\\u2902\",\"nvle\":\"\\u2264\\u20D2\",\"nvlt\":\"<\\u20D2\",\"nvltrie\":\"\\u22B4\\u20D2\",\"nvrArr\":\"\\u2903\",\"nvrtrie\":\"\\u22B5\\u20D2\",\"nvsim\":\"\\u223C\\u20D2\",\"nwarhk\":\"\\u2923\",\"nwarr\":\"\\u2196\",\"nwArr\":\"\\u21D6\",\"nwarrow\":\"\\u2196\",\"nwnear\":\"\\u2927\",\"Oacute\":\"\\xD3\",\"oacute\":\"\\xF3\",\"oast\":\"\\u229B\",\"Ocirc\":\"\\xD4\",\"ocirc\":\"\\xF4\",\"ocir\":\"\\u229A\",\"Ocy\":\"\\u041E\",\"ocy\":\"\\u043E\",\"odash\":\"\\u229D\",\"Odblac\":\"\\u0150\",\"odblac\":\"\\u0151\",\"odiv\":\"\\u2A38\",\"odot\":\"\\u2299\",\"odsold\":\"\\u29BC\",\"OElig\":\"\\u0152\",\"oelig\":\"\\u0153\",\"ofcir\":\"\\u29BF\",\"Ofr\":\"\\uD835\\uDD12\",\"ofr\":\"\\uD835\\uDD2C\",\"ogon\":\"\\u02DB\",\"Ograve\":\"\\xD2\",\"ograve\":\"\\xF2\",\"ogt\":\"\\u29C1\",\"ohbar\":\"\\u29B5\",\"ohm\":\"\\u03A9\",\"oint\":\"\\u222E\",\"olarr\":\"\\u21BA\",\"olcir\":\"\\u29BE\",\"olcross\":\"\\u29BB\",\"oline\":\"\\u203E\",\"olt\":\"\\u29C0\",\"Omacr\":\"\\u014C\",\"omacr\":\"\\u014D\",\"Omega\":\"\\u03A9\",\"omega\":\"\\u03C9\",\"Omicron\":\"\\u039F\",\"omicron\":\"\\u03BF\",\"omid\":\"\\u29B6\",\"ominus\":\"\\u2296\",\"Oopf\":\"\\uD835\\uDD46\",\"oopf\":\"\\uD835\\uDD60\",\"opar\":\"\\u29B7\",\"OpenCurlyDoubleQuote\":\"\\u201C\",\"OpenCurlyQuote\":\"\\u2018\",\"operp\":\"\\u29B9\",\"oplus\":\"\\u2295\",\"orarr\":\"\\u21BB\",\"Or\":\"\\u2A54\",\"or\":\"\\u2228\",\"ord\":\"\\u2A5D\",\"order\":\"\\u2134\",\"orderof\":\"\\u2134\",\"ordf\":\"\\xAA\",\"ordm\":\"\\xBA\",\"origof\":\"\\u22B6\",\"oror\":\"\\u2A56\",\"orslope\":\"\\u2A57\",\"orv\":\"\\u2A5B\",\"oS\":\"\\u24C8\",\"Oscr\":\"\\uD835\\uDCAA\",\"oscr\":\"\\u2134\",\"Oslash\":\"\\xD8\",\"oslash\":\"\\xF8\",\"osol\":\"\\u2298\",\"Otilde\":\"\\xD5\",\"otilde\":\"\\xF5\",\"otimesas\":\"\\u2A36\",\"Otimes\":\"\\u2A37\",\"otimes\":\"\\u2297\",\"Ouml\":\"\\xD6\",\"ouml\":\"\\xF6\",\"ovbar\":\"\\u233D\",\"OverBar\":\"\\u203E\",\"OverBrace\":\"\\u23DE\",\"OverBracket\":\"\\u23B4\",\"OverParenthesis\":\"\\u23DC\",\"para\":\"\\xB6\",\"parallel\":\"\\u2225\",\"par\":\"\\u2225\",\"parsim\":\"\\u2AF3\",\"parsl\":\"\\u2AFD\",\"part\":\"\\u2202\",\"PartialD\":\"\\u2202\",\"Pcy\":\"\\u041F\",\"pcy\":\"\\u043F\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"\\u2030\",\"perp\":\"\\u22A5\",\"pertenk\":\"\\u2031\",\"Pfr\":\"\\uD835\\uDD13\",\"pfr\":\"\\uD835\\uDD2D\",\"Phi\":\"\\u03A6\",\"phi\":\"\\u03C6\",\"phiv\":\"\\u03D5\",\"phmmat\":\"\\u2133\",\"phone\":\"\\u260E\",\"Pi\":\"\\u03A0\",\"pi\":\"\\u03C0\",\"pitchfork\":\"\\u22D4\",\"piv\":\"\\u03D6\",\"planck\":\"\\u210F\",\"planckh\":\"\\u210E\",\"plankv\":\"\\u210F\",\"plusacir\":\"\\u2A23\",\"plusb\":\"\\u229E\",\"pluscir\":\"\\u2A22\",\"plus\":\"+\",\"plusdo\":\"\\u2214\",\"plusdu\":\"\\u2A25\",\"pluse\":\"\\u2A72\",\"PlusMinus\":\"\\xB1\",\"plusmn\":\"\\xB1\",\"plussim\":\"\\u2A26\",\"plustwo\":\"\\u2A27\",\"pm\":\"\\xB1\",\"Poincareplane\":\"\\u210C\",\"pointint\":\"\\u2A15\",\"popf\":\"\\uD835\\uDD61\",\"Popf\":\"\\u2119\",\"pound\":\"\\xA3\",\"prap\":\"\\u2AB7\",\"Pr\":\"\\u2ABB\",\"pr\":\"\\u227A\",\"prcue\":\"\\u227C\",\"precapprox\":\"\\u2AB7\",\"prec\":\"\\u227A\",\"preccurlyeq\":\"\\u227C\",\"Precedes\":\"\\u227A\",\"PrecedesEqual\":\"\\u2AAF\",\"PrecedesSlantEqual\":\"\\u227C\",\"PrecedesTilde\":\"\\u227E\",\"preceq\":\"\\u2AAF\",\"precnapprox\":\"\\u2AB9\",\"precneqq\":\"\\u2AB5\",\"precnsim\":\"\\u22E8\",\"pre\":\"\\u2AAF\",\"prE\":\"\\u2AB3\",\"precsim\":\"\\u227E\",\"prime\":\"\\u2032\",\"Prime\":\"\\u2033\",\"primes\":\"\\u2119\",\"prnap\":\"\\u2AB9\",\"prnE\":\"\\u2AB5\",\"prnsim\":\"\\u22E8\",\"prod\":\"\\u220F\",\"Product\":\"\\u220F\",\"profalar\":\"\\u232E\",\"profline\":\"\\u2312\",\"profsurf\":\"\\u2313\",\"prop\":\"\\u221D\",\"Proportional\":\"\\u221D\",\"Proportion\":\"\\u2237\",\"propto\":\"\\u221D\",\"prsim\":\"\\u227E\",\"prurel\":\"\\u22B0\",\"Pscr\":\"\\uD835\\uDCAB\",\"pscr\":\"\\uD835\\uDCC5\",\"Psi\":\"\\u03A8\",\"psi\":\"\\u03C8\",\"puncsp\":\"\\u2008\",\"Qfr\":\"\\uD835\\uDD14\",\"qfr\":\"\\uD835\\uDD2E\",\"qint\":\"\\u2A0C\",\"qopf\":\"\\uD835\\uDD62\",\"Qopf\":\"\\u211A\",\"qprime\":\"\\u2057\",\"Qscr\":\"\\uD835\\uDCAC\",\"qscr\":\"\\uD835\\uDCC6\",\"quaternions\":\"\\u210D\",\"quatint\":\"\\u2A16\",\"quest\":\"?\",\"questeq\":\"\\u225F\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"rAarr\":\"\\u21DB\",\"race\":\"\\u223D\\u0331\",\"Racute\":\"\\u0154\",\"racute\":\"\\u0155\",\"radic\":\"\\u221A\",\"raemptyv\":\"\\u29B3\",\"rang\":\"\\u27E9\",\"Rang\":\"\\u27EB\",\"rangd\":\"\\u2992\",\"range\":\"\\u29A5\",\"rangle\":\"\\u27E9\",\"raquo\":\"\\xBB\",\"rarrap\":\"\\u2975\",\"rarrb\":\"\\u21E5\",\"rarrbfs\":\"\\u2920\",\"rarrc\":\"\\u2933\",\"rarr\":\"\\u2192\",\"Rarr\":\"\\u21A0\",\"rArr\":\"\\u21D2\",\"rarrfs\":\"\\u291E\",\"rarrhk\":\"\\u21AA\",\"rarrlp\":\"\\u21AC\",\"rarrpl\":\"\\u2945\",\"rarrsim\":\"\\u2974\",\"Rarrtl\":\"\\u2916\",\"rarrtl\":\"\\u21A3\",\"rarrw\":\"\\u219D\",\"ratail\":\"\\u291A\",\"rAtail\":\"\\u291C\",\"ratio\":\"\\u2236\",\"rationals\":\"\\u211A\",\"rbarr\":\"\\u290D\",\"rBarr\":\"\\u290F\",\"RBarr\":\"\\u2910\",\"rbbrk\":\"\\u2773\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"\\u298C\",\"rbrksld\":\"\\u298E\",\"rbrkslu\":\"\\u2990\",\"Rcaron\":\"\\u0158\",\"rcaron\":\"\\u0159\",\"Rcedil\":\"\\u0156\",\"rcedil\":\"\\u0157\",\"rceil\":\"\\u2309\",\"rcub\":\"}\",\"Rcy\":\"\\u0420\",\"rcy\":\"\\u0440\",\"rdca\":\"\\u2937\",\"rdldhar\":\"\\u2969\",\"rdquo\":\"\\u201D\",\"rdquor\":\"\\u201D\",\"rdsh\":\"\\u21B3\",\"real\":\"\\u211C\",\"realine\":\"\\u211B\",\"realpart\":\"\\u211C\",\"reals\":\"\\u211D\",\"Re\":\"\\u211C\",\"rect\":\"\\u25AD\",\"reg\":\"\\xAE\",\"REG\":\"\\xAE\",\"ReverseElement\":\"\\u220B\",\"ReverseEquilibrium\":\"\\u21CB\",\"ReverseUpEquilibrium\":\"\\u296F\",\"rfisht\":\"\\u297D\",\"rfloor\":\"\\u230B\",\"rfr\":\"\\uD835\\uDD2F\",\"Rfr\":\"\\u211C\",\"rHar\":\"\\u2964\",\"rhard\":\"\\u21C1\",\"rharu\":\"\\u21C0\",\"rharul\":\"\\u296C\",\"Rho\":\"\\u03A1\",\"rho\":\"\\u03C1\",\"rhov\":\"\\u03F1\",\"RightAngleBracket\":\"\\u27E9\",\"RightArrowBar\":\"\\u21E5\",\"rightarrow\":\"\\u2192\",\"RightArrow\":\"\\u2192\",\"Rightarrow\":\"\\u21D2\",\"RightArrowLeftArrow\":\"\\u21C4\",\"rightarrowtail\":\"\\u21A3\",\"RightCeiling\":\"\\u2309\",\"RightDoubleBracket\":\"\\u27E7\",\"RightDownTeeVector\":\"\\u295D\",\"RightDownVectorBar\":\"\\u2955\",\"RightDownVector\":\"\\u21C2\",\"RightFloor\":\"\\u230B\",\"rightharpoondown\":\"\\u21C1\",\"rightharpoonup\":\"\\u21C0\",\"rightleftarrows\":\"\\u21C4\",\"rightleftharpoons\":\"\\u21CC\",\"rightrightarrows\":\"\\u21C9\",\"rightsquigarrow\":\"\\u219D\",\"RightTeeArrow\":\"\\u21A6\",\"RightTee\":\"\\u22A2\",\"RightTeeVector\":\"\\u295B\",\"rightthreetimes\":\"\\u22CC\",\"RightTriangleBar\":\"\\u29D0\",\"RightTriangle\":\"\\u22B3\",\"RightTriangleEqual\":\"\\u22B5\",\"RightUpDownVector\":\"\\u294F\",\"RightUpTeeVector\":\"\\u295C\",\"RightUpVectorBar\":\"\\u2954\",\"RightUpVector\":\"\\u21BE\",\"RightVectorBar\":\"\\u2953\",\"RightVector\":\"\\u21C0\",\"ring\":\"\\u02DA\",\"risingdotseq\":\"\\u2253\",\"rlarr\":\"\\u21C4\",\"rlhar\":\"\\u21CC\",\"rlm\":\"\\u200F\",\"rmoustache\":\"\\u23B1\",\"rmoust\":\"\\u23B1\",\"rnmid\":\"\\u2AEE\",\"roang\":\"\\u27ED\",\"roarr\":\"\\u21FE\",\"robrk\":\"\\u27E7\",\"ropar\":\"\\u2986\",\"ropf\":\"\\uD835\\uDD63\",\"Ropf\":\"\\u211D\",\"roplus\":\"\\u2A2E\",\"rotimes\":\"\\u2A35\",\"RoundImplies\":\"\\u2970\",\"rpar\":\")\",\"rpargt\":\"\\u2994\",\"rppolint\":\"\\u2A12\",\"rrarr\":\"\\u21C9\",\"Rrightarrow\":\"\\u21DB\",\"rsaquo\":\"\\u203A\",\"rscr\":\"\\uD835\\uDCC7\",\"Rscr\":\"\\u211B\",\"rsh\":\"\\u21B1\",\"Rsh\":\"\\u21B1\",\"rsqb\":\"]\",\"rsquo\":\"\\u2019\",\"rsquor\":\"\\u2019\",\"rthree\":\"\\u22CC\",\"rtimes\":\"\\u22CA\",\"rtri\":\"\\u25B9\",\"rtrie\":\"\\u22B5\",\"rtrif\":\"\\u25B8\",\"rtriltri\":\"\\u29CE\",\"RuleDelayed\":\"\\u29F4\",\"ruluhar\":\"\\u2968\",\"rx\":\"\\u211E\",\"Sacute\":\"\\u015A\",\"sacute\":\"\\u015B\",\"sbquo\":\"\\u201A\",\"scap\":\"\\u2AB8\",\"Scaron\":\"\\u0160\",\"scaron\":\"\\u0161\",\"Sc\":\"\\u2ABC\",\"sc\":\"\\u227B\",\"sccue\":\"\\u227D\",\"sce\":\"\\u2AB0\",\"scE\":\"\\u2AB4\",\"Scedil\":\"\\u015E\",\"scedil\":\"\\u015F\",\"Scirc\":\"\\u015C\",\"scirc\":\"\\u015D\",\"scnap\":\"\\u2ABA\",\"scnE\":\"\\u2AB6\",\"scnsim\":\"\\u22E9\",\"scpolint\":\"\\u2A13\",\"scsim\":\"\\u227F\",\"Scy\":\"\\u0421\",\"scy\":\"\\u0441\",\"sdotb\":\"\\u22A1\",\"sdot\":\"\\u22C5\",\"sdote\":\"\\u2A66\",\"searhk\":\"\\u2925\",\"searr\":\"\\u2198\",\"seArr\":\"\\u21D8\",\"searrow\":\"\\u2198\",\"sect\":\"\\xA7\",\"semi\":\";\",\"seswar\":\"\\u2929\",\"setminus\":\"\\u2216\",\"setmn\":\"\\u2216\",\"sext\":\"\\u2736\",\"Sfr\":\"\\uD835\\uDD16\",\"sfr\":\"\\uD835\\uDD30\",\"sfrown\":\"\\u2322\",\"sharp\":\"\\u266F\",\"SHCHcy\":\"\\u0429\",\"shchcy\":\"\\u0449\",\"SHcy\":\"\\u0428\",\"shcy\":\"\\u0448\",\"ShortDownArrow\":\"\\u2193\",\"ShortLeftArrow\":\"\\u2190\",\"shortmid\":\"\\u2223\",\"shortparallel\":\"\\u2225\",\"ShortRightArrow\":\"\\u2192\",\"ShortUpArrow\":\"\\u2191\",\"shy\":\"\\xAD\",\"Sigma\":\"\\u03A3\",\"sigma\":\"\\u03C3\",\"sigmaf\":\"\\u03C2\",\"sigmav\":\"\\u03C2\",\"sim\":\"\\u223C\",\"simdot\":\"\\u2A6A\",\"sime\":\"\\u2243\",\"simeq\":\"\\u2243\",\"simg\":\"\\u2A9E\",\"simgE\":\"\\u2AA0\",\"siml\":\"\\u2A9D\",\"simlE\":\"\\u2A9F\",\"simne\":\"\\u2246\",\"simplus\":\"\\u2A24\",\"simrarr\":\"\\u2972\",\"slarr\":\"\\u2190\",\"SmallCircle\":\"\\u2218\",\"smallsetminus\":\"\\u2216\",\"smashp\":\"\\u2A33\",\"smeparsl\":\"\\u29E4\",\"smid\":\"\\u2223\",\"smile\":\"\\u2323\",\"smt\":\"\\u2AAA\",\"smte\":\"\\u2AAC\",\"smtes\":\"\\u2AAC\\uFE00\",\"SOFTcy\":\"\\u042C\",\"softcy\":\"\\u044C\",\"solbar\":\"\\u233F\",\"solb\":\"\\u29C4\",\"sol\":\"/\",\"Sopf\":\"\\uD835\\uDD4A\",\"sopf\":\"\\uD835\\uDD64\",\"spades\":\"\\u2660\",\"spadesuit\":\"\\u2660\",\"spar\":\"\\u2225\",\"sqcap\":\"\\u2293\",\"sqcaps\":\"\\u2293\\uFE00\",\"sqcup\":\"\\u2294\",\"sqcups\":\"\\u2294\\uFE00\",\"Sqrt\":\"\\u221A\",\"sqsub\":\"\\u228F\",\"sqsube\":\"\\u2291\",\"sqsubset\":\"\\u228F\",\"sqsubseteq\":\"\\u2291\",\"sqsup\":\"\\u2290\",\"sqsupe\":\"\\u2292\",\"sqsupset\":\"\\u2290\",\"sqsupseteq\":\"\\u2292\",\"square\":\"\\u25A1\",\"Square\":\"\\u25A1\",\"SquareIntersection\":\"\\u2293\",\"SquareSubset\":\"\\u228F\",\"SquareSubsetEqual\":\"\\u2291\",\"SquareSuperset\":\"\\u2290\",\"SquareSupersetEqual\":\"\\u2292\",\"SquareUnion\":\"\\u2294\",\"squarf\":\"\\u25AA\",\"squ\":\"\\u25A1\",\"squf\":\"\\u25AA\",\"srarr\":\"\\u2192\",\"Sscr\":\"\\uD835\\uDCAE\",\"sscr\":\"\\uD835\\uDCC8\",\"ssetmn\":\"\\u2216\",\"ssmile\":\"\\u2323\",\"sstarf\":\"\\u22C6\",\"Star\":\"\\u22C6\",\"star\":\"\\u2606\",\"starf\":\"\\u2605\",\"straightepsilon\":\"\\u03F5\",\"straightphi\":\"\\u03D5\",\"strns\":\"\\xAF\",\"sub\":\"\\u2282\",\"Sub\":\"\\u22D0\",\"subdot\":\"\\u2ABD\",\"subE\":\"\\u2AC5\",\"sube\":\"\\u2286\",\"subedot\":\"\\u2AC3\",\"submult\":\"\\u2AC1\",\"subnE\":\"\\u2ACB\",\"subne\":\"\\u228A\",\"subplus\":\"\\u2ABF\",\"subrarr\":\"\\u2979\",\"subset\":\"\\u2282\",\"Subset\":\"\\u22D0\",\"subseteq\":\"\\u2286\",\"subseteqq\":\"\\u2AC5\",\"SubsetEqual\":\"\\u2286\",\"subsetneq\":\"\\u228A\",\"subsetneqq\":\"\\u2ACB\",\"subsim\":\"\\u2AC7\",\"subsub\":\"\\u2AD5\",\"subsup\":\"\\u2AD3\",\"succapprox\":\"\\u2AB8\",\"succ\":\"\\u227B\",\"succcurlyeq\":\"\\u227D\",\"Succeeds\":\"\\u227B\",\"SucceedsEqual\":\"\\u2AB0\",\"SucceedsSlantEqual\":\"\\u227D\",\"SucceedsTilde\":\"\\u227F\",\"succeq\":\"\\u2AB0\",\"succnapprox\":\"\\u2ABA\",\"succneqq\":\"\\u2AB6\",\"succnsim\":\"\\u22E9\",\"succsim\":\"\\u227F\",\"SuchThat\":\"\\u220B\",\"sum\":\"\\u2211\",\"Sum\":\"\\u2211\",\"sung\":\"\\u266A\",\"sup1\":\"\\xB9\",\"sup2\":\"\\xB2\",\"sup3\":\"\\xB3\",\"sup\":\"\\u2283\",\"Sup\":\"\\u22D1\",\"supdot\":\"\\u2ABE\",\"supdsub\":\"\\u2AD8\",\"supE\":\"\\u2AC6\",\"supe\":\"\\u2287\",\"supedot\":\"\\u2AC4\",\"Superset\":\"\\u2283\",\"SupersetEqual\":\"\\u2287\",\"suphsol\":\"\\u27C9\",\"suphsub\":\"\\u2AD7\",\"suplarr\":\"\\u297B\",\"supmult\":\"\\u2AC2\",\"supnE\":\"\\u2ACC\",\"supne\":\"\\u228B\",\"supplus\":\"\\u2AC0\",\"supset\":\"\\u2283\",\"Supset\":\"\\u22D1\",\"supseteq\":\"\\u2287\",\"supseteqq\":\"\\u2AC6\",\"supsetneq\":\"\\u228B\",\"supsetneqq\":\"\\u2ACC\",\"supsim\":\"\\u2AC8\",\"supsub\":\"\\u2AD4\",\"supsup\":\"\\u2AD6\",\"swarhk\":\"\\u2926\",\"swarr\":\"\\u2199\",\"swArr\":\"\\u21D9\",\"swarrow\":\"\\u2199\",\"swnwar\":\"\\u292A\",\"szlig\":\"\\xDF\",\"Tab\":\"\\t\",\"target\":\"\\u2316\",\"Tau\":\"\\u03A4\",\"tau\":\"\\u03C4\",\"tbrk\":\"\\u23B4\",\"Tcaron\":\"\\u0164\",\"tcaron\":\"\\u0165\",\"Tcedil\":\"\\u0162\",\"tcedil\":\"\\u0163\",\"Tcy\":\"\\u0422\",\"tcy\":\"\\u0442\",\"tdot\":\"\\u20DB\",\"telrec\":\"\\u2315\",\"Tfr\":\"\\uD835\\uDD17\",\"tfr\":\"\\uD835\\uDD31\",\"there4\":\"\\u2234\",\"therefore\":\"\\u2234\",\"Therefore\":\"\\u2234\",\"Theta\":\"\\u0398\",\"theta\":\"\\u03B8\",\"thetasym\":\"\\u03D1\",\"thetav\":\"\\u03D1\",\"thickapprox\":\"\\u2248\",\"thicksim\":\"\\u223C\",\"ThickSpace\":\"\\u205F\\u200A\",\"ThinSpace\":\"\\u2009\",\"thinsp\":\"\\u2009\",\"thkap\":\"\\u2248\",\"thksim\":\"\\u223C\",\"THORN\":\"\\xDE\",\"thorn\":\"\\xFE\",\"tilde\":\"\\u02DC\",\"Tilde\":\"\\u223C\",\"TildeEqual\":\"\\u2243\",\"TildeFullEqual\":\"\\u2245\",\"TildeTilde\":\"\\u2248\",\"timesbar\":\"\\u2A31\",\"timesb\":\"\\u22A0\",\"times\":\"\\xD7\",\"timesd\":\"\\u2A30\",\"tint\":\"\\u222D\",\"toea\":\"\\u2928\",\"topbot\":\"\\u2336\",\"topcir\":\"\\u2AF1\",\"top\":\"\\u22A4\",\"Topf\":\"\\uD835\\uDD4B\",\"topf\":\"\\uD835\\uDD65\",\"topfork\":\"\\u2ADA\",\"tosa\":\"\\u2929\",\"tprime\":\"\\u2034\",\"trade\":\"\\u2122\",\"TRADE\":\"\\u2122\",\"triangle\":\"\\u25B5\",\"triangledown\":\"\\u25BF\",\"triangleleft\":\"\\u25C3\",\"trianglelefteq\":\"\\u22B4\",\"triangleq\":\"\\u225C\",\"triangleright\":\"\\u25B9\",\"trianglerighteq\":\"\\u22B5\",\"tridot\":\"\\u25EC\",\"trie\":\"\\u225C\",\"triminus\":\"\\u2A3A\",\"TripleDot\":\"\\u20DB\",\"triplus\":\"\\u2A39\",\"trisb\":\"\\u29CD\",\"tritime\":\"\\u2A3B\",\"trpezium\":\"\\u23E2\",\"Tscr\":\"\\uD835\\uDCAF\",\"tscr\":\"\\uD835\\uDCC9\",\"TScy\":\"\\u0426\",\"tscy\":\"\\u0446\",\"TSHcy\":\"\\u040B\",\"tshcy\":\"\\u045B\",\"Tstrok\":\"\\u0166\",\"tstrok\":\"\\u0167\",\"twixt\":\"\\u226C\",\"twoheadleftarrow\":\"\\u219E\",\"twoheadrightarrow\":\"\\u21A0\",\"Uacute\":\"\\xDA\",\"uacute\":\"\\xFA\",\"uarr\":\"\\u2191\",\"Uarr\":\"\\u219F\",\"uArr\":\"\\u21D1\",\"Uarrocir\":\"\\u2949\",\"Ubrcy\":\"\\u040E\",\"ubrcy\":\"\\u045E\",\"Ubreve\":\"\\u016C\",\"ubreve\":\"\\u016D\",\"Ucirc\":\"\\xDB\",\"ucirc\":\"\\xFB\",\"Ucy\":\"\\u0423\",\"ucy\":\"\\u0443\",\"udarr\":\"\\u21C5\",\"Udblac\":\"\\u0170\",\"udblac\":\"\\u0171\",\"udhar\":\"\\u296E\",\"ufisht\":\"\\u297E\",\"Ufr\":\"\\uD835\\uDD18\",\"ufr\":\"\\uD835\\uDD32\",\"Ugrave\":\"\\xD9\",\"ugrave\":\"\\xF9\",\"uHar\":\"\\u2963\",\"uharl\":\"\\u21BF\",\"uharr\":\"\\u21BE\",\"uhblk\":\"\\u2580\",\"ulcorn\":\"\\u231C\",\"ulcorner\":\"\\u231C\",\"ulcrop\":\"\\u230F\",\"ultri\":\"\\u25F8\",\"Umacr\":\"\\u016A\",\"umacr\":\"\\u016B\",\"uml\":\"\\xA8\",\"UnderBar\":\"_\",\"UnderBrace\":\"\\u23DF\",\"UnderBracket\":\"\\u23B5\",\"UnderParenthesis\":\"\\u23DD\",\"Union\":\"\\u22C3\",\"UnionPlus\":\"\\u228E\",\"Uogon\":\"\\u0172\",\"uogon\":\"\\u0173\",\"Uopf\":\"\\uD835\\uDD4C\",\"uopf\":\"\\uD835\\uDD66\",\"UpArrowBar\":\"\\u2912\",\"uparrow\":\"\\u2191\",\"UpArrow\":\"\\u2191\",\"Uparrow\":\"\\u21D1\",\"UpArrowDownArrow\":\"\\u21C5\",\"updownarrow\":\"\\u2195\",\"UpDownArrow\":\"\\u2195\",\"Updownarrow\":\"\\u21D5\",\"UpEquilibrium\":\"\\u296E\",\"upharpoonleft\":\"\\u21BF\",\"upharpoonright\":\"\\u21BE\",\"uplus\":\"\\u228E\",\"UpperLeftArrow\":\"\\u2196\",\"UpperRightArrow\":\"\\u2197\",\"upsi\":\"\\u03C5\",\"Upsi\":\"\\u03D2\",\"upsih\":\"\\u03D2\",\"Upsilon\":\"\\u03A5\",\"upsilon\":\"\\u03C5\",\"UpTeeArrow\":\"\\u21A5\",\"UpTee\":\"\\u22A5\",\"upuparrows\":\"\\u21C8\",\"urcorn\":\"\\u231D\",\"urcorner\":\"\\u231D\",\"urcrop\":\"\\u230E\",\"Uring\":\"\\u016E\",\"uring\":\"\\u016F\",\"urtri\":\"\\u25F9\",\"Uscr\":\"\\uD835\\uDCB0\",\"uscr\":\"\\uD835\\uDCCA\",\"utdot\":\"\\u22F0\",\"Utilde\":\"\\u0168\",\"utilde\":\"\\u0169\",\"utri\":\"\\u25B5\",\"utrif\":\"\\u25B4\",\"uuarr\":\"\\u21C8\",\"Uuml\":\"\\xDC\",\"uuml\":\"\\xFC\",\"uwangle\":\"\\u29A7\",\"vangrt\":\"\\u299C\",\"varepsilon\":\"\\u03F5\",\"varkappa\":\"\\u03F0\",\"varnothing\":\"\\u2205\",\"varphi\":\"\\u03D5\",\"varpi\":\"\\u03D6\",\"varpropto\":\"\\u221D\",\"varr\":\"\\u2195\",\"vArr\":\"\\u21D5\",\"varrho\":\"\\u03F1\",\"varsigma\":\"\\u03C2\",\"varsubsetneq\":\"\\u228A\\uFE00\",\"varsubsetneqq\":\"\\u2ACB\\uFE00\",\"varsupsetneq\":\"\\u228B\\uFE00\",\"varsupsetneqq\":\"\\u2ACC\\uFE00\",\"vartheta\":\"\\u03D1\",\"vartriangleleft\":\"\\u22B2\",\"vartriangleright\":\"\\u22B3\",\"vBar\":\"\\u2AE8\",\"Vbar\":\"\\u2AEB\",\"vBarv\":\"\\u2AE9\",\"Vcy\":\"\\u0412\",\"vcy\":\"\\u0432\",\"vdash\":\"\\u22A2\",\"vDash\":\"\\u22A8\",\"Vdash\":\"\\u22A9\",\"VDash\":\"\\u22AB\",\"Vdashl\":\"\\u2AE6\",\"veebar\":\"\\u22BB\",\"vee\":\"\\u2228\",\"Vee\":\"\\u22C1\",\"veeeq\":\"\\u225A\",\"vellip\":\"\\u22EE\",\"verbar\":\"|\",\"Verbar\":\"\\u2016\",\"vert\":\"|\",\"Vert\":\"\\u2016\",\"VerticalBar\":\"\\u2223\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"\\u2758\",\"VerticalTilde\":\"\\u2240\",\"VeryThinSpace\":\"\\u200A\",\"Vfr\":\"\\uD835\\uDD19\",\"vfr\":\"\\uD835\\uDD33\",\"vltri\":\"\\u22B2\",\"vnsub\":\"\\u2282\\u20D2\",\"vnsup\":\"\\u2283\\u20D2\",\"Vopf\":\"\\uD835\\uDD4D\",\"vopf\":\"\\uD835\\uDD67\",\"vprop\":\"\\u221D\",\"vrtri\":\"\\u22B3\",\"Vscr\":\"\\uD835\\uDCB1\",\"vscr\":\"\\uD835\\uDCCB\",\"vsubnE\":\"\\u2ACB\\uFE00\",\"vsubne\":\"\\u228A\\uFE00\",\"vsupnE\":\"\\u2ACC\\uFE00\",\"vsupne\":\"\\u228B\\uFE00\",\"Vvdash\":\"\\u22AA\",\"vzigzag\":\"\\u299A\",\"Wcirc\":\"\\u0174\",\"wcirc\":\"\\u0175\",\"wedbar\":\"\\u2A5F\",\"wedge\":\"\\u2227\",\"Wedge\":\"\\u22C0\",\"wedgeq\":\"\\u2259\",\"weierp\":\"\\u2118\",\"Wfr\":\"\\uD835\\uDD1A\",\"wfr\":\"\\uD835\\uDD34\",\"Wopf\":\"\\uD835\\uDD4E\",\"wopf\":\"\\uD835\\uDD68\",\"wp\":\"\\u2118\",\"wr\":\"\\u2240\",\"wreath\":\"\\u2240\",\"Wscr\":\"\\uD835\\uDCB2\",\"wscr\":\"\\uD835\\uDCCC\",\"xcap\":\"\\u22C2\",\"xcirc\":\"\\u25EF\",\"xcup\":\"\\u22C3\",\"xdtri\":\"\\u25BD\",\"Xfr\":\"\\uD835\\uDD1B\",\"xfr\":\"\\uD835\\uDD35\",\"xharr\":\"\\u27F7\",\"xhArr\":\"\\u27FA\",\"Xi\":\"\\u039E\",\"xi\":\"\\u03BE\",\"xlarr\":\"\\u27F5\",\"xlArr\":\"\\u27F8\",\"xmap\":\"\\u27FC\",\"xnis\":\"\\u22FB\",\"xodot\":\"\\u2A00\",\"Xopf\":\"\\uD835\\uDD4F\",\"xopf\":\"\\uD835\\uDD69\",\"xoplus\":\"\\u2A01\",\"xotime\":\"\\u2A02\",\"xrarr\":\"\\u27F6\",\"xrArr\":\"\\u27F9\",\"Xscr\":\"\\uD835\\uDCB3\",\"xscr\":\"\\uD835\\uDCCD\",\"xsqcup\":\"\\u2A06\",\"xuplus\":\"\\u2A04\",\"xutri\":\"\\u25B3\",\"xvee\":\"\\u22C1\",\"xwedge\":\"\\u22C0\",\"Yacute\":\"\\xDD\",\"yacute\":\"\\xFD\",\"YAcy\":\"\\u042F\",\"yacy\":\"\\u044F\",\"Ycirc\":\"\\u0176\",\"ycirc\":\"\\u0177\",\"Ycy\":\"\\u042B\",\"ycy\":\"\\u044B\",\"yen\":\"\\xA5\",\"Yfr\":\"\\uD835\\uDD1C\",\"yfr\":\"\\uD835\\uDD36\",\"YIcy\":\"\\u0407\",\"yicy\":\"\\u0457\",\"Yopf\":\"\\uD835\\uDD50\",\"yopf\":\"\\uD835\\uDD6A\",\"Yscr\":\"\\uD835\\uDCB4\",\"yscr\":\"\\uD835\\uDCCE\",\"YUcy\":\"\\u042E\",\"yucy\":\"\\u044E\",\"yuml\":\"\\xFF\",\"Yuml\":\"\\u0178\",\"Zacute\":\"\\u0179\",\"zacute\":\"\\u017A\",\"Zcaron\":\"\\u017D\",\"zcaron\":\"\\u017E\",\"Zcy\":\"\\u0417\",\"zcy\":\"\\u0437\",\"Zdot\":\"\\u017B\",\"zdot\":\"\\u017C\",\"zeetrf\":\"\\u2128\",\"ZeroWidthSpace\":\"\\u200B\",\"Zeta\":\"\\u0396\",\"zeta\":\"\\u03B6\",\"zfr\":\"\\uD835\\uDD37\",\"Zfr\":\"\\u2128\",\"ZHcy\":\"\\u0416\",\"zhcy\":\"\\u0436\",\"zigrarr\":\"\\u21DD\",\"zopf\":\"\\uD835\\uDD6B\",\"Zopf\":\"\\u2124\",\"Zscr\":\"\\uD835\\uDCB5\",\"zscr\":\"\\uD835\\uDCCF\",\"zwj\":\"\\u200D\",\"zwnj\":\"\\u200C\"};},{}],23:[function(require,module,exports){module.exports={\"Aacute\":\"\\xC1\",\"aacute\":\"\\xE1\",\"Acirc\":\"\\xC2\",\"acirc\":\"\\xE2\",\"acute\":\"\\xB4\",\"AElig\":\"\\xC6\",\"aelig\":\"\\xE6\",\"Agrave\":\"\\xC0\",\"agrave\":\"\\xE0\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"\\xC5\",\"aring\":\"\\xE5\",\"Atilde\":\"\\xC3\",\"atilde\":\"\\xE3\",\"Auml\":\"\\xC4\",\"auml\":\"\\xE4\",\"brvbar\":\"\\xA6\",\"Ccedil\":\"\\xC7\",\"ccedil\":\"\\xE7\",\"cedil\":\"\\xB8\",\"cent\":\"\\xA2\",\"copy\":\"\\xA9\",\"COPY\":\"\\xA9\",\"curren\":\"\\xA4\",\"deg\":\"\\xB0\",\"divide\":\"\\xF7\",\"Eacute\":\"\\xC9\",\"eacute\":\"\\xE9\",\"Ecirc\":\"\\xCA\",\"ecirc\":\"\\xEA\",\"Egrave\":\"\\xC8\",\"egrave\":\"\\xE8\",\"ETH\":\"\\xD0\",\"eth\":\"\\xF0\",\"Euml\":\"\\xCB\",\"euml\":\"\\xEB\",\"frac12\":\"\\xBD\",\"frac14\":\"\\xBC\",\"frac34\":\"\\xBE\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"\\xCD\",\"iacute\":\"\\xED\",\"Icirc\":\"\\xCE\",\"icirc\":\"\\xEE\",\"iexcl\":\"\\xA1\",\"Igrave\":\"\\xCC\",\"igrave\":\"\\xEC\",\"iquest\":\"\\xBF\",\"Iuml\":\"\\xCF\",\"iuml\":\"\\xEF\",\"laquo\":\"\\xAB\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"\\xAF\",\"micro\":\"\\xB5\",\"middot\":\"\\xB7\",\"nbsp\":\"\\xA0\",\"not\":\"\\xAC\",\"Ntilde\":\"\\xD1\",\"ntilde\":\"\\xF1\",\"Oacute\":\"\\xD3\",\"oacute\":\"\\xF3\",\"Ocirc\":\"\\xD4\",\"ocirc\":\"\\xF4\",\"Ograve\":\"\\xD2\",\"ograve\":\"\\xF2\",\"ordf\":\"\\xAA\",\"ordm\":\"\\xBA\",\"Oslash\":\"\\xD8\",\"oslash\":\"\\xF8\",\"Otilde\":\"\\xD5\",\"otilde\":\"\\xF5\",\"Ouml\":\"\\xD6\",\"ouml\":\"\\xF6\",\"para\":\"\\xB6\",\"plusmn\":\"\\xB1\",\"pound\":\"\\xA3\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"raquo\":\"\\xBB\",\"reg\":\"\\xAE\",\"REG\":\"\\xAE\",\"sect\":\"\\xA7\",\"shy\":\"\\xAD\",\"sup1\":\"\\xB9\",\"sup2\":\"\\xB2\",\"sup3\":\"\\xB3\",\"szlig\":\"\\xDF\",\"THORN\":\"\\xDE\",\"thorn\":\"\\xFE\",\"times\":\"\\xD7\",\"Uacute\":\"\\xDA\",\"uacute\":\"\\xFA\",\"Ucirc\":\"\\xDB\",\"ucirc\":\"\\xFB\",\"Ugrave\":\"\\xD9\",\"ugrave\":\"\\xF9\",\"uml\":\"\\xA8\",\"Uuml\":\"\\xDC\",\"uuml\":\"\\xFC\",\"Yacute\":\"\\xDD\",\"yacute\":\"\\xFD\",\"yen\":\"\\xA5\",\"yuml\":\"\\xFF\"};},{}],24:[function(require,module,exports){module.exports={\"amp\":\"&\",\"apos\":\"'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\"\"};},{}],25:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar objectCreate=Object.create||objectCreatePolyfill;var objectKeys=Object.keys||objectKeysPolyfill;var bind=Function.prototype.bind||functionBindPolyfill;function EventEmitter(){if(!this._events||!Object.prototype.hasOwnProperty.call(this,'_events')){this._events=objectCreate(null);this._eventsCount=0;}this._maxListeners=this._maxListeners||undefined;}module.exports=EventEmitter;// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners=10;var hasDefineProperty;try{var o={};if(Object.defineProperty)Object.defineProperty(o,'x',{value:0});hasDefineProperty=o.x===0;}catch(err){hasDefineProperty=false;}if(hasDefineProperty){Object.defineProperty(EventEmitter,'defaultMaxListeners',{enumerable:true,get:function get(){return defaultMaxListeners;},set:function set(arg){// check whether the input is a positive number (whose value is zero or\n// greater and not a NaN).\nif(typeof arg!=='number'||arg<0||arg!==arg)throw new TypeError('\"defaultMaxListeners\" must be a positive number');defaultMaxListeners=arg;}});}else{EventEmitter.defaultMaxListeners=defaultMaxListeners;}// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners=function setMaxListeners(n){if(typeof n!=='number'||n<0||isNaN(n))throw new TypeError('\"n\" argument must be a positive number');this._maxListeners=n;return this;};function $getMaxListeners(that){if(that._maxListeners===undefined)return EventEmitter.defaultMaxListeners;return that._maxListeners;}EventEmitter.prototype.getMaxListeners=function getMaxListeners(){return $getMaxListeners(this);};// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler,isFn,self){if(isFn)handler.call(self);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self);}}}function emitOne(handler,isFn,self,arg1){if(isFn)handler.call(self,arg1);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1);}}}function emitTwo(handler,isFn,self,arg1,arg2){if(isFn)handler.call(self,arg1,arg2);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2);}}}function emitThree(handler,isFn,self,arg1,arg2,arg3){if(isFn)handler.call(self,arg1,arg2,arg3);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2,arg3);}}}function emitMany(handler,isFn,self,args){if(isFn)handler.apply(self,args);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].apply(self,args);}}}EventEmitter.prototype.emit=function emit(type){var er,handler,len,args,i,events;var doError=type==='error';events=this._events;if(events)doError=doError&&events.error==null;else if(!doError)return false;// If there is no 'error' event listener then throw.\nif(doError){if(arguments.length>1)er=arguments[1];if(er instanceof Error){throw er;// Unhandled 'error' event\n}else{// At least give some kind of context to the user\nvar err=new Error('Unhandled \"error\" event. ('+er+')');err.context=er;throw err;}return false;}handler=events[type];if(!handler)return false;var isFn=typeof handler==='function';len=arguments.length;switch(len){// fast cases\ncase 1:emitNone(handler,isFn,this);break;case 2:emitOne(handler,isFn,this,arguments[1]);break;case 3:emitTwo(handler,isFn,this,arguments[1],arguments[2]);break;case 4:emitThree(handler,isFn,this,arguments[1],arguments[2],arguments[3]);break;// slower\ndefault:args=new Array(len-1);for(i=1;i<len;i++){args[i-1]=arguments[i];}emitMany(handler,isFn,this,args);}return true;};function _addListener(target,type,listener,prepend){var m;var events;var existing;if(typeof listener!=='function')throw new TypeError('\"listener\" argument must be a function');events=target._events;if(!events){events=target._events=objectCreate(null);target._eventsCount=0;}else{// To avoid recursion in the case that type === \"newListener\"! Before\n// adding it to the listeners, first emit \"newListener\".\nif(events.newListener){target.emit('newListener',type,listener.listener?listener.listener:listener);// Re-assign `events` because a newListener handler could have caused the\n// this._events to be assigned to a new object\nevents=target._events;}existing=events[type];}if(!existing){// Optimize the case of one listener. Don't need the extra array object.\nexisting=events[type]=listener;++target._eventsCount;}else{if(typeof existing==='function'){// Adding the second element, need to change to array.\nexisting=events[type]=prepend?[listener,existing]:[existing,listener];}else{// If we've already got an array, just append.\nif(prepend){existing.unshift(listener);}else{existing.push(listener);}}// Check for listener leak\nif(!existing.warned){m=$getMaxListeners(target);if(m&&m>0&&existing.length>m){existing.warned=true;var w=new Error('Possible EventEmitter memory leak detected. '+existing.length+' \"'+String(type)+'\" listeners '+'added. Use emitter.setMaxListeners() to '+'increase limit.');w.name='MaxListenersExceededWarning';w.emitter=target;w.type=type;w.count=existing.length;if((typeof console===\"undefined\"?\"undefined\":_typeof(console))==='object'&&console.warn){console.warn('%s: %s',w.name,w.message);}}}}return target;}EventEmitter.prototype.addListener=function addListener(type,listener){return _addListener(this,type,listener,false);};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.prependListener=function prependListener(type,listener){return _addListener(this,type,listener,true);};function onceWrapper(){if(!this.fired){this.target.removeListener(this.type,this.wrapFn);this.fired=true;switch(arguments.length){case 0:return this.listener.call(this.target);case 1:return this.listener.call(this.target,arguments[0]);case 2:return this.listener.call(this.target,arguments[0],arguments[1]);case 3:return this.listener.call(this.target,arguments[0],arguments[1],arguments[2]);default:var args=new Array(arguments.length);for(var i=0;i<args.length;++i){args[i]=arguments[i];}this.listener.apply(this.target,args);}}}function _onceWrap(target,type,listener){var state={fired:false,wrapFn:undefined,target:target,type:type,listener:listener};var wrapped=bind.call(onceWrapper,state);wrapped.listener=listener;state.wrapFn=wrapped;return wrapped;}EventEmitter.prototype.once=function once(type,listener){if(typeof listener!=='function')throw new TypeError('\"listener\" argument must be a function');this.on(type,_onceWrap(this,type,listener));return this;};EventEmitter.prototype.prependOnceListener=function prependOnceListener(type,listener){if(typeof listener!=='function')throw new TypeError('\"listener\" argument must be a function');this.prependListener(type,_onceWrap(this,type,listener));return this;};// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener=function removeListener(type,listener){var list,events,position,i,originalListener;if(typeof listener!=='function')throw new TypeError('\"listener\" argument must be a function');events=this._events;if(!events)return this;list=events[type];if(!list)return this;if(list===listener||list.listener===listener){if(--this._eventsCount===0)this._events=objectCreate(null);else{delete events[type];if(events.removeListener)this.emit('removeListener',type,list.listener||listener);}}else if(typeof list!=='function'){position=-1;for(i=list.length-1;i>=0;i--){if(list[i]===listener||list[i].listener===listener){originalListener=list[i].listener;position=i;break;}}if(position<0)return this;if(position===0)list.shift();else spliceOne(list,position);if(list.length===1)events[type]=list[0];if(events.removeListener)this.emit('removeListener',type,originalListener||listener);}return this;};EventEmitter.prototype.removeAllListeners=function removeAllListeners(type){var listeners,events,i;events=this._events;if(!events)return this;// not listening for removeListener, no need to emit\nif(!events.removeListener){if(arguments.length===0){this._events=objectCreate(null);this._eventsCount=0;}else if(events[type]){if(--this._eventsCount===0)this._events=objectCreate(null);else delete events[type];}return this;}// emit removeListener for all listeners on all events\nif(arguments.length===0){var keys=objectKeys(events);var key;for(i=0;i<keys.length;++i){key=keys[i];if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events=objectCreate(null);this._eventsCount=0;return this;}listeners=events[type];if(typeof listeners==='function'){this.removeListener(type,listeners);}else if(listeners){// LIFO order\nfor(i=listeners.length-1;i>=0;i--){this.removeListener(type,listeners[i]);}}return this;};function _listeners(target,type,unwrap){var events=target._events;if(!events)return[];var evlistener=events[type];if(!evlistener)return[];if(typeof evlistener==='function')return unwrap?[evlistener.listener||evlistener]:[evlistener];return unwrap?unwrapListeners(evlistener):arrayClone(evlistener,evlistener.length);}EventEmitter.prototype.listeners=function listeners(type){return _listeners(this,type,true);};EventEmitter.prototype.rawListeners=function rawListeners(type){return _listeners(this,type,false);};EventEmitter.listenerCount=function(emitter,type){if(typeof emitter.listenerCount==='function'){return emitter.listenerCount(type);}else{return listenerCount.call(emitter,type);}};EventEmitter.prototype.listenerCount=listenerCount;function listenerCount(type){var events=this._events;if(events){var evlistener=events[type];if(typeof evlistener==='function'){return 1;}else if(evlistener){return evlistener.length;}}return 0;}EventEmitter.prototype.eventNames=function eventNames(){return this._eventsCount>0?Reflect.ownKeys(this._events):[];};// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list,index){for(var i=index,k=i+1,n=list.length;k<n;i+=1,k+=1){list[i]=list[k];}list.pop();}function arrayClone(arr,n){var copy=new Array(n);for(var i=0;i<n;++i){copy[i]=arr[i];}return copy;}function unwrapListeners(arr){var ret=new Array(arr.length);for(var i=0;i<ret.length;++i){ret[i]=arr[i].listener||arr[i];}return ret;}function objectCreatePolyfill(proto){var F=function F(){};F.prototype=proto;return new F();}function objectKeysPolyfill(obj){var keys=[];for(var k in obj){if(Object.prototype.hasOwnProperty.call(obj,k)){keys.push(k);}}return k;}function functionBindPolyfill(context){var fn=this;return function(){return fn.apply(context,arguments);};}},{}],26:[function(require,module,exports){\"use strict\";var __extends=this&&this.__extends||function(){var _extendStatics2=function extendStatics(d,b){_extendStatics2=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics2(d,b);};return function(d,b){_extendStatics2(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var MultiplexHandler_1=__importDefault(require(\"./MultiplexHandler\"));var CollectingHandler=/** @class */function(_super){__extends(CollectingHandler,_super);function CollectingHandler(cbs){if(cbs===void 0){cbs={};}var _this=_super.call(this,function(name){var _a;var args=[];for(var _i=1;_i<arguments.length;_i++){args[_i-1]=arguments[_i];}_this.events.push([name].concat(args));// @ts-ignore\nif(_this._cbs[name])(_a=_this._cbs)[name].apply(_a,args);})||this;_this._cbs=cbs;_this.events=[];return _this;}CollectingHandler.prototype.onreset=function(){this.events=[];if(this._cbs.onreset)this._cbs.onreset();};CollectingHandler.prototype.restart=function(){var _a;if(this._cbs.onreset)this._cbs.onreset();for(var i=0;i<this.events.length;i++){var _b=this.events[i],name_1=_b[0],args=_b.slice(1);if(!this._cbs[name_1]){continue;}// @ts-ignore\n(_a=this._cbs)[name_1].apply(_a,args);}};return CollectingHandler;}(MultiplexHandler_1[\"default\"]);exports.CollectingHandler=CollectingHandler;},{\"./MultiplexHandler\":28}],27:[function(require,module,exports){\"use strict\";var __extends=this&&this.__extends||function(){var _extendStatics3=function extendStatics(d,b){_extendStatics3=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics3(d,b);};return function(d,b){_extendStatics3(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result[\"default\"]=mod;return result;};Object.defineProperty(exports,\"__esModule\",{value:true});var domhandler_1=__importDefault(require(\"domhandler\"));var DomUtils=__importStar(require(\"domutils\"));var Parser_1=require(\"./Parser\");//TODO: Consume data as it is coming in\nvar FeedHandler=/** @class */function(_super){__extends(FeedHandler,_super);/**\n     *\n     * @param callback\n     * @param options\n     */function FeedHandler(callback,options){var _this=this;if(_typeof(callback)===\"object\"&&callback!==null){callback=undefined;options=callback;}_this=_super.call(this,callback,options)||this;return _this;}FeedHandler.prototype.onend=function(){var feed={};var feedRoot=getOneElement(isValidFeed,this.dom);if(feedRoot){if(feedRoot.name===\"feed\"){var childs=feedRoot.children;feed.type=\"atom\";addConditionally(feed,\"id\",\"id\",childs);addConditionally(feed,\"title\",\"title\",childs);var href=getAttribute(\"href\",getOneElement(\"link\",childs));if(href){feed.link=href;}addConditionally(feed,\"description\",\"subtitle\",childs);var updated=fetch(\"updated\",childs);if(updated){feed.updated=new Date(updated);}addConditionally(feed,\"author\",\"email\",childs,true);feed.items=getElements(\"entry\",childs).map(function(item){var entry={};var children=item.children;addConditionally(entry,\"id\",\"id\",children);addConditionally(entry,\"title\",\"title\",children);var href=getAttribute(\"href\",getOneElement(\"link\",children));if(href){entry.link=href;}var description=fetch(\"summary\",children)||fetch(\"content\",children);if(description){entry.description=description;}var pubDate=fetch(\"updated\",children);if(pubDate){entry.pubDate=new Date(pubDate);}return entry;});}else{var childs=getOneElement(\"channel\",feedRoot.children).children;feed.type=feedRoot.name.substr(0,3);feed.id=\"\";addConditionally(feed,\"title\",\"title\",childs);addConditionally(feed,\"link\",\"link\",childs);addConditionally(feed,\"description\",\"description\",childs);var updated=fetch(\"lastBuildDate\",childs);if(updated){feed.updated=new Date(updated);}addConditionally(feed,\"author\",\"managingEditor\",childs,true);feed.items=getElements(\"item\",feedRoot.children).map(function(item){var entry={};var children=item.children;addConditionally(entry,\"id\",\"guid\",children);addConditionally(entry,\"title\",\"title\",children);addConditionally(entry,\"link\",\"link\",children);addConditionally(entry,\"description\",\"description\",children);var pubDate=fetch(\"pubDate\",children);if(pubDate)entry.pubDate=new Date(pubDate);return entry;});}}this.feed=feed;this.handleCallback(feedRoot?null:Error(\"couldn't find root of feed\"));};return FeedHandler;}(domhandler_1[\"default\"]);exports.FeedHandler=FeedHandler;function getElements(what,where){return DomUtils.getElementsByTagName(what,where,true);}function getOneElement(what,where){return DomUtils.getElementsByTagName(what,where,true,1)[0];}function fetch(what,where,recurse){if(recurse===void 0){recurse=false;}return DomUtils.getText(DomUtils.getElementsByTagName(what,where,recurse,1)).trim();}function getAttribute(name,elem){if(!elem){return null;}var attribs=elem.attribs;return attribs[name];}function addConditionally(obj,prop,what,where,recurse){if(recurse===void 0){recurse=false;}var tmp=fetch(what,where,recurse);// @ts-ignore\nif(tmp)obj[prop]=tmp;}function isValidFeed(value){return value===\"rss\"||value===\"feed\"||value===\"rdf:RDF\";}var defaultOptions={xmlMode:true};/**\n * Parse a feed.\n *\n * @param feed The feed that should be parsed, as a string.\n * @param options Optionally, options for parsing. When using this option, you probably want to set `xmlMode` to `true`.\n */function parseFeed(feed,options){if(options===void 0){options=defaultOptions;}var handler=new FeedHandler(options);new Parser_1.Parser(handler,options).end(feed);return handler.feed;}exports.parseFeed=parseFeed;},{\"./Parser\":29,\"domhandler\":7,\"domutils\":10}],28:[function(require,module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});/**\n * Calls a specific handler function for all events that are encountered.\n *\n * @param func  The function to multiplex all events to.\n */var MultiplexHandler=/** @class */function(){function MultiplexHandler(func){this._func=func;}/* Format: eventname: number of arguments */MultiplexHandler.prototype.onattribute=function(name,value){this._func(\"onattribute\",name,value);};MultiplexHandler.prototype.oncdatastart=function(){this._func(\"oncdatastart\");};MultiplexHandler.prototype.oncdataend=function(){this._func(\"oncdataend\");};MultiplexHandler.prototype.ontext=function(text){this._func(\"ontext\",text);};MultiplexHandler.prototype.onprocessinginstruction=function(name,value){this._func(\"onprocessinginstruction\",name,value);};MultiplexHandler.prototype.oncomment=function(comment){this._func(\"oncomment\",comment);};MultiplexHandler.prototype.oncommentend=function(){this._func(\"oncommentend\");};MultiplexHandler.prototype.onclosetag=function(name){this._func(\"onclosetag\",name);};MultiplexHandler.prototype.onopentag=function(name,attribs){this._func(\"onopentag\",name,attribs);};MultiplexHandler.prototype.onopentagname=function(name){this._func(\"onopentagname\",name);};MultiplexHandler.prototype.onerror=function(error){this._func(\"onerror\",error);};MultiplexHandler.prototype.onend=function(){this._func(\"onend\");};MultiplexHandler.prototype.onparserinit=function(parser){this._func(\"onparserinit\",parser);};MultiplexHandler.prototype.onreset=function(){this._func(\"onreset\");};return MultiplexHandler;}();exports[\"default\"]=MultiplexHandler;},{}],29:[function(require,module,exports){\"use strict\";var __extends=this&&this.__extends||function(){var _extendStatics4=function extendStatics(d,b){_extendStatics4=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics4(d,b);};return function(d,b){_extendStatics4(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var Tokenizer_1=__importDefault(require(\"./Tokenizer\"));var events_1=require(\"events\");var formTags=new Set([\"input\",\"option\",\"optgroup\",\"select\",\"button\",\"datalist\",\"textarea\"]);var pTag=new Set([\"p\"]);var openImpliesClose={tr:new Set([\"tr\",\"th\",\"td\"]),th:new Set([\"th\"]),td:new Set([\"thead\",\"th\",\"td\"]),body:new Set([\"head\",\"link\",\"script\"]),li:new Set([\"li\"]),p:pTag,h1:pTag,h2:pTag,h3:pTag,h4:pTag,h5:pTag,h6:pTag,select:formTags,input:formTags,output:formTags,button:formTags,datalist:formTags,textarea:formTags,option:new Set([\"option\"]),optgroup:new Set([\"optgroup\",\"option\"]),dd:new Set([\"dt\",\"dd\"]),dt:new Set([\"dt\",\"dd\"]),address:pTag,article:pTag,aside:pTag,blockquote:pTag,details:pTag,div:pTag,dl:pTag,fieldset:pTag,figcaption:pTag,figure:pTag,footer:pTag,form:pTag,header:pTag,hr:pTag,main:pTag,nav:pTag,ol:pTag,pre:pTag,section:pTag,table:pTag,ul:pTag,rt:new Set([\"rt\",\"rp\"]),rp:new Set([\"rt\",\"rp\"]),tbody:new Set([\"thead\",\"tbody\"]),tfoot:new Set([\"thead\",\"tbody\"])};var voidElements=new Set([\"area\",\"base\",\"basefont\",\"br\",\"col\",\"command\",\"embed\",\"frame\",\"hr\",\"img\",\"input\",\"isindex\",\"keygen\",\"link\",\"meta\",\"param\",\"source\",\"track\",\"wbr\"]);var foreignContextElements=new Set([\"math\",\"svg\"]);var htmlIntegrationElements=new Set([\"mi\",\"mo\",\"mn\",\"ms\",\"mtext\",\"annotation-xml\",\"foreignObject\",\"desc\",\"title\"]);var reNameEnd=/\\s|\\//;var Parser=/** @class */function(_super){__extends(Parser,_super);function Parser(cbs,options){var _this=_super.call(this)||this;_this._tagname=\"\";_this._attribname=\"\";_this._attribvalue=\"\";_this._attribs=null;_this._stack=[];_this._foreignContext=[];_this.startIndex=0;_this.endIndex=null;// Aliases for backwards compatibility\n_this.parseChunk=Parser.prototype.write;_this.done=Parser.prototype.end;_this._options=options||{};_this._cbs=cbs||{};_this._tagname=\"\";_this._attribname=\"\";_this._attribvalue=\"\";_this._attribs=null;_this._stack=[];_this._foreignContext=[];_this.startIndex=0;_this.endIndex=null;_this._lowerCaseTagNames=\"lowerCaseTags\"in _this._options?!!_this._options.lowerCaseTags:!_this._options.xmlMode;_this._lowerCaseAttributeNames=\"lowerCaseAttributeNames\"in _this._options?!!_this._options.lowerCaseAttributeNames:!_this._options.xmlMode;_this._tokenizer=new(_this._options.Tokenizer||Tokenizer_1[\"default\"])(_this._options,_this);if(_this._cbs.onparserinit)_this._cbs.onparserinit(_this);return _this;}Parser.prototype._updatePosition=function(initialOffset){if(this.endIndex===null){if(this._tokenizer._sectionStart<=initialOffset){this.startIndex=0;}else{this.startIndex=this._tokenizer._sectionStart-initialOffset;}}else this.startIndex=this.endIndex+1;this.endIndex=this._tokenizer.getAbsoluteIndex();};//Tokenizer event handlers\nParser.prototype.ontext=function(data){this._updatePosition(1);// @ts-ignore\nthis.endIndex--;if(this._cbs.ontext)this._cbs.ontext(data);};Parser.prototype.onopentagname=function(name){if(this._lowerCaseTagNames){name=name.toLowerCase();}this._tagname=name;if(!this._options.xmlMode&&Object.prototype.hasOwnProperty.call(openImpliesClose,name)){for(var el=void 0;// @ts-ignore\nopenImpliesClose[name].has(el=this._stack[this._stack.length-1]);this.onclosetag(el)){;}}if(this._options.xmlMode||!voidElements.has(name)){this._stack.push(name);if(foreignContextElements.has(name)){this._foreignContext.push(true);}else if(htmlIntegrationElements.has(name)){this._foreignContext.push(false);}}if(this._cbs.onopentagname)this._cbs.onopentagname(name);if(this._cbs.onopentag)this._attribs={};};Parser.prototype.onopentagend=function(){this._updatePosition(1);if(this._attribs){if(this._cbs.onopentag){this._cbs.onopentag(this._tagname,this._attribs);}this._attribs=null;}if(!this._options.xmlMode&&this._cbs.onclosetag&&voidElements.has(this._tagname)){this._cbs.onclosetag(this._tagname);}this._tagname=\"\";};Parser.prototype.onclosetag=function(name){this._updatePosition(1);if(this._lowerCaseTagNames){name=name.toLowerCase();}if(foreignContextElements.has(name)||htmlIntegrationElements.has(name)){this._foreignContext.pop();}if(this._stack.length&&(this._options.xmlMode||!voidElements.has(name))){var pos=this._stack.lastIndexOf(name);if(pos!==-1){if(this._cbs.onclosetag){pos=this._stack.length-pos;// @ts-ignore\nwhile(pos--){this._cbs.onclosetag(this._stack.pop());}}else this._stack.length=pos;}else if(name===\"p\"&&!this._options.xmlMode){this.onopentagname(name);this._closeCurrentTag();}}else if(!this._options.xmlMode&&(name===\"br\"||name===\"p\")){this.onopentagname(name);this._closeCurrentTag();}};Parser.prototype.onselfclosingtag=function(){if(this._options.xmlMode||this._options.recognizeSelfClosing||this._foreignContext[this._foreignContext.length-1]){this._closeCurrentTag();}else{this.onopentagend();}};Parser.prototype._closeCurrentTag=function(){var name=this._tagname;this.onopentagend();//self-closing tags will be on the top of the stack\n//(cheaper check than in onclosetag)\nif(this._stack[this._stack.length-1]===name){if(this._cbs.onclosetag){this._cbs.onclosetag(name);}this._stack.pop();}};Parser.prototype.onattribname=function(name){if(this._lowerCaseAttributeNames){name=name.toLowerCase();}this._attribname=name;};Parser.prototype.onattribdata=function(value){this._attribvalue+=value;};Parser.prototype.onattribend=function(){if(this._cbs.onattribute)this._cbs.onattribute(this._attribname,this._attribvalue);if(this._attribs&&!Object.prototype.hasOwnProperty.call(this._attribs,this._attribname)){this._attribs[this._attribname]=this._attribvalue;}this._attribname=\"\";this._attribvalue=\"\";};Parser.prototype._getInstructionName=function(value){var idx=value.search(reNameEnd);var name=idx<0?value:value.substr(0,idx);if(this._lowerCaseTagNames){name=name.toLowerCase();}return name;};Parser.prototype.ondeclaration=function(value){if(this._cbs.onprocessinginstruction){var name_1=this._getInstructionName(value);this._cbs.onprocessinginstruction(\"!\"+name_1,\"!\"+value);}};Parser.prototype.onprocessinginstruction=function(value){if(this._cbs.onprocessinginstruction){var name_2=this._getInstructionName(value);this._cbs.onprocessinginstruction(\"?\"+name_2,\"?\"+value);}};Parser.prototype.oncomment=function(value){this._updatePosition(4);if(this._cbs.oncomment)this._cbs.oncomment(value);if(this._cbs.oncommentend)this._cbs.oncommentend();};Parser.prototype.oncdata=function(value){this._updatePosition(1);if(this._options.xmlMode||this._options.recognizeCDATA){if(this._cbs.oncdatastart)this._cbs.oncdatastart();if(this._cbs.ontext)this._cbs.ontext(value);if(this._cbs.oncdataend)this._cbs.oncdataend();}else{this.oncomment(\"[CDATA[\"+value+\"]]\");}};Parser.prototype.onerror=function(err){if(this._cbs.onerror)this._cbs.onerror(err);};Parser.prototype.onend=function(){if(this._cbs.onclosetag){for(var i=this._stack.length;i>0;this._cbs.onclosetag(this._stack[--i])){;}}if(this._cbs.onend)this._cbs.onend();};//Resets the parser to a blank state, ready to parse a new HTML document\nParser.prototype.reset=function(){if(this._cbs.onreset)this._cbs.onreset();this._tokenizer.reset();this._tagname=\"\";this._attribname=\"\";this._attribs=null;this._stack=[];if(this._cbs.onparserinit)this._cbs.onparserinit(this);};//Parses a complete HTML document and pushes it to the handler\nParser.prototype.parseComplete=function(data){this.reset();this.end(data);};Parser.prototype.write=function(chunk){this._tokenizer.write(chunk);};Parser.prototype.end=function(chunk){this._tokenizer.end(chunk);};Parser.prototype.pause=function(){this._tokenizer.pause();};Parser.prototype.resume=function(){this._tokenizer.resume();};return Parser;}(events_1.EventEmitter);exports.Parser=Parser;},{\"./Tokenizer\":30,\"events\":25}],30:[function(require,module,exports){\"use strict\";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var decode_codepoint_1=__importDefault(require(\"entities/lib/decode_codepoint\"));var entities_json_1=__importDefault(require(\"entities/lib/maps/entities.json\"));var legacy_json_1=__importDefault(require(\"entities/lib/maps/legacy.json\"));var xml_json_1=__importDefault(require(\"entities/lib/maps/xml.json\"));function whitespace(c){return c===\" \"||c===\"\\n\"||c===\"\\t\"||c===\"\\f\"||c===\"\\r\";}function ifElseState(upper,SUCCESS,FAILURE){var lower=upper.toLowerCase();if(upper===lower){return function(t,c){if(c===lower){t._state=SUCCESS;}else{t._state=FAILURE;t._index--;}};}else{return function(t,c){if(c===lower||c===upper){t._state=SUCCESS;}else{t._state=FAILURE;t._index--;}};}}function consumeSpecialNameChar(upper,NEXT_STATE){var lower=upper.toLowerCase();return function(t,c){if(c===lower||c===upper){t._state=NEXT_STATE;}else{t._state=3/* InTagName */;t._index--;//consume the token again\n}};}var stateBeforeCdata1=ifElseState(\"C\",23/* BeforeCdata2 */,16/* InDeclaration */);var stateBeforeCdata2=ifElseState(\"D\",24/* BeforeCdata3 */,16/* InDeclaration */);var stateBeforeCdata3=ifElseState(\"A\",25/* BeforeCdata4 */,16/* InDeclaration */);var stateBeforeCdata4=ifElseState(\"T\",26/* BeforeCdata5 */,16/* InDeclaration */);var stateBeforeCdata5=ifElseState(\"A\",27/* BeforeCdata6 */,16/* InDeclaration */);var stateBeforeScript1=consumeSpecialNameChar(\"R\",34/* BeforeScript2 */);var stateBeforeScript2=consumeSpecialNameChar(\"I\",35/* BeforeScript3 */);var stateBeforeScript3=consumeSpecialNameChar(\"P\",36/* BeforeScript4 */);var stateBeforeScript4=consumeSpecialNameChar(\"T\",37/* BeforeScript5 */);var stateAfterScript1=ifElseState(\"R\",39/* AfterScript2 */,1/* Text */);var stateAfterScript2=ifElseState(\"I\",40/* AfterScript3 */,1/* Text */);var stateAfterScript3=ifElseState(\"P\",41/* AfterScript4 */,1/* Text */);var stateAfterScript4=ifElseState(\"T\",42/* AfterScript5 */,1/* Text */);var stateBeforeStyle1=consumeSpecialNameChar(\"Y\",44/* BeforeStyle2 */);var stateBeforeStyle2=consumeSpecialNameChar(\"L\",45/* BeforeStyle3 */);var stateBeforeStyle3=consumeSpecialNameChar(\"E\",46/* BeforeStyle4 */);var stateAfterStyle1=ifElseState(\"Y\",48/* AfterStyle2 */,1/* Text */);var stateAfterStyle2=ifElseState(\"L\",49/* AfterStyle3 */,1/* Text */);var stateAfterStyle3=ifElseState(\"E\",50/* AfterStyle4 */,1/* Text */);var stateBeforeEntity=ifElseState(\"#\",52/* BeforeNumericEntity */,53/* InNamedEntity */);var stateBeforeNumericEntity=ifElseState(\"X\",55/* InHexEntity */,54/* InNumericEntity */);var Tokenizer=/** @class */function(){function Tokenizer(options,cbs){/** The current state the tokenizer is in. */this._state=1/* Text */;/** The read buffer. */this._buffer=\"\";/** The beginning of the section that is currently being read. */this._sectionStart=0;/** The index within the buffer that we are currently looking at. */this._index=0;/**\n         * Data that has already been processed will be removed from the buffer occasionally.\n         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.\n         */this._bufferOffset=0;/** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */this._baseState=1/* Text */;/** For special parsing behavior inside of script and style tags. */this._special=1/* None */;/** Indicates whether the tokenizer has been paused. */this._running=true;/** Indicates whether the tokenizer has finished running / `.end` has been called. */this._ended=false;this._cbs=cbs;this._xmlMode=!!(options&&options.xmlMode);this._decodeEntities=!!(options&&options.decodeEntities);}Tokenizer.prototype.reset=function(){this._state=1/* Text */;this._buffer=\"\";this._sectionStart=0;this._index=0;this._bufferOffset=0;this._baseState=1/* Text */;this._special=1/* None */;this._running=true;this._ended=false;};Tokenizer.prototype._stateText=function(c){if(c===\"<\"){if(this._index>this._sectionStart){this._cbs.ontext(this._getSection());}this._state=2/* BeforeTagName */;this._sectionStart=this._index;}else if(this._decodeEntities&&this._special===1/* None */&&c===\"&\"){if(this._index>this._sectionStart){this._cbs.ontext(this._getSection());}this._baseState=1/* Text */;this._state=51/* BeforeEntity */;this._sectionStart=this._index;}};Tokenizer.prototype._stateBeforeTagName=function(c){if(c===\"/\"){this._state=5/* BeforeClosingTagName */;}else if(c===\"<\"){this._cbs.ontext(this._getSection());this._sectionStart=this._index;}else if(c===\">\"||this._special!==1/* None */||whitespace(c)){this._state=1/* Text */;}else if(c===\"!\"){this._state=15/* BeforeDeclaration */;this._sectionStart=this._index+1;}else if(c===\"?\"){this._state=17/* InProcessingInstruction */;this._sectionStart=this._index+1;}else{this._state=!this._xmlMode&&(c===\"s\"||c===\"S\")?31/* BeforeSpecial */:3/* InTagName */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInTagName=function(c){if(c===\"/\"||c===\">\"||whitespace(c)){this._emitToken(\"onopentagname\");this._state=8/* BeforeAttributeName */;this._index--;}};Tokenizer.prototype._stateBeforeClosingTagName=function(c){if(whitespace(c)){// ignore\n}else if(c===\">\"){this._state=1/* Text */;}else if(this._special!==1/* None */){if(c===\"s\"||c===\"S\"){this._state=32/* BeforeSpecialEnd */;}else{this._state=1/* Text */;this._index--;}}else{this._state=6/* InClosingTagName */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInClosingTagName=function(c){if(c===\">\"||whitespace(c)){this._emitToken(\"onclosetag\");this._state=7/* AfterClosingTagName */;this._index--;}};Tokenizer.prototype._stateAfterClosingTagName=function(c){//skip everything until \">\"\nif(c===\">\"){this._state=1/* Text */;this._sectionStart=this._index+1;}};Tokenizer.prototype._stateBeforeAttributeName=function(c){if(c===\">\"){this._cbs.onopentagend();this._state=1/* Text */;this._sectionStart=this._index+1;}else if(c===\"/\"){this._state=4/* InSelfClosingTag */;}else if(!whitespace(c)){this._state=9/* InAttributeName */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInSelfClosingTag=function(c){if(c===\">\"){this._cbs.onselfclosingtag();this._state=1/* Text */;this._sectionStart=this._index+1;}else if(!whitespace(c)){this._state=8/* BeforeAttributeName */;this._index--;}};Tokenizer.prototype._stateInAttributeName=function(c){if(c===\"=\"||c===\"/\"||c===\">\"||whitespace(c)){this._cbs.onattribname(this._getSection());this._sectionStart=-1;this._state=10/* AfterAttributeName */;this._index--;}};Tokenizer.prototype._stateAfterAttributeName=function(c){if(c===\"=\"){this._state=11/* BeforeAttributeValue */;}else if(c===\"/\"||c===\">\"){this._cbs.onattribend();this._state=8/* BeforeAttributeName */;this._index--;}else if(!whitespace(c)){this._cbs.onattribend();this._state=9/* InAttributeName */;this._sectionStart=this._index;}};Tokenizer.prototype._stateBeforeAttributeValue=function(c){if(c==='\"'){this._state=12/* InAttributeValueDq */;this._sectionStart=this._index+1;}else if(c===\"'\"){this._state=13/* InAttributeValueSq */;this._sectionStart=this._index+1;}else if(!whitespace(c)){this._state=14/* InAttributeValueNq */;this._sectionStart=this._index;this._index--;//reconsume token\n}};Tokenizer.prototype._stateInAttributeValueDoubleQuotes=function(c){if(c==='\"'){this._emitToken(\"onattribdata\");this._cbs.onattribend();this._state=8/* BeforeAttributeName */;}else if(this._decodeEntities&&c===\"&\"){this._emitToken(\"onattribdata\");this._baseState=this._state;this._state=51/* BeforeEntity */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInAttributeValueSingleQuotes=function(c){if(c===\"'\"){this._emitToken(\"onattribdata\");this._cbs.onattribend();this._state=8/* BeforeAttributeName */;}else if(this._decodeEntities&&c===\"&\"){this._emitToken(\"onattribdata\");this._baseState=this._state;this._state=51/* BeforeEntity */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInAttributeValueNoQuotes=function(c){if(whitespace(c)||c===\">\"){this._emitToken(\"onattribdata\");this._cbs.onattribend();this._state=8/* BeforeAttributeName */;this._index--;}else if(this._decodeEntities&&c===\"&\"){this._emitToken(\"onattribdata\");this._baseState=this._state;this._state=51/* BeforeEntity */;this._sectionStart=this._index;}};Tokenizer.prototype._stateBeforeDeclaration=function(c){this._state=c===\"[\"?22/* BeforeCdata1 */:c===\"-\"?18/* BeforeComment */:16/* InDeclaration */;};Tokenizer.prototype._stateInDeclaration=function(c){if(c===\">\"){this._cbs.ondeclaration(this._getSection());this._state=1/* Text */;this._sectionStart=this._index+1;}};Tokenizer.prototype._stateInProcessingInstruction=function(c){if(c===\">\"){this._cbs.onprocessinginstruction(this._getSection());this._state=1/* Text */;this._sectionStart=this._index+1;}};Tokenizer.prototype._stateBeforeComment=function(c){if(c===\"-\"){this._state=19/* InComment */;this._sectionStart=this._index+1;}else{this._state=16/* InDeclaration */;}};Tokenizer.prototype._stateInComment=function(c){if(c===\"-\")this._state=20/* AfterComment1 */;};Tokenizer.prototype._stateAfterComment1=function(c){if(c===\"-\"){this._state=21/* AfterComment2 */;}else{this._state=19/* InComment */;}};Tokenizer.prototype._stateAfterComment2=function(c){if(c===\">\"){//remove 2 trailing chars\nthis._cbs.oncomment(this._buffer.substring(this._sectionStart,this._index-2));this._state=1/* Text */;this._sectionStart=this._index+1;}else if(c!==\"-\"){this._state=19/* InComment */;}// else: stay in AFTER_COMMENT_2 (`--->`)\n};Tokenizer.prototype._stateBeforeCdata6=function(c){if(c===\"[\"){this._state=28/* InCdata */;this._sectionStart=this._index+1;}else{this._state=16/* InDeclaration */;this._index--;}};Tokenizer.prototype._stateInCdata=function(c){if(c===\"]\")this._state=29/* AfterCdata1 */;};Tokenizer.prototype._stateAfterCdata1=function(c){if(c===\"]\")this._state=30/* AfterCdata2 */;else this._state=28/* InCdata */;};Tokenizer.prototype._stateAfterCdata2=function(c){if(c===\">\"){//remove 2 trailing chars\nthis._cbs.oncdata(this._buffer.substring(this._sectionStart,this._index-2));this._state=1/* Text */;this._sectionStart=this._index+1;}else if(c!==\"]\"){this._state=28/* InCdata */;}//else: stay in AFTER_CDATA_2 (`]]]>`)\n};Tokenizer.prototype._stateBeforeSpecial=function(c){if(c===\"c\"||c===\"C\"){this._state=33/* BeforeScript1 */;}else if(c===\"t\"||c===\"T\"){this._state=43/* BeforeStyle1 */;}else{this._state=3/* InTagName */;this._index--;//consume the token again\n}};Tokenizer.prototype._stateBeforeSpecialEnd=function(c){if(this._special===2/* Script */&&(c===\"c\"||c===\"C\")){this._state=38/* AfterScript1 */;}else if(this._special===3/* Style */&&(c===\"t\"||c===\"T\")){this._state=47/* AfterStyle1 */;}else this._state=1/* Text */;};Tokenizer.prototype._stateBeforeScript5=function(c){if(c===\"/\"||c===\">\"||whitespace(c)){this._special=2/* Script */;}this._state=3/* InTagName */;this._index--;//consume the token again\n};Tokenizer.prototype._stateAfterScript5=function(c){if(c===\">\"||whitespace(c)){this._special=1/* None */;this._state=6/* InClosingTagName */;this._sectionStart=this._index-6;this._index--;//reconsume the token\n}else this._state=1/* Text */;};Tokenizer.prototype._stateBeforeStyle4=function(c){if(c===\"/\"||c===\">\"||whitespace(c)){this._special=3/* Style */;}this._state=3/* InTagName */;this._index--;//consume the token again\n};Tokenizer.prototype._stateAfterStyle4=function(c){if(c===\">\"||whitespace(c)){this._special=1/* None */;this._state=6/* InClosingTagName */;this._sectionStart=this._index-5;this._index--;//reconsume the token\n}else this._state=1/* Text */;};//for entities terminated with a semicolon\nTokenizer.prototype._parseNamedEntityStrict=function(){//offset = 1\nif(this._sectionStart+1<this._index){var entity=this._buffer.substring(this._sectionStart+1,this._index),map=this._xmlMode?xml_json_1[\"default\"]:entities_json_1[\"default\"];if(Object.prototype.hasOwnProperty.call(map,entity)){// @ts-ignore\nthis._emitPartial(map[entity]);this._sectionStart=this._index+1;}}};//parses legacy entities (without trailing semicolon)\nTokenizer.prototype._parseLegacyEntity=function(){var start=this._sectionStart+1;var limit=this._index-start;if(limit>6)limit=6;// The max length of legacy entities is 6\nwhile(limit>=2){// The min length of legacy entities is 2\nvar entity=this._buffer.substr(start,limit);if(Object.prototype.hasOwnProperty.call(legacy_json_1[\"default\"],entity)){// @ts-ignore\nthis._emitPartial(legacy_json_1[\"default\"][entity]);this._sectionStart+=limit+1;return;}else{limit--;}}};Tokenizer.prototype._stateInNamedEntity=function(c){if(c===\";\"){this._parseNamedEntityStrict();if(this._sectionStart+1<this._index&&!this._xmlMode){this._parseLegacyEntity();}this._state=this._baseState;}else if((c<\"a\"||c>\"z\")&&(c<\"A\"||c>\"Z\")&&(c<\"0\"||c>\"9\")){if(this._xmlMode||this._sectionStart+1===this._index){// ignore\n}else if(this._baseState!==1/* Text */){if(c!==\"=\"){this._parseNamedEntityStrict();}}else{this._parseLegacyEntity();}this._state=this._baseState;this._index--;}};Tokenizer.prototype._decodeNumericEntity=function(offset,base){var sectionStart=this._sectionStart+offset;if(sectionStart!==this._index){//parse entity\nvar entity=this._buffer.substring(sectionStart,this._index);var parsed=parseInt(entity,base);this._emitPartial(decode_codepoint_1[\"default\"](parsed));this._sectionStart=this._index;}else{this._sectionStart--;}this._state=this._baseState;};Tokenizer.prototype._stateInNumericEntity=function(c){if(c===\";\"){this._decodeNumericEntity(2,10);this._sectionStart++;}else if(c<\"0\"||c>\"9\"){if(!this._xmlMode){this._decodeNumericEntity(2,10);}else{this._state=this._baseState;}this._index--;}};Tokenizer.prototype._stateInHexEntity=function(c){if(c===\";\"){this._decodeNumericEntity(3,16);this._sectionStart++;}else if((c<\"a\"||c>\"f\")&&(c<\"A\"||c>\"F\")&&(c<\"0\"||c>\"9\")){if(!this._xmlMode){this._decodeNumericEntity(3,16);}else{this._state=this._baseState;}this._index--;}};Tokenizer.prototype._cleanup=function(){if(this._sectionStart<0){this._buffer=\"\";this._bufferOffset+=this._index;this._index=0;}else if(this._running){if(this._state===1/* Text */){if(this._sectionStart!==this._index){this._cbs.ontext(this._buffer.substr(this._sectionStart));}this._buffer=\"\";this._bufferOffset+=this._index;this._index=0;}else if(this._sectionStart===this._index){//the section just started\nthis._buffer=\"\";this._bufferOffset+=this._index;this._index=0;}else{//remove everything unnecessary\nthis._buffer=this._buffer.substr(this._sectionStart);this._index-=this._sectionStart;this._bufferOffset+=this._sectionStart;}this._sectionStart=0;}};//TODO make events conditional\nTokenizer.prototype.write=function(chunk){if(this._ended)this._cbs.onerror(Error(\".write() after done!\"));this._buffer+=chunk;this._parse();};// Iterates through the buffer, calling the function corresponding to the current state.\n// States that are more likely to be hit are higher up, as a performance improvement.\nTokenizer.prototype._parse=function(){while(this._index<this._buffer.length&&this._running){var c=this._buffer.charAt(this._index);if(this._state===1/* Text */){this._stateText(c);}else if(this._state===12/* InAttributeValueDq */){this._stateInAttributeValueDoubleQuotes(c);}else if(this._state===9/* InAttributeName */){this._stateInAttributeName(c);}else if(this._state===19/* InComment */){this._stateInComment(c);}else if(this._state===8/* BeforeAttributeName */){this._stateBeforeAttributeName(c);}else if(this._state===3/* InTagName */){this._stateInTagName(c);}else if(this._state===6/* InClosingTagName */){this._stateInClosingTagName(c);}else if(this._state===2/* BeforeTagName */){this._stateBeforeTagName(c);}else if(this._state===10/* AfterAttributeName */){this._stateAfterAttributeName(c);}else if(this._state===13/* InAttributeValueSq */){this._stateInAttributeValueSingleQuotes(c);}else if(this._state===11/* BeforeAttributeValue */){this._stateBeforeAttributeValue(c);}else if(this._state===5/* BeforeClosingTagName */){this._stateBeforeClosingTagName(c);}else if(this._state===7/* AfterClosingTagName */){this._stateAfterClosingTagName(c);}else if(this._state===31/* BeforeSpecial */){this._stateBeforeSpecial(c);}else if(this._state===20/* AfterComment1 */){this._stateAfterComment1(c);}else if(this._state===14/* InAttributeValueNq */){this._stateInAttributeValueNoQuotes(c);}else if(this._state===4/* InSelfClosingTag */){this._stateInSelfClosingTag(c);}else if(this._state===16/* InDeclaration */){this._stateInDeclaration(c);}else if(this._state===15/* BeforeDeclaration */){this._stateBeforeDeclaration(c);}else if(this._state===21/* AfterComment2 */){this._stateAfterComment2(c);}else if(this._state===18/* BeforeComment */){this._stateBeforeComment(c);}else if(this._state===32/* BeforeSpecialEnd */){this._stateBeforeSpecialEnd(c);}else if(this._state===38/* AfterScript1 */){stateAfterScript1(this,c);}else if(this._state===39/* AfterScript2 */){stateAfterScript2(this,c);}else if(this._state===40/* AfterScript3 */){stateAfterScript3(this,c);}else if(this._state===33/* BeforeScript1 */){stateBeforeScript1(this,c);}else if(this._state===34/* BeforeScript2 */){stateBeforeScript2(this,c);}else if(this._state===35/* BeforeScript3 */){stateBeforeScript3(this,c);}else if(this._state===36/* BeforeScript4 */){stateBeforeScript4(this,c);}else if(this._state===37/* BeforeScript5 */){this._stateBeforeScript5(c);}else if(this._state===41/* AfterScript4 */){stateAfterScript4(this,c);}else if(this._state===42/* AfterScript5 */){this._stateAfterScript5(c);}else if(this._state===43/* BeforeStyle1 */){stateBeforeStyle1(this,c);}else if(this._state===28/* InCdata */){this._stateInCdata(c);}else if(this._state===44/* BeforeStyle2 */){stateBeforeStyle2(this,c);}else if(this._state===45/* BeforeStyle3 */){stateBeforeStyle3(this,c);}else if(this._state===46/* BeforeStyle4 */){this._stateBeforeStyle4(c);}else if(this._state===47/* AfterStyle1 */){stateAfterStyle1(this,c);}else if(this._state===48/* AfterStyle2 */){stateAfterStyle2(this,c);}else if(this._state===49/* AfterStyle3 */){stateAfterStyle3(this,c);}else if(this._state===50/* AfterStyle4 */){this._stateAfterStyle4(c);}else if(this._state===17/* InProcessingInstruction */){this._stateInProcessingInstruction(c);}else if(this._state===53/* InNamedEntity */){this._stateInNamedEntity(c);}else if(this._state===22/* BeforeCdata1 */){stateBeforeCdata1(this,c);}else if(this._state===51/* BeforeEntity */){stateBeforeEntity(this,c);}else if(this._state===23/* BeforeCdata2 */){stateBeforeCdata2(this,c);}else if(this._state===24/* BeforeCdata3 */){stateBeforeCdata3(this,c);}else if(this._state===29/* AfterCdata1 */){this._stateAfterCdata1(c);}else if(this._state===30/* AfterCdata2 */){this._stateAfterCdata2(c);}else if(this._state===25/* BeforeCdata4 */){stateBeforeCdata4(this,c);}else if(this._state===26/* BeforeCdata5 */){stateBeforeCdata5(this,c);}else if(this._state===27/* BeforeCdata6 */){this._stateBeforeCdata6(c);}else if(this._state===55/* InHexEntity */){this._stateInHexEntity(c);}else if(this._state===54/* InNumericEntity */){this._stateInNumericEntity(c);}else if(this._state===52/* BeforeNumericEntity */){stateBeforeNumericEntity(this,c);}else{this._cbs.onerror(Error(\"unknown _state\"),this._state);}this._index++;}this._cleanup();};Tokenizer.prototype.pause=function(){this._running=false;};Tokenizer.prototype.resume=function(){this._running=true;if(this._index<this._buffer.length){this._parse();}if(this._ended){this._finish();}};Tokenizer.prototype.end=function(chunk){if(this._ended)this._cbs.onerror(Error(\".end() after done!\"));if(chunk)this.write(chunk);this._ended=true;if(this._running)this._finish();};Tokenizer.prototype._finish=function(){//if there is remaining data, emit it in a reasonable way\nif(this._sectionStart<this._index){this._handleTrailingData();}this._cbs.onend();};Tokenizer.prototype._handleTrailingData=function(){var data=this._buffer.substr(this._sectionStart);if(this._state===28/* InCdata */||this._state===29/* AfterCdata1 */||this._state===30/* AfterCdata2 */){this._cbs.oncdata(data);}else if(this._state===19/* InComment */||this._state===20/* AfterComment1 */||this._state===21/* AfterComment2 */){this._cbs.oncomment(data);}else if(this._state===53/* InNamedEntity */&&!this._xmlMode){this._parseLegacyEntity();if(this._sectionStart<this._index){this._state=this._baseState;this._handleTrailingData();}}else if(this._state===54/* InNumericEntity */&&!this._xmlMode){this._decodeNumericEntity(2,10);if(this._sectionStart<this._index){this._state=this._baseState;this._handleTrailingData();}}else if(this._state===55/* InHexEntity */&&!this._xmlMode){this._decodeNumericEntity(3,16);if(this._sectionStart<this._index){this._state=this._baseState;this._handleTrailingData();}}else if(this._state!==3/* InTagName */&&this._state!==8/* BeforeAttributeName */&&this._state!==11/* BeforeAttributeValue */&&this._state!==10/* AfterAttributeName */&&this._state!==9/* InAttributeName */&&this._state!==13/* InAttributeValueSq */&&this._state!==12/* InAttributeValueDq */&&this._state!==14/* InAttributeValueNq */&&this._state!==6/* InClosingTagName */){this._cbs.ontext(data);}//else, ignore remaining data\n//TODO add a way to remove current tag\n};Tokenizer.prototype.getAbsoluteIndex=function(){return this._bufferOffset+this._index;};Tokenizer.prototype._getSection=function(){return this._buffer.substring(this._sectionStart,this._index);};Tokenizer.prototype._emitToken=function(name){this._cbs[name](this._getSection());this._sectionStart=-1;};Tokenizer.prototype._emitPartial=function(value){if(this._baseState!==1/* Text */){this._cbs.onattribdata(value);//TODO implement the new event\n}else{this._cbs.ontext(value);}};return Tokenizer;}();exports[\"default\"]=Tokenizer;},{\"entities/lib/decode_codepoint\":18,\"entities/lib/maps/entities.json\":22,\"entities/lib/maps/legacy.json\":23,\"entities/lib/maps/xml.json\":24}],31:[function(require,module,exports){\"use strict\";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}}var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result[\"default\"]=mod;return result;};Object.defineProperty(exports,\"__esModule\",{value:true});var Parser_1=require(\"./Parser\");exports.Parser=Parser_1.Parser;var domhandler_1=require(\"domhandler\");exports.DomHandler=domhandler_1.DomHandler;exports.DefaultHandler=domhandler_1.DomHandler;// Helper methods\n/**\n * Parses data, returns the resulting DOM.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM builder.\n */function parseDOM(data,options){var handler=new domhandler_1.DomHandler(void 0,options);new Parser_1.Parser(handler,options).end(data);return handler.dom;}exports.parseDOM=parseDOM;/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param cb A callback that will be called once parsing has been completed.\n * @param options Optional options for the parser and DOM builder.\n * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.\n */function createDomStream(cb,options,elementCb){var handler=new domhandler_1.DomHandler(cb,options,elementCb);return new Parser_1.Parser(handler,options);}exports.createDomStream=createDomStream;var Tokenizer_1=require(\"./Tokenizer\");exports.Tokenizer=Tokenizer_1[\"default\"];var ElementType=__importStar(require(\"domelementtype\"));exports.ElementType=ElementType;/**\n * List of all events that the parser emits.\n *\n * Format: eventname: number of arguments.\n */exports.EVENTS={attribute:2,cdatastart:0,cdataend:0,text:1,processinginstruction:2,comment:1,commentend:0,closetag:1,opentag:2,opentagname:1,error:1,end:0};/*\n    All of the following exports exist for backwards-compatibility.\n    They should probably be removed eventually.\n*/__export(require(\"./FeedHandler\"));__export(require(\"./WritableStream\"));__export(require(\"./CollectingHandler\"));var DomUtils=__importStar(require(\"domutils\"));exports.DomUtils=DomUtils;var FeedHandler_1=require(\"./FeedHandler\");exports.RssHandler=FeedHandler_1.FeedHandler;},{\"./CollectingHandler\":26,\"./FeedHandler\":27,\"./Parser\":29,\"./Tokenizer\":30,\"./WritableStream\":2,\"domelementtype\":6,\"domhandler\":7,\"domutils\":10}],32:[function(require,module,exports){exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var nBits=-7;var i=isLE?nBytes-1:0;var d=isLE?-1:1;var s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8){}m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8){}if(e===0){e=1-eBias;}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity;}else{m=m+Math.pow(2,mLen);e=e-eBias;}return(s?-1:1)*m*Math.pow(2,e-mLen);};exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0;var i=isLE?0:nBytes-1;var d=isLE?1:-1;var s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax;}else{e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2;}if(e+eBias>=1){value+=rt/c;}else{value+=rt*Math.pow(2,1-eBias);}if(value*c>=2){e++;c/=2;}if(e+eBias>=eMax){m=0;e=eMax;}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias;}else{m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0;}}for(;mLen>=8;buffer[offset+i]=m&0xff,i+=d,m/=256,mLen-=8){}e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&0xff,i+=d,e/=256,eLen-=8){}buffer[offset+i-d]|=s*128;};},{}],33:[function(require,module,exports){var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var DataView=getNative(root,'DataView');module.exports=DataView;},{\"./_getNative\":93,\"./_root\":130}],34:[function(require,module,exports){var hashClear=require('./_hashClear'),hashDelete=require('./_hashDelete'),hashGet=require('./_hashGet'),hashHas=require('./_hashHas'),hashSet=require('./_hashSet');/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}// Add methods to `Hash`.\nHash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;module.exports=Hash;},{\"./_hashClear\":100,\"./_hashDelete\":101,\"./_hashGet\":102,\"./_hashHas\":103,\"./_hashSet\":104}],35:[function(require,module,exports){var listCacheClear=require('./_listCacheClear'),listCacheDelete=require('./_listCacheDelete'),listCacheGet=require('./_listCacheGet'),listCacheHas=require('./_listCacheHas'),listCacheSet=require('./_listCacheSet');/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}// Add methods to `ListCache`.\nListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;module.exports=ListCache;},{\"./_listCacheClear\":113,\"./_listCacheDelete\":114,\"./_listCacheGet\":115,\"./_listCacheHas\":116,\"./_listCacheSet\":117}],36:[function(require,module,exports){var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var Map=getNative(root,'Map');module.exports=Map;},{\"./_getNative\":93,\"./_root\":130}],37:[function(require,module,exports){var mapCacheClear=require('./_mapCacheClear'),mapCacheDelete=require('./_mapCacheDelete'),mapCacheGet=require('./_mapCacheGet'),mapCacheHas=require('./_mapCacheHas'),mapCacheSet=require('./_mapCacheSet');/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}// Add methods to `MapCache`.\nMapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;module.exports=MapCache;},{\"./_mapCacheClear\":118,\"./_mapCacheDelete\":119,\"./_mapCacheGet\":120,\"./_mapCacheHas\":121,\"./_mapCacheSet\":122}],38:[function(require,module,exports){var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var Promise=getNative(root,'Promise');module.exports=Promise;},{\"./_getNative\":93,\"./_root\":130}],39:[function(require,module,exports){var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var Set=getNative(root,'Set');module.exports=Set;},{\"./_getNative\":93,\"./_root\":130}],40:[function(require,module,exports){var ListCache=require('./_ListCache'),stackClear=require('./_stackClear'),stackDelete=require('./_stackDelete'),stackGet=require('./_stackGet'),stackHas=require('./_stackHas'),stackSet=require('./_stackSet');/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}// Add methods to `Stack`.\nStack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;module.exports=Stack;},{\"./_ListCache\":35,\"./_stackClear\":134,\"./_stackDelete\":135,\"./_stackGet\":136,\"./_stackHas\":137,\"./_stackSet\":138}],41:[function(require,module,exports){var root=require('./_root');/** Built-in value references. */var _Symbol=root.Symbol;module.exports=_Symbol;},{\"./_root\":130}],42:[function(require,module,exports){var root=require('./_root');/** Built-in value references. */var Uint8Array=root.Uint8Array;module.exports=Uint8Array;},{\"./_root\":130}],43:[function(require,module,exports){var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var WeakMap=getNative(root,'WeakMap');module.exports=WeakMap;},{\"./_getNative\":93,\"./_root\":130}],44:[function(require,module,exports){/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}module.exports=apply;},{}],45:[function(require,module,exports){/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}module.exports=arrayEach;},{}],46:[function(require,module,exports){/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}module.exports=arrayFilter;},{}],47:[function(require,module,exports){var baseTimes=require('./_baseTimes'),isArguments=require('./isArguments'),isArray=require('./isArray'),isBuffer=require('./isBuffer'),isIndex=require('./_isIndex'),isTypedArray=require('./isTypedArray');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.\nkey=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.\nisBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.\nisType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.\nisIndex(key,length)))){result.push(key);}}return result;}module.exports=arrayLikeKeys;},{\"./_baseTimes\":72,\"./_isIndex\":108,\"./isArguments\":145,\"./isArray\":146,\"./isBuffer\":149,\"./isTypedArray\":159}],48:[function(require,module,exports){/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}module.exports=arrayMap;},{}],49:[function(require,module,exports){/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}module.exports=arrayPush;},{}],50:[function(require,module,exports){var baseAssignValue=require('./_baseAssignValue'),eq=require('./eq');/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}module.exports=assignMergeValue;},{\"./_baseAssignValue\":55,\"./eq\":142}],51:[function(require,module,exports){var baseAssignValue=require('./_baseAssignValue'),eq=require('./eq');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}module.exports=assignValue;},{\"./_baseAssignValue\":55,\"./eq\":142}],52:[function(require,module,exports){var eq=require('./eq');/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}module.exports=assocIndexOf;},{\"./eq\":142}],53:[function(require,module,exports){var copyObject=require('./_copyObject'),keys=require('./keys');/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}module.exports=baseAssign;},{\"./_copyObject\":82,\"./keys\":160}],54:[function(require,module,exports){var copyObject=require('./_copyObject'),keysIn=require('./keysIn');/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}module.exports=baseAssignIn;},{\"./_copyObject\":82,\"./keysIn\":161}],55:[function(require,module,exports){var defineProperty=require('./_defineProperty');/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}module.exports=baseAssignValue;},{\"./_defineProperty\":88}],56:[function(require,module,exports){var Stack=require('./_Stack'),arrayEach=require('./_arrayEach'),assignValue=require('./_assignValue'),baseAssign=require('./_baseAssign'),baseAssignIn=require('./_baseAssignIn'),cloneBuffer=require('./_cloneBuffer'),copyArray=require('./_copyArray'),copySymbols=require('./_copySymbols'),copySymbolsIn=require('./_copySymbolsIn'),getAllKeys=require('./_getAllKeys'),getAllKeysIn=require('./_getAllKeysIn'),getTag=require('./_getTag'),initCloneArray=require('./_initCloneArray'),initCloneByTag=require('./_initCloneByTag'),initCloneObject=require('./_initCloneObject'),isArray=require('./isArray'),isBuffer=require('./isBuffer'),isMap=require('./isMap'),isObject=require('./isObject'),isSet=require('./isSet'),keys=require('./keys');/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',objectTag='[object Object]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',weakMapTag='[object WeakMap]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.\nstack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).\nassignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}module.exports=baseClone;},{\"./_Stack\":40,\"./_arrayEach\":45,\"./_assignValue\":51,\"./_baseAssign\":53,\"./_baseAssignIn\":54,\"./_cloneBuffer\":76,\"./_copyArray\":81,\"./_copySymbols\":83,\"./_copySymbolsIn\":84,\"./_getAllKeys\":90,\"./_getAllKeysIn\":91,\"./_getTag\":98,\"./_initCloneArray\":105,\"./_initCloneByTag\":106,\"./_initCloneObject\":107,\"./isArray\":146,\"./isBuffer\":149,\"./isMap\":152,\"./isObject\":153,\"./isSet\":156,\"./keys\":160}],57:[function(require,module,exports){var isObject=require('./isObject');/** Built-in value references. */var objectCreate=Object.create;/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();module.exports=baseCreate;},{\"./isObject\":153}],58:[function(require,module,exports){var createBaseFor=require('./_createBaseFor');/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */var baseFor=createBaseFor();module.exports=baseFor;},{\"./_createBaseFor\":87}],59:[function(require,module,exports){var arrayPush=require('./_arrayPush'),isArray=require('./isArray');/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}module.exports=baseGetAllKeys;},{\"./_arrayPush\":49,\"./isArray\":146}],60:[function(require,module,exports){var _Symbol2=require('./_Symbol'),getRawTag=require('./_getRawTag'),objectToString=require('./_objectToString');/** `Object#toString` result references. */var nullTag='[object Null]',undefinedTag='[object Undefined]';/** Built-in value references. */var symToStringTag=_Symbol2?_Symbol2.toStringTag:undefined;/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}module.exports=baseGetTag;},{\"./_Symbol\":41,\"./_getRawTag\":95,\"./_objectToString\":127}],61:[function(require,module,exports){var baseGetTag=require('./_baseGetTag'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var argsTag='[object Arguments]';/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}module.exports=baseIsArguments;},{\"./_baseGetTag\":60,\"./isObjectLike\":154}],62:[function(require,module,exports){var getTag=require('./_getTag'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var mapTag='[object Map]';/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}module.exports=baseIsMap;},{\"./_getTag\":98,\"./isObjectLike\":154}],63:[function(require,module,exports){var isFunction=require('./isFunction'),isMasked=require('./_isMasked'),isObject=require('./isObject'),toSource=require('./_toSource');/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */var reRegExpChar=/[\\\\^$.*+?()[\\]{}|]/g;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\\[object .+?Constructor\\]$/;/** Used for built-in method references. */var funcProto=Function.prototype,objectProto=Object.prototype;/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,'$1.*?')+'$');/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}module.exports=baseIsNative;},{\"./_isMasked\":111,\"./_toSource\":139,\"./isFunction\":150,\"./isObject\":153}],64:[function(require,module,exports){var getTag=require('./_getTag'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var setTag='[object Set]';/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}module.exports=baseIsSet;},{\"./_getTag\":98,\"./isObjectLike\":154}],65:[function(require,module,exports){var baseGetTag=require('./_baseGetTag'),isLength=require('./isLength'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',mapTag='[object Map]',numberTag='[object Number]',objectTag='[object Object]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',weakMapTag='[object WeakMap]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}module.exports=baseIsTypedArray;},{\"./_baseGetTag\":60,\"./isLength\":151,\"./isObjectLike\":154}],66:[function(require,module,exports){var isPrototype=require('./_isPrototype'),nativeKeys=require('./_nativeKeys');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}module.exports=baseKeys;},{\"./_isPrototype\":112,\"./_nativeKeys\":124}],67:[function(require,module,exports){var isObject=require('./isObject'),isPrototype=require('./_isPrototype'),nativeKeysIn=require('./_nativeKeysIn');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}module.exports=baseKeysIn;},{\"./_isPrototype\":112,\"./_nativeKeysIn\":125,\"./isObject\":153}],68:[function(require,module,exports){var Stack=require('./_Stack'),assignMergeValue=require('./_assignMergeValue'),baseFor=require('./_baseFor'),baseMergeDeep=require('./_baseMergeDeep'),isObject=require('./isObject'),keysIn=require('./keysIn'),safeGet=require('./_safeGet');/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}module.exports=baseMerge;},{\"./_Stack\":40,\"./_assignMergeValue\":50,\"./_baseFor\":58,\"./_baseMergeDeep\":69,\"./_safeGet\":131,\"./isObject\":153,\"./keysIn\":161}],69:[function(require,module,exports){var assignMergeValue=require('./_assignMergeValue'),cloneBuffer=require('./_cloneBuffer'),cloneTypedArray=require('./_cloneTypedArray'),copyArray=require('./_copyArray'),initCloneObject=require('./_initCloneObject'),isArguments=require('./isArguments'),isArray=require('./isArray'),isArrayLikeObject=require('./isArrayLikeObject'),isBuffer=require('./isBuffer'),isFunction=require('./isFunction'),isObject=require('./isObject'),isPlainObject=require('./isPlainObject'),isTypedArray=require('./isTypedArray'),safeGet=require('./_safeGet'),toPlainObject=require('./toPlainObject');/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).\nstack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}module.exports=baseMergeDeep;},{\"./_assignMergeValue\":50,\"./_cloneBuffer\":76,\"./_cloneTypedArray\":80,\"./_copyArray\":81,\"./_initCloneObject\":107,\"./_safeGet\":131,\"./isArguments\":145,\"./isArray\":146,\"./isArrayLikeObject\":148,\"./isBuffer\":149,\"./isFunction\":150,\"./isObject\":153,\"./isPlainObject\":155,\"./isTypedArray\":159,\"./toPlainObject\":165}],70:[function(require,module,exports){var identity=require('./identity'),overRest=require('./_overRest'),setToString=require('./_setToString');/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}module.exports=baseRest;},{\"./_overRest\":129,\"./_setToString\":132,\"./identity\":144}],71:[function(require,module,exports){var constant=require('./constant'),defineProperty=require('./_defineProperty'),identity=require('./identity');/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};module.exports=baseSetToString;},{\"./_defineProperty\":88,\"./constant\":141,\"./identity\":144}],72:[function(require,module,exports){/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}module.exports=baseTimes;},{}],73:[function(require,module,exports){var _Symbol3=require('./_Symbol'),arrayMap=require('./_arrayMap'),isArray=require('./isArray'),isSymbol=require('./isSymbol');/** Used as references for various `Number` constants. */var INFINITY=1/0;/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol3?_Symbol3.prototype:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.\nif(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).\nreturn arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}module.exports=baseToString;},{\"./_Symbol\":41,\"./_arrayMap\":48,\"./isArray\":146,\"./isSymbol\":158}],74:[function(require,module,exports){/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */function baseUnary(func){return function(value){return func(value);};}module.exports=baseUnary;},{}],75:[function(require,module,exports){var Uint8Array=require('./_Uint8Array');/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}module.exports=cloneArrayBuffer;},{\"./_Uint8Array\":42}],76:[function(require,module,exports){var root=require('./_root');/** Detect free variable `exports`. */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&_typeof(module)=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Built-in value references. */var Buffer=moduleExports?root.Buffer:undefined,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined;/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}module.exports=cloneBuffer;},{\"./_root\":130}],77:[function(require,module,exports){var cloneArrayBuffer=require('./_cloneArrayBuffer');/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}module.exports=cloneDataView;},{\"./_cloneArrayBuffer\":75}],78:[function(require,module,exports){/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\\w*$/;/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}module.exports=cloneRegExp;},{}],79:[function(require,module,exports){var _Symbol4=require('./_Symbol');/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol4?_Symbol4.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined;/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}module.exports=cloneSymbol;},{\"./_Symbol\":41}],80:[function(require,module,exports){var cloneArrayBuffer=require('./_cloneArrayBuffer');/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}module.exports=cloneTypedArray;},{\"./_cloneArrayBuffer\":75}],81:[function(require,module,exports){/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}module.exports=copyArray;},{}],82:[function(require,module,exports){var assignValue=require('./_assignValue'),baseAssignValue=require('./_baseAssignValue');/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}module.exports=copyObject;},{\"./_assignValue\":51,\"./_baseAssignValue\":55}],83:[function(require,module,exports){var copyObject=require('./_copyObject'),getSymbols=require('./_getSymbols');/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}module.exports=copySymbols;},{\"./_copyObject\":82,\"./_getSymbols\":96}],84:[function(require,module,exports){var copyObject=require('./_copyObject'),getSymbolsIn=require('./_getSymbolsIn');/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}module.exports=copySymbolsIn;},{\"./_copyObject\":82,\"./_getSymbolsIn\":97}],85:[function(require,module,exports){var root=require('./_root');/** Used to detect overreaching core-js shims. */var coreJsData=root['__core-js_shared__'];module.exports=coreJsData;},{\"./_root\":130}],86:[function(require,module,exports){var baseRest=require('./_baseRest'),isIterateeCall=require('./_isIterateeCall');/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}module.exports=createAssigner;},{\"./_baseRest\":70,\"./_isIterateeCall\":109}],87:[function(require,module,exports){/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}module.exports=createBaseFor;},{}],88:[function(require,module,exports){var getNative=require('./_getNative');var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();module.exports=defineProperty;},{\"./_getNative\":93}],89:[function(require,module,exports){(function(global){/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(global)=='object'&&global&&global.Object===Object&&global;module.exports=freeGlobal;}).call(this,typeof global!==\"undefined\"?global:typeof self!==\"undefined\"?self:typeof window!==\"undefined\"?window:{});},{}],90:[function(require,module,exports){var baseGetAllKeys=require('./_baseGetAllKeys'),getSymbols=require('./_getSymbols'),keys=require('./keys');/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}module.exports=getAllKeys;},{\"./_baseGetAllKeys\":59,\"./_getSymbols\":96,\"./keys\":160}],91:[function(require,module,exports){var baseGetAllKeys=require('./_baseGetAllKeys'),getSymbolsIn=require('./_getSymbolsIn'),keysIn=require('./keysIn');/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}module.exports=getAllKeysIn;},{\"./_baseGetAllKeys\":59,\"./_getSymbolsIn\":97,\"./keysIn\":161}],92:[function(require,module,exports){var isKeyable=require('./_isKeyable');/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}module.exports=getMapData;},{\"./_isKeyable\":110}],93:[function(require,module,exports){var baseIsNative=require('./_baseIsNative'),getValue=require('./_getValue');/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}module.exports=getNative;},{\"./_baseIsNative\":63,\"./_getValue\":99}],94:[function(require,module,exports){var overArg=require('./_overArg');/** Built-in value references. */var getPrototype=overArg(Object.getPrototypeOf,Object);module.exports=getPrototype;},{\"./_overArg\":128}],95:[function(require,module,exports){var _Symbol5=require('./_Symbol');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */var nativeObjectToString=objectProto.toString;/** Built-in value references. */var symToStringTag=_Symbol5?_Symbol5.toStringTag:undefined;/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}module.exports=getRawTag;},{\"./_Symbol\":41}],96:[function(require,module,exports){var arrayFilter=require('./_arrayFilter'),stubArray=require('./stubArray');/** Used for built-in method references. */var objectProto=Object.prototype;/** Built-in value references. */var propertyIsEnumerable=objectProto.propertyIsEnumerable;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeGetSymbols=Object.getOwnPropertySymbols;/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};module.exports=getSymbols;},{\"./_arrayFilter\":46,\"./stubArray\":163}],97:[function(require,module,exports){var arrayPush=require('./_arrayPush'),getPrototype=require('./_getPrototype'),getSymbols=require('./_getSymbols'),stubArray=require('./stubArray');/* Built-in method references for those with the same name as other `lodash` methods. */var nativeGetSymbols=Object.getOwnPropertySymbols;/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};module.exports=getSymbolsIn;},{\"./_arrayPush\":49,\"./_getPrototype\":94,\"./_getSymbols\":96,\"./stubArray\":163}],98:[function(require,module,exports){var DataView=require('./_DataView'),Map=require('./_Map'),Promise=require('./_Promise'),Set=require('./_Set'),WeakMap=require('./_WeakMap'),baseGetTag=require('./_baseGetTag'),toSource=require('./_toSource');/** `Object#toString` result references. */var mapTag='[object Map]',objectTag='[object Object]',promiseTag='[object Promise]',setTag='[object Set]',weakMapTag='[object WeakMap]';var dataViewTag='[object DataView]';/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}module.exports=getTag;},{\"./_DataView\":33,\"./_Map\":36,\"./_Promise\":38,\"./_Set\":39,\"./_WeakMap\":43,\"./_baseGetTag\":60,\"./_toSource\":139}],99:[function(require,module,exports){/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */function getValue(object,key){return object==null?undefined:object[key];}module.exports=getValue;},{}],100:[function(require,module,exports){var nativeCreate=require('./_nativeCreate');/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}module.exports=hashClear;},{\"./_nativeCreate\":123}],101:[function(require,module,exports){/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}module.exports=hashDelete;},{}],102:[function(require,module,exports){var nativeCreate=require('./_nativeCreate');/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}module.exports=hashGet;},{\"./_nativeCreate\":123}],103:[function(require,module,exports){var nativeCreate=require('./_nativeCreate');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}module.exports=hashHas;},{\"./_nativeCreate\":123}],104:[function(require,module,exports){var nativeCreate=require('./_nativeCreate');/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}module.exports=hashSet;},{\"./_nativeCreate\":123}],105:[function(require,module,exports){/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.\nif(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}module.exports=initCloneArray;},{}],106:[function(require,module,exports){var cloneArrayBuffer=require('./_cloneArrayBuffer'),cloneDataView=require('./_cloneDataView'),cloneRegExp=require('./_cloneRegExp'),cloneSymbol=require('./_cloneSymbol'),cloneTypedArray=require('./_cloneTypedArray');/** `Object#toString` result references. */var boolTag='[object Boolean]',dateTag='[object Date]',mapTag='[object Map]',numberTag='[object Number]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}module.exports=initCloneByTag;},{\"./_cloneArrayBuffer\":75,\"./_cloneDataView\":77,\"./_cloneRegExp\":78,\"./_cloneSymbol\":79,\"./_cloneTypedArray\":80}],107:[function(require,module,exports){var baseCreate=require('./_baseCreate'),getPrototype=require('./_getPrototype'),isPrototype=require('./_isPrototype');/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}module.exports=initCloneObject;},{\"./_baseCreate\":57,\"./_getPrototype\":94,\"./_isPrototype\":112}],108:[function(require,module,exports){/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\\d*)$/;/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */function isIndex(value,length){var type=_typeof(value);length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}module.exports=isIndex;},{}],109:[function(require,module,exports){var eq=require('./eq'),isArrayLike=require('./isArrayLike'),isIndex=require('./_isIndex'),isObject=require('./isObject');/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}module.exports=isIterateeCall;},{\"./_isIndex\":108,\"./eq\":142,\"./isArrayLike\":147,\"./isObject\":153}],110:[function(require,module,exports){/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}module.exports=isKeyable;},{}],111:[function(require,module,exports){var coreJsData=require('./_coreJsData');/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}module.exports=isMasked;},{\"./_coreJsData\":85}],112:[function(require,module,exports){/** Used for built-in method references. */var objectProto=Object.prototype;/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}module.exports=isPrototype;},{}],113:[function(require,module,exports){/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */function listCacheClear(){this.__data__=[];this.size=0;}module.exports=listCacheClear;},{}],114:[function(require,module,exports){var assocIndexOf=require('./_assocIndexOf');/** Used for built-in method references. */var arrayProto=Array.prototype;/** Built-in value references. */var splice=arrayProto.splice;/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}module.exports=listCacheDelete;},{\"./_assocIndexOf\":52}],115:[function(require,module,exports){var assocIndexOf=require('./_assocIndexOf');/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}module.exports=listCacheGet;},{\"./_assocIndexOf\":52}],116:[function(require,module,exports){var assocIndexOf=require('./_assocIndexOf');/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}module.exports=listCacheHas;},{\"./_assocIndexOf\":52}],117:[function(require,module,exports){var assocIndexOf=require('./_assocIndexOf');/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}module.exports=listCacheSet;},{\"./_assocIndexOf\":52}],118:[function(require,module,exports){var Hash=require('./_Hash'),ListCache=require('./_ListCache'),Map=require('./_Map');/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}module.exports=mapCacheClear;},{\"./_Hash\":34,\"./_ListCache\":35,\"./_Map\":36}],119:[function(require,module,exports){var getMapData=require('./_getMapData');/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}module.exports=mapCacheDelete;},{\"./_getMapData\":92}],120:[function(require,module,exports){var getMapData=require('./_getMapData');/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */function mapCacheGet(key){return getMapData(this,key).get(key);}module.exports=mapCacheGet;},{\"./_getMapData\":92}],121:[function(require,module,exports){var getMapData=require('./_getMapData');/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */function mapCacheHas(key){return getMapData(this,key).has(key);}module.exports=mapCacheHas;},{\"./_getMapData\":92}],122:[function(require,module,exports){var getMapData=require('./_getMapData');/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}module.exports=mapCacheSet;},{\"./_getMapData\":92}],123:[function(require,module,exports){var getNative=require('./_getNative');/* Built-in method references that are verified to be native. */var nativeCreate=getNative(Object,'create');module.exports=nativeCreate;},{\"./_getNative\":93}],124:[function(require,module,exports){var overArg=require('./_overArg');/* Built-in method references for those with the same name as other `lodash` methods. */var nativeKeys=overArg(Object.keys,Object);module.exports=nativeKeys;},{\"./_overArg\":128}],125:[function(require,module,exports){/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}module.exports=nativeKeysIn;},{}],126:[function(require,module,exports){var freeGlobal=require('./_freeGlobal');/** Detect free variable `exports`. */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&_typeof(module)=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.\nvar types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.\nreturn freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();module.exports=nodeUtil;},{\"./_freeGlobal\":89}],127:[function(require,module,exports){/** Used for built-in method references. */var objectProto=Object.prototype;/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */var nativeObjectToString=objectProto.toString;/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */function objectToString(value){return nativeObjectToString.call(value);}module.exports=objectToString;},{}],128:[function(require,module,exports){/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */function overArg(func,transform){return function(arg){return func(transform(arg));};}module.exports=overArg;},{}],129:[function(require,module,exports){var apply=require('./_apply');/* Built-in method references for those with the same name as other `lodash` methods. */var nativeMax=Math.max;/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}module.exports=overRest;},{\"./_apply\":44}],130:[function(require,module,exports){var freeGlobal=require('./_freeGlobal');/** Detect free variable `self`. */var freeSelf=(typeof self===\"undefined\"?\"undefined\":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();module.exports=root;},{\"./_freeGlobal\":89}],131:[function(require,module,exports){/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}module.exports=safeGet;},{}],132:[function(require,module,exports){var baseSetToString=require('./_baseSetToString'),shortOut=require('./_shortOut');/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */var setToString=shortOut(baseSetToString);module.exports=setToString;},{\"./_baseSetToString\":71,\"./_shortOut\":133}],133:[function(require,module,exports){/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeNow=Date.now;/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}module.exports=shortOut;},{}],134:[function(require,module,exports){var ListCache=require('./_ListCache');/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */function stackClear(){this.__data__=new ListCache();this.size=0;}module.exports=stackClear;},{\"./_ListCache\":35}],135:[function(require,module,exports){/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}module.exports=stackDelete;},{}],136:[function(require,module,exports){/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */function stackGet(key){return this.__data__.get(key);}module.exports=stackGet;},{}],137:[function(require,module,exports){/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */function stackHas(key){return this.__data__.has(key);}module.exports=stackHas;},{}],138:[function(require,module,exports){var ListCache=require('./_ListCache'),Map=require('./_Map'),MapCache=require('./_MapCache');/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}module.exports=stackSet;},{\"./_ListCache\":35,\"./_Map\":36,\"./_MapCache\":37}],139:[function(require,module,exports){/** Used for built-in method references. */var funcProto=Function.prototype;/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}module.exports=toSource;},{}],140:[function(require,module,exports){var baseClone=require('./_baseClone');/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_SYMBOLS_FLAG=4;/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}module.exports=cloneDeep;},{\"./_baseClone\":56}],141:[function(require,module,exports){/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */function constant(value){return function(){return value;};}module.exports=constant;},{}],142:[function(require,module,exports){/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */function eq(value,other){return value===other||value!==value&&other!==other;}module.exports=eq;},{}],143:[function(require,module,exports){var toString=require('./toString');/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */var reRegExpChar=/[\\\\^$.*+?()[\\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/**\n * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\\\$&'):string;}module.exports=escapeRegExp;},{\"./toString\":166}],144:[function(require,module,exports){/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */function identity(value){return value;}module.exports=identity;},{}],145:[function(require,module,exports){var baseIsArguments=require('./_baseIsArguments'),isObjectLike=require('./isObjectLike');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Built-in value references. */var propertyIsEnumerable=objectProto.propertyIsEnumerable;/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};module.exports=isArguments;},{\"./_baseIsArguments\":61,\"./isObjectLike\":154}],146:[function(require,module,exports){/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */var isArray=Array.isArray;module.exports=isArray;},{}],147:[function(require,module,exports){var isFunction=require('./isFunction'),isLength=require('./isLength');/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}module.exports=isArrayLike;},{\"./isFunction\":150,\"./isLength\":151}],148:[function(require,module,exports){var isArrayLike=require('./isArrayLike'),isObjectLike=require('./isObjectLike');/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}module.exports=isArrayLikeObject;},{\"./isArrayLike\":147,\"./isObjectLike\":154}],149:[function(require,module,exports){var root=require('./_root'),stubFalse=require('./stubFalse');/** Detect free variable `exports`. */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&_typeof(module)=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Built-in value references. */var Buffer=moduleExports?root.Buffer:undefined;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeIsBuffer=Buffer?Buffer.isBuffer:undefined;/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */var isBuffer=nativeIsBuffer||stubFalse;module.exports=isBuffer;},{\"./_root\":130,\"./stubFalse\":164}],150:[function(require,module,exports){var baseGetTag=require('./_baseGetTag'),isObject=require('./isObject');/** `Object#toString` result references. */var asyncTag='[object AsyncFunction]',funcTag='[object Function]',genTag='[object GeneratorFunction]',proxyTag='[object Proxy]';/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator\n// in Safari 9 which returns 'object' for typed arrays and other constructors.\nvar tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}module.exports=isFunction;},{\"./_baseGetTag\":60,\"./isObject\":153}],151:[function(require,module,exports){/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}module.exports=isLength;},{}],152:[function(require,module,exports){var baseIsMap=require('./_baseIsMap'),baseUnary=require('./_baseUnary'),nodeUtil=require('./_nodeUtil');/* Node.js helper references. */var nodeIsMap=nodeUtil&&nodeUtil.isMap;/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;module.exports=isMap;},{\"./_baseIsMap\":62,\"./_baseUnary\":74,\"./_nodeUtil\":126}],153:[function(require,module,exports){/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}module.exports=isObject;},{}],154:[function(require,module,exports){/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */function isObjectLike(value){return value!=null&&_typeof(value)=='object';}module.exports=isObjectLike;},{}],155:[function(require,module,exports){var baseGetTag=require('./_baseGetTag'),getPrototype=require('./_getPrototype'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var objectTag='[object Object]';/** Used for built-in method references. */var funcProto=Function.prototype,objectProto=Object.prototype;/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}module.exports=isPlainObject;},{\"./_baseGetTag\":60,\"./_getPrototype\":94,\"./isObjectLike\":154}],156:[function(require,module,exports){var baseIsSet=require('./_baseIsSet'),baseUnary=require('./_baseUnary'),nodeUtil=require('./_nodeUtil');/* Node.js helper references. */var nodeIsSet=nodeUtil&&nodeUtil.isSet;/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;module.exports=isSet;},{\"./_baseIsSet\":64,\"./_baseUnary\":74,\"./_nodeUtil\":126}],157:[function(require,module,exports){var baseGetTag=require('./_baseGetTag'),isArray=require('./isArray'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var stringTag='[object String]';/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}module.exports=isString;},{\"./_baseGetTag\":60,\"./isArray\":146,\"./isObjectLike\":154}],158:[function(require,module,exports){var baseGetTag=require('./_baseGetTag'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var symbolTag='[object Symbol]';/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */function isSymbol(value){return _typeof(value)=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}module.exports=isSymbol;},{\"./_baseGetTag\":60,\"./isObjectLike\":154}],159:[function(require,module,exports){var baseIsTypedArray=require('./_baseIsTypedArray'),baseUnary=require('./_baseUnary'),nodeUtil=require('./_nodeUtil');/* Node.js helper references. */var nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;module.exports=isTypedArray;},{\"./_baseIsTypedArray\":65,\"./_baseUnary\":74,\"./_nodeUtil\":126}],160:[function(require,module,exports){var arrayLikeKeys=require('./_arrayLikeKeys'),baseKeys=require('./_baseKeys'),isArrayLike=require('./isArrayLike');/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}module.exports=keys;},{\"./_arrayLikeKeys\":47,\"./_baseKeys\":66,\"./isArrayLike\":147}],161:[function(require,module,exports){var arrayLikeKeys=require('./_arrayLikeKeys'),baseKeysIn=require('./_baseKeysIn'),isArrayLike=require('./isArrayLike');/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}module.exports=keysIn;},{\"./_arrayLikeKeys\":47,\"./_baseKeysIn\":67,\"./isArrayLike\":147}],162:[function(require,module,exports){var baseMerge=require('./_baseMerge'),createAssigner=require('./_createAssigner');/**\n * This method is like `_.merge` except that it accepts `customizer` which\n * is invoked to produce the merged values of the destination and source\n * properties. If `customizer` returns `undefined`, merging is handled by the\n * method instead. The `customizer` is invoked with six arguments:\n * (objValue, srcValue, key, object, source, stack).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   if (_.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * }\n *\n * var object = { 'a': [1], 'b': [2] };\n * var other = { 'a': [3], 'b': [4] };\n *\n * _.mergeWith(object, other, customizer);\n * // => { 'a': [1, 3], 'b': [2, 4] }\n */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});module.exports=mergeWith;},{\"./_baseMerge\":68,\"./_createAssigner\":86}],163:[function(require,module,exports){/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */function stubArray(){return[];}module.exports=stubArray;},{}],164:[function(require,module,exports){/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */function stubFalse(){return false;}module.exports=stubFalse;},{}],165:[function(require,module,exports){var copyObject=require('./_copyObject'),keysIn=require('./keysIn');/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */function toPlainObject(value){return copyObject(value,keysIn(value));}module.exports=toPlainObject;},{\"./_copyObject\":82,\"./keysIn\":161}],166:[function(require,module,exports){var baseToString=require('./_baseToString');/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */function toString(value){return value==null?'':baseToString(value);}module.exports=toString;},{\"./_baseToString\":73}],167:[function(require,module,exports){(function(process){// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts,allowAboveRoot){// if the path tries to go above the root, `up` ends up > 0\nvar up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==='.'){parts.splice(i,1);}else if(last==='..'){parts.splice(i,1);up++;}else if(up){parts.splice(i,1);up--;}}// if the path is allowed to go above the root, restore leading ..s\nif(allowAboveRoot){for(;up--;up){parts.unshift('..');}}return parts;}// path.resolve([from ...], to)\n// posix version\nexports.resolve=function(){var resolvedPath='',resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:process.cwd();// Skip empty and invalid entries\nif(typeof path!=='string'){throw new TypeError('Arguments to path.resolve must be strings');}else if(!path){continue;}resolvedPath=path+'/'+resolvedPath;resolvedAbsolute=path.charAt(0)==='/';}// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n// Normalize the path\nresolvedPath=normalizeArray(filter(resolvedPath.split('/'),function(p){return!!p;}),!resolvedAbsolute).join('/');return(resolvedAbsolute?'/':'')+resolvedPath||'.';};// path.normalize(path)\n// posix version\nexports.normalize=function(path){var isAbsolute=exports.isAbsolute(path),trailingSlash=substr(path,-1)==='/';// Normalize the path\npath=normalizeArray(filter(path.split('/'),function(p){return!!p;}),!isAbsolute).join('/');if(!path&&!isAbsolute){path='.';}if(path&&trailingSlash){path+='/';}return(isAbsolute?'/':'')+path;};// posix version\nexports.isAbsolute=function(path){return path.charAt(0)==='/';};// posix version\nexports.join=function(){var paths=Array.prototype.slice.call(arguments,0);return exports.normalize(filter(paths,function(p,index){if(typeof p!=='string'){throw new TypeError('Arguments to path.join must be strings');}return p;}).join('/'));};// path.relative(from, to)\n// posix version\nexports.relative=function(from,to){from=exports.resolve(from).substr(1);to=exports.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=='')break;}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=='')break;}if(start>end)return[];return arr.slice(start,end-start+1);}var fromParts=trim(from.split('/'));var toParts=trim(to.split('/'));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break;}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push('..');}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join('/');};exports.sep='/';exports.delimiter=':';exports.dirname=function(path){if(typeof path!=='string')path=path+'';if(path.length===0)return'.';var code=path.charCodeAt(0);var hasRoot=code===47/*/*/;var end=-1;var matchedSlash=true;for(var i=path.length-1;i>=1;--i){code=path.charCodeAt(i);if(code===47/*/*/){if(!matchedSlash){end=i;break;}}else{// We saw the first non-path separator\nmatchedSlash=false;}}if(end===-1)return hasRoot?'/':'.';if(hasRoot&&end===1){// return '//';\n// Backwards-compat fix:\nreturn'/';}return path.slice(0,end);};function basename(path){if(typeof path!=='string')path=path+'';var start=0;var end=-1;var matchedSlash=true;var i;for(i=path.length-1;i>=0;--i){if(path.charCodeAt(i)===47/*/*/){// If we reached a path separator that was not part of a set of path\n// separators at the end of the string, stop now\nif(!matchedSlash){start=i+1;break;}}else if(end===-1){// We saw the first non-path separator, mark this as the end of our\n// path component\nmatchedSlash=false;end=i+1;}}if(end===-1)return'';return path.slice(start,end);}// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename=function(path,ext){var f=basename(path);if(ext&&f.substr(-1*ext.length)===ext){f=f.substr(0,f.length-ext.length);}return f;};exports.extname=function(path){if(typeof path!=='string')path=path+'';var startDot=-1;var startPart=0;var end=-1;var matchedSlash=true;// Track the state of characters (if any) we see before our first dot and\n// after any path separator we find\nvar preDotState=0;for(var i=path.length-1;i>=0;--i){var code=path.charCodeAt(i);if(code===47/*/*/){// If we reached a path separator that was not part of a set of path\n// separators at the end of the string, stop now\nif(!matchedSlash){startPart=i+1;break;}continue;}if(end===-1){// We saw the first non-path separator, mark this as the end of our\n// extension\nmatchedSlash=false;end=i+1;}if(code===46/*.*/){// If this is our first dot, mark it as the start of our extension\nif(startDot===-1)startDot=i;else if(preDotState!==1)preDotState=1;}else if(startDot!==-1){// We saw a non-dot and non-path separator before our dot, so we should\n// have a good chance at having a non-empty extension\npreDotState=-1;}}if(startDot===-1||end===-1||// We saw a non-dot character immediately before the dot\npreDotState===0||// The (right-most) trimmed path component is exactly '..'\npreDotState===1&&startDot===end-1&&startDot===startPart+1){return'';}return path.slice(startDot,end);};function filter(xs,f){if(xs.filter)return xs.filter(f);var res=[];for(var i=0;i<xs.length;i++){if(f(xs[i],i,xs))res.push(xs[i]);}return res;}// String.prototype.substr - negative index don't work in IE8\nvar substr='ab'.substr(-1)==='b'?function(str,start,len){return str.substr(start,len);}:function(str,start,len){if(start<0)start=str.length+start;return str.substr(start,len);};}).call(this,require('_process'));},{\"_process\":192}],168:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _container=_interopRequireDefault(require(\"./container\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**\n * Represents an at-rule.\n *\n * If its followed in the CSS by a {} block, this node will have\n * a nodes property representing its children.\n *\n * @extends Container\n *\n * @example\n * const root = postcss.parse('@charset \"UTF-8\"; @media print {}')\n *\n * const charset = root.first\n * charset.type  //=> 'atrule'\n * charset.nodes //=> undefined\n *\n * const media = root.last\n * media.nodes   //=> []\n */var AtRule=/*#__PURE__*/function(_Container){_inheritsLoose(AtRule,_Container);function AtRule(defaults){var _this;_this=_Container.call(this,defaults)||this;_this.type='atrule';return _this;}var _proto=AtRule.prototype;_proto.append=function append(){var _Container$prototype$;if(!this.nodes)this.nodes=[];for(var _len=arguments.length,children=new Array(_len),_key=0;_key<_len;_key++){children[_key]=arguments[_key];}return(_Container$prototype$=_Container.prototype.append).call.apply(_Container$prototype$,[this].concat(children));};_proto.prepend=function prepend(){var _Container$prototype$2;if(!this.nodes)this.nodes=[];for(var _len2=arguments.length,children=new Array(_len2),_key2=0;_key2<_len2;_key2++){children[_key2]=arguments[_key2];}return(_Container$prototype$2=_Container.prototype.prepend).call.apply(_Container$prototype$2,[this].concat(children));}/**\n   * @memberof AtRule#\n   * @member {string} name The at-rules name immediately follows the `@`.\n   *\n   * @example\n   * const root  = postcss.parse('@media print {}')\n   * media.name //=> 'media'\n   * const media = root.first\n   */ /**\n   * @memberof AtRule#\n   * @member {string} params The at-rules parameters, the values\n   *                         that follow the at-rules name but precede\n   *                         any {} block.\n   *\n   * @example\n   * const root  = postcss.parse('@media print, screen {}')\n   * const media = root.first\n   * media.params //=> 'print, screen'\n   */ /**\n   * @memberof AtRule#\n   * @member {object} raws Information to generate byte-to-byte equal\n   *                        node string as it was in the origin input.\n   *\n   * Every parser saves its own properties,\n   * but the default CSS parser uses:\n   *\n   * * `before`: the space symbols before the node. It also stores `*`\n   *   and `_` symbols before the declaration (IE hack).\n   * * `after`: the space symbols after the last child of the node\n   *   to the end of the node.\n   * * `between`: the symbols between the property and value\n   *   for declarations, selector and `{` for rules, or last parameter\n   *   and `{` for at-rules.\n   * * `semicolon`: contains true if the last child has\n   *   an (optional) semicolon.\n   * * `afterName`: the space between the at-rule name and its parameters.\n   *\n   * PostCSS cleans at-rule parameters from comments and extra spaces,\n   * but it stores origin content in raws properties.\n   * As such, if you dont change a declarations value,\n   * PostCSS will use the raw value with comments.\n   *\n   * @example\n   * const root = postcss.parse('  @media\\nprint {\\n}')\n   * root.first.first.raws //=> { before: '  ',\n   *                       //     between: ' ',\n   *                       //     afterName: '\\n',\n   *                       //     after: '\\n' }\n   */;return AtRule;}(_container[\"default\"]);var _default=AtRule;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./container\":170}],169:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _node=_interopRequireDefault(require(\"./node\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**\n * Represents a comment between declarations or statements (rule and at-rules).\n *\n * Comments inside selectors, at-rule parameters, or declaration values\n * will be stored in the `raws` properties explained above.\n *\n * @extends Node\n */var Comment=/*#__PURE__*/function(_Node){_inheritsLoose(Comment,_Node);function Comment(defaults){var _this;_this=_Node.call(this,defaults)||this;_this.type='comment';return _this;}/**\n   * @memberof Comment#\n   * @member {string} text The comments text.\n   */ /**\n   * @memberof Comment#\n   * @member {object} raws Information to generate byte-to-byte equal\n   *                       node string as it was in the origin input.\n   *\n   * Every parser saves its own properties,\n   * but the default CSS parser uses:\n   *\n   * * `before`: the space symbols before the node.\n   * * `left`: the space symbols between `/*` and the comments text.\n   * * `right`: the space symbols between the comments text.\n   */return Comment;}(_node[\"default\"]);var _default=Comment;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./node\":177}],170:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _declaration=_interopRequireDefault(require(\"./declaration\"));var _comment=_interopRequireDefault(require(\"./comment\"));var _node=_interopRequireDefault(require(\"./node\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}function cleanSource(nodes){return nodes.map(function(i){if(i.nodes)i.nodes=cleanSource(i.nodes);delete i.source;return i;});}/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */var Container=/*#__PURE__*/function(_Node){_inheritsLoose(Container,_Node);function Container(){return _Node.apply(this,arguments)||this;}var _proto=Container.prototype;_proto.push=function push(child){child.parent=this;this.nodes.push(child);return this;}/**\n   * Iterates through the containers immediate children,\n   * calling `callback` for each child.\n   *\n   * Returning `false` in the callback will break iteration.\n   *\n   * This method only iterates through the containers immediate children.\n   * If you need to recursively iterate through all the containers descendant\n   * nodes, use {@link Container#walk}.\n   *\n   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n   * if you are mutating the array of child nodes during iteration.\n   * PostCSS will adjust the current index to match the mutations.\n   *\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * const root = postcss.parse('a { color: black; z-index: 1 }')\n   * const rule = root.first\n   *\n   * for (const decl of rule.nodes) {\n   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n   *   // Cycle will be infinite, because cloneBefore moves the current node\n   *   // to the next index\n   * }\n   *\n   * rule.each(decl => {\n   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n   *   // Will be executed only for color and z-index\n   * })\n   */;_proto.each=function each(callback){if(!this.lastEach)this.lastEach=0;if(!this.indexes)this.indexes={};this.lastEach+=1;var id=this.lastEach;this.indexes[id]=0;if(!this.nodes)return undefined;var index,result;while(this.indexes[id]<this.nodes.length){index=this.indexes[id];result=callback(this.nodes[index],index);if(result===false)break;this.indexes[id]+=1;}delete this.indexes[id];return result;}/**\n   * Traverses the containers descendant nodes, calling callback\n   * for each node.\n   *\n   * Like container.each(), this method is safe to use\n   * if you are mutating arrays during iteration.\n   *\n   * If you only need to iterate through the containers immediate children,\n   * use {@link Container#each}.\n   *\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walk(node => {\n   *   // Traverses all descendant nodes.\n   * })\n   */;_proto.walk=function walk(callback){return this.each(function(child,i){var result;try{result=callback(child,i);}catch(e){e.postcssNode=child;if(e.stack&&child.source&&/\\n\\s{4}at /.test(e.stack)){var s=child.source;e.stack=e.stack.replace(/\\n\\s{4}at /,\"$&\"+s.input.from+\":\"+s.start.line+\":\"+s.start.column+\"$&\");}throw e;}if(result!==false&&child.walk){result=child.walk(callback);}return result;});}/**\n   * Traverses the containers descendant nodes, calling callback\n   * for each declaration node.\n   *\n   * If you pass a filter, iteration will only happen over declarations\n   * with matching properties.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [prop]   String or regular expression\n   *                                 to filter declarations by property name.\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walkDecls(decl => {\n   *   checkPropertySupport(decl.prop)\n   * })\n   *\n   * root.walkDecls('border-radius', decl => {\n   *   decl.remove()\n   * })\n   *\n   * root.walkDecls(/^background/, decl => {\n   *   decl.value = takeFirstColorFromGradient(decl.value)\n   * })\n   */;_proto.walkDecls=function walkDecls(prop,callback){if(!callback){callback=prop;return this.walk(function(child,i){if(child.type==='decl'){return callback(child,i);}});}if(prop instanceof RegExp){return this.walk(function(child,i){if(child.type==='decl'&&prop.test(child.prop)){return callback(child,i);}});}return this.walk(function(child,i){if(child.type==='decl'&&child.prop===prop){return callback(child,i);}});}/**\n   * Traverses the containers descendant nodes, calling callback\n   * for each rule node.\n   *\n   * If you pass a filter, iteration will only happen over rules\n   * with matching selectors.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [selector] String or regular expression\n   *                                   to filter rules by selector.\n   * @param {childIterator} callback   Iterator receives each node and index.\n   *\n   * @return {false|undefined} returns `false` if iteration was broke.\n   *\n   * @example\n   * const selectors = []\n   * root.walkRules(rule => {\n   *   selectors.push(rule.selector)\n   * })\n   * console.log(`Your CSS uses ${ selectors.length } selectors`)\n   */;_proto.walkRules=function walkRules(selector,callback){if(!callback){callback=selector;return this.walk(function(child,i){if(child.type==='rule'){return callback(child,i);}});}if(selector instanceof RegExp){return this.walk(function(child,i){if(child.type==='rule'&&selector.test(child.selector)){return callback(child,i);}});}return this.walk(function(child,i){if(child.type==='rule'&&child.selector===selector){return callback(child,i);}});}/**\n   * Traverses the containers descendant nodes, calling callback\n   * for each at-rule node.\n   *\n   * If you pass a filter, iteration will only happen over at-rules\n   * that have matching names.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [name]   String or regular expression\n   *                                 to filter at-rules by name.\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walkAtRules(rule => {\n   *   if (isOld(rule.name)) rule.remove()\n   * })\n   *\n   * let first = false\n   * root.walkAtRules('charset', rule => {\n   *   if (!first) {\n   *     first = true\n   *   } else {\n   *     rule.remove()\n   *   }\n   * })\n   */;_proto.walkAtRules=function walkAtRules(name,callback){if(!callback){callback=name;return this.walk(function(child,i){if(child.type==='atrule'){return callback(child,i);}});}if(name instanceof RegExp){return this.walk(function(child,i){if(child.type==='atrule'&&name.test(child.name)){return callback(child,i);}});}return this.walk(function(child,i){if(child.type==='atrule'&&child.name===name){return callback(child,i);}});}/**\n   * Traverses the containers descendant nodes, calling callback\n   * for each comment node.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walkComments(comment => {\n   *   comment.remove()\n   * })\n   */;_proto.walkComments=function walkComments(callback){return this.walk(function(child,i){if(child.type==='comment'){return callback(child,i);}});}/**\n   * Inserts new nodes to the end of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children New nodes.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })\n   * rule.append(decl1, decl2)\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n   * root.append({ selector: 'a' })                       // rule\n   * rule.append({ prop: 'color', value: 'black' })       // declaration\n   * rule.append({ text: 'Comment' })                     // comment\n   *\n   * root.append('a {}')\n   * root.first.append('color: black; z-index: 1')\n   */;_proto.append=function append(){for(var _len=arguments.length,children=new Array(_len),_key=0;_key<_len;_key++){children[_key]=arguments[_key];}for(var _i=0,_children=children;_i<_children.length;_i++){var child=_children[_i];var nodes=this.normalize(child,this.last);for(var _iterator=nodes,_isArray=Array.isArray(_iterator),_i2=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i2>=_iterator.length)break;_ref=_iterator[_i2++];}else{_i2=_iterator.next();if(_i2.done)break;_ref=_i2.value;}var node=_ref;this.nodes.push(node);}}return this;}/**\n   * Inserts new nodes to the start of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children New nodes.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })\n   * rule.prepend(decl1, decl2)\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n   * root.append({ selector: 'a' })                       // rule\n   * rule.append({ prop: 'color', value: 'black' })       // declaration\n   * rule.append({ text: 'Comment' })                     // comment\n   *\n   * root.append('a {}')\n   * root.first.append('color: black; z-index: 1')\n   */;_proto.prepend=function prepend(){for(var _len2=arguments.length,children=new Array(_len2),_key2=0;_key2<_len2;_key2++){children[_key2]=arguments[_key2];}children=children.reverse();for(var _iterator2=children,_isArray2=Array.isArray(_iterator2),_i3=0,_iterator2=_isArray2?_iterator2:_iterator2[Symbol.iterator]();;){var _ref2;if(_isArray2){if(_i3>=_iterator2.length)break;_ref2=_iterator2[_i3++];}else{_i3=_iterator2.next();if(_i3.done)break;_ref2=_i3.value;}var child=_ref2;var nodes=this.normalize(child,this.first,'prepend').reverse();for(var _iterator3=nodes,_isArray3=Array.isArray(_iterator3),_i4=0,_iterator3=_isArray3?_iterator3:_iterator3[Symbol.iterator]();;){var _ref3;if(_isArray3){if(_i4>=_iterator3.length)break;_ref3=_iterator3[_i4++];}else{_i4=_iterator3.next();if(_i4.done)break;_ref3=_i4.value;}var node=_ref3;this.nodes.unshift(node);}for(var id in this.indexes){this.indexes[id]=this.indexes[id]+nodes.length;}}return this;};_proto.cleanRaws=function cleanRaws(keepBetween){_Node.prototype.cleanRaws.call(this,keepBetween);if(this.nodes){for(var _iterator4=this.nodes,_isArray4=Array.isArray(_iterator4),_i5=0,_iterator4=_isArray4?_iterator4:_iterator4[Symbol.iterator]();;){var _ref4;if(_isArray4){if(_i5>=_iterator4.length)break;_ref4=_iterator4[_i5++];}else{_i5=_iterator4.next();if(_i5.done)break;_ref4=_i5.value;}var node=_ref4;node.cleanRaws(keepBetween);}}}/**\n   * Insert new node before old node within the container.\n   *\n   * @param {Node|number} exist             Child or childs index.\n   * @param {Node|object|string|Node[]} add New node.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))\n   */;_proto.insertBefore=function insertBefore(exist,add){exist=this.index(exist);var type=exist===0?'prepend':false;var nodes=this.normalize(add,this.nodes[exist],type).reverse();for(var _iterator5=nodes,_isArray5=Array.isArray(_iterator5),_i6=0,_iterator5=_isArray5?_iterator5:_iterator5[Symbol.iterator]();;){var _ref5;if(_isArray5){if(_i6>=_iterator5.length)break;_ref5=_iterator5[_i6++];}else{_i6=_iterator5.next();if(_i6.done)break;_ref5=_i6.value;}var node=_ref5;this.nodes.splice(exist,0,node);}var index;for(var id in this.indexes){index=this.indexes[id];if(exist<=index){this.indexes[id]=index+nodes.length;}}return this;}/**\n   * Insert new node after old node within the container.\n   *\n   * @param {Node|number} exist             Child or childs index.\n   * @param {Node|object|string|Node[]} add New node.\n   *\n   * @return {Node} This node for methods chain.\n   */;_proto.insertAfter=function insertAfter(exist,add){exist=this.index(exist);var nodes=this.normalize(add,this.nodes[exist]).reverse();for(var _iterator6=nodes,_isArray6=Array.isArray(_iterator6),_i7=0,_iterator6=_isArray6?_iterator6:_iterator6[Symbol.iterator]();;){var _ref6;if(_isArray6){if(_i7>=_iterator6.length)break;_ref6=_iterator6[_i7++];}else{_i7=_iterator6.next();if(_i7.done)break;_ref6=_i7.value;}var node=_ref6;this.nodes.splice(exist+1,0,node);}var index;for(var id in this.indexes){index=this.indexes[id];if(exist<index){this.indexes[id]=index+nodes.length;}}return this;}/**\n   * Removes node from the container and cleans the parent properties\n   * from the node and its children.\n   *\n   * @param {Node|number} child Child or childs index.\n   *\n   * @return {Node} This node for methods chain\n   *\n   * @example\n   * rule.nodes.length  //=> 5\n   * rule.removeChild(decl)\n   * rule.nodes.length  //=> 4\n   * decl.parent        //=> undefined\n   */;_proto.removeChild=function removeChild(child){child=this.index(child);this.nodes[child].parent=undefined;this.nodes.splice(child,1);var index;for(var id in this.indexes){index=this.indexes[id];if(index>=child){this.indexes[id]=index-1;}}return this;}/**\n   * Removes all children from the container\n   * and cleans their parent properties.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * rule.removeAll()\n   * rule.nodes.length //=> 0\n   */;_proto.removeAll=function removeAll(){for(var _iterator7=this.nodes,_isArray7=Array.isArray(_iterator7),_i8=0,_iterator7=_isArray7?_iterator7:_iterator7[Symbol.iterator]();;){var _ref7;if(_isArray7){if(_i8>=_iterator7.length)break;_ref7=_iterator7[_i8++];}else{_i8=_iterator7.next();if(_i8.done)break;_ref7=_i8.value;}var node=_ref7;node.parent=undefined;}this.nodes=[];return this;}/**\n   * Passes all declaration values within the container that match pattern\n   * through callback, replacing those values with the returned result\n   * of callback.\n   *\n   * This method is useful if you are using a custom unit or function\n   * and need to iterate through all values.\n   *\n   * @param {string|RegExp} pattern      Replace pattern.\n   * @param {object} opts                Options to speed up the search.\n   * @param {string|string[]} opts.props An array of property names.\n   * @param {string} opts.fast           String thats used to narrow down\n   *                                     values and speed up the regexp search.\n   * @param {function|string} callback   String to replace pattern or callback\n   *                                     that returns a new value. The callback\n   *                                     will receive the same arguments\n   *                                     as those passed to a function parameter\n   *                                     of `String#replace`.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n   *   return 15 * parseInt(string) + 'px'\n   * })\n   */;_proto.replaceValues=function replaceValues(pattern,opts,callback){if(!callback){callback=opts;opts={};}this.walkDecls(function(decl){if(opts.props&&opts.props.indexOf(decl.prop)===-1)return;if(opts.fast&&decl.value.indexOf(opts.fast)===-1)return;decl.value=decl.value.replace(pattern,callback);});return this;}/**\n   * Returns `true` if callback returns `true`\n   * for all of the containers children.\n   *\n   * @param {childCondition} condition Iterator returns true or false.\n   *\n   * @return {boolean} Is every child pass condition.\n   *\n   * @example\n   * const noPrefixes = rule.every(i => i.prop[0] !== '-')\n   */;_proto.every=function every(condition){return this.nodes.every(condition);}/**\n   * Returns `true` if callback returns `true` for (at least) one\n   * of the containers children.\n   *\n   * @param {childCondition} condition Iterator returns true or false.\n   *\n   * @return {boolean} Is some child pass condition.\n   *\n   * @example\n   * const hasPrefix = rule.some(i => i.prop[0] === '-')\n   */;_proto.some=function some(condition){return this.nodes.some(condition);}/**\n   * Returns a `child`s index within the {@link Container#nodes} array.\n   *\n   * @param {Node} child Child of the current container.\n   *\n   * @return {number} Child index.\n   *\n   * @example\n   * rule.index( rule.nodes[2] ) //=> 2\n   */;_proto.index=function index(child){if(typeof child==='number'){return child;}return this.nodes.indexOf(child);}/**\n   * The containers first child.\n   *\n   * @type {Node}\n   *\n   * @example\n   * rule.first === rules.nodes[0]\n   */;_proto.normalize=function normalize(nodes,sample){var _this=this;if(typeof nodes==='string'){var parse=require('./parse');nodes=cleanSource(parse(nodes).nodes);}else if(Array.isArray(nodes)){nodes=nodes.slice(0);for(var _iterator8=nodes,_isArray8=Array.isArray(_iterator8),_i9=0,_iterator8=_isArray8?_iterator8:_iterator8[Symbol.iterator]();;){var _ref8;if(_isArray8){if(_i9>=_iterator8.length)break;_ref8=_iterator8[_i9++];}else{_i9=_iterator8.next();if(_i9.done)break;_ref8=_i9.value;}var i=_ref8;if(i.parent)i.parent.removeChild(i,'ignore');}}else if(nodes.type==='root'){nodes=nodes.nodes.slice(0);for(var _iterator9=nodes,_isArray9=Array.isArray(_iterator9),_i10=0,_iterator9=_isArray9?_iterator9:_iterator9[Symbol.iterator]();;){var _ref9;if(_isArray9){if(_i10>=_iterator9.length)break;_ref9=_iterator9[_i10++];}else{_i10=_iterator9.next();if(_i10.done)break;_ref9=_i10.value;}var _i11=_ref9;if(_i11.parent)_i11.parent.removeChild(_i11,'ignore');}}else if(nodes.type){nodes=[nodes];}else if(nodes.prop){if(typeof nodes.value==='undefined'){throw new Error('Value field is missed in node creation');}else if(typeof nodes.value!=='string'){nodes.value=String(nodes.value);}nodes=[new _declaration[\"default\"](nodes)];}else if(nodes.selector){var Rule=require('./rule');nodes=[new Rule(nodes)];}else if(nodes.name){var AtRule=require('./at-rule');nodes=[new AtRule(nodes)];}else if(nodes.text){nodes=[new _comment[\"default\"](nodes)];}else{throw new Error('Unknown node type in node creation');}var processed=nodes.map(function(i){if(i.parent)i.parent.removeChild(i);if(typeof i.raws.before==='undefined'){if(sample&&typeof sample.raws.before!=='undefined'){i.raws.before=sample.raws.before.replace(/[^\\s]/g,'');}}i.parent=_this;return i;});return processed;}/**\n   * @memberof Container#\n   * @member {Node[]} nodes An array containing the containers children.\n   *\n   * @example\n   * const root = postcss.parse('a { color: black }')\n   * root.nodes.length           //=> 1\n   * root.nodes[0].selector      //=> 'a'\n   * root.nodes[0].nodes[0].prop //=> 'color'\n   */;_createClass(Container,[{key:\"first\",get:function get(){if(!this.nodes)return undefined;return this.nodes[0];}/**\n     * The containers last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last === rule.nodes[rule.nodes.length - 1]\n     */},{key:\"last\",get:function get(){if(!this.nodes)return undefined;return this.nodes[this.nodes.length-1];}}]);return Container;}(_node[\"default\"]);var _default=Container;/**\n * @callback childCondition\n * @param {Node} node    Container child.\n * @param {number} index Child index.\n * @param {Node[]} nodes All container children.\n * @return {boolean}\n */ /**\n * @callback childIterator\n * @param {Node} node    Container child.\n * @param {number} index Child index.\n * @return {false|undefined} Returning `false` will break iteration.\n */exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./at-rule\":168,\"./comment\":169,\"./declaration\":172,\"./node\":177,\"./parse\":178,\"./rule\":185}],171:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _supportsColor=_interopRequireDefault(require(\"supports-color\"));var _chalk=_interopRequireDefault(require(\"chalk\"));var _terminalHighlight=_interopRequireDefault(require(\"./terminal-highlight\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}function _wrapNativeSuper(Class){var _cache=typeof Map===\"function\"?new Map():undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!==\"function\"){throw new TypeError(\"Super expression must either be null or a function\");}if(typeof _cache!==\"undefined\"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper);}function Wrapper(){return _construct(Class,arguments,_getPrototypeOf(this).constructor);}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf(Wrapper,Class);};return _wrapNativeSuper(Class);}function isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _construct(Parent,args,Class){if(isNativeReflectConstruct()){_construct=Reflect.construct;}else{_construct=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor();if(Class)_setPrototypeOf(instance,Class.prototype);return instance;};}return _construct.apply(null,arguments);}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf(\"[native code]\")!==-1;}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}/**\n * The CSS parser throws this error for broken CSS.\n *\n * Custom parsers can throw this error for broken custom syntax using\n * the {@link Node#error} method.\n *\n * PostCSS will use the input source map to detect the original error location.\n * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,\n * PostCSS will show the original position in the Sass file.\n *\n * If you need the position in the PostCSS input\n * (e.g., to debug the previous compiler), use `error.input.file`.\n *\n * @example\n * // Catching and checking syntax error\n * try {\n *   postcss.parse('a{')\n * } catch (error) {\n *   if (error.name === 'CssSyntaxError') {\n *     error //=> CssSyntaxError\n *   }\n * }\n *\n * @example\n * // Raising error from plugin\n * throw node.error('Unknown variable', { plugin: 'postcss-vars' })\n */var CssSyntaxError=/*#__PURE__*/function(_Error){_inheritsLoose(CssSyntaxError,_Error);/**\n   * @param {string} message  Error message.\n   * @param {number} [line]   Source line of the error.\n   * @param {number} [column] Source column of the error.\n   * @param {string} [source] Source code of the broken file.\n   * @param {string} [file]   Absolute path to the broken file.\n   * @param {string} [plugin] PostCSS plugin name, if error came from plugin.\n   */function CssSyntaxError(message,line,column,source,file,plugin){var _this;_this=_Error.call(this,message)||this;/**\n     * Always equal to `'CssSyntaxError'`. You should always check error type\n     * by `error.name === 'CssSyntaxError'`\n     * instead of `error instanceof CssSyntaxError`,\n     * because npm could have several PostCSS versions.\n     *\n     * @type {string}\n     *\n     * @example\n     * if (error.name === 'CssSyntaxError') {\n     *   error //=> CssSyntaxError\n     * }\n     */_this.name='CssSyntaxError';/**\n     * Error message.\n     *\n     * @type {string}\n     *\n     * @example\n     * error.message //=> 'Unclosed block'\n     */_this.reason=message;if(file){/**\n       * Absolute path to the broken file.\n       *\n       * @type {string}\n       *\n       * @example\n       * error.file       //=> 'a.sass'\n       * error.input.file //=> 'a.css'\n       */_this.file=file;}if(source){/**\n       * Source code of the broken file.\n       *\n       * @type {string}\n       *\n       * @example\n       * error.source       //=> 'a { b {} }'\n       * error.input.column //=> 'a b { }'\n       */_this.source=source;}if(plugin){/**\n       * Plugin name, if error came from plugin.\n       *\n       * @type {string}\n       *\n       * @example\n       * error.plugin //=> 'postcss-vars'\n       */_this.plugin=plugin;}if(typeof line!=='undefined'&&typeof column!=='undefined'){/**\n       * Source line of the error.\n       *\n       * @type {number}\n       *\n       * @example\n       * error.line       //=> 2\n       * error.input.line //=> 4\n       */_this.line=line;/**\n       * Source column of the error.\n       *\n       * @type {number}\n       *\n       * @example\n       * error.column       //=> 1\n       * error.input.column //=> 4\n       */_this.column=column;}_this.setMessage();if(Error.captureStackTrace){Error.captureStackTrace(_assertThisInitialized(_this),CssSyntaxError);}return _this;}var _proto=CssSyntaxError.prototype;_proto.setMessage=function setMessage(){/**\n     * Full error text in the GNU error format\n     * with plugin, file, line and column.\n     *\n     * @type {string}\n     *\n     * @example\n     * error.message //=> 'a.css:1:1: Unclosed block'\n     */this.message=this.plugin?this.plugin+': ':'';this.message+=this.file?this.file:'<css input>';if(typeof this.line!=='undefined'){this.message+=':'+this.line+':'+this.column;}this.message+=': '+this.reason;}/**\n   * Returns a few lines of CSS source that caused the error.\n   *\n   * If the CSS has an input source map without `sourceContent`,\n   * this method will return an empty string.\n   *\n   * @param {boolean} [color] Whether arrow will be colored red by terminal\n   *                          color codes. By default, PostCSS will detect\n   *                          color support by `process.stdout.isTTY`\n   *                          and `process.env.NODE_DISABLE_COLORS`.\n   *\n   * @example\n   * error.showSourceCode() //=> \"  4 | }\n   *                        //      5 | a {\n   *                        //    > 6 |   bad\n   *                        //        |   ^\n   *                        //      7 | }\n   *                        //      8 | b {\"\n   *\n   * @return {string} Few lines of CSS source that caused the error.\n   */;_proto.showSourceCode=function showSourceCode(color){var _this2=this;if(!this.source)return'';var css=this.source;if(_terminalHighlight[\"default\"]){if(typeof color==='undefined')color=_supportsColor[\"default\"].stdout;if(color)css=(0,_terminalHighlight[\"default\"])(css);}var lines=css.split(/\\r?\\n/);var start=Math.max(this.line-3,0);var end=Math.min(this.line+2,lines.length);var maxWidth=String(end).length;function mark(text){if(color&&_chalk[\"default\"].red){return _chalk[\"default\"].red.bold(text);}return text;}function aside(text){if(color&&_chalk[\"default\"].gray){return _chalk[\"default\"].gray(text);}return text;}return lines.slice(start,end).map(function(line,index){var number=start+1+index;var gutter=' '+(' '+number).slice(-maxWidth)+' | ';if(number===_this2.line){var spacing=aside(gutter.replace(/\\d/g,' '))+line.slice(0,_this2.column-1).replace(/[^\\t]/g,' ');return mark('>')+aside(gutter)+line+'\\n '+spacing+mark('^');}return' '+aside(gutter)+line;}).join('\\n');}/**\n   * Returns error position, message and source code of the broken part.\n   *\n   * @example\n   * error.toString() //=> \"CssSyntaxError: app.css:1:1: Unclosed block\n   *                  //    > 1 | a {\n   *                  //        | ^\"\n   *\n   * @return {string} Error position, message and source code.\n   */;_proto.toString=function toString(){var code=this.showSourceCode();if(code){code='\\n\\n'+code+'\\n';}return this.name+': '+this.message+code;}/**\n   * @memberof CssSyntaxError#\n   * @member {Input} input Input object with PostCSS internal information\n   *                       about input file. If input has source map\n   *                       from previous tool, PostCSS will use origin\n   *                       (for example, Sass) source. You can use this\n   *                       object to get PostCSS input source.\n   *\n   * @example\n   * error.input.file //=> 'a.css'\n   * error.file       //=> 'a.sass'\n   */;return CssSyntaxError;}(_wrapNativeSuper(Error));var _default=CssSyntaxError;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./terminal-highlight\":2,\"chalk\":2,\"supports-color\":2}],172:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _node=_interopRequireDefault(require(\"./node\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**\n * Represents a CSS declaration.\n *\n * @extends Node\n *\n * @example\n * const root = postcss.parse('a { color: black }')\n * const decl = root.first.first\n * decl.type       //=> 'decl'\n * decl.toString() //=> ' color: black'\n */var Declaration=/*#__PURE__*/function(_Node){_inheritsLoose(Declaration,_Node);function Declaration(defaults){var _this;_this=_Node.call(this,defaults)||this;_this.type='decl';return _this;}/**\n   * @memberof Declaration#\n   * @member {string} prop The declarations property name.\n   *\n   * @example\n   * const root = postcss.parse('a { color: black }')\n   * const decl = root.first.first\n   * decl.prop //=> 'color'\n   */ /**\n   * @memberof Declaration#\n   * @member {string} value The declarations value.\n   *\n   * @example\n   * const root = postcss.parse('a { color: black }')\n   * const decl = root.first.first\n   * decl.value //=> 'black'\n   */ /**\n   * @memberof Declaration#\n   * @member {boolean} important `true` if the declaration\n   *                             has an !important annotation.\n   *\n   * @example\n   * const root = postcss.parse('a { color: black !important; color: red }')\n   * root.first.first.important //=> true\n   * root.first.last.important  //=> undefined\n   */ /**\n   * @memberof Declaration#\n   * @member {object} raws Information to generate byte-to-byte equal\n   *                       node string as it was in the origin input.\n   *\n   * Every parser saves its own properties,\n   * but the default CSS parser uses:\n   *\n   * * `before`: the space symbols before the node. It also stores `*`\n   *   and `_` symbols before the declaration (IE hack).\n   * * `between`: the symbols between the property and value\n   *   for declarations.\n   * * `important`: the content of the important statement,\n   *   if it is not just `!important`.\n   *\n   * PostCSS cleans declaration from comments and extra spaces,\n   * but it stores origin content in raws properties.\n   * As such, if you dont change a declarations value,\n   * PostCSS will use the raw value with comments.\n   *\n   * @example\n   * const root = postcss.parse('a {\\n  color:black\\n}')\n   * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n   */return Declaration;}(_node[\"default\"]);var _default=Declaration;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./node\":177}],173:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _path=_interopRequireDefault(require(\"path\"));var _cssSyntaxError=_interopRequireDefault(require(\"./css-syntax-error\"));var _previousMap=_interopRequireDefault(require(\"./previous-map\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}var sequence=0;/**\n * Represents the source CSS.\n *\n * @example\n * const root  = postcss.parse(css, { from: file })\n * const input = root.source.input\n */var Input=/*#__PURE__*/function(){/**\n   * @param {string} css    Input CSS source.\n   * @param {object} [opts] {@link Processor#process} options.\n   */function Input(css,opts){if(opts===void 0){opts={};}if(css===null||_typeof(css)==='object'&&!css.toString){throw new Error(\"PostCSS received \"+css+\" instead of CSS string\");}/**\n     * Input CSS source\n     *\n     * @type {string}\n     *\n     * @example\n     * const input = postcss.parse('a{}', { from: file }).input\n     * input.css //=> \"a{}\"\n     */this.css=css.toString();if(this.css[0]===\"\\uFEFF\"||this.css[0]===\"\\uFFFE\"){this.hasBOM=true;this.css=this.css.slice(1);}else{this.hasBOM=false;}if(opts.from){if(/^\\w+:\\/\\//.test(opts.from)||_path[\"default\"].isAbsolute(opts.from)){/**\n         * The absolute path to the CSS source file defined\n         * with the `from` option.\n         *\n         * @type {string}\n         *\n         * @example\n         * const root = postcss.parse(css, { from: 'a.css' })\n         * root.source.input.file //=> '/home/ai/a.css'\n         */this.file=opts.from;}else{this.file=_path[\"default\"].resolve(opts.from);}}var map=new _previousMap[\"default\"](this.css,opts);if(map.text){/**\n       * The input source map passed from a compilation step before PostCSS\n       * (for example, from Sass compiler).\n       *\n       * @type {PreviousMap}\n       *\n       * @example\n       * root.source.input.map.consumer().sources //=> ['a.sass']\n       */this.map=map;var file=map.consumer().file;if(!this.file&&file)this.file=this.mapResolve(file);}if(!this.file){sequence+=1;/**\n       * The unique ID of the CSS source. It will be created if `from` option\n       * is not provided (because PostCSS does not know the file path).\n       *\n       * @type {string}\n       *\n       * @example\n       * const root = postcss.parse(css)\n       * root.source.input.file //=> undefined\n       * root.source.input.id   //=> \"<input css 1>\"\n       */this.id='<input css '+sequence+'>';}if(this.map)this.map.file=this.from;}var _proto=Input.prototype;_proto.error=function error(message,line,column,opts){if(opts===void 0){opts={};}var result;var origin=this.origin(line,column);if(origin){result=new _cssSyntaxError[\"default\"](message,origin.line,origin.column,origin.source,origin.file,opts.plugin);}else{result=new _cssSyntaxError[\"default\"](message,line,column,this.css,this.file,opts.plugin);}result.input={line:line,column:column,source:this.css};if(this.file)result.input.file=this.file;return result;}/**\n   * Reads the input source map and returns a symbol position\n   * in the input source (e.g., in a Sass file that was compiled\n   * to CSS before being passed to PostCSS).\n   *\n   * @param {number} line   Line in input CSS.\n   * @param {number} column Column in input CSS.\n   *\n   * @return {filePosition} Position in input source.\n   *\n   * @example\n   * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }\n   */;_proto.origin=function origin(line,column){if(!this.map)return false;var consumer=this.map.consumer();var from=consumer.originalPositionFor({line:line,column:column});if(!from.source)return false;var result={file:this.mapResolve(from.source),line:from.line,column:from.column};var source=consumer.sourceContentFor(from.source);if(source)result.source=source;return result;};_proto.mapResolve=function mapResolve(file){if(/^\\w+:\\/\\//.test(file)){return file;}return _path[\"default\"].resolve(this.map.consumer().sourceRoot||'.',file);}/**\n   * The CSS source identifier. Contains {@link Input#file} if the user\n   * set the `from` option, or {@link Input#id} if they did not.\n   *\n   * @type {string}\n   *\n   * @example\n   * const root = postcss.parse(css, { from: 'a.css' })\n   * root.source.input.from //=> \"/home/ai/a.css\"\n   *\n   * const root = postcss.parse(css)\n   * root.source.input.from //=> \"<input css 1>\"\n   */;_createClass(Input,[{key:\"from\",get:function get(){return this.file||this.id;}}]);return Input;}();var _default=Input;/**\n * @typedef  {object} filePosition\n * @property {string} file   Path to file.\n * @property {number} line   Source line in file.\n * @property {number} column Source column in file.\n */exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./css-syntax-error\":171,\"./previous-map\":181,\"path\":167}],174:[function(require,module,exports){(function(process){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _mapGenerator=_interopRequireDefault(require(\"./map-generator\"));var _stringify2=_interopRequireDefault(require(\"./stringify\"));var _warnOnce=_interopRequireDefault(require(\"./warn-once\"));var _result=_interopRequireDefault(require(\"./result\"));var _parse=_interopRequireDefault(require(\"./parse\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function isPromise(obj){return _typeof(obj)==='object'&&typeof obj.then==='function';}/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([autoprefixer]).process(css)\n */var LazyResult=/*#__PURE__*/function(){function LazyResult(processor,css,opts){this.stringified=false;this.processed=false;var root;if(_typeof(css)==='object'&&css!==null&&css.type==='root'){root=css;}else if(css instanceof LazyResult||css instanceof _result[\"default\"]){root=css.root;if(css.map){if(typeof opts.map==='undefined')opts.map={};if(!opts.map.inline)opts.map.inline=false;opts.map.prev=css.map;}}else{var parser=_parse[\"default\"];if(opts.syntax)parser=opts.syntax.parse;if(opts.parser)parser=opts.parser;if(parser.parse)parser=parser.parse;try{root=parser(css,opts);}catch(error){this.error=error;}}this.result=new _result[\"default\"](processor,root,opts);}/**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   *\n   * @type {Processor}\n   */var _proto=LazyResult.prototype;/**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} Warnings from plugins.\n   */_proto.warnings=function warnings(){return this.sync().warnings();}/**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css\n   *\n   * @return {string} Output CSS.\n   */;_proto.toString=function toString(){return this.css;}/**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled Callback will be executed\n   *                                  when all plugins will finish work.\n   * @param {onRejected}  onRejected  Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {\n   *   console.log(result.css)\n   * })\n   */;_proto.then=function then(onFulfilled,onRejected){if(process.env.NODE_ENV!=='production'){if(!('from'in this.opts)){(0,_warnOnce[\"default\"])('Without `from` option PostCSS could generate wrong source map '+'and will not find Browserslist config. Set it to CSS file path '+'or to `undefined` to prevent this warning.');}}return this.async().then(onFulfilled,onRejected);}/**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).then(result => {\n   *   console.log(result.css)\n   * }).catch(error => {\n   *   console.error(error)\n   * })\n   */;_proto[\"catch\"]=function _catch(onRejected){return this.async()[\"catch\"](onRejected);}/**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onFinally on any error or when all plugins will finish work.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFinally} onFinally Callback will be executed on any error or\n   *                              when all plugins will finish work.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).finally(() => {\n   *   console.log('processing ended')\n   * })\n   */;_proto[\"finally\"]=function _finally(onFinally){return this.async().then(onFinally,onFinally);};_proto.handleError=function handleError(error,plugin){try{this.error=error;if(error.name==='CssSyntaxError'&&!error.plugin){error.plugin=plugin.postcssPlugin;error.setMessage();}else if(plugin.postcssVersion){if(process.env.NODE_ENV!=='production'){var pluginName=plugin.postcssPlugin;var pluginVer=plugin.postcssVersion;var runtimeVer=this.result.processor.version;var a=pluginVer.split('.');var b=runtimeVer.split('.');if(a[0]!==b[0]||parseInt(a[1])>parseInt(b[1])){console.error('Unknown error from PostCSS plugin. Your current PostCSS '+'version is '+runtimeVer+', but '+pluginName+' uses '+pluginVer+'. Perhaps this is the source of the error below.');}}}}catch(err){if(console&&console.error)console.error(err);}};_proto.asyncTick=function asyncTick(resolve,reject){var _this=this;if(this.plugin>=this.processor.plugins.length){this.processed=true;return resolve();}try{var plugin=this.processor.plugins[this.plugin];var promise=this.run(plugin);this.plugin+=1;if(isPromise(promise)){promise.then(function(){_this.asyncTick(resolve,reject);})[\"catch\"](function(error){_this.handleError(error,plugin);_this.processed=true;reject(error);});}else{this.asyncTick(resolve,reject);}}catch(error){this.processed=true;reject(error);}};_proto.async=function async(){var _this2=this;if(this.processed){return new Promise(function(resolve,reject){if(_this2.error){reject(_this2.error);}else{resolve(_this2.stringify());}});}if(this.processing){return this.processing;}this.processing=new Promise(function(resolve,reject){if(_this2.error)return reject(_this2.error);_this2.plugin=0;_this2.asyncTick(resolve,reject);}).then(function(){_this2.processed=true;return _this2.stringify();});return this.processing;};_proto.sync=function sync(){if(this.processed)return this.result;this.processed=true;if(this.processing){throw new Error('Use process(css).then(cb) to work with async plugins');}if(this.error)throw this.error;for(var _iterator=this.result.processor.plugins,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var plugin=_ref;var promise=this.run(plugin);if(isPromise(promise)){throw new Error('Use process(css).then(cb) to work with async plugins');}}return this.result;};_proto.run=function run(plugin){this.result.lastPlugin=plugin;try{return plugin(this.result.root,this.result);}catch(error){this.handleError(error,plugin);throw error;}};_proto.stringify=function stringify(){if(this.stringified)return this.result;this.stringified=true;this.sync();var opts=this.result.opts;var str=_stringify2[\"default\"];if(opts.syntax)str=opts.syntax.stringify;if(opts.stringifier)str=opts.stringifier;if(str.stringify)str=str.stringify;var map=new _mapGenerator[\"default\"](str,this.result.root,this.result.opts);var data=map.generate();this.result.css=data[0];this.result.map=data[1];return this.result;};_createClass(LazyResult,[{key:\"processor\",get:function get(){return this.result.processor;}/**\n     * Options from the {@link Processor#process} call.\n     *\n     * @type {processOptions}\n     */},{key:\"opts\",get:function get(){return this.result.opts;}/**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */},{key:\"css\",get:function get(){return this.stringify().css;}/**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */},{key:\"content\",get:function get(){return this.stringify().content;}/**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */},{key:\"map\",get:function get(){return this.stringify().map;}/**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */},{key:\"root\",get:function get(){return this.sync().root;}/**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */},{key:\"messages\",get:function get(){return this.sync().messages;}}]);return LazyResult;}();var _default=LazyResult;/**\n * @callback onFulfilled\n * @param {Result} result\n */ /**\n * @callback onRejected\n * @param {Error} error\n */exports[\"default\"]=_default;module.exports=exports[\"default\"];}).call(this,require('_process'));},{\"./map-generator\":176,\"./parse\":178,\"./result\":183,\"./stringify\":187,\"./warn-once\":190,\"_process\":192}],175:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;/**\n * Contains helpers for safely splitting lists of CSS values,\n * preserving parentheses and quotes.\n *\n * @example\n * const list = postcss.list\n *\n * @namespace list\n */var list={split:function split(string,separators,last){var array=[];var current='';var split=false;var func=0;var quote=false;var escape=false;for(var i=0;i<string.length;i++){var letter=string[i];if(quote){if(escape){escape=false;}else if(letter==='\\\\'){escape=true;}else if(letter===quote){quote=false;}}else if(letter==='\"'||letter==='\\''){quote=letter;}else if(letter==='('){func+=1;}else if(letter===')'){if(func>0)func-=1;}else if(func===0){if(separators.indexOf(letter)!==-1)split=true;}if(split){if(current!=='')array.push(current.trim());current='';split=false;}else{current+=letter;}}if(last||current!=='')array.push(current.trim());return array;},/**\n   * Safely splits space-separated values (such as those for `background`,\n   * `border-radius`, and other shorthand properties).\n   *\n   * @param {string} string Space-separated values.\n   *\n   * @return {string[]} Split values.\n   *\n   * @example\n   * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']\n   */space:function space(string){var spaces=[' ','\\n','\\t'];return list.split(string,spaces);},/**\n   * Safely splits comma-separated values (such as those for `transition-*`\n   * and `background` properties).\n   *\n   * @param {string} string Comma-separated values.\n   *\n   * @return {string[]} Split values.\n   *\n   * @example\n   * postcss.list.comma('black, linear-gradient(white, black)')\n   * //=> ['black', 'linear-gradient(white, black)']\n   */comma:function comma(string){return list.split(string,[','],true);}};var _default=list;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{}],176:[function(require,module,exports){(function(Buffer){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _sourceMap=_interopRequireDefault(require(\"source-map\"));var _path=_interopRequireDefault(require(\"path\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}var MapGenerator=/*#__PURE__*/function(){function MapGenerator(stringify,root,opts){this.stringify=stringify;this.mapOpts=opts.map||{};this.root=root;this.opts=opts;}var _proto=MapGenerator.prototype;_proto.isMap=function isMap(){if(typeof this.opts.map!=='undefined'){return!!this.opts.map;}return this.previous().length>0;};_proto.previous=function previous(){var _this=this;if(!this.previousMaps){this.previousMaps=[];this.root.walk(function(node){if(node.source&&node.source.input.map){var map=node.source.input.map;if(_this.previousMaps.indexOf(map)===-1){_this.previousMaps.push(map);}}});}return this.previousMaps;};_proto.isInline=function isInline(){if(typeof this.mapOpts.inline!=='undefined'){return this.mapOpts.inline;}var annotation=this.mapOpts.annotation;if(typeof annotation!=='undefined'&&annotation!==true){return false;}if(this.previous().length){return this.previous().some(function(i){return i.inline;});}return true;};_proto.isSourcesContent=function isSourcesContent(){if(typeof this.mapOpts.sourcesContent!=='undefined'){return this.mapOpts.sourcesContent;}if(this.previous().length){return this.previous().some(function(i){return i.withContent();});}return true;};_proto.clearAnnotation=function clearAnnotation(){if(this.mapOpts.annotation===false)return;var node;for(var i=this.root.nodes.length-1;i>=0;i--){node=this.root.nodes[i];if(node.type!=='comment')continue;if(node.text.indexOf('# sourceMappingURL=')===0){this.root.removeChild(i);}}};_proto.setSourcesContent=function setSourcesContent(){var _this2=this;var already={};this.root.walk(function(node){if(node.source){var from=node.source.input.from;if(from&&!already[from]){already[from]=true;var relative=_this2.relative(from);_this2.map.setSourceContent(relative,node.source.input.css);}}});};_proto.applyPrevMaps=function applyPrevMaps(){for(var _iterator=this.previous(),_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var prev=_ref;var from=this.relative(prev.file);var root=prev.root||_path[\"default\"].dirname(prev.file);var map=void 0;if(this.mapOpts.sourcesContent===false){map=new _sourceMap[\"default\"].SourceMapConsumer(prev.text);if(map.sourcesContent){map.sourcesContent=map.sourcesContent.map(function(){return null;});}}else{map=prev.consumer();}this.map.applySourceMap(map,from,this.relative(root));}};_proto.isAnnotation=function isAnnotation(){if(this.isInline()){return true;}if(typeof this.mapOpts.annotation!=='undefined'){return this.mapOpts.annotation;}if(this.previous().length){return this.previous().some(function(i){return i.annotation;});}return true;};_proto.toBase64=function toBase64(str){if(Buffer){return Buffer.from(str).toString('base64');}return window.btoa(unescape(encodeURIComponent(str)));};_proto.addAnnotation=function addAnnotation(){var content;if(this.isInline()){content='data:application/json;base64,'+this.toBase64(this.map.toString());}else if(typeof this.mapOpts.annotation==='string'){content=this.mapOpts.annotation;}else{content=this.outputFile()+'.map';}var eol='\\n';if(this.css.indexOf('\\r\\n')!==-1)eol='\\r\\n';this.css+=eol+'/*# sourceMappingURL='+content+' */';};_proto.outputFile=function outputFile(){if(this.opts.to){return this.relative(this.opts.to);}if(this.opts.from){return this.relative(this.opts.from);}return'to.css';};_proto.generateMap=function generateMap(){this.generateString();if(this.isSourcesContent())this.setSourcesContent();if(this.previous().length>0)this.applyPrevMaps();if(this.isAnnotation())this.addAnnotation();if(this.isInline()){return[this.css];}return[this.css,this.map];};_proto.relative=function relative(file){if(file.indexOf('<')===0)return file;if(/^\\w+:\\/\\//.test(file))return file;var from=this.opts.to?_path[\"default\"].dirname(this.opts.to):'.';if(typeof this.mapOpts.annotation==='string'){from=_path[\"default\"].dirname(_path[\"default\"].resolve(from,this.mapOpts.annotation));}file=_path[\"default\"].relative(from,file);if(_path[\"default\"].sep==='\\\\'){return file.replace(/\\\\/g,'/');}return file;};_proto.sourcePath=function sourcePath(node){if(this.mapOpts.from){return this.mapOpts.from;}return this.relative(node.source.input.from);};_proto.generateString=function generateString(){var _this3=this;this.css='';this.map=new _sourceMap[\"default\"].SourceMapGenerator({file:this.outputFile()});var line=1;var column=1;var lines,last;this.stringify(this.root,function(str,node,type){_this3.css+=str;if(node&&type!=='end'){if(node.source&&node.source.start){_this3.map.addMapping({source:_this3.sourcePath(node),generated:{line:line,column:column-1},original:{line:node.source.start.line,column:node.source.start.column-1}});}else{_this3.map.addMapping({source:'<no source>',original:{line:1,column:0},generated:{line:line,column:column-1}});}}lines=str.match(/\\n/g);if(lines){line+=lines.length;last=str.lastIndexOf('\\n');column=str.length-last;}else{column+=str.length;}if(node&&type!=='start'){var p=node.parent||{raws:{}};if(node.type!=='decl'||node!==p.last||p.raws.semicolon){if(node.source&&node.source.end){_this3.map.addMapping({source:_this3.sourcePath(node),generated:{line:line,column:column-2},original:{line:node.source.end.line,column:node.source.end.column-1}});}else{_this3.map.addMapping({source:'<no source>',original:{line:1,column:0},generated:{line:line,column:column-1}});}}}});};_proto.generate=function generate(){this.clearAnnotation();if(this.isMap()){return this.generateMap();}var result='';this.stringify(this.root,function(i){result+=i;});return[result];};return MapGenerator;}();var _default=MapGenerator;exports[\"default\"]=_default;module.exports=exports[\"default\"];}).call(this,require(\"buffer\").Buffer);},{\"buffer\":3,\"path\":167,\"source-map\":207}],177:[function(require,module,exports){(function(process){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _cssSyntaxError=_interopRequireDefault(require(\"./css-syntax-error\"));var _stringifier=_interopRequireDefault(require(\"./stringifier\"));var _stringify=_interopRequireDefault(require(\"./stringify\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function cloneNode(obj,parent){var cloned=new obj.constructor();for(var i in obj){if(!obj.hasOwnProperty(i))continue;var value=obj[i];var type=_typeof(value);if(i==='parent'&&type==='object'){if(parent)cloned[i]=parent;}else if(i==='source'){cloned[i]=value;}else if(value instanceof Array){cloned[i]=value.map(function(j){return cloneNode(j,cloned);});}else{if(type==='object'&&value!==null)value=cloneNode(value);cloned[i]=value;}}return cloned;}/**\n * All node classes inherit the following common methods.\n *\n * @abstract\n */var Node=/*#__PURE__*/function(){/**\n   * @param {object} [defaults] Value for node properties.\n   */function Node(defaults){if(defaults===void 0){defaults={};}this.raws={};if(process.env.NODE_ENV!=='production'){if(_typeof(defaults)!=='object'&&typeof defaults!=='undefined'){throw new Error('PostCSS nodes constructor accepts object, not '+JSON.stringify(defaults));}}for(var name in defaults){this[name]=defaults[name];}}/**\n   * Returns a `CssSyntaxError` instance containing the original position\n   * of the node in the source, showing line and column numbers and also\n   * a small excerpt to facilitate debugging.\n   *\n   * If present, an input source map will be used to get the original position\n   * of the source, even from a previous compilation step\n   * (e.g., from Sass compilation).\n   *\n   * This method produces very useful error messages.\n   *\n   * @param {string} message     Error description.\n   * @param {object} [opts]      Options.\n   * @param {string} opts.plugin Plugin name that created this error.\n   *                             PostCSS will set it automatically.\n   * @param {string} opts.word   A word inside a nodes string that should\n   *                             be highlighted as the source of the error.\n   * @param {number} opts.index  An index inside a nodes string that should\n   *                             be highlighted as the source of the error.\n   *\n   * @return {CssSyntaxError} Error object to throw it.\n   *\n   * @example\n   * if (!variables[name]) {\n   *   throw decl.error('Unknown variable ' + name, { word: name })\n   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n   *   //   color: $black\n   *   // a\n   *   //          ^\n   *   //   background: white\n   * }\n   */var _proto=Node.prototype;_proto.error=function error(message,opts){if(opts===void 0){opts={};}if(this.source){var pos=this.positionBy(opts);return this.source.input.error(message,pos.line,pos.column,opts);}return new _cssSyntaxError[\"default\"](message);}/**\n   * This method is provided as a convenience wrapper for {@link Result#warn}.\n   *\n   * @param {Result} result      The {@link Result} instance\n   *                             that will receive the warning.\n   * @param {string} text        Warning message.\n   * @param {object} [opts]      Options\n   * @param {string} opts.plugin Plugin name that created this warning.\n   *                             PostCSS will set it automatically.\n   * @param {string} opts.word   A word inside a nodes string that should\n   *                             be highlighted as the source of the warning.\n   * @param {number} opts.index  An index inside a nodes string that should\n   *                             be highlighted as the source of the warning.\n   *\n   * @return {Warning} Created warning object.\n   *\n   * @example\n   * const plugin = postcss.plugin('postcss-deprecated', () => {\n   *   return (root, result) => {\n   *     root.walkDecls('bad', decl => {\n   *       decl.warn(result, 'Deprecated property bad')\n   *     })\n   *   }\n   * })\n   */;_proto.warn=function warn(result,text,opts){var data={node:this};for(var i in opts){data[i]=opts[i];}return result.warn(text,data);}/**\n   * Removes the node from its parent and cleans the parent properties\n   * from the node and its children.\n   *\n   * @example\n   * if (decl.prop.match(/^-webkit-/)) {\n   *   decl.remove()\n   * }\n   *\n   * @return {Node} Node to make calls chain.\n   */;_proto.remove=function remove(){if(this.parent){this.parent.removeChild(this);}this.parent=undefined;return this;}/**\n   * Returns a CSS string representing the node.\n   *\n   * @param {stringifier|syntax} [stringifier] A syntax to use\n   *                                           in string generation.\n   *\n   * @return {string} CSS string of this node.\n   *\n   * @example\n   * postcss.rule({ selector: 'a' }).toString() //=> \"a {}\"\n   */;_proto.toString=function toString(stringifier){if(stringifier===void 0){stringifier=_stringify[\"default\"];}if(stringifier.stringify)stringifier=stringifier.stringify;var result='';stringifier(this,function(i){result+=i;});return result;}/**\n   * Returns an exact clone of the node.\n   *\n   * The resulting cloned node and its (cloned) children will retain\n   * code style properties.\n   *\n   * @param {object} [overrides] New properties to override in the clone.\n   *\n   * @example\n   * decl.raws.before    //=> \"\\n  \"\n   * const cloned = decl.clone({ prop: '-moz-' + decl.prop })\n   * cloned.raws.before  //=> \"\\n  \"\n   * cloned.toString()   //=> -moz-transform: scale(0)\n   *\n   * @return {Node} Clone of the node.\n   */;_proto.clone=function clone(overrides){if(overrides===void 0){overrides={};}var cloned=cloneNode(this);for(var name in overrides){cloned[name]=overrides[name];}return cloned;}/**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * before the current node.\n   *\n   * @param {object} [overrides] Mew properties to override in the clone.\n   *\n   * @example\n   * decl.cloneBefore({ prop: '-moz-' + decl.prop })\n   *\n   * @return {Node} New node\n   */;_proto.cloneBefore=function cloneBefore(overrides){if(overrides===void 0){overrides={};}var cloned=this.clone(overrides);this.parent.insertBefore(this,cloned);return cloned;}/**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * after the current node.\n   *\n   * @param {object} [overrides] New properties to override in the clone.\n   *\n   * @return {Node} New node.\n   */;_proto.cloneAfter=function cloneAfter(overrides){if(overrides===void 0){overrides={};}var cloned=this.clone(overrides);this.parent.insertAfter(this,cloned);return cloned;}/**\n   * Inserts node(s) before the current node and removes the current node.\n   *\n   * @param {...Node} nodes Mode(s) to replace current one.\n   *\n   * @example\n   * if (atrule.name === 'mixin') {\n   *   atrule.replaceWith(mixinRules[atrule.params])\n   * }\n   *\n   * @return {Node} Current node to methods chain.\n   */;_proto.replaceWith=function replaceWith(){if(this.parent){for(var _len=arguments.length,nodes=new Array(_len),_key=0;_key<_len;_key++){nodes[_key]=arguments[_key];}for(var _i=0,_nodes=nodes;_i<_nodes.length;_i++){var node=_nodes[_i];this.parent.insertBefore(this,node);}this.remove();}return this;}/**\n   * Returns the next child of the nodes parent.\n   * Returns `undefined` if the current node is the last child.\n   *\n   * @return {Node|undefined} Next node.\n   *\n   * @example\n   * if (comment.text === 'delete next') {\n   *   const next = comment.next()\n   *   if (next) {\n   *     next.remove()\n   *   }\n   * }\n   */;_proto.next=function next(){if(!this.parent)return undefined;var index=this.parent.index(this);return this.parent.nodes[index+1];}/**\n   * Returns the previous child of the nodes parent.\n   * Returns `undefined` if the current node is the first child.\n   *\n   * @return {Node|undefined} Previous node.\n   *\n   * @example\n   * const annotation = decl.prev()\n   * if (annotation.type === 'comment') {\n   *   readAnnotation(annotation.text)\n   * }\n   */;_proto.prev=function prev(){if(!this.parent)return undefined;var index=this.parent.index(this);return this.parent.nodes[index-1];}/**\n   * Insert new node before current node to current nodes parent.\n   *\n   * Just alias for `node.parent.insertBefore(node, add)`.\n   *\n   * @param {Node|object|string|Node[]} add New node.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * decl.before('content: \"\"')\n   */;_proto.before=function before(add){this.parent.insertBefore(this,add);return this;}/**\n   * Insert new node after current node to current nodes parent.\n   *\n   * Just alias for `node.parent.insertAfter(node, add)`.\n   *\n   * @param {Node|object|string|Node[]} add New node.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * decl.after('color: black')\n   */;_proto.after=function after(add){this.parent.insertAfter(this,add);return this;};_proto.toJSON=function toJSON(){var fixed={};for(var name in this){if(!this.hasOwnProperty(name))continue;if(name==='parent')continue;var value=this[name];if(value instanceof Array){fixed[name]=value.map(function(i){if(_typeof(i)==='object'&&i.toJSON){return i.toJSON();}else{return i;}});}else if(_typeof(value)==='object'&&value.toJSON){fixed[name]=value.toJSON();}else{fixed[name]=value;}}return fixed;}/**\n   * Returns a {@link Node#raws} value. If the node is missing\n   * the code style property (because the node was manually built or cloned),\n   * PostCSS will try to autodetect the code style property by looking\n   * at other nodes in the tree.\n   *\n   * @param {string} prop          Name of code style property.\n   * @param {string} [defaultType] Name of default value, it can be missed\n   *                               if the value is the same as prop.\n   *\n   * @example\n   * const root = postcss.parse('a { background: white }')\n   * root.nodes[0].append({ prop: 'color', value: 'black' })\n   * root.nodes[0].nodes[1].raws.before   //=> undefined\n   * root.nodes[0].nodes[1].raw('before') //=> ' '\n   *\n   * @return {string} Code style value.\n   */;_proto.raw=function raw(prop,defaultType){var str=new _stringifier[\"default\"]();return str.raw(this,prop,defaultType);}/**\n   * Finds the Root instance of the nodes tree.\n   *\n   * @example\n   * root.nodes[0].nodes[0].root() === root\n   *\n   * @return {Root} Root parent.\n   */;_proto.root=function root(){var result=this;while(result.parent){result=result.parent;}return result;}/**\n   * Clear the code style properties for the node and its children.\n   *\n   * @param {boolean} [keepBetween] Keep the raws.between symbols.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * node.raws.before  //=> ' '\n   * node.cleanRaws()\n   * node.raws.before  //=> undefined\n   */;_proto.cleanRaws=function cleanRaws(keepBetween){delete this.raws.before;delete this.raws.after;if(!keepBetween)delete this.raws.between;};_proto.positionInside=function positionInside(index){var string=this.toString();var column=this.source.start.column;var line=this.source.start.line;for(var i=0;i<index;i++){if(string[i]==='\\n'){column=1;line+=1;}else{column+=1;}}return{line:line,column:column};};_proto.positionBy=function positionBy(opts){var pos=this.source.start;if(opts.index){pos=this.positionInside(opts.index);}else if(opts.word){var index=this.toString().indexOf(opts.word);if(index!==-1)pos=this.positionInside(index);}return pos;}/**\n   * @memberof Node#\n   * @member {string} type String representing the nodes type.\n   *                       Possible values are `root`, `atrule`, `rule`,\n   *                       `decl`, or `comment`.\n   *\n   * @example\n   * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'\n   */ /**\n   * @memberof Node#\n   * @member {Container} parent The nodes parent node.\n   *\n   * @example\n   * root.nodes[0].parent === root\n   */ /**\n   * @memberof Node#\n   * @member {source} source The input source of the node.\n   *\n   * The property is used in source map generation.\n   *\n   * If you create a node manually (e.g., with `postcss.decl()`),\n   * that node will not have a `source` property and will be absent\n   * from the source map. For this reason, the plugin developer should\n   * consider cloning nodes to create new ones (in which case the new nodes\n   * source will reference the original, cloned node) or setting\n   * the `source` property manually.\n   *\n   * ```js\n   * // Bad\n   * const prefixed = postcss.decl({\n   *   prop: '-moz-' + decl.prop,\n   *   value: decl.value\n   * })\n   *\n   * // Good\n   * const prefixed = decl.clone({ prop: '-moz-' + decl.prop })\n   * ```\n   *\n   * ```js\n   * if (atrule.name === 'add-link') {\n   *   const rule = postcss.rule({ selector: 'a', source: atrule.source })\n   *   atrule.parent.insertBefore(atrule, rule)\n   * }\n   * ```\n   *\n   * @example\n   * decl.source.input.from //=> '/home/ai/a.sass'\n   * decl.source.start      //=> { line: 10, column: 2 }\n   * decl.source.end        //=> { line: 10, column: 12 }\n   */ /**\n   * @memberof Node#\n   * @member {object} raws Information to generate byte-to-byte equal\n   *                       node string as it was in the origin input.\n   *\n   * Every parser saves its own properties,\n   * but the default CSS parser uses:\n   *\n   * * `before`: the space symbols before the node. It also stores `*`\n   *   and `_` symbols before the declaration (IE hack).\n   * * `after`: the space symbols after the last child of the node\n   *   to the end of the node.\n   * * `between`: the symbols between the property and value\n   *   for declarations, selector and `{` for rules, or last parameter\n   *   and `{` for at-rules.\n   * * `semicolon`: contains true if the last child has\n   *   an (optional) semicolon.\n   * * `afterName`: the space between the at-rule name and its parameters.\n   * * `left`: the space symbols between `/*` and the comments text.\n   * * `right`: the space symbols between the comments text\n   *   and <code>*&#47;</code>.\n   * * `important`: the content of the important statement,\n   *   if it is not just `!important`.\n   *\n   * PostCSS cleans selectors, declaration values and at-rule parameters\n   * from comments and extra spaces, but it stores origin content in raws\n   * properties. As such, if you dont change a declarations value,\n   * PostCSS will use the raw value with comments.\n   *\n   * @example\n   * const root = postcss.parse('a {\\n  color:black\\n}')\n   * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n   */;return Node;}();var _default=Node;/**\n * @typedef {object} position\n * @property {number} line   Source line in file.\n * @property {number} column Source column in file.\n */ /**\n * @typedef {object} source\n * @property {Input} input    {@link Input} with input file\n * @property {position} start The starting position of the nodes source.\n * @property {position} end   The ending position of the nodes source.\n */exports[\"default\"]=_default;module.exports=exports[\"default\"];}).call(this,require('_process'));},{\"./css-syntax-error\":171,\"./stringifier\":186,\"./stringify\":187,\"_process\":192}],178:[function(require,module,exports){(function(process){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _parser=_interopRequireDefault(require(\"./parser\"));var _input=_interopRequireDefault(require(\"./input\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function parse(css,opts){var input=new _input[\"default\"](css,opts);var parser=new _parser[\"default\"](input);try{parser.parse();}catch(e){if(process.env.NODE_ENV!=='production'){if(e.name==='CssSyntaxError'&&opts&&opts.from){if(/\\.scss$/i.test(opts.from)){e.message+='\\nYou tried to parse SCSS with '+'the standard CSS parser; '+'try again with the postcss-scss parser';}else if(/\\.sass/i.test(opts.from)){e.message+='\\nYou tried to parse Sass with '+'the standard CSS parser; '+'try again with the postcss-sass parser';}else if(/\\.less$/i.test(opts.from)){e.message+='\\nYou tried to parse Less with '+'the standard CSS parser; '+'try again with the postcss-less parser';}}}throw e;}return parser.root;}var _default=parse;exports[\"default\"]=_default;module.exports=exports[\"default\"];}).call(this,require('_process'));},{\"./input\":173,\"./parser\":179,\"_process\":192}],179:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _declaration=_interopRequireDefault(require(\"./declaration\"));var _tokenize=_interopRequireDefault(require(\"./tokenize\"));var _comment=_interopRequireDefault(require(\"./comment\"));var _atRule=_interopRequireDefault(require(\"./at-rule\"));var _root=_interopRequireDefault(require(\"./root\"));var _rule=_interopRequireDefault(require(\"./rule\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}var Parser=/*#__PURE__*/function(){function Parser(input){this.input=input;this.root=new _root[\"default\"]();this.current=this.root;this.spaces='';this.semicolon=false;this.createTokenizer();this.root.source={input:input,start:{line:1,column:1}};}var _proto=Parser.prototype;_proto.createTokenizer=function createTokenizer(){this.tokenizer=(0,_tokenize[\"default\"])(this.input);};_proto.parse=function parse(){var token;while(!this.tokenizer.endOfFile()){token=this.tokenizer.nextToken();switch(token[0]){case'space':this.spaces+=token[1];break;case';':this.freeSemicolon(token);break;case'}':this.end(token);break;case'comment':this.comment(token);break;case'at-word':this.atrule(token);break;case'{':this.emptyRule(token);break;default:this.other(token);break;}}this.endFile();};_proto.comment=function comment(token){var node=new _comment[\"default\"]();this.init(node,token[2],token[3]);node.source.end={line:token[4],column:token[5]};var text=token[1].slice(2,-2);if(/^\\s*$/.test(text)){node.text='';node.raws.left=text;node.raws.right='';}else{var match=text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);node.text=match[2];node.raws.left=match[1];node.raws.right=match[3];}};_proto.emptyRule=function emptyRule(token){var node=new _rule[\"default\"]();this.init(node,token[2],token[3]);node.selector='';node.raws.between='';this.current=node;};_proto.other=function other(start){var end=false;var type=null;var colon=false;var bracket=null;var brackets=[];var tokens=[];var token=start;while(token){type=token[0];tokens.push(token);if(type==='('||type==='['){if(!bracket)bracket=token;brackets.push(type==='('?')':']');}else if(brackets.length===0){if(type===';'){if(colon){this.decl(tokens);return;}else{break;}}else if(type==='{'){this.rule(tokens);return;}else if(type==='}'){this.tokenizer.back(tokens.pop());end=true;break;}else if(type===':'){colon=true;}}else if(type===brackets[brackets.length-1]){brackets.pop();if(brackets.length===0)bracket=null;}token=this.tokenizer.nextToken();}if(this.tokenizer.endOfFile())end=true;if(brackets.length>0)this.unclosedBracket(bracket);if(end&&colon){while(tokens.length){token=tokens[tokens.length-1][0];if(token!=='space'&&token!=='comment')break;this.tokenizer.back(tokens.pop());}this.decl(tokens);}else{this.unknownWord(tokens);}};_proto.rule=function rule(tokens){tokens.pop();var node=new _rule[\"default\"]();this.init(node,tokens[0][2],tokens[0][3]);node.raws.between=this.spacesAndCommentsFromEnd(tokens);this.raw(node,'selector',tokens);this.current=node;};_proto.decl=function decl(tokens){var node=new _declaration[\"default\"]();this.init(node);var last=tokens[tokens.length-1];if(last[0]===';'){this.semicolon=true;tokens.pop();}if(last[4]){node.source.end={line:last[4],column:last[5]};}else{node.source.end={line:last[2],column:last[3]};}while(tokens[0][0]!=='word'){if(tokens.length===1)this.unknownWord(tokens);node.raws.before+=tokens.shift()[1];}node.source.start={line:tokens[0][2],column:tokens[0][3]};node.prop='';while(tokens.length){var type=tokens[0][0];if(type===':'||type==='space'||type==='comment'){break;}node.prop+=tokens.shift()[1];}node.raws.between='';var token;while(tokens.length){token=tokens.shift();if(token[0]===':'){node.raws.between+=token[1];break;}else{if(token[0]==='word'&&/\\w/.test(token[1])){this.unknownWord([token]);}node.raws.between+=token[1];}}if(node.prop[0]==='_'||node.prop[0]==='*'){node.raws.before+=node.prop[0];node.prop=node.prop.slice(1);}node.raws.between+=this.spacesAndCommentsFromStart(tokens);this.precheckMissedSemicolon(tokens);for(var i=tokens.length-1;i>0;i--){token=tokens[i];if(token[1].toLowerCase()==='!important'){node.important=true;var string=this.stringFrom(tokens,i);string=this.spacesFromEnd(tokens)+string;if(string!==' !important')node.raws.important=string;break;}else if(token[1].toLowerCase()==='important'){var cache=tokens.slice(0);var str='';for(var j=i;j>0;j--){var _type=cache[j][0];if(str.trim().indexOf('!')===0&&_type!=='space'){break;}str=cache.pop()[1]+str;}if(str.trim().indexOf('!')===0){node.important=true;node.raws.important=str;tokens=cache;}}if(token[0]!=='space'&&token[0]!=='comment'){break;}}this.raw(node,'value',tokens);if(node.value.indexOf(':')!==-1)this.checkMissedSemicolon(tokens);};_proto.atrule=function atrule(token){var node=new _atRule[\"default\"]();node.name=token[1].slice(1);if(node.name===''){this.unnamedAtrule(node,token);}this.init(node,token[2],token[3]);var prev;var shift;var last=false;var open=false;var params=[];while(!this.tokenizer.endOfFile()){token=this.tokenizer.nextToken();if(token[0]===';'){node.source.end={line:token[2],column:token[3]};this.semicolon=true;break;}else if(token[0]==='{'){open=true;break;}else if(token[0]==='}'){if(params.length>0){shift=params.length-1;prev=params[shift];while(prev&&prev[0]==='space'){prev=params[--shift];}if(prev){node.source.end={line:prev[4],column:prev[5]};}}this.end(token);break;}else{params.push(token);}if(this.tokenizer.endOfFile()){last=true;break;}}node.raws.between=this.spacesAndCommentsFromEnd(params);if(params.length){node.raws.afterName=this.spacesAndCommentsFromStart(params);this.raw(node,'params',params);if(last){token=params[params.length-1];node.source.end={line:token[4],column:token[5]};this.spaces=node.raws.between;node.raws.between='';}}else{node.raws.afterName='';node.params='';}if(open){node.nodes=[];this.current=node;}};_proto.end=function end(token){if(this.current.nodes&&this.current.nodes.length){this.current.raws.semicolon=this.semicolon;}this.semicolon=false;this.current.raws.after=(this.current.raws.after||'')+this.spaces;this.spaces='';if(this.current.parent){this.current.source.end={line:token[2],column:token[3]};this.current=this.current.parent;}else{this.unexpectedClose(token);}};_proto.endFile=function endFile(){if(this.current.parent)this.unclosedBlock();if(this.current.nodes&&this.current.nodes.length){this.current.raws.semicolon=this.semicolon;}this.current.raws.after=(this.current.raws.after||'')+this.spaces;};_proto.freeSemicolon=function freeSemicolon(token){this.spaces+=token[1];if(this.current.nodes){var prev=this.current.nodes[this.current.nodes.length-1];if(prev&&prev.type==='rule'&&!prev.raws.ownSemicolon){prev.raws.ownSemicolon=this.spaces;this.spaces='';}}}// Helpers\n;_proto.init=function init(node,line,column){this.current.push(node);node.source={start:{line:line,column:column},input:this.input};node.raws.before=this.spaces;this.spaces='';if(node.type!=='comment')this.semicolon=false;};_proto.raw=function raw(node,prop,tokens){var token,type;var length=tokens.length;var value='';var clean=true;var next,prev;var pattern=/^([.|#])?([\\w])+/i;for(var i=0;i<length;i+=1){token=tokens[i];type=token[0];if(type==='comment'&&node.type==='rule'){prev=tokens[i-1];next=tokens[i+1];if(prev[0]!=='space'&&next[0]!=='space'&&pattern.test(prev[1])&&pattern.test(next[1])){value+=token[1];}else{clean=false;}continue;}if(type==='comment'||type==='space'&&i===length-1){clean=false;}else{value+=token[1];}}if(!clean){var raw=tokens.reduce(function(all,i){return all+i[1];},'');node.raws[prop]={value:value,raw:raw};}node[prop]=value;};_proto.spacesAndCommentsFromEnd=function spacesAndCommentsFromEnd(tokens){var lastTokenType;var spaces='';while(tokens.length){lastTokenType=tokens[tokens.length-1][0];if(lastTokenType!=='space'&&lastTokenType!=='comment')break;spaces=tokens.pop()[1]+spaces;}return spaces;};_proto.spacesAndCommentsFromStart=function spacesAndCommentsFromStart(tokens){var next;var spaces='';while(tokens.length){next=tokens[0][0];if(next!=='space'&&next!=='comment')break;spaces+=tokens.shift()[1];}return spaces;};_proto.spacesFromEnd=function spacesFromEnd(tokens){var lastTokenType;var spaces='';while(tokens.length){lastTokenType=tokens[tokens.length-1][0];if(lastTokenType!=='space')break;spaces=tokens.pop()[1]+spaces;}return spaces;};_proto.stringFrom=function stringFrom(tokens,from){var result='';for(var i=from;i<tokens.length;i++){result+=tokens[i][1];}tokens.splice(from,tokens.length-from);return result;};_proto.colon=function colon(tokens){var brackets=0;var token,type,prev;for(var i=0;i<tokens.length;i++){token=tokens[i];type=token[0];if(type==='('){brackets+=1;}if(type===')'){brackets-=1;}if(brackets===0&&type===':'){if(!prev){this.doubleColon(token);}else if(prev[0]==='word'&&prev[1]==='progid'){continue;}else{return i;}}prev=token;}return false;}// Errors\n;_proto.unclosedBracket=function unclosedBracket(bracket){throw this.input.error('Unclosed bracket',bracket[2],bracket[3]);};_proto.unknownWord=function unknownWord(tokens){throw this.input.error('Unknown word',tokens[0][2],tokens[0][3]);};_proto.unexpectedClose=function unexpectedClose(token){throw this.input.error('Unexpected }',token[2],token[3]);};_proto.unclosedBlock=function unclosedBlock(){var pos=this.current.source.start;throw this.input.error('Unclosed block',pos.line,pos.column);};_proto.doubleColon=function doubleColon(token){throw this.input.error('Double colon',token[2],token[3]);};_proto.unnamedAtrule=function unnamedAtrule(node,token){throw this.input.error('At-rule without name',token[2],token[3]);};_proto.precheckMissedSemicolon=function precheckMissedSemicolon()/* tokens */{// Hook for Safe Parser\n};_proto.checkMissedSemicolon=function checkMissedSemicolon(tokens){var colon=this.colon(tokens);if(colon===false)return;var founded=0;var token;for(var j=colon-1;j>=0;j--){token=tokens[j];if(token[0]!=='space'){founded+=1;if(founded===2)break;}}throw this.input.error('Missed semicolon',token[2],token[3]);};return Parser;}();exports[\"default\"]=Parser;module.exports=exports[\"default\"];},{\"./at-rule\":168,\"./comment\":169,\"./declaration\":172,\"./root\":184,\"./rule\":185,\"./tokenize\":188}],180:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _declaration=_interopRequireDefault(require(\"./declaration\"));var _processor=_interopRequireDefault(require(\"./processor\"));var _stringify=_interopRequireDefault(require(\"./stringify\"));var _comment=_interopRequireDefault(require(\"./comment\"));var _atRule=_interopRequireDefault(require(\"./at-rule\"));var _vendor=_interopRequireDefault(require(\"./vendor\"));var _parse=_interopRequireDefault(require(\"./parse\"));var _list=_interopRequireDefault(require(\"./list\"));var _rule=_interopRequireDefault(require(\"./rule\"));var _root=_interopRequireDefault(require(\"./root\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}/**\n * Create a new {@link Processor} instance that will apply `plugins`\n * as CSS processors.\n *\n * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.\n *        See {@link Processor#use} for plugin format.\n *\n * @return {Processor} Processor to process multiple CSS.\n *\n * @example\n * import postcss from 'postcss'\n *\n * postcss(plugins).process(css, { from, to }).then(result => {\n *   console.log(result.css)\n * })\n *\n * @namespace postcss\n */function postcss(){for(var _len=arguments.length,plugins=new Array(_len),_key=0;_key<_len;_key++){plugins[_key]=arguments[_key];}if(plugins.length===1&&Array.isArray(plugins[0])){plugins=plugins[0];}return new _processor[\"default\"](plugins);}/**\n * Creates a PostCSS plugin with a standard API.\n *\n * The newly-wrapped function will provide both the name and PostCSS\n * version of the plugin.\n *\n * ```js\n * const processor = postcss([replace])\n * processor.plugins[0].postcssPlugin  //=> 'postcss-replace'\n * processor.plugins[0].postcssVersion //=> '6.0.0'\n * ```\n *\n * The plugin function receives 2 arguments: {@link Root}\n * and {@link Result} instance. The function should mutate the provided\n * `Root` node. Alternatively, you can create a new `Root` node\n * and override the `result.root` property.\n *\n * ```js\n * const cleaner = postcss.plugin('postcss-cleaner', () => {\n *   return (root, result) => {\n *     result.root = postcss.root()\n *   }\n * })\n * ```\n *\n * As a convenience, plugins also expose a `process` method so that you can use\n * them as standalone tools.\n *\n * ```js\n * cleaner.process(css, processOpts, pluginOpts)\n * // This is equivalent to:\n * postcss([ cleaner(pluginOpts) ]).process(css, processOpts)\n * ```\n *\n * Asynchronous plugins should return a `Promise` instance.\n *\n * ```js\n * postcss.plugin('postcss-import', () => {\n *   return (root, result) => {\n *     return new Promise( (resolve, reject) => {\n *       fs.readFile('base.css', (base) => {\n *         root.prepend(base)\n *         resolve()\n *       })\n *     })\n *   }\n * })\n * ```\n *\n * Add warnings using the {@link Node#warn} method.\n * Send data to other plugins using the {@link Result#messages} array.\n *\n * ```js\n * postcss.plugin('postcss-caniuse-test', () => {\n *   return (root, result) => {\n *     root.walkDecls(decl => {\n *       if (!caniuse.support(decl.prop)) {\n *         decl.warn(result, 'Some browsers do not support ' + decl.prop)\n *       }\n *     })\n *   }\n * })\n * ```\n *\n * @param {string} name          PostCSS plugin name. Same as in `name`\n *                               property in `package.json`. It will be saved\n *                               in `plugin.postcssPlugin` property.\n * @param {function} initializer Will receive plugin options\n *                               and should return {@link pluginFunction}\n *\n * @return {Plugin} PostCSS plugin.\n */postcss.plugin=function plugin(name,initializer){function creator(){var transformer=initializer.apply(void 0,arguments);transformer.postcssPlugin=name;transformer.postcssVersion=new _processor[\"default\"]().version;return transformer;}var cache;Object.defineProperty(creator,'postcss',{get:function get(){if(!cache)cache=creator();return cache;}});creator.process=function(css,processOpts,pluginOpts){return postcss([creator(pluginOpts)]).process(css,processOpts);};return creator;};/**\n * Default function to convert a node tree into a CSS string.\n *\n * @param {Node} node       Start node for stringifing. Usually {@link Root}.\n * @param {builder} builder Function to concatenate CSS from nodes parts\n *                          or generate string and source map.\n *\n * @return {void}\n *\n * @function\n */postcss.stringify=_stringify[\"default\"];/**\n * Parses source css and returns a new {@link Root} node,\n * which contains the source CSS nodes.\n *\n * @param {string|toString} css   String with input CSS or any object\n *                                with toString() method, like a Buffer\n * @param {processOptions} [opts] Options with only `from` and `map` keys.\n *\n * @return {Root} PostCSS AST.\n *\n * @example\n * // Simple CSS concatenation with source map support\n * const root1 = postcss.parse(css1, { from: file1 })\n * const root2 = postcss.parse(css2, { from: file2 })\n * root1.append(root2).toResult().css\n *\n * @function\n */postcss.parse=_parse[\"default\"];/**\n * Contains the {@link vendor} module.\n *\n * @type {vendor}\n *\n * @example\n * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']\n */postcss.vendor=_vendor[\"default\"];/**\n * Contains the {@link list} module.\n *\n * @member {list}\n *\n * @example\n * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']\n */postcss.list=_list[\"default\"];/**\n * Creates a new {@link Comment} node.\n *\n * @param {object} [defaults] Properties for the new node.\n *\n * @return {Comment} New comment node\n *\n * @example\n * postcss.comment({ text: 'test' })\n */postcss.comment=function(defaults){return new _comment[\"default\"](defaults);};/**\n * Creates a new {@link AtRule} node.\n *\n * @param {object} [defaults] Properties for the new node.\n *\n * @return {AtRule} new at-rule node\n *\n * @example\n * postcss.atRule({ name: 'charset' }).toString() //=> \"@charset\"\n */postcss.atRule=function(defaults){return new _atRule[\"default\"](defaults);};/**\n * Creates a new {@link Declaration} node.\n *\n * @param {object} [defaults] Properties for the new node.\n *\n * @return {Declaration} new declaration node\n *\n * @example\n * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> \"color: red\"\n */postcss.decl=function(defaults){return new _declaration[\"default\"](defaults);};/**\n * Creates a new {@link Rule} node.\n *\n * @param {object} [defaults] Properties for the new node.\n *\n * @return {Rule} new rule node\n *\n * @example\n * postcss.rule({ selector: 'a' }).toString() //=> \"a {\\n}\"\n */postcss.rule=function(defaults){return new _rule[\"default\"](defaults);};/**\n * Creates a new {@link Root} node.\n *\n * @param {object} [defaults] Properties for the new node.\n *\n * @return {Root} new root node.\n *\n * @example\n * postcss.root({ after: '\\n' }).toString() //=> \"\\n\"\n */postcss.root=function(defaults){return new _root[\"default\"](defaults);};var _default=postcss;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./at-rule\":168,\"./comment\":169,\"./declaration\":172,\"./list\":175,\"./parse\":178,\"./processor\":182,\"./root\":184,\"./rule\":185,\"./stringify\":187,\"./vendor\":189}],181:[function(require,module,exports){(function(Buffer){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _sourceMap=_interopRequireDefault(require(\"source-map\"));var _path=_interopRequireDefault(require(\"path\"));var _fs=_interopRequireDefault(require(\"fs\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function fromBase64(str){if(Buffer){return Buffer.from(str,'base64').toString();}else{return window.atob(str);}}/**\n * Source map information from input CSS.\n * For example, source map after Sass compiler.\n *\n * This class will automatically find source map in input CSS or in file system\n * near input file (according `from` option).\n *\n * @example\n * const root = postcss.parse(css, { from: 'a.sass.css' })\n * root.input.map //=> PreviousMap\n */var PreviousMap=/*#__PURE__*/function(){/**\n   * @param {string}         css    Input CSS source.\n   * @param {processOptions} [opts] {@link Processor#process} options.\n   */function PreviousMap(css,opts){this.loadAnnotation(css);/**\n     * Was source map inlined by data-uri to input CSS.\n     *\n     * @type {boolean}\n     */this.inline=this.startWith(this.annotation,'data:');var prev=opts.map?opts.map.prev:undefined;var text=this.loadMap(opts.from,prev);if(text)this.text=text;}/**\n   * Create a instance of `SourceMapGenerator` class\n   * from the `source-map` library to work with source map information.\n   *\n   * It is lazy method, so it will create object only on first call\n   * and then it will use cache.\n   *\n   * @return {SourceMapGenerator} Object with source map information.\n   */var _proto=PreviousMap.prototype;_proto.consumer=function consumer(){if(!this.consumerCache){this.consumerCache=new _sourceMap[\"default\"].SourceMapConsumer(this.text);}return this.consumerCache;}/**\n   * Does source map contains `sourcesContent` with input source text.\n   *\n   * @return {boolean} Is `sourcesContent` present.\n   */;_proto.withContent=function withContent(){return!!(this.consumer().sourcesContent&&this.consumer().sourcesContent.length>0);};_proto.startWith=function startWith(string,start){if(!string)return false;return string.substr(0,start.length)===start;};_proto.getAnnotationURL=function getAnnotationURL(sourceMapString){return sourceMapString.match(/\\/\\*\\s*# sourceMappingURL=(.*)\\s*\\*\\//)[1].trim();};_proto.loadAnnotation=function loadAnnotation(css){var annotations=css.match(/\\/\\*\\s*# sourceMappingURL=(.*)\\s*\\*\\//mg);if(annotations&&annotations.length>0){// Locate the last sourceMappingURL to avoid picking up\n// sourceMappingURLs from comments, strings, etc.\nvar lastAnnotation=annotations[annotations.length-1];if(lastAnnotation){this.annotation=this.getAnnotationURL(lastAnnotation);}}};_proto.decodeInline=function decodeInline(text){var baseCharsetUri=/^data:application\\/json;charset=utf-?8;base64,/;var baseUri=/^data:application\\/json;base64,/;var uri='data:application/json,';if(this.startWith(text,uri)){return decodeURIComponent(text.substr(uri.length));}if(baseCharsetUri.test(text)||baseUri.test(text)){return fromBase64(text.substr(RegExp.lastMatch.length));}var encoding=text.match(/data:application\\/json;([^,]+),/)[1];throw new Error('Unsupported source map encoding '+encoding);};_proto.loadMap=function loadMap(file,prev){if(prev===false)return false;if(prev){if(typeof prev==='string'){return prev;}else if(typeof prev==='function'){var prevPath=prev(file);if(prevPath&&_fs[\"default\"].existsSync&&_fs[\"default\"].existsSync(prevPath)){return _fs[\"default\"].readFileSync(prevPath,'utf-8').toString().trim();}else{throw new Error('Unable to load previous source map: '+prevPath.toString());}}else if(prev instanceof _sourceMap[\"default\"].SourceMapConsumer){return _sourceMap[\"default\"].SourceMapGenerator.fromSourceMap(prev).toString();}else if(prev instanceof _sourceMap[\"default\"].SourceMapGenerator){return prev.toString();}else if(this.isMap(prev)){return JSON.stringify(prev);}else{throw new Error('Unsupported previous source map format: '+prev.toString());}}else if(this.inline){return this.decodeInline(this.annotation);}else if(this.annotation){var map=this.annotation;if(file)map=_path[\"default\"].join(_path[\"default\"].dirname(file),map);this.root=_path[\"default\"].dirname(map);if(_fs[\"default\"].existsSync&&_fs[\"default\"].existsSync(map)){return _fs[\"default\"].readFileSync(map,'utf-8').toString().trim();}else{return false;}}};_proto.isMap=function isMap(map){if(_typeof(map)!=='object')return false;return typeof map.mappings==='string'||typeof map._mappings==='string';};return PreviousMap;}();var _default=PreviousMap;exports[\"default\"]=_default;module.exports=exports[\"default\"];}).call(this,require(\"buffer\").Buffer);},{\"buffer\":3,\"fs\":2,\"path\":167,\"source-map\":207}],182:[function(require,module,exports){(function(process){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _lazyResult=_interopRequireDefault(require(\"./lazy-result\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}/**\n * Contains plugins to process CSS. Create one `Processor` instance,\n * initialize its plugins, and then use that instance on numerous CSS files.\n *\n * @example\n * const processor = postcss([autoprefixer, precss])\n * processor.process(css1).then(result => console.log(result.css))\n * processor.process(css2).then(result => console.log(result.css))\n */var Processor=/*#__PURE__*/function(){/**\n   * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.\n   *        See {@link Processor#use} for plugin format.\n   */function Processor(plugins){if(plugins===void 0){plugins=[];}/**\n     * Current PostCSS version.\n     *\n     * @type {string}\n     *\n     * @example\n     * if (result.processor.version.split('.')[0] !== '6') {\n     *   throw new Error('This plugin works only with PostCSS 6')\n     * }\n     */this.version='7.0.31';/**\n     * Plugins added to this processor.\n     *\n     * @type {pluginFunction[]}\n     *\n     * @example\n     * const processor = postcss([autoprefixer, precss])\n     * processor.plugins.length //=> 2\n     */this.plugins=this.normalize(plugins);}/**\n   * Adds a plugin to be used as a CSS processor.\n   *\n   * PostCSS plugin can be in 4 formats:\n   * * A plugin created by {@link postcss.plugin} method.\n   * * A function. PostCSS will pass the function a @{link Root}\n   *   as the first argument and current {@link Result} instance\n   *   as the second.\n   * * An object with a `postcss` method. PostCSS will use that method\n   *   as described in #2.\n   * * Another {@link Processor} instance. PostCSS will copy plugins\n   *   from that instance into this one.\n   *\n   * Plugins can also be added by passing them as arguments when creating\n   * a `postcss` instance (see [`postcss(plugins)`]).\n   *\n   * Asynchronous plugins should return a `Promise` instance.\n   *\n   * @param {Plugin|pluginFunction|Processor} plugin PostCSS plugin\n   *                                                 or {@link Processor}\n   *                                                 with plugins.\n   *\n   * @example\n   * const processor = postcss()\n   *   .use(autoprefixer)\n   *   .use(precss)\n   *\n   * @return {Processes} Current processor to make methods chain.\n   */var _proto=Processor.prototype;_proto.use=function use(plugin){this.plugins=this.plugins.concat(this.normalize([plugin]));return this;}/**\n   * Parses source CSS and returns a {@link LazyResult} Promise proxy.\n   * Because some plugins can be asynchronous it doesnt make\n   * any transformations. Transformations will be applied\n   * in the {@link LazyResult} methods.\n   *\n   * @param {string|toString|Result} css String with input CSS or any object\n   *                                     with a `toString()` method,\n   *                                     like a Buffer. Optionally, send\n   *                                     a {@link Result} instance\n   *                                     and the processor will take\n   *                                     the {@link Root} from it.\n   * @param {processOptions} [opts]      Options.\n   *\n   * @return {LazyResult} Promise proxy.\n   *\n   * @example\n   * processor.process(css, { from: 'a.css', to: 'a.out.css' })\n   *   .then(result => {\n   *      console.log(result.css)\n   *   })\n   */;_proto.process=function(_process){function process(_x){return _process.apply(this,arguments);}process.toString=function(){return _process.toString();};return process;}(function(css,opts){if(opts===void 0){opts={};}if(this.plugins.length===0&&opts.parser===opts.stringifier){if(process.env.NODE_ENV!=='production'){if(typeof console!=='undefined'&&console.warn){console.warn('You did not set any plugins, parser, or stringifier. '+'Right now, PostCSS does nothing. Pick plugins for your case '+'on https://www.postcss.parts/ and use them in postcss.config.js.');}}}return new _lazyResult[\"default\"](this,css,opts);});_proto.normalize=function normalize(plugins){var normalized=[];for(var _iterator=plugins,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var i=_ref;if(i.postcss)i=i.postcss;if(_typeof(i)==='object'&&Array.isArray(i.plugins)){normalized=normalized.concat(i.plugins);}else if(typeof i==='function'){normalized.push(i);}else if(_typeof(i)==='object'&&(i.parse||i.stringify)){if(process.env.NODE_ENV!=='production'){throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use '+'one of the syntax/parser/stringifier options as outlined '+'in your PostCSS runner documentation.');}}else{throw new Error(i+' is not a PostCSS plugin');}}return normalized;};return Processor;}();var _default=Processor;/**\n * @callback builder\n * @param {string} part          Part of generated CSS connected to this node.\n * @param {Node}   node          AST node.\n * @param {\"start\"|\"end\"} [type] Nodes part type.\n */ /**\n * @callback parser\n *\n * @param {string|toString} css   String with input CSS or any object\n *                                with toString() method, like a Buffer.\n * @param {processOptions} [opts] Options with only `from` and `map` keys.\n *\n * @return {Root} PostCSS AST\n */ /**\n * @callback stringifier\n *\n * @param {Node} node       Start node for stringifing. Usually {@link Root}.\n * @param {builder} builder Function to concatenate CSS from nodes parts\n *                          or generate string and source map.\n *\n * @return {void}\n */ /**\n * @typedef {object} syntax\n * @property {parser} parse          Function to generate AST by string.\n * @property {stringifier} stringify Function to generate string by AST.\n */ /**\n * @typedef {object} toString\n * @property {function} toString\n */ /**\n * @callback pluginFunction\n * @param {Root} root     Parsed input CSS.\n * @param {Result} result Result to set warnings or check other plugins.\n */ /**\n * @typedef {object} Plugin\n * @property {function} postcss PostCSS plugin function.\n */ /**\n * @typedef {object} processOptions\n * @property {string} from             The path of the CSS source file.\n *                                     You should always set `from`,\n *                                     because it is used in source map\n *                                     generation and syntax error messages.\n * @property {string} to               The path where youll put the output\n *                                     CSS file. You should always set `to`\n *                                     to generate correct source maps.\n * @property {parser} parser           Function to generate AST by string.\n * @property {stringifier} stringifier Class to generate string by AST.\n * @property {syntax} syntax           Object with `parse` and `stringify`.\n * @property {object} map              Source map options.\n * @property {boolean} map.inline                    Does source map should\n *                                                   be embedded in the output\n *                                                   CSS as a base64-encoded\n *                                                   comment.\n * @property {string|object|false|function} map.prev Source map content\n *                                                   from a previous\n *                                                   processing step\n *                                                   (for example, Sass).\n *                                                   PostCSS will try to find\n *                                                   previous map automatically,\n *                                                   so you could disable it by\n *                                                   `false` value.\n * @property {boolean} map.sourcesContent            Does PostCSS should set\n *                                                   the origin content to map.\n * @property {string|false} map.annotation           Does PostCSS should set\n *                                                   annotation comment to map.\n * @property {string} map.from                       Override `from` in maps\n *                                                   sources`.\n */exports[\"default\"]=_default;module.exports=exports[\"default\"];}).call(this,require('_process'));},{\"./lazy-result\":174,\"_process\":192}],183:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _warning=_interopRequireDefault(require(\"./warning\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}/**\n * Provides the result of the PostCSS transformations.\n *\n * A Result instance is returned by {@link LazyResult#then}\n * or {@link Root#toResult} methods.\n *\n * @example\n * postcss([autoprefixer]).process(css).then(result => {\n *  console.log(result.css)\n * })\n *\n * @example\n * const result2 = postcss.parse(css).toResult()\n */var Result=/*#__PURE__*/function(){/**\n   * @param {Processor} processor Processor used for this transformation.\n   * @param {Root}      root      Root node after all transformations.\n   * @param {processOptions} opts Options from the {@link Processor#process}\n   *                              or {@link Root#toResult}.\n   */function Result(processor,root,opts){/**\n     * The Processor instance used for this transformation.\n     *\n     * @type {Processor}\n     *\n     * @example\n     * for (const plugin of result.processor.plugins) {\n     *   if (plugin.postcssPlugin === 'postcss-bad') {\n     *     throw 'postcss-good is incompatible with postcss-bad'\n     *   }\n     * })\n     */this.processor=processor;/**\n     * Contains messages from plugins (e.g., warnings or custom messages).\n     * Each message should have type and plugin properties.\n     *\n     * @type {Message[]}\n     *\n     * @example\n     * postcss.plugin('postcss-min-browser', () => {\n     *   return (root, result) => {\n     *     const browsers = detectMinBrowsersByCanIUse(root)\n     *     result.messages.push({\n     *       type: 'min-browser',\n     *       plugin: 'postcss-min-browser',\n     *       browsers\n     *     })\n     *   }\n     * })\n     */this.messages=[];/**\n     * Root node after all transformations.\n     *\n     * @type {Root}\n     *\n     * @example\n     * root.toResult().root === root\n     */this.root=root;/**\n     * Options from the {@link Processor#process} or {@link Root#toResult} call\n     * that produced this Result instance.\n     *\n     * @type {processOptions}\n     *\n     * @example\n     * root.toResult(opts).opts === opts\n     */this.opts=opts;/**\n     * A CSS string representing of {@link Result#root}.\n     *\n     * @type {string}\n     *\n     * @example\n     * postcss.parse('a{}').toResult().css //=> \"a{}\"\n     */this.css=undefined;/**\n     * An instance of `SourceMapGenerator` class from the `source-map` library,\n     * representing changes to the {@link Result#root} instance.\n     *\n     * @type {SourceMapGenerator}\n     *\n     * @example\n     * result.map.toJSON() //=> { version: 3, file: 'a.css',  }\n     *\n     * @example\n     * if (result.map) {\n     *   fs.writeFileSync(result.opts.to + '.map', result.map.toString())\n     * }\n     */this.map=undefined;}/**\n   * Returns for @{link Result#css} content.\n   *\n   * @example\n   * result + '' === result.css\n   *\n   * @return {string} String representing of {@link Result#root}.\n   */var _proto=Result.prototype;_proto.toString=function toString(){return this.css;}/**\n   * Creates an instance of {@link Warning} and adds it\n   * to {@link Result#messages}.\n   *\n   * @param {string} text        Warning message.\n   * @param {Object} [opts]      Warning options.\n   * @param {Node}   opts.node   CSS node that caused the warning.\n   * @param {string} opts.word   Word in CSS source that caused the warning.\n   * @param {number} opts.index  Index in CSS node string that caused\n   *                             the warning.\n   * @param {string} opts.plugin Name of the plugin that created\n   *                             this warning. {@link Result#warn} fills\n   *                             this property automatically.\n   *\n   * @return {Warning} Created warning.\n   */;_proto.warn=function warn(text,opts){if(opts===void 0){opts={};}if(!opts.plugin){if(this.lastPlugin&&this.lastPlugin.postcssPlugin){opts.plugin=this.lastPlugin.postcssPlugin;}}var warning=new _warning[\"default\"](text,opts);this.messages.push(warning);return warning;}/**\n     * Returns warnings from plugins. Filters {@link Warning} instances\n     * from {@link Result#messages}.\n     *\n     * @example\n     * result.warnings().forEach(warn => {\n     *   console.warn(warn.toString())\n     * })\n     *\n     * @return {Warning[]} Warnings from plugins.\n     */;_proto.warnings=function warnings(){return this.messages.filter(function(i){return i.type==='warning';});}/**\n   * An alias for the {@link Result#css} property.\n   * Use it with syntaxes that generate non-CSS output.\n   *\n   * @type {string}\n   *\n   * @example\n   * result.css === result.content\n   */;_createClass(Result,[{key:\"content\",get:function get(){return this.css;}}]);return Result;}();var _default=Result;/**\n * @typedef  {object} Message\n * @property {string} type   Message type.\n * @property {string} plugin Source PostCSS plugin name.\n */exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./warning\":191}],184:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _container=_interopRequireDefault(require(\"./container\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**\n * Represents a CSS file and contains all its parsed nodes.\n *\n * @extends Container\n *\n * @example\n * const root = postcss.parse('a{color:black} b{z-index:2}')\n * root.type         //=> 'root'\n * root.nodes.length //=> 2\n */var Root=/*#__PURE__*/function(_Container){_inheritsLoose(Root,_Container);function Root(defaults){var _this;_this=_Container.call(this,defaults)||this;_this.type='root';if(!_this.nodes)_this.nodes=[];return _this;}var _proto=Root.prototype;_proto.removeChild=function removeChild(child,ignore){var index=this.index(child);if(!ignore&&index===0&&this.nodes.length>1){this.nodes[1].raws.before=this.nodes[index].raws.before;}return _Container.prototype.removeChild.call(this,child);};_proto.normalize=function normalize(child,sample,type){var nodes=_Container.prototype.normalize.call(this,child);if(sample){if(type==='prepend'){if(this.nodes.length>1){sample.raws.before=this.nodes[1].raws.before;}else{delete sample.raws.before;}}else if(this.first!==sample){for(var _iterator=nodes,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var node=_ref;node.raws.before=sample.raws.before;}}}return nodes;}/**\n   * Returns a {@link Result} instance representing the roots CSS.\n   *\n   * @param {processOptions} [opts] Options with only `to` and `map` keys.\n   *\n   * @return {Result} Result with current roots CSS.\n   *\n   * @example\n   * const root1 = postcss.parse(css1, { from: 'a.css' })\n   * const root2 = postcss.parse(css2, { from: 'b.css' })\n   * root1.append(root2)\n   * const result = root1.toResult({ to: 'all.css', map: true })\n   */;_proto.toResult=function toResult(opts){if(opts===void 0){opts={};}var LazyResult=require('./lazy-result');var Processor=require('./processor');var lazy=new LazyResult(new Processor(),this,opts);return lazy.stringify();}/**\n   * @memberof Root#\n   * @member {object} raws Information to generate byte-to-byte equal\n   *                       node string as it was in the origin input.\n   *\n   * Every parser saves its own properties,\n   * but the default CSS parser uses:\n   *\n   * * `after`: the space symbols after the last child to the end of file.\n   * * `semicolon`: is the last child has an (optional) semicolon.\n   *\n   * @example\n   * postcss.parse('a {}\\n').raws //=> { after: '\\n' }\n   * postcss.parse('a {}').raws   //=> { after: '' }\n   */;return Root;}(_container[\"default\"]);var _default=Root;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./container\":170,\"./lazy-result\":174,\"./processor\":182}],185:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _container=_interopRequireDefault(require(\"./container\"));var _list=_interopRequireDefault(require(\"./list\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**\n * Represents a CSS rule: a selector followed by a declaration block.\n *\n * @extends Container\n *\n * @example\n * const root = postcss.parse('a{}')\n * const rule = root.first\n * rule.type       //=> 'rule'\n * rule.toString() //=> 'a{}'\n */var Rule=/*#__PURE__*/function(_Container){_inheritsLoose(Rule,_Container);function Rule(defaults){var _this;_this=_Container.call(this,defaults)||this;_this.type='rule';if(!_this.nodes)_this.nodes=[];return _this;}/**\n   * An array containing the rules individual selectors.\n   * Groups of selectors are split at commas.\n   *\n   * @type {string[]}\n   *\n   * @example\n   * const root = postcss.parse('a, b { }')\n   * const rule = root.first\n   *\n   * rule.selector  //=> 'a, b'\n   * rule.selectors //=> ['a', 'b']\n   *\n   * rule.selectors = ['a', 'strong']\n   * rule.selector //=> 'a, strong'\n   */_createClass(Rule,[{key:\"selectors\",get:function get(){return _list[\"default\"].comma(this.selector);},set:function set(values){var match=this.selector?this.selector.match(/,\\s*/):null;var sep=match?match[0]:','+this.raw('between','beforeOpen');this.selector=values.join(sep);}/**\n     * @memberof Rule#\n     * @member {string} selector The rules full selector represented\n     *                           as a string.\n     *\n     * @example\n     * const root = postcss.parse('a, b { }')\n     * const rule = root.first\n     * rule.selector //=> 'a, b'\n     */ /**\n     * @memberof Rule#\n     * @member {object} raws Information to generate byte-to-byte equal\n     *                       node string as it was in the origin input.\n     *\n     * Every parser saves its own properties,\n     * but the default CSS parser uses:\n     *\n     * * `before`: the space symbols before the node. It also stores `*`\n     *   and `_` symbols before the declaration (IE hack).\n     * * `after`: the space symbols after the last child of the node\n     *   to the end of the node.\n     * * `between`: the symbols between the property and value\n     *   for declarations, selector and `{` for rules, or last parameter\n     *   and `{` for at-rules.\n     * * `semicolon`: contains `true` if the last child has\n     *   an (optional) semicolon.\n     * * `ownSemicolon`: contains `true` if there is semicolon after rule.\n     *\n     * PostCSS cleans selectors from comments and extra spaces,\n     * but it stores origin content in raws properties.\n     * As such, if you dont change a declarations value,\n     * PostCSS will use the raw value with comments.\n     *\n     * @example\n     * const root = postcss.parse('a {\\n  color:black\\n}')\n     * root.first.first.raws //=> { before: '', between: ' ', after: '\\n' }\n     */}]);return Rule;}(_container[\"default\"]);var _default=Rule;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./container\":170,\"./list\":175}],186:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var DEFAULT_RAW={colon:': ',indent:'    ',beforeDecl:'\\n',beforeRule:'\\n',beforeOpen:' ',beforeClose:'\\n',beforeComment:'\\n',after:'\\n',emptyBody:'',commentLeft:' ',commentRight:' ',semicolon:false};function capitalize(str){return str[0].toUpperCase()+str.slice(1);}var Stringifier=/*#__PURE__*/function(){function Stringifier(builder){this.builder=builder;}var _proto=Stringifier.prototype;_proto.stringify=function stringify(node,semicolon){this[node.type](node,semicolon);};_proto.root=function root(node){this.body(node);if(node.raws.after)this.builder(node.raws.after);};_proto.comment=function comment(node){var left=this.raw(node,'left','commentLeft');var right=this.raw(node,'right','commentRight');this.builder('/*'+left+node.text+right+'*/',node);};_proto.decl=function decl(node,semicolon){var between=this.raw(node,'between','colon');var string=node.prop+between+this.rawValue(node,'value');if(node.important){string+=node.raws.important||' !important';}if(semicolon)string+=';';this.builder(string,node);};_proto.rule=function rule(node){this.block(node,this.rawValue(node,'selector'));if(node.raws.ownSemicolon){this.builder(node.raws.ownSemicolon,node,'end');}};_proto.atrule=function atrule(node,semicolon){var name='@'+node.name;var params=node.params?this.rawValue(node,'params'):'';if(typeof node.raws.afterName!=='undefined'){name+=node.raws.afterName;}else if(params){name+=' ';}if(node.nodes){this.block(node,name+params);}else{var end=(node.raws.between||'')+(semicolon?';':'');this.builder(name+params+end,node);}};_proto.body=function body(node){var last=node.nodes.length-1;while(last>0){if(node.nodes[last].type!=='comment')break;last-=1;}var semicolon=this.raw(node,'semicolon');for(var i=0;i<node.nodes.length;i++){var child=node.nodes[i];var before=this.raw(child,'before');if(before)this.builder(before);this.stringify(child,last!==i||semicolon);}};_proto.block=function block(node,start){var between=this.raw(node,'between','beforeOpen');this.builder(start+between+'{',node,'start');var after;if(node.nodes&&node.nodes.length){this.body(node);after=this.raw(node,'after');}else{after=this.raw(node,'after','emptyBody');}if(after)this.builder(after);this.builder('}',node,'end');};_proto.raw=function raw(node,own,detect){var value;if(!detect)detect=own;// Already had\nif(own){value=node.raws[own];if(typeof value!=='undefined')return value;}var parent=node.parent;// Hack for first rule in CSS\nif(detect==='before'){if(!parent||parent.type==='root'&&parent.first===node){return'';}}// Floating child without parent\nif(!parent)return DEFAULT_RAW[detect];// Detect style by other nodes\nvar root=node.root();if(!root.rawCache)root.rawCache={};if(typeof root.rawCache[detect]!=='undefined'){return root.rawCache[detect];}if(detect==='before'||detect==='after'){return this.beforeAfter(node,detect);}else{var method='raw'+capitalize(detect);if(this[method]){value=this[method](root,node);}else{root.walk(function(i){value=i.raws[own];if(typeof value!=='undefined')return false;});}}if(typeof value==='undefined')value=DEFAULT_RAW[detect];root.rawCache[detect]=value;return value;};_proto.rawSemicolon=function rawSemicolon(root){var value;root.walk(function(i){if(i.nodes&&i.nodes.length&&i.last.type==='decl'){value=i.raws.semicolon;if(typeof value!=='undefined')return false;}});return value;};_proto.rawEmptyBody=function rawEmptyBody(root){var value;root.walk(function(i){if(i.nodes&&i.nodes.length===0){value=i.raws.after;if(typeof value!=='undefined')return false;}});return value;};_proto.rawIndent=function rawIndent(root){if(root.raws.indent)return root.raws.indent;var value;root.walk(function(i){var p=i.parent;if(p&&p!==root&&p.parent&&p.parent===root){if(typeof i.raws.before!=='undefined'){var parts=i.raws.before.split('\\n');value=parts[parts.length-1];value=value.replace(/[^\\s]/g,'');return false;}}});return value;};_proto.rawBeforeComment=function rawBeforeComment(root,node){var value;root.walkComments(function(i){if(typeof i.raws.before!=='undefined'){value=i.raws.before;if(value.indexOf('\\n')!==-1){value=value.replace(/[^\\n]+$/,'');}return false;}});if(typeof value==='undefined'){value=this.raw(node,null,'beforeDecl');}else if(value){value=value.replace(/[^\\s]/g,'');}return value;};_proto.rawBeforeDecl=function rawBeforeDecl(root,node){var value;root.walkDecls(function(i){if(typeof i.raws.before!=='undefined'){value=i.raws.before;if(value.indexOf('\\n')!==-1){value=value.replace(/[^\\n]+$/,'');}return false;}});if(typeof value==='undefined'){value=this.raw(node,null,'beforeRule');}else if(value){value=value.replace(/[^\\s]/g,'');}return value;};_proto.rawBeforeRule=function rawBeforeRule(root){var value;root.walk(function(i){if(i.nodes&&(i.parent!==root||root.first!==i)){if(typeof i.raws.before!=='undefined'){value=i.raws.before;if(value.indexOf('\\n')!==-1){value=value.replace(/[^\\n]+$/,'');}return false;}}});if(value)value=value.replace(/[^\\s]/g,'');return value;};_proto.rawBeforeClose=function rawBeforeClose(root){var value;root.walk(function(i){if(i.nodes&&i.nodes.length>0){if(typeof i.raws.after!=='undefined'){value=i.raws.after;if(value.indexOf('\\n')!==-1){value=value.replace(/[^\\n]+$/,'');}return false;}}});if(value)value=value.replace(/[^\\s]/g,'');return value;};_proto.rawBeforeOpen=function rawBeforeOpen(root){var value;root.walk(function(i){if(i.type!=='decl'){value=i.raws.between;if(typeof value!=='undefined')return false;}});return value;};_proto.rawColon=function rawColon(root){var value;root.walkDecls(function(i){if(typeof i.raws.between!=='undefined'){value=i.raws.between.replace(/[^\\s:]/g,'');return false;}});return value;};_proto.beforeAfter=function beforeAfter(node,detect){var value;if(node.type==='decl'){value=this.raw(node,null,'beforeDecl');}else if(node.type==='comment'){value=this.raw(node,null,'beforeComment');}else if(detect==='before'){value=this.raw(node,null,'beforeRule');}else{value=this.raw(node,null,'beforeClose');}var buf=node.parent;var depth=0;while(buf&&buf.type!=='root'){depth+=1;buf=buf.parent;}if(value.indexOf('\\n')!==-1){var indent=this.raw(node,null,'indent');if(indent.length){for(var step=0;step<depth;step++){value+=indent;}}}return value;};_proto.rawValue=function rawValue(node,prop){var value=node[prop];var raw=node.raws[prop];if(raw&&raw.value===value){return raw.raw;}return value;};return Stringifier;}();var _default=Stringifier;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{}],187:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _stringifier=_interopRequireDefault(require(\"./stringifier\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}function stringify(node,builder){var str=new _stringifier[\"default\"](builder);str.stringify(node);}var _default=stringify;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{\"./stringifier\":186}],188:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=tokenizer;var SINGLE_QUOTE='\\''.charCodeAt(0);var DOUBLE_QUOTE='\"'.charCodeAt(0);var BACKSLASH='\\\\'.charCodeAt(0);var SLASH='/'.charCodeAt(0);var NEWLINE='\\n'.charCodeAt(0);var SPACE=' '.charCodeAt(0);var FEED='\\f'.charCodeAt(0);var TAB='\\t'.charCodeAt(0);var CR='\\r'.charCodeAt(0);var OPEN_SQUARE='['.charCodeAt(0);var CLOSE_SQUARE=']'.charCodeAt(0);var OPEN_PARENTHESES='('.charCodeAt(0);var CLOSE_PARENTHESES=')'.charCodeAt(0);var OPEN_CURLY='{'.charCodeAt(0);var CLOSE_CURLY='}'.charCodeAt(0);var SEMICOLON=';'.charCodeAt(0);var ASTERISK='*'.charCodeAt(0);var COLON=':'.charCodeAt(0);var AT='@'.charCodeAt(0);var RE_AT_END=/[ \\n\\t\\r\\f{}()'\"\\\\;/[\\]#]/g;var RE_WORD_END=/[ \\n\\t\\r\\f(){}:;@!'\"\\\\\\][#]|\\/(?=\\*)/g;var RE_BAD_BRACKET=/.[\\\\/(\"'\\n]/;var RE_HEX_ESCAPE=/[a-f0-9]/i;function tokenizer(input,options){if(options===void 0){options={};}var css=input.css.valueOf();var ignore=options.ignoreErrors;var code,next,quote,lines,last,content,escape;var nextLine,nextOffset,escaped,escapePos,prev,n,currentToken;var length=css.length;var offset=-1;var line=1;var pos=0;var buffer=[];var returned=[];function position(){return pos;}function unclosed(what){throw input.error('Unclosed '+what,line,pos-offset);}function endOfFile(){return returned.length===0&&pos>=length;}function nextToken(opts){if(returned.length)return returned.pop();if(pos>=length)return;var ignoreUnclosed=opts?opts.ignoreUnclosed:false;code=css.charCodeAt(pos);if(code===NEWLINE||code===FEED||code===CR&&css.charCodeAt(pos+1)!==NEWLINE){offset=pos;line+=1;}switch(code){case NEWLINE:case SPACE:case TAB:case CR:case FEED:next=pos;do{next+=1;code=css.charCodeAt(next);if(code===NEWLINE){offset=next;line+=1;}}while(code===SPACE||code===NEWLINE||code===TAB||code===CR||code===FEED);currentToken=['space',css.slice(pos,next)];pos=next-1;break;case OPEN_SQUARE:case CLOSE_SQUARE:case OPEN_CURLY:case CLOSE_CURLY:case COLON:case SEMICOLON:case CLOSE_PARENTHESES:var controlChar=String.fromCharCode(code);currentToken=[controlChar,controlChar,line,pos-offset];break;case OPEN_PARENTHESES:prev=buffer.length?buffer.pop()[1]:'';n=css.charCodeAt(pos+1);if(prev==='url'&&n!==SINGLE_QUOTE&&n!==DOUBLE_QUOTE&&n!==SPACE&&n!==NEWLINE&&n!==TAB&&n!==FEED&&n!==CR){next=pos;do{escaped=false;next=css.indexOf(')',next+1);if(next===-1){if(ignore||ignoreUnclosed){next=pos;break;}else{unclosed('bracket');}}escapePos=next;while(css.charCodeAt(escapePos-1)===BACKSLASH){escapePos-=1;escaped=!escaped;}}while(escaped);currentToken=['brackets',css.slice(pos,next+1),line,pos-offset,line,next-offset];pos=next;}else{next=css.indexOf(')',pos+1);content=css.slice(pos,next+1);if(next===-1||RE_BAD_BRACKET.test(content)){currentToken=['(','(',line,pos-offset];}else{currentToken=['brackets',content,line,pos-offset,line,next-offset];pos=next;}}break;case SINGLE_QUOTE:case DOUBLE_QUOTE:quote=code===SINGLE_QUOTE?'\\'':'\"';next=pos;do{escaped=false;next=css.indexOf(quote,next+1);if(next===-1){if(ignore||ignoreUnclosed){next=pos+1;break;}else{unclosed('string');}}escapePos=next;while(css.charCodeAt(escapePos-1)===BACKSLASH){escapePos-=1;escaped=!escaped;}}while(escaped);content=css.slice(pos,next+1);lines=content.split('\\n');last=lines.length-1;if(last>0){nextLine=line+last;nextOffset=next-lines[last].length;}else{nextLine=line;nextOffset=offset;}currentToken=['string',css.slice(pos,next+1),line,pos-offset,nextLine,next-nextOffset];offset=nextOffset;line=nextLine;pos=next;break;case AT:RE_AT_END.lastIndex=pos+1;RE_AT_END.test(css);if(RE_AT_END.lastIndex===0){next=css.length-1;}else{next=RE_AT_END.lastIndex-2;}currentToken=['at-word',css.slice(pos,next+1),line,pos-offset,line,next-offset];pos=next;break;case BACKSLASH:next=pos;escape=true;while(css.charCodeAt(next+1)===BACKSLASH){next+=1;escape=!escape;}code=css.charCodeAt(next+1);if(escape&&code!==SLASH&&code!==SPACE&&code!==NEWLINE&&code!==TAB&&code!==CR&&code!==FEED){next+=1;if(RE_HEX_ESCAPE.test(css.charAt(next))){while(RE_HEX_ESCAPE.test(css.charAt(next+1))){next+=1;}if(css.charCodeAt(next+1)===SPACE){next+=1;}}}currentToken=['word',css.slice(pos,next+1),line,pos-offset,line,next-offset];pos=next;break;default:if(code===SLASH&&css.charCodeAt(pos+1)===ASTERISK){next=css.indexOf('*/',pos+2)+1;if(next===0){if(ignore||ignoreUnclosed){next=css.length;}else{unclosed('comment');}}content=css.slice(pos,next+1);lines=content.split('\\n');last=lines.length-1;if(last>0){nextLine=line+last;nextOffset=next-lines[last].length;}else{nextLine=line;nextOffset=offset;}currentToken=['comment',content,line,pos-offset,nextLine,next-nextOffset];offset=nextOffset;line=nextLine;pos=next;}else{RE_WORD_END.lastIndex=pos+1;RE_WORD_END.test(css);if(RE_WORD_END.lastIndex===0){next=css.length-1;}else{next=RE_WORD_END.lastIndex-2;}currentToken=['word',css.slice(pos,next+1),line,pos-offset,line,next-offset];buffer.push(currentToken);pos=next;}break;}pos++;return currentToken;}function back(token){returned.push(token);}return{back:back,nextToken:nextToken,endOfFile:endOfFile,position:position};}module.exports=exports[\"default\"];},{}],189:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;/**\n * Contains helpers for working with vendor prefixes.\n *\n * @example\n * const vendor = postcss.vendor\n *\n * @namespace vendor\n */var vendor={/**\n   * Returns the vendor prefix extracted from an input string.\n   *\n   * @param {string} prop String with or without vendor prefix.\n   *\n   * @return {string} vendor prefix or empty string\n   *\n   * @example\n   * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'\n   * postcss.vendor.prefix('tab-size')      //=> ''\n   */prefix:function prefix(prop){var match=prop.match(/^(-\\w+-)/);if(match){return match[0];}return'';},/**\n     * Returns the input string stripped of its vendor prefix.\n     *\n     * @param {string} prop String with or without vendor prefix.\n     *\n     * @return {string} String name without vendor prefixes.\n     *\n     * @example\n     * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'\n     */unprefixed:function unprefixed(prop){return prop.replace(/^-\\w+-/,'');}};var _default=vendor;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{}],190:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=warnOnce;var printed={};function warnOnce(message){if(printed[message])return;printed[message]=true;if(typeof console!=='undefined'&&console.warn){console.warn(message);}}module.exports=exports[\"default\"];},{}],191:[function(require,module,exports){\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;/**\n * Represents a plugins warning. It can be created using {@link Node#warn}.\n *\n * @example\n * if (decl.important) {\n *   decl.warn(result, 'Avoid !important', { word: '!important' })\n * }\n */var Warning=/*#__PURE__*/function(){/**\n   * @param {string} text        Warning message.\n   * @param {Object} [opts]      Warning options.\n   * @param {Node}   opts.node   CSS node that caused the warning.\n   * @param {string} opts.word   Word in CSS source that caused the warning.\n   * @param {number} opts.index  Index in CSS node string that caused\n   *                             the warning.\n   * @param {string} opts.plugin Name of the plugin that created\n   *                             this warning. {@link Result#warn} fills\n   *                             this property automatically.\n   */function Warning(text,opts){if(opts===void 0){opts={};}/**\n     * Type to filter warnings from {@link Result#messages}.\n     * Always equal to `\"warning\"`.\n     *\n     * @type {string}\n     *\n     * @example\n     * const nonWarning = result.messages.filter(i => i.type !== 'warning')\n     */this.type='warning';/**\n     * The warning message.\n     *\n     * @type {string}\n     *\n     * @example\n     * warning.text //=> 'Try to avoid !important'\n     */this.text=text;if(opts.node&&opts.node.source){var pos=opts.node.positionBy(opts);/**\n       * Line in the input file with this warnings source.\n       * @type {number}\n       *\n       * @example\n       * warning.line //=> 5\n       */this.line=pos.line;/**\n       * Column in the input file with this warnings source.\n       *\n       * @type {number}\n       *\n       * @example\n       * warning.column //=> 6\n       */this.column=pos.column;}for(var opt in opts){this[opt]=opts[opt];}}/**\n   * Returns a warning position and message.\n   *\n   * @example\n   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'\n   *\n   * @return {string} Warning position and message.\n   */var _proto=Warning.prototype;_proto.toString=function toString(){if(this.node){return this.node.error(this.text,{plugin:this.plugin,index:this.index,word:this.word}).message;}if(this.plugin){return this.plugin+': '+this.text;}return this.text;}/**\n   * @memberof Warning#\n   * @member {string} plugin The name of the plugin that created\n   *                         it will fill this property automatically.\n   *                         this warning. When you call {@link Node#warn}\n   *\n   * @example\n   * warning.plugin //=> 'postcss-important'\n   */ /**\n   * @memberof Warning#\n   * @member {Node} node Contains the CSS node that caused the warning.\n   *\n   * @example\n   * warning.node.toString() //=> 'color: white !important'\n   */;return Warning;}();var _default=Warning;exports[\"default\"]=_default;module.exports=exports[\"default\"];},{}],192:[function(require,module,exports){// shim for using process in browser\nvar process=module.exports={};// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error('setTimeout has not been defined');}function defaultClearTimeout(){throw new Error('clearTimeout has not been defined');}(function(){try{if(typeof setTimeout==='function'){cachedSetTimeout=setTimeout;}else{cachedSetTimeout=defaultSetTimout;}}catch(e){cachedSetTimeout=defaultSetTimout;}try{if(typeof clearTimeout==='function'){cachedClearTimeout=clearTimeout;}else{cachedClearTimeout=defaultClearTimeout;}}catch(e){cachedClearTimeout=defaultClearTimeout;}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){//normal enviroments in sane situations\nreturn setTimeout(fun,0);}// if setTimeout wasn't available but was latter defined\nif((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0);}try{// when when somebody has screwed with setTimeout but no I.E. maddness\nreturn cachedSetTimeout(fun,0);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\nreturn cachedSetTimeout.call(null,fun,0);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\nreturn cachedSetTimeout.call(this,fun,0);}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){//normal enviroments in sane situations\nreturn clearTimeout(marker);}// if clearTimeout wasn't available but was latter defined\nif((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker);}try{// when when somebody has screwed with setTimeout but no I.E. maddness\nreturn cachedClearTimeout(marker);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\nreturn cachedClearTimeout.call(null,marker);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n// Some versions of I.E. have different rules for clearTimeout vs setTimeout\nreturn cachedClearTimeout.call(this,marker);}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return;}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue);}else{queueIndex=-1;}if(queue.length){drainQueue();}}function drainQueue(){if(draining){return;}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run();}}queueIndex=-1;len=queue.length;}currentQueue=null;draining=false;runClearTimeout(timeout);}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue);}};// v8 likes predictible objects\nfunction Item(fun,array){this.fun=fun;this.array=array;}Item.prototype.run=function(){this.fun.apply(null,this.array);};process.title='browser';process.browser=true;process.env={};process.argv=[];process.version='';// empty string to avoid regexp issues\nprocess.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(name){return[];};process.binding=function(name){throw new Error('process.binding is not supported');};process.cwd=function(){return'/';};process.chdir=function(dir){throw new Error('process.chdir is not supported');};process.umask=function(){return 0;};},{}],193:[function(require,module,exports){(function(global){/*! https://mths.be/punycode v1.4.1 by @mathias */;(function(root){/** Detect free variables */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;var freeModule=_typeof(module)=='object'&&module&&!module.nodeType&&module;var freeGlobal=_typeof(global)=='object'&&global;if(freeGlobal.global===freeGlobal||freeGlobal.window===freeGlobal||freeGlobal.self===freeGlobal){root=freeGlobal;}/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */var punycode,/** Highest positive signed 32-bit float value */maxInt=2147483647,// aka. 0x7FFFFFFF or 2^31-1\n/** Bootstring parameters */base=36,tMin=1,tMax=26,skew=38,damp=700,initialBias=72,initialN=128,// 0x80\ndelimiter='-',// '\\x2D'\n/** Regular expressions */regexPunycode=/^xn--/,regexNonASCII=/[^\\x20-\\x7E]/,// unprintable ASCII chars + non-ASCII chars\nregexSeparators=/[\\x2E\\u3002\\uFF0E\\uFF61]/g,// RFC 3490 separators\n/** Error messages */errors={'overflow':'Overflow: input needs wider integers to process','not-basic':'Illegal input >= 0x80 (not a basic code point)','invalid-input':'Invalid input'},/** Convenience shortcuts */baseMinusTMin=base-tMin,floor=Math.floor,stringFromCharCode=String.fromCharCode,/** Temporary variable */key;/*--------------------------------------------------------------------------*/ /**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */function error(type){throw new RangeError(errors[type]);}/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */function map(array,fn){var length=array.length;var result=[];while(length--){result[length]=fn(array[length]);}return result;}/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */function mapDomain(string,fn){var parts=string.split('@');var result='';if(parts.length>1){// In email addresses, only the domain name should be punycoded. Leave\n// the local part (i.e. everything up to `@`) intact.\nresult=parts[0]+'@';string=parts[1];}// Avoid `split(regex)` for IE8 compatibility. See #17.\nstring=string.replace(regexSeparators,'\\x2E');var labels=string.split('.');var encoded=map(labels,fn).join('.');return result+encoded;}/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */function ucs2decode(string){var output=[],counter=0,length=string.length,value,extra;while(counter<length){value=string.charCodeAt(counter++);if(value>=0xD800&&value<=0xDBFF&&counter<length){// high surrogate, and there is a next character\nextra=string.charCodeAt(counter++);if((extra&0xFC00)==0xDC00){// low surrogate\noutput.push(((value&0x3FF)<<10)+(extra&0x3FF)+0x10000);}else{// unmatched surrogate; only append this code unit, in case the next\n// code unit is the high surrogate of a surrogate pair\noutput.push(value);counter--;}}else{output.push(value);}}return output;}/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */function ucs2encode(array){return map(array,function(value){var output='';if(value>0xFFFF){value-=0x10000;output+=stringFromCharCode(value>>>10&0x3FF|0xD800);value=0xDC00|value&0x3FF;}output+=stringFromCharCode(value);return output;}).join('');}/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */function basicToDigit(codePoint){if(codePoint-48<10){return codePoint-22;}if(codePoint-65<26){return codePoint-65;}if(codePoint-97<26){return codePoint-97;}return base;}/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */function digitToBasic(digit,flag){//  0..25 map to ASCII a..z or A..Z\n// 26..35 map to ASCII 0..9\nreturn digit+22+75*(digit<26)-((flag!=0)<<5);}/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */function adapt(delta,numPoints,firstTime){var k=0;delta=firstTime?floor(delta/damp):delta>>1;delta+=floor(delta/numPoints);for(;/* no initialization */delta>baseMinusTMin*tMax>>1;k+=base){delta=floor(delta/baseMinusTMin);}return floor(k+(baseMinusTMin+1)*delta/(delta+skew));}/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */function decode(input){// Don't use UCS-2\nvar output=[],inputLength=input.length,out,i=0,n=initialN,bias=initialBias,basic,j,index,oldi,w,k,digit,t,/** Cached calculation results */baseMinusT;// Handle the basic code points: let `basic` be the number of input code\n// points before the last delimiter, or `0` if there is none, then copy\n// the first basic code points to the output.\nbasic=input.lastIndexOf(delimiter);if(basic<0){basic=0;}for(j=0;j<basic;++j){// if it's not a basic code point\nif(input.charCodeAt(j)>=0x80){error('not-basic');}output.push(input.charCodeAt(j));}// Main decoding loop: start just after the last delimiter if any basic code\n// points were copied; start at the beginning otherwise.\nfor(index=basic>0?basic+1:0;index<inputLength;)/* no final expression */{// `index` is the index of the next character to be consumed.\n// Decode a generalized variable-length integer into `delta`,\n// which gets added to `i`. The overflow checking is easier\n// if we increase `i` as we go, then subtract off its starting\n// value at the end to obtain `delta`.\nfor(oldi=i,w=1,k=base;;/* no condition */k+=base){if(index>=inputLength){error('invalid-input');}digit=basicToDigit(input.charCodeAt(index++));if(digit>=base||digit>floor((maxInt-i)/w)){error('overflow');}i+=digit*w;t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(digit<t){break;}baseMinusT=base-t;if(w>floor(maxInt/baseMinusT)){error('overflow');}w*=baseMinusT;}out=output.length+1;bias=adapt(i-oldi,out,oldi==0);// `i` was supposed to wrap around from `out` to `0`,\n// incrementing `n` each time, so we'll fix that now:\nif(floor(i/out)>maxInt-n){error('overflow');}n+=floor(i/out);i%=out;// Insert `n` at position `i` of the output\noutput.splice(i++,0,n);}return ucs2encode(output);}/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */function encode(input){var n,delta,handledCPCount,basicLength,bias,j,m,q,k,t,currentValue,output=[],/** `inputLength` will hold the number of code points in `input`. */inputLength,/** Cached calculation results */handledCPCountPlusOne,baseMinusT,qMinusT;// Convert the input in UCS-2 to Unicode\ninput=ucs2decode(input);// Cache the length\ninputLength=input.length;// Initialize the state\nn=initialN;delta=0;bias=initialBias;// Handle the basic code points\nfor(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<0x80){output.push(stringFromCharCode(currentValue));}}handledCPCount=basicLength=output.length;// `handledCPCount` is the number of code points that have been handled;\n// `basicLength` is the number of basic code points.\n// Finish the basic string - if it is not empty - with a delimiter\nif(basicLength){output.push(delimiter);}// Main encoding loop:\nwhile(handledCPCount<inputLength){// All non-basic code points < n have been handled already. Find the next\n// larger one:\nfor(m=maxInt,j=0;j<inputLength;++j){currentValue=input[j];if(currentValue>=n&&currentValue<m){m=currentValue;}}// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n// but guard against overflow\nhandledCPCountPlusOne=handledCPCount+1;if(m-n>floor((maxInt-delta)/handledCPCountPlusOne)){error('overflow');}delta+=(m-n)*handledCPCountPlusOne;n=m;for(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<n&&++delta>maxInt){error('overflow');}if(currentValue==n){// Represent delta as a generalized variable-length integer\nfor(q=delta,k=base;;/* no condition */k+=base){t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(q<t){break;}qMinusT=q-t;baseMinusT=base-t;output.push(stringFromCharCode(digitToBasic(t+qMinusT%baseMinusT,0)));q=floor(qMinusT/baseMinusT);}output.push(stringFromCharCode(digitToBasic(q,0)));bias=adapt(delta,handledCPCountPlusOne,handledCPCount==basicLength);delta=0;++handledCPCount;}}++delta;++n;}return output.join('');}/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */function toUnicode(input){return mapDomain(input,function(string){return regexPunycode.test(string)?decode(string.slice(4).toLowerCase()):string;});}/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */function toASCII(input){return mapDomain(input,function(string){return regexNonASCII.test(string)?'xn--'+encode(string):string;});}/*--------------------------------------------------------------------------*/ /** Define the public API */punycode={/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */'version':'1.4.1',/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */'ucs2':{'decode':ucs2decode,'encode':ucs2encode},'decode':decode,'encode':encode,'toASCII':toASCII,'toUnicode':toUnicode};/** Expose `punycode` */ // Some AMD build optimizers, like r.js, check for specific condition patterns\n// like the following:\nif(typeof define=='function'&&_typeof(define.amd)=='object'&&define.amd){define('punycode',function(){return punycode;});}else if(freeExports&&freeModule){if(module.exports==freeExports){// in Node.js, io.js, or RingoJS v0.8.0+\nfreeModule.exports=punycode;}else{// in Narwhal or RingoJS v0.7.0-\nfor(key in punycode){punycode.hasOwnProperty(key)&&(freeExports[key]=punycode[key]);}}}else{// in Rhino or a web browser\nroot.punycode=punycode;}})(this);}).call(this,typeof global!==\"undefined\"?global:typeof self!==\"undefined\"?self:typeof window!==\"undefined\"?window:{});},{}],194:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop);}module.exports=function(qs,sep,eq,options){sep=sep||'&';eq=eq||'=';var obj={};if(typeof qs!=='string'||qs.length===0){return obj;}var regexp=/\\+/g;qs=qs.split(sep);var maxKeys=1000;if(options&&typeof options.maxKeys==='number'){maxKeys=options.maxKeys;}var len=qs.length;// maxKeys <= 0 means that we should not limit keys count\nif(maxKeys>0&&len>maxKeys){len=maxKeys;}for(var i=0;i<len;++i){var x=qs[i].replace(regexp,'%20'),idx=x.indexOf(eq),kstr,vstr,k,v;if(idx>=0){kstr=x.substr(0,idx);vstr=x.substr(idx+1);}else{kstr=x;vstr='';}k=decodeURIComponent(kstr);v=decodeURIComponent(vstr);if(!hasOwnProperty(obj,k)){obj[k]=v;}else if(isArray(obj[k])){obj[k].push(v);}else{obj[k]=[obj[k],v];}}return obj;};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};},{}],195:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';var stringifyPrimitive=function stringifyPrimitive(v){switch(_typeof(v)){case'string':return v;case'boolean':return v?'true':'false';case'number':return isFinite(v)?v:'';default:return'';}};module.exports=function(obj,sep,eq,name){sep=sep||'&';eq=eq||'=';if(obj===null){obj=undefined;}if(_typeof(obj)==='object'){return map(objectKeys(obj),function(k){var ks=encodeURIComponent(stringifyPrimitive(k))+eq;if(isArray(obj[k])){return map(obj[k],function(v){return ks+encodeURIComponent(stringifyPrimitive(v));}).join(sep);}else{return ks+encodeURIComponent(stringifyPrimitive(obj[k]));}}).join(sep);}if(!name)return'';return encodeURIComponent(stringifyPrimitive(name))+eq+encodeURIComponent(stringifyPrimitive(obj));};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};function map(xs,f){if(xs.map)return xs.map(f);var res=[];for(var i=0;i<xs.length;i++){res.push(f(xs[i],i));}return res;}var objectKeys=Object.keys||function(obj){var res=[];for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))res.push(key);}return res;};},{}],196:[function(require,module,exports){'use strict';exports.decode=exports.parse=require('./decode');exports.encode=exports.stringify=require('./encode');},{\"./decode\":194,\"./encode\":195}],197:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */var util=require('./util');var has=Object.prototype.hasOwnProperty;var hasNativeMap=typeof Map!==\"undefined\";/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */function ArraySet(){this._array=[];this._set=hasNativeMap?new Map():Object.create(null);}/**\n * Static method for creating ArraySet instances from an existing array.\n */ArraySet.fromArray=function ArraySet_fromArray(aArray,aAllowDuplicates){var set=new ArraySet();for(var i=0,len=aArray.length;i<len;i++){set.add(aArray[i],aAllowDuplicates);}return set;};/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */ArraySet.prototype.size=function ArraySet_size(){return hasNativeMap?this._set.size:Object.getOwnPropertyNames(this._set).length;};/**\n * Add the given string to this set.\n *\n * @param String aStr\n */ArraySet.prototype.add=function ArraySet_add(aStr,aAllowDuplicates){var sStr=hasNativeMap?aStr:util.toSetString(aStr);var isDuplicate=hasNativeMap?this.has(aStr):has.call(this._set,sStr);var idx=this._array.length;if(!isDuplicate||aAllowDuplicates){this._array.push(aStr);}if(!isDuplicate){if(hasNativeMap){this._set.set(aStr,idx);}else{this._set[sStr]=idx;}}};/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */ArraySet.prototype.has=function ArraySet_has(aStr){if(hasNativeMap){return this._set.has(aStr);}else{var sStr=util.toSetString(aStr);return has.call(this._set,sStr);}};/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */ArraySet.prototype.indexOf=function ArraySet_indexOf(aStr){if(hasNativeMap){var idx=this._set.get(aStr);if(idx>=0){return idx;}}else{var sStr=util.toSetString(aStr);if(has.call(this._set,sStr)){return this._set[sStr];}}throw new Error('\"'+aStr+'\" is not in the set.');};/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */ArraySet.prototype.at=function ArraySet_at(aIdx){if(aIdx>=0&&aIdx<this._array.length){return this._array[aIdx];}throw new Error('No element indexed by '+aIdx);};/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */ArraySet.prototype.toArray=function ArraySet_toArray(){return this._array.slice();};exports.ArraySet=ArraySet;},{\"./util\":206}],198:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */var base64=require('./base64');// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\nvar VLQ_BASE_SHIFT=5;// binary: 100000\nvar VLQ_BASE=1<<VLQ_BASE_SHIFT;// binary: 011111\nvar VLQ_BASE_MASK=VLQ_BASE-1;// binary: 100000\nvar VLQ_CONTINUATION_BIT=VLQ_BASE;/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */function toVLQSigned(aValue){return aValue<0?(-aValue<<1)+1:(aValue<<1)+0;}/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */function fromVLQSigned(aValue){var isNegative=(aValue&1)===1;var shifted=aValue>>1;return isNegative?-shifted:shifted;}/**\n * Returns the base 64 VLQ encoded value.\n */exports.encode=function base64VLQ_encode(aValue){var encoded=\"\";var digit;var vlq=toVLQSigned(aValue);do{digit=vlq&VLQ_BASE_MASK;vlq>>>=VLQ_BASE_SHIFT;if(vlq>0){// There are still more digits in this value, so we must make sure the\n// continuation bit is marked.\ndigit|=VLQ_CONTINUATION_BIT;}encoded+=base64.encode(digit);}while(vlq>0);return encoded;};/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */exports.decode=function base64VLQ_decode(aStr,aIndex,aOutParam){var strLen=aStr.length;var result=0;var shift=0;var continuation,digit;do{if(aIndex>=strLen){throw new Error(\"Expected more digits in base 64 VLQ value.\");}digit=base64.decode(aStr.charCodeAt(aIndex++));if(digit===-1){throw new Error(\"Invalid base64 digit: \"+aStr.charAt(aIndex-1));}continuation=!!(digit&VLQ_CONTINUATION_BIT);digit&=VLQ_BASE_MASK;result=result+(digit<<shift);shift+=VLQ_BASE_SHIFT;}while(continuation);aOutParam.value=fromVLQSigned(result);aOutParam.rest=aIndex;};},{\"./base64\":199}],199:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */var intToCharMap='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */exports.encode=function(number){if(0<=number&&number<intToCharMap.length){return intToCharMap[number];}throw new TypeError(\"Must be between 0 and 63: \"+number);};/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */exports.decode=function(charCode){var bigA=65;// 'A'\nvar bigZ=90;// 'Z'\nvar littleA=97;// 'a'\nvar littleZ=122;// 'z'\nvar zero=48;// '0'\nvar nine=57;// '9'\nvar plus=43;// '+'\nvar slash=47;// '/'\nvar littleOffset=26;var numberOffset=52;// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\nif(bigA<=charCode&&charCode<=bigZ){return charCode-bigA;}// 26 - 51: abcdefghijklmnopqrstuvwxyz\nif(littleA<=charCode&&charCode<=littleZ){return charCode-littleA+littleOffset;}// 52 - 61: 0123456789\nif(zero<=charCode&&charCode<=nine){return charCode-zero+numberOffset;}// 62: +\nif(charCode==plus){return 62;}// 63: /\nif(charCode==slash){return 63;}// Invalid base64 digit.\nreturn-1;};},{}],200:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */exports.GREATEST_LOWER_BOUND=1;exports.LEAST_UPPER_BOUND=2;/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */function recursiveSearch(aLow,aHigh,aNeedle,aHaystack,aCompare,aBias){// This function terminates when one of the following is true:\n//\n//   1. We find the exact element we are looking for.\n//\n//   2. We did not find the exact element, but we can return the index of\n//      the next-closest element.\n//\n//   3. We did not find the exact element, and there is no next-closest\n//      element than the one we are searching for, so we return -1.\nvar mid=Math.floor((aHigh-aLow)/2)+aLow;var cmp=aCompare(aNeedle,aHaystack[mid],true);if(cmp===0){// Found the element we are looking for.\nreturn mid;}else if(cmp>0){// Our needle is greater than aHaystack[mid].\nif(aHigh-mid>1){// The element is in the upper half.\nreturn recursiveSearch(mid,aHigh,aNeedle,aHaystack,aCompare,aBias);}// The exact needle element was not found in this haystack. Determine if\n// we are in termination case (3) or (2) and return the appropriate thing.\nif(aBias==exports.LEAST_UPPER_BOUND){return aHigh<aHaystack.length?aHigh:-1;}else{return mid;}}else{// Our needle is less than aHaystack[mid].\nif(mid-aLow>1){// The element is in the lower half.\nreturn recursiveSearch(aLow,mid,aNeedle,aHaystack,aCompare,aBias);}// we are in termination case (3) or (2) and return the appropriate thing.\nif(aBias==exports.LEAST_UPPER_BOUND){return mid;}else{return aLow<0?-1:aLow;}}}/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */exports.search=function search(aNeedle,aHaystack,aCompare,aBias){if(aHaystack.length===0){return-1;}var index=recursiveSearch(-1,aHaystack.length,aNeedle,aHaystack,aCompare,aBias||exports.GREATEST_LOWER_BOUND);if(index<0){return-1;}// We have found either the exact element, or the next-closest element than\n// the one we are searching for. However, there may be more than one such\n// element. Make sure we always return the smallest of these.\nwhile(index-1>=0){if(aCompare(aHaystack[index],aHaystack[index-1],true)!==0){break;}--index;}return index;};},{}],201:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */var util=require('./util');/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */function generatedPositionAfter(mappingA,mappingB){// Optimized for most common case\nvar lineA=mappingA.generatedLine;var lineB=mappingB.generatedLine;var columnA=mappingA.generatedColumn;var columnB=mappingB.generatedColumn;return lineB>lineA||lineB==lineA&&columnB>=columnA||util.compareByGeneratedPositionsInflated(mappingA,mappingB)<=0;}/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */function MappingList(){this._array=[];this._sorted=true;// Serves as infimum\nthis._last={generatedLine:-1,generatedColumn:0};}/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */MappingList.prototype.unsortedForEach=function MappingList_forEach(aCallback,aThisArg){this._array.forEach(aCallback,aThisArg);};/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */MappingList.prototype.add=function MappingList_add(aMapping){if(generatedPositionAfter(this._last,aMapping)){this._last=aMapping;this._array.push(aMapping);}else{this._sorted=false;this._array.push(aMapping);}};/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */MappingList.prototype.toArray=function MappingList_toArray(){if(!this._sorted){this._array.sort(util.compareByGeneratedPositionsInflated);this._sorted=true;}return this._array;};exports.MappingList=MappingList;},{\"./util\":206}],202:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ // It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */function swap(ary,x,y){var temp=ary[x];ary[x]=ary[y];ary[y]=temp;}/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */function randomIntInRange(low,high){return Math.round(low+Math.random()*(high-low));}/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */function doQuickSort(ary,comparator,p,r){// If our lower bound is less than our upper bound, we (1) partition the\n// array into two pieces and (2) recurse on each half. If it is not, this is\n// the empty array and our base case.\nif(p<r){// (1) Partitioning.\n//\n// The partitioning chooses a pivot between `p` and `r` and moves all\n// elements that are less than or equal to the pivot to the before it, and\n// all the elements that are greater than it after it. The effect is that\n// once partition is done, the pivot is in the exact place it will be when\n// the array is put in sorted order, and it will not need to be moved\n// again. This runs in O(n) time.\n// Always choose a random pivot so that an input array which is reverse\n// sorted does not cause O(n^2) running time.\nvar pivotIndex=randomIntInRange(p,r);var i=p-1;swap(ary,pivotIndex,r);var pivot=ary[r];// Immediately after `j` is incremented in this loop, the following hold\n// true:\n//\n//   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n//\n//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\nfor(var j=p;j<r;j++){if(comparator(ary[j],pivot)<=0){i+=1;swap(ary,i,j);}}swap(ary,i+1,j);var q=i+1;// (2) Recurse on each half.\ndoQuickSort(ary,comparator,p,q-1);doQuickSort(ary,comparator,q+1,r);}}/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */exports.quickSort=function(ary,comparator){doQuickSort(ary,comparator,0,ary.length-1);};},{}],203:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */var util=require('./util');var binarySearch=require('./binary-search');var ArraySet=require('./array-set').ArraySet;var base64VLQ=require('./base64-vlq');var quickSort=require('./quick-sort').quickSort;function SourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=util.parseSourceMapInput(aSourceMap);}return sourceMap.sections!=null?new IndexedSourceMapConsumer(sourceMap,aSourceMapURL):new BasicSourceMapConsumer(sourceMap,aSourceMapURL);}SourceMapConsumer.fromSourceMap=function(aSourceMap,aSourceMapURL){return BasicSourceMapConsumer.fromSourceMap(aSourceMap,aSourceMapURL);};/**\n * The version of the source mapping spec that we are consuming.\n */SourceMapConsumer.prototype._version=3;// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\nSourceMapConsumer.prototype.__generatedMappings=null;Object.defineProperty(SourceMapConsumer.prototype,'_generatedMappings',{configurable:true,enumerable:true,get:function get(){if(!this.__generatedMappings){this._parseMappings(this._mappings,this.sourceRoot);}return this.__generatedMappings;}});SourceMapConsumer.prototype.__originalMappings=null;Object.defineProperty(SourceMapConsumer.prototype,'_originalMappings',{configurable:true,enumerable:true,get:function get(){if(!this.__originalMappings){this._parseMappings(this._mappings,this.sourceRoot);}return this.__originalMappings;}});SourceMapConsumer.prototype._charIsMappingSeparator=function SourceMapConsumer_charIsMappingSeparator(aStr,index){var c=aStr.charAt(index);return c===\";\"||c===\",\";};/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */SourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(aStr,aSourceRoot){throw new Error(\"Subclasses must implement _parseMappings\");};SourceMapConsumer.GENERATED_ORDER=1;SourceMapConsumer.ORIGINAL_ORDER=2;SourceMapConsumer.GREATEST_LOWER_BOUND=1;SourceMapConsumer.LEAST_UPPER_BOUND=2;/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */SourceMapConsumer.prototype.eachMapping=function SourceMapConsumer_eachMapping(aCallback,aContext,aOrder){var context=aContext||null;var order=aOrder||SourceMapConsumer.GENERATED_ORDER;var mappings;switch(order){case SourceMapConsumer.GENERATED_ORDER:mappings=this._generatedMappings;break;case SourceMapConsumer.ORIGINAL_ORDER:mappings=this._originalMappings;break;default:throw new Error(\"Unknown order of iteration.\");}var sourceRoot=this.sourceRoot;mappings.map(function(mapping){var source=mapping.source===null?null:this._sources.at(mapping.source);source=util.computeSourceURL(sourceRoot,source,this._sourceMapURL);return{source:source,generatedLine:mapping.generatedLine,generatedColumn:mapping.generatedColumn,originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:mapping.name===null?null:this._names.at(mapping.name)};},this).forEach(aCallback,context);};/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */SourceMapConsumer.prototype.allGeneratedPositionsFor=function SourceMapConsumer_allGeneratedPositionsFor(aArgs){var line=util.getArg(aArgs,'line');// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n// returns the index of the closest mapping less than the needle. By\n// setting needle.originalColumn to 0, we thus find the last mapping for\n// the given line, provided such a mapping exists.\nvar needle={source:util.getArg(aArgs,'source'),originalLine:line,originalColumn:util.getArg(aArgs,'column',0)};needle.source=this._findSourceIndex(needle.source);if(needle.source<0){return[];}var mappings=[];var index=this._findMapping(needle,this._originalMappings,\"originalLine\",\"originalColumn\",util.compareByOriginalPositions,binarySearch.LEAST_UPPER_BOUND);if(index>=0){var mapping=this._originalMappings[index];if(aArgs.column===undefined){var originalLine=mapping.originalLine;// Iterate until either we run out of mappings, or we run into\n// a mapping for a different line than the one we found. Since\n// mappings are sorted, this is guaranteed to find all mappings for\n// the line we found.\nwhile(mapping&&mapping.originalLine===originalLine){mappings.push({line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)});mapping=this._originalMappings[++index];}}else{var originalColumn=mapping.originalColumn;// Iterate until either we run out of mappings, or we run into\n// a mapping for a different line than the one we were searching for.\n// Since mappings are sorted, this is guaranteed to find all mappings for\n// the line we are searching for.\nwhile(mapping&&mapping.originalLine===line&&mapping.originalColumn==originalColumn){mappings.push({line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)});mapping=this._originalMappings[++index];}}}return mappings;};exports.SourceMapConsumer=SourceMapConsumer;/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */function BasicSourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=util.parseSourceMapInput(aSourceMap);}var version=util.getArg(sourceMap,'version');var sources=util.getArg(sourceMap,'sources');// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n// requires the array) to play nice here.\nvar names=util.getArg(sourceMap,'names',[]);var sourceRoot=util.getArg(sourceMap,'sourceRoot',null);var sourcesContent=util.getArg(sourceMap,'sourcesContent',null);var mappings=util.getArg(sourceMap,'mappings');var file=util.getArg(sourceMap,'file',null);// Once again, Sass deviates from the spec and supplies the version as a\n// string rather than a number, so we use loose equality checking here.\nif(version!=this._version){throw new Error('Unsupported version: '+version);}if(sourceRoot){sourceRoot=util.normalize(sourceRoot);}sources=sources.map(String)// Some source maps produce relative source paths like \"./foo.js\" instead of\n// \"foo.js\".  Normalize these first so that future comparisons will succeed.\n// See bugzil.la/1090768.\n.map(util.normalize)// Always ensure that absolute sources are internally stored relative to\n// the source root, if the source root is absolute. Not doing this would\n// be particularly problematic when the source root is a prefix of the\n// source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n.map(function(source){return sourceRoot&&util.isAbsolute(sourceRoot)&&util.isAbsolute(source)?util.relative(sourceRoot,source):source;});// Pass `true` below to allow duplicate names and sources. While source maps\n// are intended to be compressed and deduplicated, the TypeScript compiler\n// sometimes generates source maps with duplicates in them. See Github issue\n// #72 and bugzil.la/889492.\nthis._names=ArraySet.fromArray(names.map(String),true);this._sources=ArraySet.fromArray(sources,true);this._absoluteSources=this._sources.toArray().map(function(s){return util.computeSourceURL(sourceRoot,s,aSourceMapURL);});this.sourceRoot=sourceRoot;this.sourcesContent=sourcesContent;this._mappings=mappings;this._sourceMapURL=aSourceMapURL;this.file=file;}BasicSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);BasicSourceMapConsumer.prototype.consumer=SourceMapConsumer;/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */BasicSourceMapConsumer.prototype._findSourceIndex=function(aSource){var relativeSource=aSource;if(this.sourceRoot!=null){relativeSource=util.relative(this.sourceRoot,relativeSource);}if(this._sources.has(relativeSource)){return this._sources.indexOf(relativeSource);}// Maybe aSource is an absolute URL as returned by |sources|.  In\n// this case we can't simply undo the transform.\nvar i;for(i=0;i<this._absoluteSources.length;++i){if(this._absoluteSources[i]==aSource){return i;}}return-1;};/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */BasicSourceMapConsumer.fromSourceMap=function SourceMapConsumer_fromSourceMap(aSourceMap,aSourceMapURL){var smc=Object.create(BasicSourceMapConsumer.prototype);var names=smc._names=ArraySet.fromArray(aSourceMap._names.toArray(),true);var sources=smc._sources=ArraySet.fromArray(aSourceMap._sources.toArray(),true);smc.sourceRoot=aSourceMap._sourceRoot;smc.sourcesContent=aSourceMap._generateSourcesContent(smc._sources.toArray(),smc.sourceRoot);smc.file=aSourceMap._file;smc._sourceMapURL=aSourceMapURL;smc._absoluteSources=smc._sources.toArray().map(function(s){return util.computeSourceURL(smc.sourceRoot,s,aSourceMapURL);});// Because we are modifying the entries (by converting string sources and\n// names to indices into the sources and names ArraySets), we have to make\n// a copy of the entry or else bad things happen. Shared mutable state\n// strikes again! See github issue #191.\nvar generatedMappings=aSourceMap._mappings.toArray().slice();var destGeneratedMappings=smc.__generatedMappings=[];var destOriginalMappings=smc.__originalMappings=[];for(var i=0,length=generatedMappings.length;i<length;i++){var srcMapping=generatedMappings[i];var destMapping=new Mapping();destMapping.generatedLine=srcMapping.generatedLine;destMapping.generatedColumn=srcMapping.generatedColumn;if(srcMapping.source){destMapping.source=sources.indexOf(srcMapping.source);destMapping.originalLine=srcMapping.originalLine;destMapping.originalColumn=srcMapping.originalColumn;if(srcMapping.name){destMapping.name=names.indexOf(srcMapping.name);}destOriginalMappings.push(destMapping);}destGeneratedMappings.push(destMapping);}quickSort(smc.__originalMappings,util.compareByOriginalPositions);return smc;};/**\n * The version of the source mapping spec that we are consuming.\n */BasicSourceMapConsumer.prototype._version=3;/**\n * The list of original sources.\n */Object.defineProperty(BasicSourceMapConsumer.prototype,'sources',{get:function get(){return this._absoluteSources.slice();}});/**\n * Provide the JIT with a nice shape / hidden class.\n */function Mapping(){this.generatedLine=0;this.generatedColumn=0;this.source=null;this.originalLine=null;this.originalColumn=null;this.name=null;}/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */BasicSourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(aStr,aSourceRoot){var generatedLine=1;var previousGeneratedColumn=0;var previousOriginalLine=0;var previousOriginalColumn=0;var previousSource=0;var previousName=0;var length=aStr.length;var index=0;var cachedSegments={};var temp={};var originalMappings=[];var generatedMappings=[];var mapping,str,segment,end,value;while(index<length){if(aStr.charAt(index)===';'){generatedLine++;index++;previousGeneratedColumn=0;}else if(aStr.charAt(index)===','){index++;}else{mapping=new Mapping();mapping.generatedLine=generatedLine;// Because each offset is encoded relative to the previous one,\n// many segments often have the same encoding. We can exploit this\n// fact by caching the parsed variable length fields of each segment,\n// allowing us to avoid a second parse if we encounter the same\n// segment again.\nfor(end=index;end<length;end++){if(this._charIsMappingSeparator(aStr,end)){break;}}str=aStr.slice(index,end);segment=cachedSegments[str];if(segment){index+=str.length;}else{segment=[];while(index<end){base64VLQ.decode(aStr,index,temp);value=temp.value;index=temp.rest;segment.push(value);}if(segment.length===2){throw new Error('Found a source, but no line and column');}if(segment.length===3){throw new Error('Found a source and line, but no column');}cachedSegments[str]=segment;}// Generated column.\nmapping.generatedColumn=previousGeneratedColumn+segment[0];previousGeneratedColumn=mapping.generatedColumn;if(segment.length>1){// Original source.\nmapping.source=previousSource+segment[1];previousSource+=segment[1];// Original line.\nmapping.originalLine=previousOriginalLine+segment[2];previousOriginalLine=mapping.originalLine;// Lines are stored 0-based\nmapping.originalLine+=1;// Original column.\nmapping.originalColumn=previousOriginalColumn+segment[3];previousOriginalColumn=mapping.originalColumn;if(segment.length>4){// Original name.\nmapping.name=previousName+segment[4];previousName+=segment[4];}}generatedMappings.push(mapping);if(typeof mapping.originalLine==='number'){originalMappings.push(mapping);}}}quickSort(generatedMappings,util.compareByGeneratedPositionsDeflated);this.__generatedMappings=generatedMappings;quickSort(originalMappings,util.compareByOriginalPositions);this.__originalMappings=originalMappings;};/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */BasicSourceMapConsumer.prototype._findMapping=function SourceMapConsumer_findMapping(aNeedle,aMappings,aLineName,aColumnName,aComparator,aBias){// To return the position we are searching for, we must first find the\n// mapping for the given position and then return the opposite position it\n// points to. Because the mappings are sorted, we can use binary search to\n// find the best mapping.\nif(aNeedle[aLineName]<=0){throw new TypeError('Line must be greater than or equal to 1, got '+aNeedle[aLineName]);}if(aNeedle[aColumnName]<0){throw new TypeError('Column must be greater than or equal to 0, got '+aNeedle[aColumnName]);}return binarySearch.search(aNeedle,aMappings,aComparator,aBias);};/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */BasicSourceMapConsumer.prototype.computeColumnSpans=function SourceMapConsumer_computeColumnSpans(){for(var index=0;index<this._generatedMappings.length;++index){var mapping=this._generatedMappings[index];// Mappings do not contain a field for the last generated columnt. We\n// can come up with an optimistic estimate, however, by assuming that\n// mappings are contiguous (i.e. given two consecutive mappings, the\n// first mapping ends where the second one starts).\nif(index+1<this._generatedMappings.length){var nextMapping=this._generatedMappings[index+1];if(mapping.generatedLine===nextMapping.generatedLine){mapping.lastGeneratedColumn=nextMapping.generatedColumn-1;continue;}}// The last mapping for each line spans the entire line.\nmapping.lastGeneratedColumn=Infinity;}};/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */BasicSourceMapConsumer.prototype.originalPositionFor=function SourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,'line'),generatedColumn:util.getArg(aArgs,'column')};var index=this._findMapping(needle,this._generatedMappings,\"generatedLine\",\"generatedColumn\",util.compareByGeneratedPositionsDeflated,util.getArg(aArgs,'bias',SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._generatedMappings[index];if(mapping.generatedLine===needle.generatedLine){var source=util.getArg(mapping,'source',null);if(source!==null){source=this._sources.at(source);source=util.computeSourceURL(this.sourceRoot,source,this._sourceMapURL);}var name=util.getArg(mapping,'name',null);if(name!==null){name=this._names.at(name);}return{source:source,line:util.getArg(mapping,'originalLine',null),column:util.getArg(mapping,'originalColumn',null),name:name};}}return{source:null,line:null,column:null,name:null};};/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */BasicSourceMapConsumer.prototype.hasContentsOfAllSources=function BasicSourceMapConsumer_hasContentsOfAllSources(){if(!this.sourcesContent){return false;}return this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(sc){return sc==null;});};/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */BasicSourceMapConsumer.prototype.sourceContentFor=function SourceMapConsumer_sourceContentFor(aSource,nullOnMissing){if(!this.sourcesContent){return null;}var index=this._findSourceIndex(aSource);if(index>=0){return this.sourcesContent[index];}var relativeSource=aSource;if(this.sourceRoot!=null){relativeSource=util.relative(this.sourceRoot,relativeSource);}var url;if(this.sourceRoot!=null&&(url=util.urlParse(this.sourceRoot))){// XXX: file:// URIs and absolute paths lead to unexpected behavior for\n// many users. We can help them out when they expect file:// URIs to\n// behave like it would if they were running a local HTTP server. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\nvar fileUriAbsPath=relativeSource.replace(/^file:\\/\\//,\"\");if(url.scheme==\"file\"&&this._sources.has(fileUriAbsPath)){return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];}if((!url.path||url.path==\"/\")&&this._sources.has(\"/\"+relativeSource)){return this.sourcesContent[this._sources.indexOf(\"/\"+relativeSource)];}}// This function is used recursively from\n// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n// don't want to throw if we can't find the source - we just want to\n// return null, so we provide a flag to exit gracefully.\nif(nullOnMissing){return null;}else{throw new Error('\"'+relativeSource+'\" is not in the SourceMap.');}};/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */BasicSourceMapConsumer.prototype.generatedPositionFor=function SourceMapConsumer_generatedPositionFor(aArgs){var source=util.getArg(aArgs,'source');source=this._findSourceIndex(source);if(source<0){return{line:null,column:null,lastColumn:null};}var needle={source:source,originalLine:util.getArg(aArgs,'line'),originalColumn:util.getArg(aArgs,'column')};var index=this._findMapping(needle,this._originalMappings,\"originalLine\",\"originalColumn\",util.compareByOriginalPositions,util.getArg(aArgs,'bias',SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._originalMappings[index];if(mapping.source===needle.source){return{line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)};}}return{line:null,column:null,lastColumn:null};};exports.BasicSourceMapConsumer=BasicSourceMapConsumer;/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */function IndexedSourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=util.parseSourceMapInput(aSourceMap);}var version=util.getArg(sourceMap,'version');var sections=util.getArg(sourceMap,'sections');if(version!=this._version){throw new Error('Unsupported version: '+version);}this._sources=new ArraySet();this._names=new ArraySet();var lastOffset={line:-1,column:0};this._sections=sections.map(function(s){if(s.url){// The url field will require support for asynchronicity.\n// See https://github.com/mozilla/source-map/issues/16\nthrow new Error('Support for url field in sections not implemented.');}var offset=util.getArg(s,'offset');var offsetLine=util.getArg(offset,'line');var offsetColumn=util.getArg(offset,'column');if(offsetLine<lastOffset.line||offsetLine===lastOffset.line&&offsetColumn<lastOffset.column){throw new Error('Section offsets must be ordered and non-overlapping.');}lastOffset=offset;return{generatedOffset:{// The offset fields are 0-based, but we use 1-based indices when\n// encoding/decoding from VLQ.\ngeneratedLine:offsetLine+1,generatedColumn:offsetColumn+1},consumer:new SourceMapConsumer(util.getArg(s,'map'),aSourceMapURL)};});}IndexedSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);IndexedSourceMapConsumer.prototype.constructor=SourceMapConsumer;/**\n * The version of the source mapping spec that we are consuming.\n */IndexedSourceMapConsumer.prototype._version=3;/**\n * The list of original sources.\n */Object.defineProperty(IndexedSourceMapConsumer.prototype,'sources',{get:function get(){var sources=[];for(var i=0;i<this._sections.length;i++){for(var j=0;j<this._sections[i].consumer.sources.length;j++){sources.push(this._sections[i].consumer.sources[j]);}}return sources;}});/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */IndexedSourceMapConsumer.prototype.originalPositionFor=function IndexedSourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,'line'),generatedColumn:util.getArg(aArgs,'column')};// Find the section containing the generated position we're trying to map\n// to an original position.\nvar sectionIndex=binarySearch.search(needle,this._sections,function(needle,section){var cmp=needle.generatedLine-section.generatedOffset.generatedLine;if(cmp){return cmp;}return needle.generatedColumn-section.generatedOffset.generatedColumn;});var section=this._sections[sectionIndex];if(!section){return{source:null,line:null,column:null,name:null};}return section.consumer.originalPositionFor({line:needle.generatedLine-(section.generatedOffset.generatedLine-1),column:needle.generatedColumn-(section.generatedOffset.generatedLine===needle.generatedLine?section.generatedOffset.generatedColumn-1:0),bias:aArgs.bias});};/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */IndexedSourceMapConsumer.prototype.hasContentsOfAllSources=function IndexedSourceMapConsumer_hasContentsOfAllSources(){return this._sections.every(function(s){return s.consumer.hasContentsOfAllSources();});};/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */IndexedSourceMapConsumer.prototype.sourceContentFor=function IndexedSourceMapConsumer_sourceContentFor(aSource,nullOnMissing){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var content=section.consumer.sourceContentFor(aSource,true);if(content){return content;}}if(nullOnMissing){return null;}else{throw new Error('\"'+aSource+'\" is not in the SourceMap.');}};/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */IndexedSourceMapConsumer.prototype.generatedPositionFor=function IndexedSourceMapConsumer_generatedPositionFor(aArgs){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];// Only consider this section if the requested source is in the list of\n// sources of the consumer.\nif(section.consumer._findSourceIndex(util.getArg(aArgs,'source'))===-1){continue;}var generatedPosition=section.consumer.generatedPositionFor(aArgs);if(generatedPosition){var ret={line:generatedPosition.line+(section.generatedOffset.generatedLine-1),column:generatedPosition.column+(section.generatedOffset.generatedLine===generatedPosition.line?section.generatedOffset.generatedColumn-1:0)};return ret;}}return{line:null,column:null};};/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */IndexedSourceMapConsumer.prototype._parseMappings=function IndexedSourceMapConsumer_parseMappings(aStr,aSourceRoot){this.__generatedMappings=[];this.__originalMappings=[];for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var sectionMappings=section.consumer._generatedMappings;for(var j=0;j<sectionMappings.length;j++){var mapping=sectionMappings[j];var source=section.consumer._sources.at(mapping.source);source=util.computeSourceURL(section.consumer.sourceRoot,source,this._sourceMapURL);this._sources.add(source);source=this._sources.indexOf(source);var name=null;if(mapping.name){name=section.consumer._names.at(mapping.name);this._names.add(name);name=this._names.indexOf(name);}// The mappings coming from the consumer for the section have\n// generated positions relative to the start of the section, so we\n// need to offset them to be relative to the start of the concatenated\n// generated file.\nvar adjustedMapping={source:source,generatedLine:mapping.generatedLine+(section.generatedOffset.generatedLine-1),generatedColumn:mapping.generatedColumn+(section.generatedOffset.generatedLine===mapping.generatedLine?section.generatedOffset.generatedColumn-1:0),originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:name};this.__generatedMappings.push(adjustedMapping);if(typeof adjustedMapping.originalLine==='number'){this.__originalMappings.push(adjustedMapping);}}}quickSort(this.__generatedMappings,util.compareByGeneratedPositionsDeflated);quickSort(this.__originalMappings,util.compareByOriginalPositions);};exports.IndexedSourceMapConsumer=IndexedSourceMapConsumer;},{\"./array-set\":197,\"./base64-vlq\":198,\"./binary-search\":200,\"./quick-sort\":202,\"./util\":206}],204:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */var base64VLQ=require('./base64-vlq');var util=require('./util');var ArraySet=require('./array-set').ArraySet;var MappingList=require('./mapping-list').MappingList;/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */function SourceMapGenerator(aArgs){if(!aArgs){aArgs={};}this._file=util.getArg(aArgs,'file',null);this._sourceRoot=util.getArg(aArgs,'sourceRoot',null);this._skipValidation=util.getArg(aArgs,'skipValidation',false);this._sources=new ArraySet();this._names=new ArraySet();this._mappings=new MappingList();this._sourcesContents=null;}SourceMapGenerator.prototype._version=3;/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */SourceMapGenerator.fromSourceMap=function SourceMapGenerator_fromSourceMap(aSourceMapConsumer){var sourceRoot=aSourceMapConsumer.sourceRoot;var generator=new SourceMapGenerator({file:aSourceMapConsumer.file,sourceRoot:sourceRoot});aSourceMapConsumer.eachMapping(function(mapping){var newMapping={generated:{line:mapping.generatedLine,column:mapping.generatedColumn}};if(mapping.source!=null){newMapping.source=mapping.source;if(sourceRoot!=null){newMapping.source=util.relative(sourceRoot,newMapping.source);}newMapping.original={line:mapping.originalLine,column:mapping.originalColumn};if(mapping.name!=null){newMapping.name=mapping.name;}}generator.addMapping(newMapping);});aSourceMapConsumer.sources.forEach(function(sourceFile){var sourceRelative=sourceFile;if(sourceRoot!==null){sourceRelative=util.relative(sourceRoot,sourceFile);}if(!generator._sources.has(sourceRelative)){generator._sources.add(sourceRelative);}var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){generator.setSourceContent(sourceFile,content);}});return generator;};/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */SourceMapGenerator.prototype.addMapping=function SourceMapGenerator_addMapping(aArgs){var generated=util.getArg(aArgs,'generated');var original=util.getArg(aArgs,'original',null);var source=util.getArg(aArgs,'source',null);var name=util.getArg(aArgs,'name',null);if(!this._skipValidation){this._validateMapping(generated,original,source,name);}if(source!=null){source=String(source);if(!this._sources.has(source)){this._sources.add(source);}}if(name!=null){name=String(name);if(!this._names.has(name)){this._names.add(name);}}this._mappings.add({generatedLine:generated.line,generatedColumn:generated.column,originalLine:original!=null&&original.line,originalColumn:original!=null&&original.column,source:source,name:name});};/**\n * Set the source content for a source file.\n */SourceMapGenerator.prototype.setSourceContent=function SourceMapGenerator_setSourceContent(aSourceFile,aSourceContent){var source=aSourceFile;if(this._sourceRoot!=null){source=util.relative(this._sourceRoot,source);}if(aSourceContent!=null){// Add the source content to the _sourcesContents map.\n// Create a new _sourcesContents map if the property is null.\nif(!this._sourcesContents){this._sourcesContents=Object.create(null);}this._sourcesContents[util.toSetString(source)]=aSourceContent;}else if(this._sourcesContents){// Remove the source file from the _sourcesContents map.\n// If the _sourcesContents map is empty, set the property to null.\ndelete this._sourcesContents[util.toSetString(source)];if(Object.keys(this._sourcesContents).length===0){this._sourcesContents=null;}}};/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */SourceMapGenerator.prototype.applySourceMap=function SourceMapGenerator_applySourceMap(aSourceMapConsumer,aSourceFile,aSourceMapPath){var sourceFile=aSourceFile;// If aSourceFile is omitted, we will use the file property of the SourceMap\nif(aSourceFile==null){if(aSourceMapConsumer.file==null){throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, '+'or the source map\\'s \"file\" property. Both were omitted.');}sourceFile=aSourceMapConsumer.file;}var sourceRoot=this._sourceRoot;// Make \"sourceFile\" relative if an absolute Url is passed.\nif(sourceRoot!=null){sourceFile=util.relative(sourceRoot,sourceFile);}// Applying the SourceMap can add and remove items from the sources and\n// the names array.\nvar newSources=new ArraySet();var newNames=new ArraySet();// Find mappings for the \"sourceFile\"\nthis._mappings.unsortedForEach(function(mapping){if(mapping.source===sourceFile&&mapping.originalLine!=null){// Check if it can be mapped by the source map, then update the mapping.\nvar original=aSourceMapConsumer.originalPositionFor({line:mapping.originalLine,column:mapping.originalColumn});if(original.source!=null){// Copy mapping\nmapping.source=original.source;if(aSourceMapPath!=null){mapping.source=util.join(aSourceMapPath,mapping.source);}if(sourceRoot!=null){mapping.source=util.relative(sourceRoot,mapping.source);}mapping.originalLine=original.line;mapping.originalColumn=original.column;if(original.name!=null){mapping.name=original.name;}}}var source=mapping.source;if(source!=null&&!newSources.has(source)){newSources.add(source);}var name=mapping.name;if(name!=null&&!newNames.has(name)){newNames.add(name);}},this);this._sources=newSources;this._names=newNames;// Copy sourcesContents of applied map.\naSourceMapConsumer.sources.forEach(function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){if(aSourceMapPath!=null){sourceFile=util.join(aSourceMapPath,sourceFile);}if(sourceRoot!=null){sourceFile=util.relative(sourceRoot,sourceFile);}this.setSourceContent(sourceFile,content);}},this);};/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */SourceMapGenerator.prototype._validateMapping=function SourceMapGenerator_validateMapping(aGenerated,aOriginal,aSource,aName){// When aOriginal is truthy but has empty values for .line and .column,\n// it is most likely a programmer error. In this case we throw a very\n// specific error message to try to guide them the right way.\n// For example: https://github.com/Polymer/polymer-bundler/pull/519\nif(aOriginal&&typeof aOriginal.line!=='number'&&typeof aOriginal.column!=='number'){throw new Error('original.line and original.column are not numbers -- you probably meant to omit '+'the original mapping entirely and only map the generated position. If so, pass '+'null for the original mapping instead of an object with empty or null values.');}if(aGenerated&&'line'in aGenerated&&'column'in aGenerated&&aGenerated.line>0&&aGenerated.column>=0&&!aOriginal&&!aSource&&!aName){// Case 1.\nreturn;}else if(aGenerated&&'line'in aGenerated&&'column'in aGenerated&&aOriginal&&'line'in aOriginal&&'column'in aOriginal&&aGenerated.line>0&&aGenerated.column>=0&&aOriginal.line>0&&aOriginal.column>=0&&aSource){// Cases 2 and 3.\nreturn;}else{throw new Error('Invalid mapping: '+JSON.stringify({generated:aGenerated,source:aSource,original:aOriginal,name:aName}));}};/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */SourceMapGenerator.prototype._serializeMappings=function SourceMapGenerator_serializeMappings(){var previousGeneratedColumn=0;var previousGeneratedLine=1;var previousOriginalColumn=0;var previousOriginalLine=0;var previousName=0;var previousSource=0;var result='';var next;var mapping;var nameIdx;var sourceIdx;var mappings=this._mappings.toArray();for(var i=0,len=mappings.length;i<len;i++){mapping=mappings[i];next='';if(mapping.generatedLine!==previousGeneratedLine){previousGeneratedColumn=0;while(mapping.generatedLine!==previousGeneratedLine){next+=';';previousGeneratedLine++;}}else{if(i>0){if(!util.compareByGeneratedPositionsInflated(mapping,mappings[i-1])){continue;}next+=',';}}next+=base64VLQ.encode(mapping.generatedColumn-previousGeneratedColumn);previousGeneratedColumn=mapping.generatedColumn;if(mapping.source!=null){sourceIdx=this._sources.indexOf(mapping.source);next+=base64VLQ.encode(sourceIdx-previousSource);previousSource=sourceIdx;// lines are stored 0-based in SourceMap spec version 3\nnext+=base64VLQ.encode(mapping.originalLine-1-previousOriginalLine);previousOriginalLine=mapping.originalLine-1;next+=base64VLQ.encode(mapping.originalColumn-previousOriginalColumn);previousOriginalColumn=mapping.originalColumn;if(mapping.name!=null){nameIdx=this._names.indexOf(mapping.name);next+=base64VLQ.encode(nameIdx-previousName);previousName=nameIdx;}}result+=next;}return result;};SourceMapGenerator.prototype._generateSourcesContent=function SourceMapGenerator_generateSourcesContent(aSources,aSourceRoot){return aSources.map(function(source){if(!this._sourcesContents){return null;}if(aSourceRoot!=null){source=util.relative(aSourceRoot,source);}var key=util.toSetString(source);return Object.prototype.hasOwnProperty.call(this._sourcesContents,key)?this._sourcesContents[key]:null;},this);};/**\n * Externalize the source map.\n */SourceMapGenerator.prototype.toJSON=function SourceMapGenerator_toJSON(){var map={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};if(this._file!=null){map.file=this._file;}if(this._sourceRoot!=null){map.sourceRoot=this._sourceRoot;}if(this._sourcesContents){map.sourcesContent=this._generateSourcesContent(map.sources,map.sourceRoot);}return map;};/**\n * Render the source map being generated to a string.\n */SourceMapGenerator.prototype.toString=function SourceMapGenerator_toString(){return JSON.stringify(this.toJSON());};exports.SourceMapGenerator=SourceMapGenerator;},{\"./array-set\":197,\"./base64-vlq\":198,\"./mapping-list\":201,\"./util\":206}],205:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */var SourceMapGenerator=require('./source-map-generator').SourceMapGenerator;var util=require('./util');// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE=/(\\r?\\n)/;// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE=10;// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode=\"$$$isSourceNode$$$\";/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */function SourceNode(aLine,aColumn,aSource,aChunks,aName){this.children=[];this.sourceContents={};this.line=aLine==null?null:aLine;this.column=aColumn==null?null:aColumn;this.source=aSource==null?null:aSource;this.name=aName==null?null:aName;this[isSourceNode]=true;if(aChunks!=null)this.add(aChunks);}/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */SourceNode.fromStringWithSourceMap=function SourceNode_fromStringWithSourceMap(aGeneratedCode,aSourceMapConsumer,aRelativePath){// The SourceNode we want to fill with the generated code\n// and the SourceMap\nvar node=new SourceNode();// All even indices of this array are one line of the generated code,\n// while all odd indices are the newlines between two adjacent lines\n// (since `REGEX_NEWLINE` captures its match).\n// Processed fragments are accessed by calling `shiftNextLine`.\nvar remainingLines=aGeneratedCode.split(REGEX_NEWLINE);var remainingLinesIndex=0;var shiftNextLine=function shiftNextLine(){var lineContents=getNextLine();// The last line of a file might not have a newline.\nvar newLine=getNextLine()||\"\";return lineContents+newLine;function getNextLine(){return remainingLinesIndex<remainingLines.length?remainingLines[remainingLinesIndex++]:undefined;}};// We need to remember the position of \"remainingLines\"\nvar lastGeneratedLine=1,lastGeneratedColumn=0;// The generate SourceNodes we need a code range.\n// To extract it current and last mapping is used.\n// Here we store the last mapping.\nvar lastMapping=null;aSourceMapConsumer.eachMapping(function(mapping){if(lastMapping!==null){// We add the code from \"lastMapping\" to \"mapping\":\n// First check if there is a new line in between.\nif(lastGeneratedLine<mapping.generatedLine){// Associate first line with \"lastMapping\"\naddMappingWithCode(lastMapping,shiftNextLine());lastGeneratedLine++;lastGeneratedColumn=0;// The remaining code is added without mapping\n}else{// There is no new line in between.\n// Associate the code between \"lastGeneratedColumn\" and\n// \"mapping.generatedColumn\" with \"lastMapping\"\nvar nextLine=remainingLines[remainingLinesIndex]||'';var code=nextLine.substr(0,mapping.generatedColumn-lastGeneratedColumn);remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn-lastGeneratedColumn);lastGeneratedColumn=mapping.generatedColumn;addMappingWithCode(lastMapping,code);// No more remaining code, continue\nlastMapping=mapping;return;}}// We add the generated code until the first mapping\n// to the SourceNode without any mapping.\n// Each line is added as separate string.\nwhile(lastGeneratedLine<mapping.generatedLine){node.add(shiftNextLine());lastGeneratedLine++;}if(lastGeneratedColumn<mapping.generatedColumn){var nextLine=remainingLines[remainingLinesIndex]||'';node.add(nextLine.substr(0,mapping.generatedColumn));remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn);lastGeneratedColumn=mapping.generatedColumn;}lastMapping=mapping;},this);// We have processed all mappings.\nif(remainingLinesIndex<remainingLines.length){if(lastMapping){// Associate the remaining code in the current line with \"lastMapping\"\naddMappingWithCode(lastMapping,shiftNextLine());}// and add the remaining lines without any mapping\nnode.add(remainingLines.splice(remainingLinesIndex).join(\"\"));}// Copy sourcesContent into SourceNode\naSourceMapConsumer.sources.forEach(function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){if(aRelativePath!=null){sourceFile=util.join(aRelativePath,sourceFile);}node.setSourceContent(sourceFile,content);}});return node;function addMappingWithCode(mapping,code){if(mapping===null||mapping.source===undefined){node.add(code);}else{var source=aRelativePath?util.join(aRelativePath,mapping.source):mapping.source;node.add(new SourceNode(mapping.originalLine,mapping.originalColumn,source,code,mapping.name));}}};/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */SourceNode.prototype.add=function SourceNode_add(aChunk){if(Array.isArray(aChunk)){aChunk.forEach(function(chunk){this.add(chunk);},this);}else if(aChunk[isSourceNode]||typeof aChunk===\"string\"){if(aChunk){this.children.push(aChunk);}}else{throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+aChunk);}return this;};/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */SourceNode.prototype.prepend=function SourceNode_prepend(aChunk){if(Array.isArray(aChunk)){for(var i=aChunk.length-1;i>=0;i--){this.prepend(aChunk[i]);}}else if(aChunk[isSourceNode]||typeof aChunk===\"string\"){this.children.unshift(aChunk);}else{throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+aChunk);}return this;};/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */SourceNode.prototype.walk=function SourceNode_walk(aFn){var chunk;for(var i=0,len=this.children.length;i<len;i++){chunk=this.children[i];if(chunk[isSourceNode]){chunk.walk(aFn);}else{if(chunk!==''){aFn(chunk,{source:this.source,line:this.line,column:this.column,name:this.name});}}}};/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */SourceNode.prototype.join=function SourceNode_join(aSep){var newChildren;var i;var len=this.children.length;if(len>0){newChildren=[];for(i=0;i<len-1;i++){newChildren.push(this.children[i]);newChildren.push(aSep);}newChildren.push(this.children[i]);this.children=newChildren;}return this;};/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */SourceNode.prototype.replaceRight=function SourceNode_replaceRight(aPattern,aReplacement){var lastChild=this.children[this.children.length-1];if(lastChild[isSourceNode]){lastChild.replaceRight(aPattern,aReplacement);}else if(typeof lastChild==='string'){this.children[this.children.length-1]=lastChild.replace(aPattern,aReplacement);}else{this.children.push(''.replace(aPattern,aReplacement));}return this;};/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */SourceNode.prototype.setSourceContent=function SourceNode_setSourceContent(aSourceFile,aSourceContent){this.sourceContents[util.toSetString(aSourceFile)]=aSourceContent;};/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */SourceNode.prototype.walkSourceContents=function SourceNode_walkSourceContents(aFn){for(var i=0,len=this.children.length;i<len;i++){if(this.children[i][isSourceNode]){this.children[i].walkSourceContents(aFn);}}var sources=Object.keys(this.sourceContents);for(var i=0,len=sources.length;i<len;i++){aFn(util.fromSetString(sources[i]),this.sourceContents[sources[i]]);}};/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */SourceNode.prototype.toString=function SourceNode_toString(){var str=\"\";this.walk(function(chunk){str+=chunk;});return str;};/**\n * Returns the string representation of this source node along with a source\n * map.\n */SourceNode.prototype.toStringWithSourceMap=function SourceNode_toStringWithSourceMap(aArgs){var generated={code:\"\",line:1,column:0};var map=new SourceMapGenerator(aArgs);var sourceMappingActive=false;var lastOriginalSource=null;var lastOriginalLine=null;var lastOriginalColumn=null;var lastOriginalName=null;this.walk(function(chunk,original){generated.code+=chunk;if(original.source!==null&&original.line!==null&&original.column!==null){if(lastOriginalSource!==original.source||lastOriginalLine!==original.line||lastOriginalColumn!==original.column||lastOriginalName!==original.name){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name});}lastOriginalSource=original.source;lastOriginalLine=original.line;lastOriginalColumn=original.column;lastOriginalName=original.name;sourceMappingActive=true;}else if(sourceMappingActive){map.addMapping({generated:{line:generated.line,column:generated.column}});lastOriginalSource=null;sourceMappingActive=false;}for(var idx=0,length=chunk.length;idx<length;idx++){if(chunk.charCodeAt(idx)===NEWLINE_CODE){generated.line++;generated.column=0;// Mappings end at eol\nif(idx+1===length){lastOriginalSource=null;sourceMappingActive=false;}else if(sourceMappingActive){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name});}}else{generated.column++;}}});this.walkSourceContents(function(sourceFile,sourceContent){map.setSourceContent(sourceFile,sourceContent);});return{code:generated.code,map:map};};exports.SourceNode=SourceNode;},{\"./source-map-generator\":204,\"./util\":206}],206:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ /**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */function getArg(aArgs,aName,aDefaultValue){if(aName in aArgs){return aArgs[aName];}else if(arguments.length===3){return aDefaultValue;}else{throw new Error('\"'+aName+'\" is a required argument.');}}exports.getArg=getArg;var urlRegexp=/^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;var dataUrlRegexp=/^data:.+\\,.+$/;function urlParse(aUrl){var match=aUrl.match(urlRegexp);if(!match){return null;}return{scheme:match[1],auth:match[2],host:match[3],port:match[4],path:match[5]};}exports.urlParse=urlParse;function urlGenerate(aParsedUrl){var url='';if(aParsedUrl.scheme){url+=aParsedUrl.scheme+':';}url+='//';if(aParsedUrl.auth){url+=aParsedUrl.auth+'@';}if(aParsedUrl.host){url+=aParsedUrl.host;}if(aParsedUrl.port){url+=\":\"+aParsedUrl.port;}if(aParsedUrl.path){url+=aParsedUrl.path;}return url;}exports.urlGenerate=urlGenerate;/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */function normalize(aPath){var path=aPath;var url=urlParse(aPath);if(url){if(!url.path){return aPath;}path=url.path;}var isAbsolute=exports.isAbsolute(path);var parts=path.split(/\\/+/);for(var part,up=0,i=parts.length-1;i>=0;i--){part=parts[i];if(part==='.'){parts.splice(i,1);}else if(part==='..'){up++;}else if(up>0){if(part===''){// The first part is blank if the path is absolute. Trying to go\n// above the root is a no-op. Therefore we can remove all '..' parts\n// directly after the root.\nparts.splice(i+1,up);up=0;}else{parts.splice(i,2);up--;}}}path=parts.join('/');if(path===''){path=isAbsolute?'/':'.';}if(url){url.path=path;return urlGenerate(url);}return path;}exports.normalize=normalize;/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */function join(aRoot,aPath){if(aRoot===\"\"){aRoot=\".\";}if(aPath===\"\"){aPath=\".\";}var aPathUrl=urlParse(aPath);var aRootUrl=urlParse(aRoot);if(aRootUrl){aRoot=aRootUrl.path||'/';}// `join(foo, '//www.example.org')`\nif(aPathUrl&&!aPathUrl.scheme){if(aRootUrl){aPathUrl.scheme=aRootUrl.scheme;}return urlGenerate(aPathUrl);}if(aPathUrl||aPath.match(dataUrlRegexp)){return aPath;}// `join('http://', 'www.example.com')`\nif(aRootUrl&&!aRootUrl.host&&!aRootUrl.path){aRootUrl.host=aPath;return urlGenerate(aRootUrl);}var joined=aPath.charAt(0)==='/'?aPath:normalize(aRoot.replace(/\\/+$/,'')+'/'+aPath);if(aRootUrl){aRootUrl.path=joined;return urlGenerate(aRootUrl);}return joined;}exports.join=join;exports.isAbsolute=function(aPath){return aPath.charAt(0)==='/'||urlRegexp.test(aPath);};/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */function relative(aRoot,aPath){if(aRoot===\"\"){aRoot=\".\";}aRoot=aRoot.replace(/\\/$/,'');// It is possible for the path to be above the root. In this case, simply\n// checking whether the root is a prefix of the path won't work. Instead, we\n// need to remove components from the root one by one, until either we find\n// a prefix that fits, or we run out of components to remove.\nvar level=0;while(aPath.indexOf(aRoot+'/')!==0){var index=aRoot.lastIndexOf(\"/\");if(index<0){return aPath;}// If the only part of the root that is left is the scheme (i.e. http://,\n// file:///, etc.), one or more slashes (/), or simply nothing at all, we\n// have exhausted all components, so the path is not relative to the root.\naRoot=aRoot.slice(0,index);if(aRoot.match(/^([^\\/]+:\\/)?\\/*$/)){return aPath;}++level;}// Make sure we add a \"../\" for each component we removed from the root.\nreturn Array(level+1).join(\"../\")+aPath.substr(aRoot.length+1);}exports.relative=relative;var supportsNullProto=function(){var obj=Object.create(null);return!('__proto__'in obj);}();function identity(s){return s;}/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */function toSetString(aStr){if(isProtoString(aStr)){return'$'+aStr;}return aStr;}exports.toSetString=supportsNullProto?identity:toSetString;function fromSetString(aStr){if(isProtoString(aStr)){return aStr.slice(1);}return aStr;}exports.fromSetString=supportsNullProto?identity:fromSetString;function isProtoString(s){if(!s){return false;}var length=s.length;if(length<9/* \"__proto__\".length */){return false;}if(s.charCodeAt(length-1)!==95/* '_' */||s.charCodeAt(length-2)!==95/* '_' */||s.charCodeAt(length-3)!==111/* 'o' */||s.charCodeAt(length-4)!==116/* 't' */||s.charCodeAt(length-5)!==111/* 'o' */||s.charCodeAt(length-6)!==114/* 'r' */||s.charCodeAt(length-7)!==112/* 'p' */||s.charCodeAt(length-8)!==95/* '_' */||s.charCodeAt(length-9)!==95/* '_' */){return false;}for(var i=length-10;i>=0;i--){if(s.charCodeAt(i)!==36/* '$' */){return false;}}return true;}/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */function compareByOriginalPositions(mappingA,mappingB,onlyCompareOriginal){var cmp=strcmp(mappingA.source,mappingB.source);if(cmp!==0){return cmp;}cmp=mappingA.originalLine-mappingB.originalLine;if(cmp!==0){return cmp;}cmp=mappingA.originalColumn-mappingB.originalColumn;if(cmp!==0||onlyCompareOriginal){return cmp;}cmp=mappingA.generatedColumn-mappingB.generatedColumn;if(cmp!==0){return cmp;}cmp=mappingA.generatedLine-mappingB.generatedLine;if(cmp!==0){return cmp;}return strcmp(mappingA.name,mappingB.name);}exports.compareByOriginalPositions=compareByOriginalPositions;/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */function compareByGeneratedPositionsDeflated(mappingA,mappingB,onlyCompareGenerated){var cmp=mappingA.generatedLine-mappingB.generatedLine;if(cmp!==0){return cmp;}cmp=mappingA.generatedColumn-mappingB.generatedColumn;if(cmp!==0||onlyCompareGenerated){return cmp;}cmp=strcmp(mappingA.source,mappingB.source);if(cmp!==0){return cmp;}cmp=mappingA.originalLine-mappingB.originalLine;if(cmp!==0){return cmp;}cmp=mappingA.originalColumn-mappingB.originalColumn;if(cmp!==0){return cmp;}return strcmp(mappingA.name,mappingB.name);}exports.compareByGeneratedPositionsDeflated=compareByGeneratedPositionsDeflated;function strcmp(aStr1,aStr2){if(aStr1===aStr2){return 0;}if(aStr1===null){return 1;// aStr2 !== null\n}if(aStr2===null){return-1;// aStr1 !== null\n}if(aStr1>aStr2){return 1;}return-1;}/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */function compareByGeneratedPositionsInflated(mappingA,mappingB){var cmp=mappingA.generatedLine-mappingB.generatedLine;if(cmp!==0){return cmp;}cmp=mappingA.generatedColumn-mappingB.generatedColumn;if(cmp!==0){return cmp;}cmp=strcmp(mappingA.source,mappingB.source);if(cmp!==0){return cmp;}cmp=mappingA.originalLine-mappingB.originalLine;if(cmp!==0){return cmp;}cmp=mappingA.originalColumn-mappingB.originalColumn;if(cmp!==0){return cmp;}return strcmp(mappingA.name,mappingB.name);}exports.compareByGeneratedPositionsInflated=compareByGeneratedPositionsInflated;/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */function parseSourceMapInput(str){return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/,''));}exports.parseSourceMapInput=parseSourceMapInput;/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */function computeSourceURL(sourceRoot,sourceURL,sourceMapURL){sourceURL=sourceURL||'';if(sourceRoot){// This follows what Chrome does.\nif(sourceRoot[sourceRoot.length-1]!=='/'&&sourceURL[0]!=='/'){sourceRoot+='/';}// The spec says:\n//   Line 4: An optional source root, useful for relocating source\n//   files on a server or removing repeated values in the\n//   sources entry.  This value is prepended to the individual\n//   entries in the source field.\nsourceURL=sourceRoot+sourceURL;}// Historically, SourceMapConsumer did not take the sourceMapURL as\n// a parameter.  This mode is still somewhat supported, which is why\n// this code block is conditional.  However, it's preferable to pass\n// the source map URL to SourceMapConsumer, so that this function\n// can implement the source URL resolution algorithm as outlined in\n// the spec.  This block is basically the equivalent of:\n//    new URL(sourceURL, sourceMapURL).toString()\n// ... except it avoids using URL, which wasn't available in the\n// older releases of node still supported by this library.\n//\n// The spec says:\n//   If the sources are not absolute URLs after prepending of the\n//   sourceRoot, the sources are resolved relative to the\n//   SourceMap (like resolving script src in a html document).\nif(sourceMapURL){var parsed=urlParse(sourceMapURL);if(!parsed){throw new Error(\"sourceMapURL could not be parsed\");}if(parsed.path){// Strip the last path component, but keep the \"/\".\nvar index=parsed.path.lastIndexOf('/');if(index>=0){parsed.path=parsed.path.substring(0,index+1);}}sourceURL=join(urlGenerate(parsed),sourceURL);}return normalize(sourceURL);}exports.computeSourceURL=computeSourceURL;},{}],207:[function(require,module,exports){/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */exports.SourceMapGenerator=require('./lib/source-map-generator').SourceMapGenerator;exports.SourceMapConsumer=require('./lib/source-map-consumer').SourceMapConsumer;exports.SourceNode=require('./lib/source-node').SourceNode;},{\"./lib/source-map-consumer\":203,\"./lib/source-map-generator\":204,\"./lib/source-node\":205}],208:[function(require,module,exports){'use strict';var integerRegex=/^\\d+$/;function deepUnique(array){return array.sort().filter(function(element,index){return JSON.stringify(element)!==JSON.stringify(array[index-1]);});}exports.parse=function(string){return deepUnique(string.split(',').map(function(part){var result={};part.trim().split(/\\s+/).forEach(function(element,index){if(index===0){result.url=element;return;}var value=element.slice(0,element.length-1);var postfix=element[element.length-1];var integerValue=parseInt(value,10);var floatValue=parseFloat(value);if(postfix==='w'&&integerRegex.test(value)){result.width=integerValue;}else if(postfix==='h'&&integerRegex.test(value)){result.height=integerValue;}else if(postfix==='x'&&!Number.isNaN(floatValue)){result.density=floatValue;}else{throw new Error(\"Invalid srcset descriptor: \".concat(element));}});return result;}));};exports.stringify=function(array){return _toConsumableArray(new Set(array.map(function(element){if(!element.url){throw new Error('URL is required');}var result=[element.url];if(element.width){result.push(\"\".concat(element.width,\"w\"));}if(element.height){result.push(\"\".concat(element.height,\"h\"));}if(element.density){result.push(\"\".concat(element.density,\"x\"));}return result.join(' ');}))).join(', ');};},{}],209:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';var punycode=require('punycode');var util=require('./util');exports.parse=urlParse;exports.resolve=urlResolve;exports.resolveObject=urlResolveObject;exports.format=urlFormat;exports.Url=Url;function Url(){this.protocol=null;this.slashes=null;this.auth=null;this.host=null;this.port=null;this.hostname=null;this.hash=null;this.search=null;this.query=null;this.pathname=null;this.path=null;this.href=null;}// Reference: RFC 3986, RFC 1808, RFC 2396\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern=/^([a-z0-9.+-]+:)/i,portPattern=/:[0-9]*$/,// Special case for a simple path URL\nsimplePathPattern=/^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,// RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\ndelims=['<','>','\"','`',' ','\\r','\\n','\\t'],// RFC 2396: characters not allowed for various reasons.\nunwise=['{','}','|','\\\\','^','`'].concat(delims),// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\nautoEscape=['\\''].concat(unwise),// Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\nnonHostChars=['%','/','?',';','#'].concat(autoEscape),hostEndingChars=['/','?','#'],hostnameMaxLen=255,hostnamePartPattern=/^[+a-z0-9A-Z_-]{0,63}$/,hostnamePartStart=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,// protocols that can allow \"unsafe\" and \"unwise\" chars.\nunsafeProtocol={'javascript':true,'javascript:':true},// protocols that never have a hostname.\nhostlessProtocol={'javascript':true,'javascript:':true},// protocols that always contain a // bit.\nslashedProtocol={'http':true,'https':true,'ftp':true,'gopher':true,'file':true,'http:':true,'https:':true,'ftp:':true,'gopher:':true,'file:':true},querystring=require('querystring');function urlParse(url,parseQueryString,slashesDenoteHost){if(url&&util.isObject(url)&&url instanceof Url)return url;var u=new Url();u.parse(url,parseQueryString,slashesDenoteHost);return u;}Url.prototype.parse=function(url,parseQueryString,slashesDenoteHost){if(!util.isString(url)){throw new TypeError(\"Parameter 'url' must be a string, not \"+_typeof(url));}// Copy chrome, IE, opera backslash-handling behavior.\n// Back slashes before the query string get converted to forward slashes\n// See: https://code.google.com/p/chromium/issues/detail?id=25916\nvar queryIndex=url.indexOf('?'),splitter=queryIndex!==-1&&queryIndex<url.indexOf('#')?'?':'#',uSplit=url.split(splitter),slashRegex=/\\\\/g;uSplit[0]=uSplit[0].replace(slashRegex,'/');url=uSplit.join(splitter);var rest=url;// trim before proceeding.\n// This is to support parse stuff like \"  http://foo.com  \\n\"\nrest=rest.trim();if(!slashesDenoteHost&&url.split('#').length===1){// Try fast path regexp\nvar simplePath=simplePathPattern.exec(rest);if(simplePath){this.path=rest;this.href=rest;this.pathname=simplePath[1];if(simplePath[2]){this.search=simplePath[2];if(parseQueryString){this.query=querystring.parse(this.search.substr(1));}else{this.query=this.search.substr(1);}}else if(parseQueryString){this.search='';this.query={};}return this;}}var proto=protocolPattern.exec(rest);if(proto){proto=proto[0];var lowerProto=proto.toLowerCase();this.protocol=lowerProto;rest=rest.substr(proto.length);}// figure out if it's got a host\n// user@server is *always* interpreted as a hostname, and url\n// resolution will treat //foo/bar as host=foo,path=bar because that's\n// how the browser resolves relative URLs.\nif(slashesDenoteHost||proto||rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)){var slashes=rest.substr(0,2)==='//';if(slashes&&!(proto&&hostlessProtocol[proto])){rest=rest.substr(2);this.slashes=true;}}if(!hostlessProtocol[proto]&&(slashes||proto&&!slashedProtocol[proto])){// there's a hostname.\n// the first instance of /, ?, ;, or # ends the host.\n//\n// If there is an @ in the hostname, then non-host chars *are* allowed\n// to the left of the last @ sign, unless some host-ending character\n// comes *before* the @-sign.\n// URLs are obnoxious.\n//\n// ex:\n// http://a@b@c/ => user:a@b host:c\n// http://a@b?@c => user:a host:c path:/?@c\n// v0.12 TODO(isaacs): This is not quite how Chrome does things.\n// Review our test case against browsers more comprehensively.\n// find the first instance of any hostEndingChars\nvar hostEnd=-1;for(var i=0;i<hostEndingChars.length;i++){var hec=rest.indexOf(hostEndingChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd))hostEnd=hec;}// at this point, either we have an explicit point where the\n// auth portion cannot go past, or the last @ char is the decider.\nvar auth,atSign;if(hostEnd===-1){// atSign can be anywhere.\natSign=rest.lastIndexOf('@');}else{// atSign must be in auth portion.\n// http://a@b/c@d => host:b auth:a path:/c@d\natSign=rest.lastIndexOf('@',hostEnd);}// Now we have a portion which is definitely the auth.\n// Pull that off.\nif(atSign!==-1){auth=rest.slice(0,atSign);rest=rest.slice(atSign+1);this.auth=decodeURIComponent(auth);}// the host is the remaining to the left of the first non-host char\nhostEnd=-1;for(var i=0;i<nonHostChars.length;i++){var hec=rest.indexOf(nonHostChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd))hostEnd=hec;}// if we still have not hit it, then the entire thing is a host.\nif(hostEnd===-1)hostEnd=rest.length;this.host=rest.slice(0,hostEnd);rest=rest.slice(hostEnd);// pull out port.\nthis.parseHost();// we've indicated that there is a hostname,\n// so even if it's empty, it has to be present.\nthis.hostname=this.hostname||'';// if hostname begins with [ and ends with ]\n// assume that it's an IPv6 address.\nvar ipv6Hostname=this.hostname[0]==='['&&this.hostname[this.hostname.length-1]===']';// validate a little.\nif(!ipv6Hostname){var hostparts=this.hostname.split(/\\./);for(var i=0,l=hostparts.length;i<l;i++){var part=hostparts[i];if(!part)continue;if(!part.match(hostnamePartPattern)){var newpart='';for(var j=0,k=part.length;j<k;j++){if(part.charCodeAt(j)>127){// we replace non-ASCII char with a temporary placeholder\n// we need this to make sure size of hostname is not\n// broken by replacing non-ASCII by nothing\nnewpart+='x';}else{newpart+=part[j];}}// we test again with ASCII char only\nif(!newpart.match(hostnamePartPattern)){var validParts=hostparts.slice(0,i);var notHost=hostparts.slice(i+1);var bit=part.match(hostnamePartStart);if(bit){validParts.push(bit[1]);notHost.unshift(bit[2]);}if(notHost.length){rest='/'+notHost.join('.')+rest;}this.hostname=validParts.join('.');break;}}}}if(this.hostname.length>hostnameMaxLen){this.hostname='';}else{// hostnames are always lower case.\nthis.hostname=this.hostname.toLowerCase();}if(!ipv6Hostname){// IDNA Support: Returns a punycoded representation of \"domain\".\n// It only converts parts of the domain name that\n// have non-ASCII characters, i.e. it doesn't matter if\n// you call it with a domain that already is ASCII-only.\nthis.hostname=punycode.toASCII(this.hostname);}var p=this.port?':'+this.port:'';var h=this.hostname||'';this.host=h+p;this.href+=this.host;// strip [ and ] from the hostname\n// the host field still retains them, though\nif(ipv6Hostname){this.hostname=this.hostname.substr(1,this.hostname.length-2);if(rest[0]!=='/'){rest='/'+rest;}}}// now rest is set to the post-host stuff.\n// chop off any delim chars.\nif(!unsafeProtocol[lowerProto]){// First, make 100% sure that any \"autoEscape\" chars get\n// escaped, even if encodeURIComponent doesn't think they\n// need to be.\nfor(var i=0,l=autoEscape.length;i<l;i++){var ae=autoEscape[i];if(rest.indexOf(ae)===-1)continue;var esc=encodeURIComponent(ae);if(esc===ae){esc=escape(ae);}rest=rest.split(ae).join(esc);}}// chop off from the tail first.\nvar hash=rest.indexOf('#');if(hash!==-1){// got a fragment string.\nthis.hash=rest.substr(hash);rest=rest.slice(0,hash);}var qm=rest.indexOf('?');if(qm!==-1){this.search=rest.substr(qm);this.query=rest.substr(qm+1);if(parseQueryString){this.query=querystring.parse(this.query);}rest=rest.slice(0,qm);}else if(parseQueryString){// no query string, but parseQueryString still requested\nthis.search='';this.query={};}if(rest)this.pathname=rest;if(slashedProtocol[lowerProto]&&this.hostname&&!this.pathname){this.pathname='/';}//to support http.request\nif(this.pathname||this.search){var p=this.pathname||'';var s=this.search||'';this.path=p+s;}// finally, reconstruct the href based on what has been validated.\nthis.href=this.format();return this;};// format a parsed object into a url string\nfunction urlFormat(obj){// ensure it's an object, and not a string url.\n// If it's an obj, this is a no-op.\n// this way, you can call url_format() on strings\n// to clean up potentially wonky urls.\nif(util.isString(obj))obj=urlParse(obj);if(!(obj instanceof Url))return Url.prototype.format.call(obj);return obj.format();}Url.prototype.format=function(){var auth=this.auth||'';if(auth){auth=encodeURIComponent(auth);auth=auth.replace(/%3A/i,':');auth+='@';}var protocol=this.protocol||'',pathname=this.pathname||'',hash=this.hash||'',host=false,query='';if(this.host){host=auth+this.host;}else if(this.hostname){host=auth+(this.hostname.indexOf(':')===-1?this.hostname:'['+this.hostname+']');if(this.port){host+=':'+this.port;}}if(this.query&&util.isObject(this.query)&&Object.keys(this.query).length){query=querystring.stringify(this.query);}var search=this.search||query&&'?'+query||'';if(protocol&&protocol.substr(-1)!==':')protocol+=':';// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n// unless they had them to begin with.\nif(this.slashes||(!protocol||slashedProtocol[protocol])&&host!==false){host='//'+(host||'');if(pathname&&pathname.charAt(0)!=='/')pathname='/'+pathname;}else if(!host){host='';}if(hash&&hash.charAt(0)!=='#')hash='#'+hash;if(search&&search.charAt(0)!=='?')search='?'+search;pathname=pathname.replace(/[?#]/g,function(match){return encodeURIComponent(match);});search=search.replace('#','%23');return protocol+host+pathname+search+hash;};function urlResolve(source,relative){return urlParse(source,false,true).resolve(relative);}Url.prototype.resolve=function(relative){return this.resolveObject(urlParse(relative,false,true)).format();};function urlResolveObject(source,relative){if(!source)return relative;return urlParse(source,false,true).resolveObject(relative);}Url.prototype.resolveObject=function(relative){if(util.isString(relative)){var rel=new Url();rel.parse(relative,false,true);relative=rel;}var result=new Url();var tkeys=Object.keys(this);for(var tk=0;tk<tkeys.length;tk++){var tkey=tkeys[tk];result[tkey]=this[tkey];}// hash is always overridden, no matter what.\n// even href=\"\" will remove it.\nresult.hash=relative.hash;// if the relative url is empty, then there's nothing left to do here.\nif(relative.href===''){result.href=result.format();return result;}// hrefs like //foo/bar always cut to the protocol.\nif(relative.slashes&&!relative.protocol){// take everything except the protocol from relative\nvar rkeys=Object.keys(relative);for(var rk=0;rk<rkeys.length;rk++){var rkey=rkeys[rk];if(rkey!=='protocol')result[rkey]=relative[rkey];}//urlParse appends trailing / to urls like http://www.example.com\nif(slashedProtocol[result.protocol]&&result.hostname&&!result.pathname){result.path=result.pathname='/';}result.href=result.format();return result;}if(relative.protocol&&relative.protocol!==result.protocol){// if it's a known url protocol, then changing\n// the protocol does weird things\n// first, if it's not file:, then we MUST have a host,\n// and if there was a path\n// to begin with, then we MUST have a path.\n// if it is file:, then the host is dropped,\n// because that's known to be hostless.\n// anything else is assumed to be absolute.\nif(!slashedProtocol[relative.protocol]){var keys=Object.keys(relative);for(var v=0;v<keys.length;v++){var k=keys[v];result[k]=relative[k];}result.href=result.format();return result;}result.protocol=relative.protocol;if(!relative.host&&!hostlessProtocol[relative.protocol]){var relPath=(relative.pathname||'').split('/');while(relPath.length&&!(relative.host=relPath.shift())){;}if(!relative.host)relative.host='';if(!relative.hostname)relative.hostname='';if(relPath[0]!=='')relPath.unshift('');if(relPath.length<2)relPath.unshift('');result.pathname=relPath.join('/');}else{result.pathname=relative.pathname;}result.search=relative.search;result.query=relative.query;result.host=relative.host||'';result.auth=relative.auth;result.hostname=relative.hostname||relative.host;result.port=relative.port;// to support http.request\nif(result.pathname||result.search){var p=result.pathname||'';var s=result.search||'';result.path=p+s;}result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;}var isSourceAbs=result.pathname&&result.pathname.charAt(0)==='/',isRelAbs=relative.host||relative.pathname&&relative.pathname.charAt(0)==='/',mustEndAbs=isRelAbs||isSourceAbs||result.host&&relative.pathname,removeAllDots=mustEndAbs,srcPath=result.pathname&&result.pathname.split('/')||[],relPath=relative.pathname&&relative.pathname.split('/')||[],psychotic=result.protocol&&!slashedProtocol[result.protocol];// if the url is a non-slashed url, then relative\n// links like ../.. should be able\n// to crawl up to the hostname, as well.  This is strange.\n// result.protocol has already been set by now.\n// Later on, put the first path part into the host field.\nif(psychotic){result.hostname='';result.port=null;if(result.host){if(srcPath[0]==='')srcPath[0]=result.host;else srcPath.unshift(result.host);}result.host='';if(relative.protocol){relative.hostname=null;relative.port=null;if(relative.host){if(relPath[0]==='')relPath[0]=relative.host;else relPath.unshift(relative.host);}relative.host=null;}mustEndAbs=mustEndAbs&&(relPath[0]===''||srcPath[0]==='');}if(isRelAbs){// it's absolute.\nresult.host=relative.host||relative.host===''?relative.host:result.host;result.hostname=relative.hostname||relative.hostname===''?relative.hostname:result.hostname;result.search=relative.search;result.query=relative.query;srcPath=relPath;// fall through to the dot-handling below.\n}else if(relPath.length){// it's relative\n// throw away the existing file, and take the new path instead.\nif(!srcPath)srcPath=[];srcPath.pop();srcPath=srcPath.concat(relPath);result.search=relative.search;result.query=relative.query;}else if(!util.isNullOrUndefined(relative.search)){// just pull out the search.\n// like href='?foo'.\n// Put this after the other two cases because it simplifies the booleans\nif(psychotic){result.hostname=result.host=srcPath.shift();//occationaly the auth can get stuck only in host\n//this especially happens in cases like\n//url.resolveObject('mailto:local1@domain1', 'local2@domain2')\nvar authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.host=result.hostname=authInHost.shift();}}result.search=relative.search;result.query=relative.query;//to support http.request\nif(!util.isNull(result.pathname)||!util.isNull(result.search)){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.href=result.format();return result;}if(!srcPath.length){// no path at all.  easy.\n// we've already handled the other stuff above.\nresult.pathname=null;//to support http.request\nif(result.search){result.path='/'+result.search;}else{result.path=null;}result.href=result.format();return result;}// if a url ENDs in . or .., then it must get a trailing slash.\n// however, if it ends in anything else non-slashy,\n// then it must NOT get a trailing slash.\nvar last=srcPath.slice(-1)[0];var hasTrailingSlash=(result.host||relative.host||srcPath.length>1)&&(last==='.'||last==='..')||last==='';// strip single dots, resolve double dots to parent dir\n// if the path tries to go above the root, `up` ends up > 0\nvar up=0;for(var i=srcPath.length;i>=0;i--){last=srcPath[i];if(last==='.'){srcPath.splice(i,1);}else if(last==='..'){srcPath.splice(i,1);up++;}else if(up){srcPath.splice(i,1);up--;}}// if the path is allowed to go above the root, restore leading ..s\nif(!mustEndAbs&&!removeAllDots){for(;up--;up){srcPath.unshift('..');}}if(mustEndAbs&&srcPath[0]!==''&&(!srcPath[0]||srcPath[0].charAt(0)!=='/')){srcPath.unshift('');}if(hasTrailingSlash&&srcPath.join('/').substr(-1)!=='/'){srcPath.push('');}var isAbsolute=srcPath[0]===''||srcPath[0]&&srcPath[0].charAt(0)==='/';// put the host back\nif(psychotic){result.hostname=result.host=isAbsolute?'':srcPath.length?srcPath.shift():'';//occationaly the auth can get stuck only in host\n//this especially happens in cases like\n//url.resolveObject('mailto:local1@domain1', 'local2@domain2')\nvar authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.host=result.hostname=authInHost.shift();}}mustEndAbs=mustEndAbs||result.host&&srcPath.length;if(mustEndAbs&&!isAbsolute){srcPath.unshift('');}if(!srcPath.length){result.pathname=null;result.path=null;}else{result.pathname=srcPath.join('/');}//to support request.http\nif(!util.isNull(result.pathname)||!util.isNull(result.search)){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.auth=relative.auth||result.auth;result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;};Url.prototype.parseHost=function(){var host=this.host;var port=portPattern.exec(host);if(port){port=port[0];if(port!==':'){this.port=port.substr(1);}host=host.substr(0,host.length-port.length);}if(host)this.hostname=host;};},{\"./util\":210,\"punycode\":193,\"querystring\":196}],210:[function(require,module,exports){'use strict';module.exports={isString:function isString(arg){return typeof arg==='string';},isObject:function isObject(arg){return _typeof(arg)==='object'&&arg!==null;},isNull:function isNull(arg){return arg===null;},isNullOrUndefined:function isNullOrUndefined(arg){return arg==null;}};},{}],211:[function(require,module,exports){/* eslint-disable no-useless-escape */var htmlparser=require('htmlparser2');var quoteRegexp=require('lodash/escapeRegExp');var cloneDeep=require('lodash/cloneDeep');var mergeWith=require('lodash/mergeWith');var isString=require('lodash/isString');var isPlainObject=require('lodash/isPlainObject');var srcset=require('srcset');var postcss=require('postcss');var url=require('url');// Tags that can conceivably represent stand-alone media.\nvar mediaTags=['img','audio','video','picture','svg','object','map','iframe','embed'];// Tags that are inherently vulnerable to being used in XSS attacks.\nvar vulnerableTags=['script','style'];function each(obj,cb){if(obj){Object.keys(obj).forEach(function(key){cb(obj[key],key);});}}// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj,key){return{}.hasOwnProperty.call(obj,key);}// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a,cb){var n=[];each(a,function(v){if(cb(v)){n.push(v);}});return n;}function isEmptyObject(obj){for(var key in obj){if(has(obj,key)){return false;}}return true;}module.exports=sanitizeHtml;// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nvar VALID_HTML_ATTRIBUTE_NAME=/^[^\\0\\t\\n\\f\\r /<=>]+$/;// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\nfunction sanitizeHtml(html,options,_recursing){var result='';// Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\nvar tempResult='';function Frame(tag,attribs){var that=this;this.tag=tag;this.attribs=attribs||{};this.tagPosition=result.length;this.text='';// Node inner text\nthis.mediaChildren=[];this.updateParentNodeText=function(){if(stack.length){var parentFrame=stack[stack.length-1];parentFrame.text+=that.text;}};this.updateParentNodeMediaChildren=function(){if(stack.length&&mediaTags.includes(this.tag)){var parentFrame=stack[stack.length-1];parentFrame.mediaChildren.push(this.tag);}};}if(!options){options=sanitizeHtml.defaults;options.parser=htmlParserDefaults;}else{options=Object.assign({},sanitizeHtml.defaults,options);if(options.parser){options.parser=Object.assign({},htmlParserDefaults,options.parser);}else{options.parser=htmlParserDefaults;}}// vulnerableTags\nvulnerableTags.forEach(function(tag){if(options.allowedTags&&options.allowedTags.includes(tag)&&!options.allowVulnerableTags){// eslint-disable-next-line no-console\nconsole.warn(\"\\n\\n\\u26A0\\uFE0F Your `allowedTags` option includes, `\".concat(tag,\"`, which is inherently\\nvulnerable to XSS attacks. Please remove it from `allowedTags`.\\nOr, to disable this warning, add the `allowVulnerableTags` option\\nand ensure you are accounting for this risk.\\n\\n\"));}});// Tags that contain something other than HTML, or where discarding\n// the text when the tag is disallowed makes sense for other reasons.\n// If we are not allowing these tags, we should drop their content too.\n// For other tags you would drop the tag but keep its content.\nvar nonTextTagsArray=options.nonTextTags||['script','style','textarea','option'];var allowedAttributesMap;var allowedAttributesGlobMap;if(options.allowedAttributes){allowedAttributesMap={};allowedAttributesGlobMap={};each(options.allowedAttributes,function(attributes,tag){allowedAttributesMap[tag]=[];var globRegex=[];attributes.forEach(function(obj){if(isString(obj)&&obj.indexOf('*')>=0){globRegex.push(quoteRegexp(obj).replace(/\\\\\\*/g,'.*'));}else{allowedAttributesMap[tag].push(obj);}});allowedAttributesGlobMap[tag]=new RegExp('^('+globRegex.join('|')+')$');});}var allowedClassesMap={};each(options.allowedClasses,function(classes,tag){// Implicitly allows the class attribute\nif(allowedAttributesMap){if(!has(allowedAttributesMap,tag)){allowedAttributesMap[tag]=[];}allowedAttributesMap[tag].push('class');}allowedClassesMap[tag]=classes;});var transformTagsMap={};var transformTagsAll;each(options.transformTags,function(transform,tag){var transFun;if(typeof transform==='function'){transFun=transform;}else if(typeof transform===\"string\"){transFun=sanitizeHtml.simpleTransform(transform);}if(tag==='*'){transformTagsAll=transFun;}else{transformTagsMap[tag]=transFun;}});var depth;var stack;var skipMap;var transformMap;var skipText;var skipTextDepth;initializeState();var parser=new htmlparser.Parser({onopentag:function onopentag(name,attribs){// If `enforceHtmlBoundary` is `true` and this has found the opening\n// `html` tag, reset the state.\nif(options.enforceHtmlBoundary&&name==='html'){initializeState();}if(skipText){skipTextDepth++;return;}var frame=new Frame(name,attribs);stack.push(frame);var skip=false;var hasText=!!frame.text;var transformedTag;if(has(transformTagsMap,name)){transformedTag=transformTagsMap[name](name,attribs);frame.attribs=attribs=transformedTag.attribs;if(transformedTag.text!==undefined){frame.innerText=transformedTag.text;}if(name!==transformedTag.tagName){frame.name=name=transformedTag.tagName;transformMap[depth]=transformedTag.tagName;}}if(transformTagsAll){transformedTag=transformTagsAll(name,attribs);frame.attribs=attribs=transformedTag.attribs;if(name!==transformedTag.tagName){frame.name=name=transformedTag.tagName;transformMap[depth]=transformedTag.tagName;}}if(options.allowedTags&&options.allowedTags.indexOf(name)===-1||options.disallowedTagsMode==='recursiveEscape'&&!isEmptyObject(skipMap)){skip=true;skipMap[depth]=true;if(options.disallowedTagsMode==='discard'){if(nonTextTagsArray.indexOf(name)!==-1){skipText=true;skipTextDepth=1;}}skipMap[depth]=true;}depth++;if(skip){if(options.disallowedTagsMode==='discard'){// We want the contents but not this tag\nreturn;}tempResult=result;result='';}result+='<'+name;if(!allowedAttributesMap||has(allowedAttributesMap,name)||allowedAttributesMap['*']){each(attribs,function(value,a){if(!VALID_HTML_ATTRIBUTE_NAME.test(a)){// This prevents part of an attribute name in the output from being\n// interpreted as the end of an attribute, or end of a tag.\ndelete frame.attribs[a];return;}var parsed;// check allowedAttributesMap for the element and attribute and modify the value\n// as necessary if there are specific values defined.\nvar passedAllowedAttributesMapCheck=false;if(!allowedAttributesMap||has(allowedAttributesMap,name)&&allowedAttributesMap[name].indexOf(a)!==-1||allowedAttributesMap['*']&&allowedAttributesMap['*'].indexOf(a)!==-1||has(allowedAttributesGlobMap,name)&&allowedAttributesGlobMap[name].test(a)||allowedAttributesGlobMap['*']&&allowedAttributesGlobMap['*'].test(a)){passedAllowedAttributesMapCheck=true;}else if(allowedAttributesMap&&allowedAttributesMap[name]){var _iterator10=_createForOfIteratorHelper(allowedAttributesMap[name]),_step;try{for(_iterator10.s();!(_step=_iterator10.n()).done;){var o=_step.value;if(isPlainObject(o)&&o.name&&o.name===a){passedAllowedAttributesMapCheck=true;var newValue='';if(o.multiple===true){// verify the values that are allowed\nvar splitStrArray=value.split(' ');var _iterator11=_createForOfIteratorHelper(splitStrArray),_step2;try{for(_iterator11.s();!(_step2=_iterator11.n()).done;){var s=_step2.value;if(o.values.indexOf(s)!==-1){if(newValue===''){newValue=s;}else{newValue+=' '+s;}}}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}}else if(o.values.indexOf(value)>=0){// verified an allowed value matches the entire attribute value\nnewValue=value;}value=newValue;}}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}}if(passedAllowedAttributesMapCheck){if(options.allowedSchemesAppliedToAttributes.indexOf(a)!==-1){if(naughtyHref(name,value)){delete frame.attribs[a];return;}}if(name==='iframe'&&a==='src'){var allowed=true;try{// naughtyHref is in charge of whether protocol relative URLs\n// are cool. We should just accept them\nparsed=url.parse(value,false,true);var isRelativeUrl=parsed&&parsed.host===null&&parsed.protocol===null;if(isRelativeUrl){// default value of allowIframeRelativeUrls is true\n// unless allowedIframeHostnames or allowedIframeDomains specified\nallowed=has(options,\"allowIframeRelativeUrls\")?options.allowIframeRelativeUrls:!options.allowedIframeHostnames&&!options.allowedIframeDomains;}else if(options.allowedIframeHostnames||options.allowedIframeDomains){var allowedHostname=(options.allowedIframeHostnames||[]).find(function(hostname){return hostname===parsed.hostname;});var allowedDomain=(options.allowedIframeDomains||[]).find(function(domain){return parsed.hostname===domain||parsed.hostname.endsWith(\".\".concat(domain));});allowed=allowedHostname||allowedDomain;}}catch(e){// Unparseable iframe src\nallowed=false;}if(!allowed){delete frame.attribs[a];return;}}if(a==='srcset'){try{parsed=srcset.parse(value);each(parsed,function(value){if(naughtyHref('srcset',value.url)){value.evil=true;}});parsed=filter(parsed,function(v){return!v.evil;});if(!parsed.length){delete frame.attribs[a];return;}else{value=srcset.stringify(filter(parsed,function(v){return!v.evil;}));frame.attribs[a]=value;}}catch(e){// Unparseable srcset\ndelete frame.attribs[a];return;}}if(a==='class'){value=filterClasses(value,allowedClassesMap[name]);if(!value.length){delete frame.attribs[a];return;}}if(a==='style'){try{var abstractSyntaxTree=postcss.parse(name+\" {\"+value+\"}\");var filteredAST=filterCss(abstractSyntaxTree,options.allowedStyles);value=stringifyStyleAttributes(filteredAST);if(value.length===0){delete frame.attribs[a];return;}}catch(e){delete frame.attribs[a];return;}}result+=' '+a;if(value&&value.length){result+='=\"'+escapeHtml(value,true)+'\"';}}else{delete frame.attribs[a];}});}if(options.selfClosing.indexOf(name)!==-1){result+=\" />\";}else{result+=\">\";if(frame.innerText&&!hasText&&!options.textFilter){result+=frame.innerText;}}if(skip){result=tempResult+escapeHtml(result);tempResult='';}},ontext:function ontext(text){if(skipText){return;}var lastFrame=stack[stack.length-1];var tag;if(lastFrame){tag=lastFrame.tag;// If inner text was set by transform function then let's use it\ntext=lastFrame.innerText!==undefined?lastFrame.innerText:text;}if(options.disallowedTagsMode==='discard'&&(tag==='script'||tag==='style')){// htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n// script tags is, by definition, game over for XSS protection, so if that's\n// your concern, don't allow them. The same is essentially true for style tags\n// which have their own collection of XSS vectors.\nresult+=text;}else{var escaped=escapeHtml(text,false);if(options.textFilter){result+=options.textFilter(escaped,tag);}else{result+=escaped;}}if(stack.length){var frame=stack[stack.length-1];frame.text+=text;}},onclosetag:function onclosetag(name){if(skipText){skipTextDepth--;if(!skipTextDepth){skipText=false;}else{return;}}var frame=stack.pop();if(!frame){// Do not crash on bad markup\nreturn;}skipText=options.enforceHtmlBoundary?name==='html':false;depth--;var skip=skipMap[depth];if(skip){delete skipMap[depth];if(options.disallowedTagsMode==='discard'){frame.updateParentNodeText();return;}tempResult=result;result='';}if(transformMap[depth]){name=transformMap[depth];delete transformMap[depth];}if(options.exclusiveFilter&&options.exclusiveFilter(frame)){result=result.substr(0,frame.tagPosition);return;}frame.updateParentNodeMediaChildren();frame.updateParentNodeText();if(options.selfClosing.indexOf(name)!==-1){// Already output />\nif(skip){result=tempResult;tempResult='';}return;}result+=\"</\"+name+\">\";if(skip){result=tempResult+escapeHtml(result);tempResult='';}}},options.parser);parser.write(html);parser.end();return result;function initializeState(){result='';depth=0;stack=[];skipMap={};transformMap={};skipText=false;skipTextDepth=0;}function escapeHtml(s,quote){if(typeof s!=='string'){s=s+'';}if(options.parser.decodeEntities){s=s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/\\>/g,'&gt;');if(quote){s=s.replace(/\\\"/g,'&quot;');}}// TODO: this is inadequate because it will pass `&0;`. This approach\n// will not work, each & must be considered with regard to whether it\n// is followed by a 100% syntactically valid entity or not, and escaped\n// if it is not. If this bothers you, don't set parser.decodeEntities\n// to false. (The default is true.)\ns=s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g,'&amp;')// Match ampersands not part of existing HTML entity\n.replace(/</g,'&lt;').replace(/\\>/g,'&gt;');if(quote){s=s.replace(/\\\"/g,'&quot;');}return s;}function naughtyHref(name,href){// Browsers ignore character codes of 32 (space) and below in a surprising\n// number of situations. Start reading here:\n// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n// eslint-disable-next-line no-control-regex\nhref=href.replace(/[\\x00-\\x20]+/g,'');// Clobber any comments in URLs, which the browser might\n// interpret inside an XML data island, allowing\n// a javascript: URL to be snuck through\nhref=href.replace(/<\\!\\-\\-.*?\\-\\-\\>/g,'');// Case insensitive so we don't get faked out by JAVASCRIPT #1\nvar matches=href.match(/^([a-zA-Z]+)\\:/);if(!matches){// Protocol-relative URL starting with any combination of '/' and '\\'\nif(href.match(/^[\\/\\\\]{2}/)){return!options.allowProtocolRelative;}// No scheme\nreturn false;}var scheme=matches[1].toLowerCase();if(has(options.allowedSchemesByTag,name)){return options.allowedSchemesByTag[name].indexOf(scheme)===-1;}return!options.allowedSchemes||options.allowedSchemes.indexOf(scheme)===-1;}/**\n   * Filters user input css properties by whitelisted regex attributes.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - Abstract Syntax Tree with filtered style attributes.\n   */function filterCss(abstractSyntaxTree,allowedStyles){if(!allowedStyles){return abstractSyntaxTree;}var filteredAST=cloneDeep(abstractSyntaxTree);var astRules=abstractSyntaxTree.nodes[0];var selectedRule;// Merge global and tag-specific styles into new AST.\nif(allowedStyles[astRules.selector]&&allowedStyles['*']){selectedRule=mergeWith(cloneDeep(allowedStyles[astRules.selector]),allowedStyles['*'],function(objValue,srcValue){if(Array.isArray(objValue)){return objValue.concat(srcValue);}});}else{selectedRule=allowedStyles[astRules.selector]||allowedStyles['*'];}if(selectedRule){filteredAST.nodes[0].nodes=astRules.nodes.reduce(filterDeclarations(selectedRule),[]);}return filteredAST;}/**\n   * Extracts the style attribues from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center;font-family:helvetica;\"\n   */function stringifyStyleAttributes(filteredAST){return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes,attributeObject){extractedAttributes.push(attributeObject.prop+':'+attributeObject.value);return extractedAttributes;},[]).join(';');}/**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the whitelist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass whitelisting.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */function filterDeclarations(selectedRule){return function(allowedDeclarationsList,attributeObject){// If this property is whitelisted...\nif(selectedRule.hasOwnProperty(attributeObject.prop)){var matchesRegex=selectedRule[attributeObject.prop].some(function(regularExpression){return regularExpression.test(attributeObject.value);});if(matchesRegex){allowedDeclarationsList.push(attributeObject);}}return allowedDeclarationsList;};}function filterClasses(classes,allowed){if(!allowed){// The class attribute is allowed without filtering on this tag\nreturn classes;}classes=classes.split(/\\s+/);return classes.filter(function(clss){return allowed.indexOf(clss)!==-1;}).join(' ');}}// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\nvar htmlParserDefaults={decodeEntities:true};sanitizeHtml.defaults={allowedTags:['h3','h4','h5','h6','blockquote','p','a','ul','ol','nl','li','b','i','strong','em','strike','abbr','code','hr','br','div','table','thead','caption','tbody','tr','th','td','pre','iframe'],disallowedTagsMode:'discard',allowedAttributes:{a:['href','name','target'],// We don't currently allow img itself by default, but this\n// would make sense if we did. You could add srcset here,\n// and if you do the URL is checked for safety\nimg:['src']},// Lots of these won't come up by default because we don't allow them\nselfClosing:['img','br','hr','area','base','basefont','input','link','meta'],// URL schemes we permit\nallowedSchemes:['http','https','ftp','mailto'],allowedSchemesByTag:{},allowedSchemesAppliedToAttributes:['href','src','cite'],allowProtocolRelative:true,enforceHtmlBoundary:false};sanitizeHtml.simpleTransform=function(newTagName,newAttribs,merge){merge=merge===undefined?true:merge;newAttribs=newAttribs||{};return function(tagName,attribs){var attrib;if(merge){for(attrib in newAttribs){attribs[attrib]=newAttribs[attrib];}}else{attribs=newAttribs;}return{tagName:newTagName,attribs:attribs};};};},{\"htmlparser2\":31,\"lodash/cloneDeep\":140,\"lodash/escapeRegExp\":143,\"lodash/isPlainObject\":155,\"lodash/isString\":157,\"lodash/mergeWith\":162,\"postcss\":180,\"srcset\":208,\"url\":209}]},{},[211])(211);});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuaXRpemUtaHRtbC9kaXN0L3Nhbml0aXplLWh0bWwuanM/MDRlZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxzS0FBYSxzREFBc0QsT0FBTywwREFBMEQseUdBQXlHLFdBQVcsUUFBUSxxQkFBcUIsT0FBTyxtQkFBbUIsc0JBQXNCLFdBQVcsT0FBTywwQkFBMEIsa0JBQWtCLFVBQVUsT0FBTyw4SkFBOEosMkNBQTJDLE9BQU8sZUFBZSx5QkFBeUIsZ0JBQWdCLG1CQUFtQiwyQkFBMkIsYUFBYSxtQkFBbUIsWUFBWSxTQUFTLGdCQUFnQixJQUFJLHlEQUF5RCxRQUFRLHlCQUF5QixpQ0FBaUMsK0dBQStHLDhCQUE4Qiw2SkFBNkosK0NBQStDLGFBQWEsMERBQTBELG9EQUFvRCxvREFBb0QsNkNBQTZDLDJHQUEyRyxnQ0FBZ0MseUZBQXlGLGlDQUFpQyxxREFBcUQsb0NBQW9DLDRDQUE0QyxnQ0FBZ0MsTUFBTSxLQUFLLGdCQUFnQixhQUFhLHNCQUFzQiwwQkFBMEIsa0VBQWtFLDhCQUE4QixxQkFBcUIsS0FBSyw4QkFBOEIsZ0hBQWdILHFCQUFxQixhQUFhLElBQUksTUFBNEIsQ0FBQyxTQUFXLDREQUE0RCxvQkFBb0IsUUFBUSxJQUFzQyxFQUFFLGlDQUFPLEVBQUUsb0NBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQSxvR0FBQyxFQUFFLElBQUksVUFBNEssQ0FBQyxhQUFhLDBCQUEwQixrQkFBa0Isa0JBQWtCLGdCQUFnQixVQUFVLFVBQVUsMENBQTBDLGdCQUFnQixPQUFDLE9BQU8sb0JBQW9CLDhDQUE4QyxtQ0FBbUMsWUFBWSxZQUFZLG1DQUFtQyxpQkFBaUIsZ0JBQWdCLHVCQUF1QixxQkFBcUIsa0RBQWtELFdBQVcsS0FBSyxTQUFTLFVBQVUsVUFBVSxJQUFJLG9DQUFvQyxhQUFhLDhCQUE4QixnQ0FBZ0Msb0NBQW9DLGNBQWMsaUJBQWlCLHlEQUF5RCw0RUFBNEUsNEJBQTRCLE1BQU0sS0FB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a0gsNEJBQTRCLG1DQUFtQyxHQUFHLEtBQUssbUVBQW1FLGlCQUFpQix1RkFBdUYsb0JBQW9CO0FBQ2piO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDLGNBQWMsT0FBTyxzQ0FBc0Msa0JBQWtCLHNCQUFzQjtBQUNuRyxvREFBb0QsdUZBQXVGLHlFQUF5RSw0QkFBNEIsWUFBWSxJQUFJO0FBQ2hRO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTyxzQ0FBc0M7QUFDNUQsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZ0RBQWdELHlEQUF5RDtBQUN6RyxzREFBc0QscUZBQXFGLHNEQUFzRCxFQUFFLGlCQUFpQixnREFBZ0Qsa0NBQWtDLHdDQUF3QyxhQUFhO0FBQzNWLGdCQUFnQiw2QkFBNkIscUNBQXFDLG1DQUFtQyxjQUFjO0FBQ25JO0FBQ0Esd0JBQXdCLHFCQUFxQix1QkFBdUIsd1BBQXdQO0FBQzVUO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxxRUFBcUUsK0dBQStHLG1FQUFtRSxtQ0FBbUMsMEJBQTBCLGlDQUFpQyxXQUFXLFVBQVUsMEJBQTBCLHFDQUFxQyxLQUFLLG9CQUFvQixPQUFPLHlDQUF5QyxFQUFFLCtLQUErSyxFQUFFLEdBQUcsY0FBYyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zYW5pdGl6ZS1odG1sL2Rpc3Qvc2FuaXRpemUtaHRtbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sYWxsb3dBcnJheUxpa2Upe3ZhciBpdDtpZih0eXBlb2YgU3ltYm9sPT09XCJ1bmRlZmluZWRcInx8b1tTeW1ib2wuaXRlcmF0b3JdPT1udWxsKXtpZihBcnJheS5pc0FycmF5KG8pfHwoaXQ9X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKXx8YWxsb3dBcnJheUxpa2UmJm8mJnR5cGVvZiBvLmxlbmd0aD09PVwibnVtYmVyXCIpe2lmKGl0KW89aXQ7dmFyIGk9MDt2YXIgRj1mdW5jdGlvbiBGKCl7fTtyZXR1cm57czpGLG46ZnVuY3Rpb24gbigpe2lmKGk+PW8ubGVuZ3RoKXJldHVybntkb25lOnRydWV9O3JldHVybntkb25lOmZhbHNlLHZhbHVlOm9baSsrXX07fSxlOmZ1bmN0aW9uIGUoX2Upe3Rocm93IF9lO30sZjpGfTt9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO312YXIgbm9ybWFsQ29tcGxldGlvbj10cnVlLGRpZEVycj1mYWxzZSxlcnI7cmV0dXJue3M6ZnVuY3Rpb24gcygpe2l0PW9bU3ltYm9sLml0ZXJhdG9yXSgpO30sbjpmdW5jdGlvbiBuKCl7dmFyIHN0ZXA9aXQubmV4dCgpO25vcm1hbENvbXBsZXRpb249c3RlcC5kb25lO3JldHVybiBzdGVwO30sZTpmdW5jdGlvbiBlKF9lMil7ZGlkRXJyPXRydWU7ZXJyPV9lMjt9LGY6ZnVuY3Rpb24gZigpe3RyeXtpZighbm9ybWFsQ29tcGxldGlvbiYmaXRbXCJyZXR1cm5cIl0hPW51bGwpaXRbXCJyZXR1cm5cIl0oKTt9ZmluYWxseXtpZihkaWRFcnIpdGhyb3cgZXJyO319fTt9ZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycil7cmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpfHxfaXRlcmFibGVUb0FycmF5KGFycil8fF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpfHxfbm9uSXRlcmFibGVTcHJlYWQoKTt9ZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7fWZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLG1pbkxlbil7aWYoIW8pcmV0dXJuO2lmKHR5cGVvZiBvPT09XCJzdHJpbmdcIilyZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobyxtaW5MZW4pO3ZhciBuPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LC0xKTtpZihuPT09XCJPYmplY3RcIiYmby5jb25zdHJ1Y3RvciluPW8uY29uc3RydWN0b3IubmFtZTtpZihuPT09XCJNYXBcInx8bj09PVwiU2V0XCIpcmV0dXJuIEFycmF5LmZyb20obyk7aWYobj09PVwiQXJndW1lbnRzXCJ8fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLG1pbkxlbik7fWZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcil7aWYodHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCImJlN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpcmV0dXJuIEFycmF5LmZyb20oaXRlcik7fWZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpe2lmKEFycmF5LmlzQXJyYXkoYXJyKSlyZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTt9ZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLGxlbil7aWYobGVuPT1udWxsfHxsZW4+YXJyLmxlbmd0aClsZW49YXJyLmxlbmd0aDtmb3IodmFyIGk9MCxhcnIyPW5ldyBBcnJheShsZW4pO2k8bGVuO2krKyl7YXJyMltpXT1hcnJbaV07fXJldHVybiBhcnIyO31mdW5jdGlvbiBfdHlwZW9mKG9iail7XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO2lmKHR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PT1cInN5bWJvbFwiKXtfdHlwZW9mPWZ1bmN0aW9uIF90eXBlb2Yob2JqKXtyZXR1cm4gdHlwZW9mIG9iajt9O31lbHNle190eXBlb2Y9ZnVuY3Rpb24gX3R5cGVvZihvYmope3JldHVybiBvYmomJnR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJm9iai5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmb2JqIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBvYmo7fTt9cmV0dXJuIF90eXBlb2Yob2JqKTt9KGZ1bmN0aW9uKGYpe2lmKCh0eXBlb2YgZXhwb3J0cz09PVwidW5kZWZpbmVkXCI/XCJ1bmRlZmluZWRcIjpfdHlwZW9mKGV4cG9ydHMpKT09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCk7fWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpO31lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvdzt9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWw7fWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGY7fWVsc2V7Zz10aGlzO31nLnNhbml0aXplSHRtbD1mKCk7fX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYTt9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpO30scCxwLmV4cG9ydHMscixlLG4sdCk7fXJldHVybiBuW2ldLmV4cG9ydHM7fWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKyl7byh0W2ldKTt9cmV0dXJuIG87fXJldHVybiByO30oKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7J3VzZSBzdHJpY3QnO2V4cG9ydHMuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO2V4cG9ydHMudG9CeXRlQXJyYXk9dG9CeXRlQXJyYXk7ZXhwb3J0cy5mcm9tQnl0ZUFycmF5PWZyb21CeXRlQXJyYXk7dmFyIGxvb2t1cD1bXTt2YXIgcmV2TG9va3VwPVtdO3ZhciBBcnI9dHlwZW9mIFVpbnQ4QXJyYXkhPT0ndW5kZWZpbmVkJz9VaW50OEFycmF5OkFycmF5O3ZhciBjb2RlPSdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztmb3IodmFyIGk9MCxsZW49Y29kZS5sZW5ndGg7aTxsZW47KytpKXtsb29rdXBbaV09Y29kZVtpXTtyZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXT1pO30vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldPTYyO3Jldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV09NjM7ZnVuY3Rpb24gZ2V0TGVucyhiNjQpe3ZhciBsZW49YjY0Lmxlbmd0aDtpZihsZW4lND4wKXt0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKTt9Ly8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbnZhciB2YWxpZExlbj1iNjQuaW5kZXhPZignPScpO2lmKHZhbGlkTGVuPT09LTEpdmFsaWRMZW49bGVuO3ZhciBwbGFjZUhvbGRlcnNMZW49dmFsaWRMZW49PT1sZW4/MDo0LXZhbGlkTGVuJTQ7cmV0dXJuW3ZhbGlkTGVuLHBsYWNlSG9sZGVyc0xlbl07fS8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aChiNjQpe3ZhciBsZW5zPWdldExlbnMoYjY0KTt2YXIgdmFsaWRMZW49bGVuc1swXTt2YXIgcGxhY2VIb2xkZXJzTGVuPWxlbnNbMV07cmV0dXJuKHZhbGlkTGVuK3BsYWNlSG9sZGVyc0xlbikqMy80LXBsYWNlSG9sZGVyc0xlbjt9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoYjY0LHZhbGlkTGVuLHBsYWNlSG9sZGVyc0xlbil7cmV0dXJuKHZhbGlkTGVuK3BsYWNlSG9sZGVyc0xlbikqMy80LXBsYWNlSG9sZGVyc0xlbjt9ZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0KXt2YXIgdG1wO3ZhciBsZW5zPWdldExlbnMoYjY0KTt2YXIgdmFsaWRMZW49bGVuc1swXTt2YXIgcGxhY2VIb2xkZXJzTGVuPWxlbnNbMV07dmFyIGFycj1uZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCx2YWxpZExlbixwbGFjZUhvbGRlcnNMZW4pKTt2YXIgY3VyQnl0ZT0wOy8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbnZhciBsZW49cGxhY2VIb2xkZXJzTGVuPjA/dmFsaWRMZW4tNDp2YWxpZExlbjt2YXIgaTtmb3IoaT0wO2k8bGVuO2krPTQpe3RtcD1yZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldPDwxOHxyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSsxKV08PDEyfHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKzIpXTw8NnxyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSszKV07YXJyW2N1ckJ5dGUrK109dG1wPj4xNiYweEZGO2FycltjdXJCeXRlKytdPXRtcD4+OCYweEZGO2FycltjdXJCeXRlKytdPXRtcCYweEZGO31pZihwbGFjZUhvbGRlcnNMZW49PT0yKXt0bXA9cmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXTw8MnxyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSsxKV0+PjQ7YXJyW2N1ckJ5dGUrK109dG1wJjB4RkY7fWlmKHBsYWNlSG9sZGVyc0xlbj09PTEpe3RtcD1yZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldPDwxMHxyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSsxKV08PDR8cmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkrMildPj4yO2FycltjdXJCeXRlKytdPXRtcD4+OCYweEZGO2FycltjdXJCeXRlKytdPXRtcCYweEZGO31yZXR1cm4gYXJyO31mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQobnVtKXtyZXR1cm4gbG9va3VwW251bT4+MTgmMHgzRl0rbG9va3VwW251bT4+MTImMHgzRl0rbG9va3VwW251bT4+NiYweDNGXStsb29rdXBbbnVtJjB4M0ZdO31mdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCxzdGFydCxlbmQpe3ZhciB0bXA7dmFyIG91dHB1dD1bXTtmb3IodmFyIGk9c3RhcnQ7aTxlbmQ7aSs9Myl7dG1wPSh1aW50OFtpXTw8MTYmMHhGRjAwMDApKyh1aW50OFtpKzFdPDw4JjB4RkYwMCkrKHVpbnQ4W2krMl0mMHhGRik7b3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO31yZXR1cm4gb3V0cHV0LmpvaW4oJycpO31mdW5jdGlvbiBmcm9tQnl0ZUFycmF5KHVpbnQ4KXt2YXIgdG1wO3ZhciBsZW49dWludDgubGVuZ3RoO3ZhciBleHRyYUJ5dGVzPWxlbiUzOy8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG52YXIgcGFydHM9W107dmFyIG1heENodW5rTGVuZ3RoPTE2MzgzOy8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuZm9yKHZhciBpPTAsbGVuMj1sZW4tZXh0cmFCeXRlcztpPGxlbjI7aSs9bWF4Q2h1bmtMZW5ndGgpe3BhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsaSxpK21heENodW5rTGVuZ3RoPmxlbjI/bGVuMjppK21heENodW5rTGVuZ3RoKSk7fS8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbmlmKGV4dHJhQnl0ZXM9PT0xKXt0bXA9dWludDhbbGVuLTFdO3BhcnRzLnB1c2gobG9va3VwW3RtcD4+Ml0rbG9va3VwW3RtcDw8NCYweDNGXSsnPT0nKTt9ZWxzZSBpZihleHRyYUJ5dGVzPT09Mil7dG1wPSh1aW50OFtsZW4tMl08PDgpK3VpbnQ4W2xlbi0xXTtwYXJ0cy5wdXNoKGxvb2t1cFt0bXA+PjEwXStsb29rdXBbdG1wPj40JjB4M0ZdK2xvb2t1cFt0bXA8PDImMHgzRl0rJz0nKTt9cmV0dXJuIHBhcnRzLmpvaW4oJycpO319LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt9LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oQnVmZmVyKXsvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi8gLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi8ndXNlIHN0cmljdCc7dmFyIGJhc2U2ND1yZXF1aXJlKCdiYXNlNjQtanMnKTt2YXIgaWVlZTc1ND1yZXF1aXJlKCdpZWVlNzU0Jyk7ZXhwb3J0cy5CdWZmZXI9QnVmZmVyO2V4cG9ydHMuU2xvd0J1ZmZlcj1TbG93QnVmZmVyO2V4cG9ydHMuSU5TUEVDVF9NQVhfQllURVM9NTA7dmFyIEtfTUFYX0xFTkdUSD0weDdmZmZmZmZmO2V4cG9ydHMua01heExlbmd0aD1LX01BWF9MRU5HVEg7LyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL0J1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUPXR5cGVkQXJyYXlTdXBwb3J0KCk7aWYoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZSE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgY29uc29sZS5lcnJvcj09PSdmdW5jdGlvbicpe2NvbnNvbGUuZXJyb3IoJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnKydgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LicpO31mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpey8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbnRyeXt2YXIgYXJyPW5ldyBVaW50OEFycmF5KDEpO2Fyci5fX3Byb3RvX189e19fcHJvdG9fXzpVaW50OEFycmF5LnByb3RvdHlwZSxmb286ZnVuY3Rpb24gZm9vKCl7cmV0dXJuIDQyO319O3JldHVybiBhcnIuZm9vKCk9PT00Mjt9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlO319T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsJ3BhcmVudCcse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcjt9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsJ29mZnNldCcse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXQ7fX0pO2Z1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihsZW5ndGgpe2lmKGxlbmd0aD5LX01BWF9MRU5HVEgpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2xlbmd0aCsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyk7fS8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG52YXIgYnVmPW5ldyBVaW50OEFycmF5KGxlbmd0aCk7YnVmLl9fcHJvdG9fXz1CdWZmZXIucHJvdG90eXBlO3JldHVybiBidWY7fS8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9mdW5jdGlvbiBCdWZmZXIoYXJnLGVuY29kaW5nT3JPZmZzZXQsbGVuZ3RoKXsvLyBDb21tb24gY2FzZS5cbmlmKHR5cGVvZiBhcmc9PT0nbnVtYmVyJyl7aWYodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQ9PT0nc3RyaW5nJyl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTt9cmV0dXJuIGFsbG9jVW5zYWZlKGFyZyk7fXJldHVybiBmcm9tKGFyZyxlbmNvZGluZ09yT2Zmc2V0LGxlbmd0aCk7fS8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZih0eXBlb2YgU3ltYm9sIT09J3VuZGVmaW5lZCcmJlN5bWJvbC5zcGVjaWVzIT1udWxsJiZCdWZmZXJbU3ltYm9sLnNwZWNpZXNdPT09QnVmZmVyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLFN5bWJvbC5zcGVjaWVzLHt2YWx1ZTpudWxsLGNvbmZpZ3VyYWJsZTp0cnVlLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6ZmFsc2V9KTt9QnVmZmVyLnBvb2xTaXplPTgxOTI7Ly8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gZnJvbSh2YWx1ZSxlbmNvZGluZ09yT2Zmc2V0LGxlbmd0aCl7aWYodHlwZW9mIHZhbHVlPT09J3N0cmluZycpe3JldHVybiBmcm9tU3RyaW5nKHZhbHVlLGVuY29kaW5nT3JPZmZzZXQpO31pZihBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKXtyZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSk7fWlmKHZhbHVlPT1udWxsKXt0aHJvdyBUeXBlRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcrJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcrX3R5cGVvZih2YWx1ZSkpO31pZihpc0luc3RhbmNlKHZhbHVlLEFycmF5QnVmZmVyKXx8dmFsdWUmJmlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSxlbmNvZGluZ09yT2Zmc2V0LGxlbmd0aCk7fWlmKHR5cGVvZiB2YWx1ZT09PSdudW1iZXInKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpO312YXIgdmFsdWVPZj12YWx1ZS52YWx1ZU9mJiZ2YWx1ZS52YWx1ZU9mKCk7aWYodmFsdWVPZiE9bnVsbCYmdmFsdWVPZiE9PXZhbHVlKXtyZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZixlbmNvZGluZ09yT2Zmc2V0LGxlbmd0aCk7fXZhciBiPWZyb21PYmplY3QodmFsdWUpO2lmKGIpcmV0dXJuIGI7aWYodHlwZW9mIFN5bWJvbCE9PSd1bmRlZmluZWQnJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdPT09J2Z1bmN0aW9uJyl7cmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLGVuY29kaW5nT3JPZmZzZXQsbGVuZ3RoKTt9dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJysnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJytfdHlwZW9mKHZhbHVlKSk7fS8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9CdWZmZXIuZnJvbT1mdW5jdGlvbih2YWx1ZSxlbmNvZGluZ09yT2Zmc2V0LGxlbmd0aCl7cmV0dXJuIGZyb20odmFsdWUsZW5jb2RpbmdPck9mZnNldCxsZW5ndGgpO307Ly8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlO0J1ZmZlci5fX3Byb3RvX189VWludDhBcnJheTtmdW5jdGlvbiBhc3NlcnRTaXplKHNpemUpe2lmKHR5cGVvZiBzaXplIT09J251bWJlcicpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKTt9ZWxzZSBpZihzaXplPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK3NpemUrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpO319ZnVuY3Rpb24gYWxsb2Moc2l6ZSxmaWxsLGVuY29kaW5nKXthc3NlcnRTaXplKHNpemUpO2lmKHNpemU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSk7fWlmKGZpbGwhPT11bmRlZmluZWQpey8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4vLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4vLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG5yZXR1cm4gdHlwZW9mIGVuY29kaW5nPT09J3N0cmluZyc/Y3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCxlbmNvZGluZyk6Y3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCk7fXJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSk7fS8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL0J1ZmZlci5hbGxvYz1mdW5jdGlvbihzaXplLGZpbGwsZW5jb2Rpbmcpe3JldHVybiBhbGxvYyhzaXplLGZpbGwsZW5jb2RpbmcpO307ZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSl7YXNzZXJ0U2l6ZShzaXplKTtyZXR1cm4gY3JlYXRlQnVmZmVyKHNpemU8MD8wOmNoZWNrZWQoc2l6ZSl8MCk7fS8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovQnVmZmVyLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKHNpemUpe3JldHVybiBhbGxvY1Vuc2FmZShzaXplKTt9Oy8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9CdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKHNpemUpe3JldHVybiBhbGxvY1Vuc2FmZShzaXplKTt9O2Z1bmN0aW9uIGZyb21TdHJpbmcoc3RyaW5nLGVuY29kaW5nKXtpZih0eXBlb2YgZW5jb2RpbmchPT0nc3RyaW5nJ3x8ZW5jb2Rpbmc9PT0nJyl7ZW5jb2Rpbmc9J3V0ZjgnO31pZighQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnK2VuY29kaW5nKTt9dmFyIGxlbmd0aD1ieXRlTGVuZ3RoKHN0cmluZyxlbmNvZGluZyl8MDt2YXIgYnVmPWNyZWF0ZUJ1ZmZlcihsZW5ndGgpO3ZhciBhY3R1YWw9YnVmLndyaXRlKHN0cmluZyxlbmNvZGluZyk7aWYoYWN0dWFsIT09bGVuZ3RoKXsvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbi8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4vLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbmJ1Zj1idWYuc2xpY2UoMCxhY3R1YWwpO31yZXR1cm4gYnVmO31mdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGFycmF5KXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aDwwPzA6Y2hlY2tlZChhcnJheS5sZW5ndGgpfDA7dmFyIGJ1Zj1jcmVhdGVCdWZmZXIobGVuZ3RoKTtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKz0xKXtidWZbaV09YXJyYXlbaV0mMjU1O31yZXR1cm4gYnVmO31mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoYXJyYXksYnl0ZU9mZnNldCxsZW5ndGgpe2lmKGJ5dGVPZmZzZXQ8MHx8YXJyYXkuYnl0ZUxlbmd0aDxieXRlT2Zmc2V0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTt9aWYoYXJyYXkuYnl0ZUxlbmd0aDxieXRlT2Zmc2V0KyhsZW5ndGh8fDApKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTt9dmFyIGJ1ZjtpZihieXRlT2Zmc2V0PT09dW5kZWZpbmVkJiZsZW5ndGg9PT11bmRlZmluZWQpe2J1Zj1uZXcgVWludDhBcnJheShhcnJheSk7fWVsc2UgaWYobGVuZ3RoPT09dW5kZWZpbmVkKXtidWY9bmV3IFVpbnQ4QXJyYXkoYXJyYXksYnl0ZU9mZnNldCk7fWVsc2V7YnVmPW5ldyBVaW50OEFycmF5KGFycmF5LGJ5dGVPZmZzZXQsbGVuZ3RoKTt9Ly8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbmJ1Zi5fX3Byb3RvX189QnVmZmVyLnByb3RvdHlwZTtyZXR1cm4gYnVmO31mdW5jdGlvbiBmcm9tT2JqZWN0KG9iail7aWYoQnVmZmVyLmlzQnVmZmVyKG9iaikpe3ZhciBsZW49Y2hlY2tlZChvYmoubGVuZ3RoKXwwO3ZhciBidWY9Y3JlYXRlQnVmZmVyKGxlbik7aWYoYnVmLmxlbmd0aD09PTApe3JldHVybiBidWY7fW9iai5jb3B5KGJ1ZiwwLDAsbGVuKTtyZXR1cm4gYnVmO31pZihvYmoubGVuZ3RoIT09dW5kZWZpbmVkKXtpZih0eXBlb2Ygb2JqLmxlbmd0aCE9PSdudW1iZXInfHxudW1iZXJJc05hTihvYmoubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKTt9cmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKTt9aWYob2JqLnR5cGU9PT0nQnVmZmVyJyYmQXJyYXkuaXNBcnJheShvYmouZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKTt9fWZ1bmN0aW9uIGNoZWNrZWQobGVuZ3RoKXsvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbi8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuaWYobGVuZ3RoPj1LX01BWF9MRU5HVEgpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcrJ3NpemU6IDB4JytLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpKycgYnl0ZXMnKTt9cmV0dXJuIGxlbmd0aHwwO31mdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCl7aWYoK2xlbmd0aCE9bGVuZ3RoKXsvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxubGVuZ3RoPTA7fXJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aCk7fUJ1ZmZlci5pc0J1ZmZlcj1mdW5jdGlvbiBpc0J1ZmZlcihiKXtyZXR1cm4gYiE9bnVsbCYmYi5faXNCdWZmZXI9PT10cnVlJiZiIT09QnVmZmVyLnByb3RvdHlwZTsvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufTtCdWZmZXIuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGEsYil7aWYoaXNJbnN0YW5jZShhLFVpbnQ4QXJyYXkpKWE9QnVmZmVyLmZyb20oYSxhLm9mZnNldCxhLmJ5dGVMZW5ndGgpO2lmKGlzSW5zdGFuY2UoYixVaW50OEFycmF5KSliPUJ1ZmZlci5mcm9tKGIsYi5vZmZzZXQsYi5ieXRlTGVuZ3RoKTtpZighQnVmZmVyLmlzQnVmZmVyKGEpfHwhQnVmZmVyLmlzQnVmZmVyKGIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyk7fWlmKGE9PT1iKXJldHVybiAwO3ZhciB4PWEubGVuZ3RoO3ZhciB5PWIubGVuZ3RoO2Zvcih2YXIgaT0wLGxlbj1NYXRoLm1pbih4LHkpO2k8bGVuOysraSl7aWYoYVtpXSE9PWJbaV0pe3g9YVtpXTt5PWJbaV07YnJlYWs7fX1pZih4PHkpcmV0dXJuLTE7aWYoeTx4KXJldHVybiAxO3JldHVybiAwO307QnVmZmVyLmlzRW5jb2Rpbmc9ZnVuY3Rpb24gaXNFbmNvZGluZyhlbmNvZGluZyl7c3dpdGNoKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSl7Y2FzZSdoZXgnOmNhc2UndXRmOCc6Y2FzZSd1dGYtOCc6Y2FzZSdhc2NpaSc6Y2FzZSdsYXRpbjEnOmNhc2UnYmluYXJ5JzpjYXNlJ2Jhc2U2NCc6Y2FzZSd1Y3MyJzpjYXNlJ3Vjcy0yJzpjYXNlJ3V0ZjE2bGUnOmNhc2UndXRmLTE2bGUnOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlO319O0J1ZmZlci5jb25jYXQ9ZnVuY3Rpb24gY29uY2F0KGxpc3QsbGVuZ3RoKXtpZighQXJyYXkuaXNBcnJheShsaXN0KSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7fWlmKGxpc3QubGVuZ3RoPT09MCl7cmV0dXJuIEJ1ZmZlci5hbGxvYygwKTt9dmFyIGk7aWYobGVuZ3RoPT09dW5kZWZpbmVkKXtsZW5ndGg9MDtmb3IoaT0wO2k8bGlzdC5sZW5ndGg7KytpKXtsZW5ndGgrPWxpc3RbaV0ubGVuZ3RoO319dmFyIGJ1ZmZlcj1CdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTt2YXIgcG9zPTA7Zm9yKGk9MDtpPGxpc3QubGVuZ3RoOysraSl7dmFyIGJ1Zj1saXN0W2ldO2lmKGlzSW5zdGFuY2UoYnVmLFVpbnQ4QXJyYXkpKXtidWY9QnVmZmVyLmZyb20oYnVmKTt9aWYoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTt9YnVmLmNvcHkoYnVmZmVyLHBvcyk7cG9zKz1idWYubGVuZ3RoO31yZXR1cm4gYnVmZmVyO307ZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsZW5jb2Rpbmcpe2lmKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKXtyZXR1cm4gc3RyaW5nLmxlbmd0aDt9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZyl8fGlzSW5zdGFuY2Uoc3RyaW5nLEFycmF5QnVmZmVyKSl7cmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoO31pZih0eXBlb2Ygc3RyaW5nIT09J3N0cmluZycpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnKydSZWNlaXZlZCB0eXBlICcrX3R5cGVvZihzdHJpbmcpKTt9dmFyIGxlbj1zdHJpbmcubGVuZ3RoO3ZhciBtdXN0TWF0Y2g9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl09PT10cnVlO2lmKCFtdXN0TWF0Y2gmJmxlbj09PTApcmV0dXJuIDA7Ly8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG52YXIgbG93ZXJlZENhc2U9ZmFsc2U7Zm9yKDs7KXtzd2l0Y2goZW5jb2Rpbmcpe2Nhc2UnYXNjaWknOmNhc2UnbGF0aW4xJzpjYXNlJ2JpbmFyeSc6cmV0dXJuIGxlbjtjYXNlJ3V0ZjgnOmNhc2UndXRmLTgnOnJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDtjYXNlJ3VjczInOmNhc2UndWNzLTInOmNhc2UndXRmMTZsZSc6Y2FzZSd1dGYtMTZsZSc6cmV0dXJuIGxlbioyO2Nhc2UnaGV4JzpyZXR1cm4gbGVuPj4+MTtjYXNlJ2Jhc2U2NCc6cmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7ZGVmYXVsdDppZihsb3dlcmVkQ2FzZSl7cmV0dXJuIG11c3RNYXRjaD8tMTp1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsvLyBhc3N1bWUgdXRmOFxufWVuY29kaW5nPSgnJytlbmNvZGluZykudG9Mb3dlckNhc2UoKTtsb3dlcmVkQ2FzZT10cnVlO319fUJ1ZmZlci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGVuY29kaW5nLHN0YXJ0LGVuZCl7dmFyIGxvd2VyZWRDYXNlPWZhbHNlOy8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cbi8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbi8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuaWYoc3RhcnQ9PT11bmRlZmluZWR8fHN0YXJ0PDApe3N0YXJ0PTA7fS8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4vLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuaWYoc3RhcnQ+dGhpcy5sZW5ndGgpe3JldHVybicnO31pZihlbmQ9PT11bmRlZmluZWR8fGVuZD50aGlzLmxlbmd0aCl7ZW5kPXRoaXMubGVuZ3RoO31pZihlbmQ8PTApe3JldHVybicnO30vLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuZW5kPj4+PTA7c3RhcnQ+Pj49MDtpZihlbmQ8PXN0YXJ0KXtyZXR1cm4nJzt9aWYoIWVuY29kaW5nKWVuY29kaW5nPSd1dGY4Jzt3aGlsZSh0cnVlKXtzd2l0Y2goZW5jb2Rpbmcpe2Nhc2UnaGV4JzpyZXR1cm4gaGV4U2xpY2UodGhpcyxzdGFydCxlbmQpO2Nhc2UndXRmOCc6Y2FzZSd1dGYtOCc6cmV0dXJuIHV0ZjhTbGljZSh0aGlzLHN0YXJ0LGVuZCk7Y2FzZSdhc2NpaSc6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxzdGFydCxlbmQpO2Nhc2UnbGF0aW4xJzpjYXNlJ2JpbmFyeSc6cmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsc3RhcnQsZW5kKTtjYXNlJ2Jhc2U2NCc6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsc3RhcnQsZW5kKTtjYXNlJ3VjczInOmNhc2UndWNzLTInOmNhc2UndXRmMTZsZSc6Y2FzZSd1dGYtMTZsZSc6cmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLHN0YXJ0LGVuZCk7ZGVmYXVsdDppZihsb3dlcmVkQ2FzZSl0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnK2VuY29kaW5nKTtlbmNvZGluZz0oZW5jb2RpbmcrJycpLnRvTG93ZXJDYXNlKCk7bG93ZXJlZENhc2U9dHJ1ZTt9fX0vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyPXRydWU7ZnVuY3Rpb24gc3dhcChiLG4sbSl7dmFyIGk9YltuXTtiW25dPWJbbV07YlttXT1pO31CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgbGVuPXRoaXMubGVuZ3RoO2lmKGxlbiUyIT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJyk7fWZvcih2YXIgaT0wO2k8bGVuO2krPTIpe3N3YXAodGhpcyxpLGkrMSk7fXJldHVybiB0aGlzO307QnVmZmVyLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24gc3dhcDMyKCl7dmFyIGxlbj10aGlzLmxlbmd0aDtpZihsZW4lNCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpO31mb3IodmFyIGk9MDtpPGxlbjtpKz00KXtzd2FwKHRoaXMsaSxpKzMpO3N3YXAodGhpcyxpKzEsaSsyKTt9cmV0dXJuIHRoaXM7fTtCdWZmZXIucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbiBzd2FwNjQoKXt2YXIgbGVuPXRoaXMubGVuZ3RoO2lmKGxlbiU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJyk7fWZvcih2YXIgaT0wO2k8bGVuO2krPTgpe3N3YXAodGhpcyxpLGkrNyk7c3dhcCh0aGlzLGkrMSxpKzYpO3N3YXAodGhpcyxpKzIsaSs1KTtzd2FwKHRoaXMsaSszLGkrNCk7fXJldHVybiB0aGlzO307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBsZW5ndGg9dGhpcy5sZW5ndGg7aWYobGVuZ3RoPT09MClyZXR1cm4nJztpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm4gdXRmOFNsaWNlKHRoaXMsMCxsZW5ndGgpO3JldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpO307QnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZz1CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nO0J1ZmZlci5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uIGVxdWFscyhiKXtpZighQnVmZmVyLmlzQnVmZmVyKGIpKXRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKTtpZih0aGlzPT09YilyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxiKT09PTA7fTtCdWZmZXIucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe3ZhciBzdHI9Jyc7dmFyIG1heD1leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTO3N0cj10aGlzLnRvU3RyaW5nKCdoZXgnLDAsbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywnJDEgJykudHJpbSgpO2lmKHRoaXMubGVuZ3RoPm1heClzdHIrPScgLi4uICc7cmV0dXJuJzxCdWZmZXIgJytzdHIrJz4nO307QnVmZmVyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUodGFyZ2V0LHN0YXJ0LGVuZCx0aGlzU3RhcnQsdGhpc0VuZCl7aWYoaXNJbnN0YW5jZSh0YXJnZXQsVWludDhBcnJheSkpe3RhcmdldD1CdWZmZXIuZnJvbSh0YXJnZXQsdGFyZ2V0Lm9mZnNldCx0YXJnZXQuYnl0ZUxlbmd0aCk7fWlmKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJysnUmVjZWl2ZWQgdHlwZSAnK190eXBlb2YodGFyZ2V0KSk7fWlmKHN0YXJ0PT09dW5kZWZpbmVkKXtzdGFydD0wO31pZihlbmQ9PT11bmRlZmluZWQpe2VuZD10YXJnZXQ/dGFyZ2V0Lmxlbmd0aDowO31pZih0aGlzU3RhcnQ9PT11bmRlZmluZWQpe3RoaXNTdGFydD0wO31pZih0aGlzRW5kPT09dW5kZWZpbmVkKXt0aGlzRW5kPXRoaXMubGVuZ3RoO31pZihzdGFydDwwfHxlbmQ+dGFyZ2V0Lmxlbmd0aHx8dGhpc1N0YXJ0PDB8fHRoaXNFbmQ+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKTt9aWYodGhpc1N0YXJ0Pj10aGlzRW5kJiZzdGFydD49ZW5kKXtyZXR1cm4gMDt9aWYodGhpc1N0YXJ0Pj10aGlzRW5kKXtyZXR1cm4tMTt9aWYoc3RhcnQ+PWVuZCl7cmV0dXJuIDE7fXN0YXJ0Pj4+PTA7ZW5kPj4+PTA7dGhpc1N0YXJ0Pj4+PTA7dGhpc0VuZD4+Pj0wO2lmKHRoaXM9PT10YXJnZXQpcmV0dXJuIDA7dmFyIHg9dGhpc0VuZC10aGlzU3RhcnQ7dmFyIHk9ZW5kLXN0YXJ0O3ZhciBsZW49TWF0aC5taW4oeCx5KTt2YXIgdGhpc0NvcHk9dGhpcy5zbGljZSh0aGlzU3RhcnQsdGhpc0VuZCk7dmFyIHRhcmdldENvcHk9dGFyZ2V0LnNsaWNlKHN0YXJ0LGVuZCk7Zm9yKHZhciBpPTA7aTxsZW47KytpKXtpZih0aGlzQ29weVtpXSE9PXRhcmdldENvcHlbaV0pe3g9dGhpc0NvcHlbaV07eT10YXJnZXRDb3B5W2ldO2JyZWFrO319aWYoeDx5KXJldHVybi0xO2lmKHk8eClyZXR1cm4gMTtyZXR1cm4gMDt9Oy8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoYnVmZmVyLHZhbCxieXRlT2Zmc2V0LGVuY29kaW5nLGRpcil7Ly8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG5pZihidWZmZXIubGVuZ3RoPT09MClyZXR1cm4tMTsvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuaWYodHlwZW9mIGJ5dGVPZmZzZXQ9PT0nc3RyaW5nJyl7ZW5jb2Rpbmc9Ynl0ZU9mZnNldDtieXRlT2Zmc2V0PTA7fWVsc2UgaWYoYnl0ZU9mZnNldD4weDdmZmZmZmZmKXtieXRlT2Zmc2V0PTB4N2ZmZmZmZmY7fWVsc2UgaWYoYnl0ZU9mZnNldDwtMHg4MDAwMDAwMCl7Ynl0ZU9mZnNldD0tMHg4MDAwMDAwMDt9Ynl0ZU9mZnNldD0rYnl0ZU9mZnNldDsvLyBDb2VyY2UgdG8gTnVtYmVyLlxuaWYobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpey8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuYnl0ZU9mZnNldD1kaXI/MDpidWZmZXIubGVuZ3RoLTE7fS8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG5pZihieXRlT2Zmc2V0PDApYnl0ZU9mZnNldD1idWZmZXIubGVuZ3RoK2J5dGVPZmZzZXQ7aWYoYnl0ZU9mZnNldD49YnVmZmVyLmxlbmd0aCl7aWYoZGlyKXJldHVybi0xO2Vsc2UgYnl0ZU9mZnNldD1idWZmZXIubGVuZ3RoLTE7fWVsc2UgaWYoYnl0ZU9mZnNldDwwKXtpZihkaXIpYnl0ZU9mZnNldD0wO2Vsc2UgcmV0dXJuLTE7fS8vIE5vcm1hbGl6ZSB2YWxcbmlmKHR5cGVvZiB2YWw9PT0nc3RyaW5nJyl7dmFsPUJ1ZmZlci5mcm9tKHZhbCxlbmNvZGluZyk7fS8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG5pZihCdWZmZXIuaXNCdWZmZXIodmFsKSl7Ly8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuaWYodmFsLmxlbmd0aD09PTApe3JldHVybi0xO31yZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlcix2YWwsYnl0ZU9mZnNldCxlbmNvZGluZyxkaXIpO31lbHNlIGlmKHR5cGVvZiB2YWw9PT0nbnVtYmVyJyl7dmFsPXZhbCYweEZGOy8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbmlmKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mPT09J2Z1bmN0aW9uJyl7aWYoZGlyKXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlcix2YWwsYnl0ZU9mZnNldCk7fWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLHZhbCxieXRlT2Zmc2V0KTt9fXJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLFt2YWxdLGJ5dGVPZmZzZXQsZW5jb2RpbmcsZGlyKTt9dGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJyk7fWZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnIsdmFsLGJ5dGVPZmZzZXQsZW5jb2RpbmcsZGlyKXt2YXIgaW5kZXhTaXplPTE7dmFyIGFyckxlbmd0aD1hcnIubGVuZ3RoO3ZhciB2YWxMZW5ndGg9dmFsLmxlbmd0aDtpZihlbmNvZGluZyE9PXVuZGVmaW5lZCl7ZW5jb2Rpbmc9U3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO2lmKGVuY29kaW5nPT09J3VjczInfHxlbmNvZGluZz09PSd1Y3MtMid8fGVuY29kaW5nPT09J3V0ZjE2bGUnfHxlbmNvZGluZz09PSd1dGYtMTZsZScpe2lmKGFyci5sZW5ndGg8Mnx8dmFsLmxlbmd0aDwyKXtyZXR1cm4tMTt9aW5kZXhTaXplPTI7YXJyTGVuZ3RoLz0yO3ZhbExlbmd0aC89MjtieXRlT2Zmc2V0Lz0yO319ZnVuY3Rpb24gcmVhZChidWYsaSl7aWYoaW5kZXhTaXplPT09MSl7cmV0dXJuIGJ1ZltpXTt9ZWxzZXtyZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpKmluZGV4U2l6ZSk7fX12YXIgaTtpZihkaXIpe3ZhciBmb3VuZEluZGV4PS0xO2ZvcihpPWJ5dGVPZmZzZXQ7aTxhcnJMZW5ndGg7aSsrKXtpZihyZWFkKGFycixpKT09PXJlYWQodmFsLGZvdW5kSW5kZXg9PT0tMT8wOmktZm91bmRJbmRleCkpe2lmKGZvdW5kSW5kZXg9PT0tMSlmb3VuZEluZGV4PWk7aWYoaS1mb3VuZEluZGV4KzE9PT12YWxMZW5ndGgpcmV0dXJuIGZvdW5kSW5kZXgqaW5kZXhTaXplO31lbHNle2lmKGZvdW5kSW5kZXghPT0tMSlpLT1pLWZvdW5kSW5kZXg7Zm91bmRJbmRleD0tMTt9fX1lbHNle2lmKGJ5dGVPZmZzZXQrdmFsTGVuZ3RoPmFyckxlbmd0aClieXRlT2Zmc2V0PWFyckxlbmd0aC12YWxMZW5ndGg7Zm9yKGk9Ynl0ZU9mZnNldDtpPj0wO2ktLSl7dmFyIGZvdW5kPXRydWU7Zm9yKHZhciBqPTA7ajx2YWxMZW5ndGg7aisrKXtpZihyZWFkKGFycixpK2opIT09cmVhZCh2YWwsaikpe2ZvdW5kPWZhbHNlO2JyZWFrO319aWYoZm91bmQpcmV0dXJuIGk7fX1yZXR1cm4tMTt9QnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbiBpbmNsdWRlcyh2YWwsYnl0ZU9mZnNldCxlbmNvZGluZyl7cmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsYnl0ZU9mZnNldCxlbmNvZGluZykhPT0tMTt9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKHZhbCxieXRlT2Zmc2V0LGVuY29kaW5nKXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyx2YWwsYnl0ZU9mZnNldCxlbmNvZGluZyx0cnVlKTt9O0J1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24gbGFzdEluZGV4T2YodmFsLGJ5dGVPZmZzZXQsZW5jb2Rpbmcpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLHZhbCxieXRlT2Zmc2V0LGVuY29kaW5nLGZhbHNlKTt9O2Z1bmN0aW9uIGhleFdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl7b2Zmc2V0PU51bWJlcihvZmZzZXQpfHwwO3ZhciByZW1haW5pbmc9YnVmLmxlbmd0aC1vZmZzZXQ7aWYoIWxlbmd0aCl7bGVuZ3RoPXJlbWFpbmluZzt9ZWxzZXtsZW5ndGg9TnVtYmVyKGxlbmd0aCk7aWYobGVuZ3RoPnJlbWFpbmluZyl7bGVuZ3RoPXJlbWFpbmluZzt9fXZhciBzdHJMZW49c3RyaW5nLmxlbmd0aDtpZihsZW5ndGg+c3RyTGVuLzIpe2xlbmd0aD1zdHJMZW4vMjt9Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXt2YXIgcGFyc2VkPXBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSoyLDIpLDE2KTtpZihudW1iZXJJc05hTihwYXJzZWQpKXJldHVybiBpO2J1ZltvZmZzZXQraV09cGFyc2VkO31yZXR1cm4gaTt9ZnVuY3Rpb24gdXRmOFdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl7cmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLGJ1Zi5sZW5ndGgtb2Zmc2V0KSxidWYsb2Zmc2V0LGxlbmd0aCk7fWZ1bmN0aW9uIGFzY2lpV3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXtyZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSxidWYsb2Zmc2V0LGxlbmd0aCk7fWZ1bmN0aW9uIGxhdGluMVdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl7cmV0dXJuIGFzY2lpV3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKTt9ZnVuY3Rpb24gYmFzZTY0V3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksYnVmLG9mZnNldCxsZW5ndGgpO31mdW5jdGlvbiB1Y3MyV3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsYnVmLmxlbmd0aC1vZmZzZXQpLGJ1ZixvZmZzZXQsbGVuZ3RoKTt9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShzdHJpbmcsb2Zmc2V0LGxlbmd0aCxlbmNvZGluZyl7Ly8gQnVmZmVyI3dyaXRlKHN0cmluZylcbmlmKG9mZnNldD09PXVuZGVmaW5lZCl7ZW5jb2Rpbmc9J3V0ZjgnO2xlbmd0aD10aGlzLmxlbmd0aDtvZmZzZXQ9MDsvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbn1lbHNlIGlmKGxlbmd0aD09PXVuZGVmaW5lZCYmdHlwZW9mIG9mZnNldD09PSdzdHJpbmcnKXtlbmNvZGluZz1vZmZzZXQ7bGVuZ3RoPXRoaXMubGVuZ3RoO29mZnNldD0wOy8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG59ZWxzZSBpZihpc0Zpbml0ZShvZmZzZXQpKXtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZihpc0Zpbml0ZShsZW5ndGgpKXtsZW5ndGg9bGVuZ3RoPj4+MDtpZihlbmNvZGluZz09PXVuZGVmaW5lZCllbmNvZGluZz0ndXRmOCc7fWVsc2V7ZW5jb2Rpbmc9bGVuZ3RoO2xlbmd0aD11bmRlZmluZWQ7fX1lbHNle3Rocm93IG5ldyBFcnJvcignQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnKTt9dmFyIHJlbWFpbmluZz10aGlzLmxlbmd0aC1vZmZzZXQ7aWYobGVuZ3RoPT09dW5kZWZpbmVkfHxsZW5ndGg+cmVtYWluaW5nKWxlbmd0aD1yZW1haW5pbmc7aWYoc3RyaW5nLmxlbmd0aD4wJiYobGVuZ3RoPDB8fG9mZnNldDwwKXx8b2Zmc2V0PnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKTt9aWYoIWVuY29kaW5nKWVuY29kaW5nPSd1dGY4Jzt2YXIgbG93ZXJlZENhc2U9ZmFsc2U7Zm9yKDs7KXtzd2l0Y2goZW5jb2Rpbmcpe2Nhc2UnaGV4JzpyZXR1cm4gaGV4V3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7Y2FzZSd1dGY4JzpjYXNlJ3V0Zi04JzpyZXR1cm4gdXRmOFdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2Nhc2UnYXNjaWknOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2Nhc2UnbGF0aW4xJzpjYXNlJ2JpbmFyeSc6cmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2Nhc2UnYmFzZTY0JzovLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxucmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2Nhc2UndWNzMic6Y2FzZSd1Y3MtMic6Y2FzZSd1dGYxNmxlJzpjYXNlJ3V0Zi0xNmxlJzpyZXR1cm4gdWNzMldyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2RlZmF1bHQ6aWYobG93ZXJlZENhc2UpdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJytlbmNvZGluZyk7ZW5jb2Rpbmc9KCcnK2VuY29kaW5nKS50b0xvd2VyQ2FzZSgpO2xvd2VyZWRDYXNlPXRydWU7fX19O0J1ZmZlci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe3JldHVybnt0eXBlOidCdWZmZXInLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfTt9O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGJ1ZixzdGFydCxlbmQpe2lmKHN0YXJ0PT09MCYmZW5kPT09YnVmLmxlbmd0aCl7cmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zik7fWVsc2V7cmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCxlbmQpKTt9fWZ1bmN0aW9uIHV0ZjhTbGljZShidWYsc3RhcnQsZW5kKXtlbmQ9TWF0aC5taW4oYnVmLmxlbmd0aCxlbmQpO3ZhciByZXM9W107dmFyIGk9c3RhcnQ7d2hpbGUoaTxlbmQpe3ZhciBmaXJzdEJ5dGU9YnVmW2ldO3ZhciBjb2RlUG9pbnQ9bnVsbDt2YXIgYnl0ZXNQZXJTZXF1ZW5jZT1maXJzdEJ5dGU+MHhFRj80OmZpcnN0Qnl0ZT4weERGPzM6Zmlyc3RCeXRlPjB4QkY/MjoxO2lmKGkrYnl0ZXNQZXJTZXF1ZW5jZTw9ZW5kKXt2YXIgc2Vjb25kQnl0ZSx0aGlyZEJ5dGUsZm91cnRoQnl0ZSx0ZW1wQ29kZVBvaW50O3N3aXRjaChieXRlc1BlclNlcXVlbmNlKXtjYXNlIDE6aWYoZmlyc3RCeXRlPDB4ODApe2NvZGVQb2ludD1maXJzdEJ5dGU7fWJyZWFrO2Nhc2UgMjpzZWNvbmRCeXRlPWJ1ZltpKzFdO2lmKChzZWNvbmRCeXRlJjB4QzApPT09MHg4MCl7dGVtcENvZGVQb2ludD0oZmlyc3RCeXRlJjB4MUYpPDwweDZ8c2Vjb25kQnl0ZSYweDNGO2lmKHRlbXBDb2RlUG9pbnQ+MHg3Ril7Y29kZVBvaW50PXRlbXBDb2RlUG9pbnQ7fX1icmVhaztjYXNlIDM6c2Vjb25kQnl0ZT1idWZbaSsxXTt0aGlyZEJ5dGU9YnVmW2krMl07aWYoKHNlY29uZEJ5dGUmMHhDMCk9PT0weDgwJiYodGhpcmRCeXRlJjB4QzApPT09MHg4MCl7dGVtcENvZGVQb2ludD0oZmlyc3RCeXRlJjB4Rik8PDB4Q3woc2Vjb25kQnl0ZSYweDNGKTw8MHg2fHRoaXJkQnl0ZSYweDNGO2lmKHRlbXBDb2RlUG9pbnQ+MHg3RkYmJih0ZW1wQ29kZVBvaW50PDB4RDgwMHx8dGVtcENvZGVQb2ludD4weERGRkYpKXtjb2RlUG9pbnQ9dGVtcENvZGVQb2ludDt9fWJyZWFrO2Nhc2UgNDpzZWNvbmRCeXRlPWJ1ZltpKzFdO3RoaXJkQnl0ZT1idWZbaSsyXTtmb3VydGhCeXRlPWJ1ZltpKzNdO2lmKChzZWNvbmRCeXRlJjB4QzApPT09MHg4MCYmKHRoaXJkQnl0ZSYweEMwKT09PTB4ODAmJihmb3VydGhCeXRlJjB4QzApPT09MHg4MCl7dGVtcENvZGVQb2ludD0oZmlyc3RCeXRlJjB4Rik8PDB4MTJ8KHNlY29uZEJ5dGUmMHgzRik8PDB4Q3wodGhpcmRCeXRlJjB4M0YpPDwweDZ8Zm91cnRoQnl0ZSYweDNGO2lmKHRlbXBDb2RlUG9pbnQ+MHhGRkZGJiZ0ZW1wQ29kZVBvaW50PDB4MTEwMDAwKXtjb2RlUG9pbnQ9dGVtcENvZGVQb2ludDt9fX19aWYoY29kZVBvaW50PT09bnVsbCl7Ly8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuY29kZVBvaW50PTB4RkZGRDtieXRlc1BlclNlcXVlbmNlPTE7fWVsc2UgaWYoY29kZVBvaW50PjB4RkZGRil7Ly8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbmNvZGVQb2ludC09MHgxMDAwMDtyZXMucHVzaChjb2RlUG9pbnQ+Pj4xMCYweDNGRnwweEQ4MDApO2NvZGVQb2ludD0weERDMDB8Y29kZVBvaW50JjB4M0ZGO31yZXMucHVzaChjb2RlUG9pbnQpO2krPWJ5dGVzUGVyU2VxdWVuY2U7fXJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKTt9Ly8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEg9MHgxMDAwO2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShjb2RlUG9pbnRzKXt2YXIgbGVuPWNvZGVQb2ludHMubGVuZ3RoO2lmKGxlbjw9TUFYX0FSR1VNRU5UU19MRU5HVEgpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxjb2RlUG9pbnRzKTsvLyBhdm9pZCBleHRyYSBzbGljZSgpXG59Ly8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxudmFyIHJlcz0nJzt2YXIgaT0wO3doaWxlKGk8bGVuKXtyZXMrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGNvZGVQb2ludHMuc2xpY2UoaSxpKz1NQVhfQVJHVU1FTlRTX0xFTkdUSCkpO31yZXR1cm4gcmVzO31mdW5jdGlvbiBhc2NpaVNsaWNlKGJ1ZixzdGFydCxlbmQpe3ZhciByZXQ9Jyc7ZW5kPU1hdGgubWluKGJ1Zi5sZW5ndGgsZW5kKTtmb3IodmFyIGk9c3RhcnQ7aTxlbmQ7KytpKXtyZXQrPVN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldJjB4N0YpO31yZXR1cm4gcmV0O31mdW5jdGlvbiBsYXRpbjFTbGljZShidWYsc3RhcnQsZW5kKXt2YXIgcmV0PScnO2VuZD1NYXRoLm1pbihidWYubGVuZ3RoLGVuZCk7Zm9yKHZhciBpPXN0YXJ0O2k8ZW5kOysraSl7cmV0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7fXJldHVybiByZXQ7fWZ1bmN0aW9uIGhleFNsaWNlKGJ1ZixzdGFydCxlbmQpe3ZhciBsZW49YnVmLmxlbmd0aDtpZighc3RhcnR8fHN0YXJ0PDApc3RhcnQ9MDtpZighZW5kfHxlbmQ8MHx8ZW5kPmxlbillbmQ9bGVuO3ZhciBvdXQ9Jyc7Zm9yKHZhciBpPXN0YXJ0O2k8ZW5kOysraSl7b3V0Kz10b0hleChidWZbaV0pO31yZXR1cm4gb3V0O31mdW5jdGlvbiB1dGYxNmxlU2xpY2UoYnVmLHN0YXJ0LGVuZCl7dmFyIGJ5dGVzPWJ1Zi5zbGljZShzdGFydCxlbmQpO3ZhciByZXM9Jyc7Zm9yKHZhciBpPTA7aTxieXRlcy5sZW5ndGg7aSs9Mil7cmVzKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldK2J5dGVzW2krMV0qMjU2KTt9cmV0dXJuIHJlczt9QnVmZmVyLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbiBzbGljZShzdGFydCxlbmQpe3ZhciBsZW49dGhpcy5sZW5ndGg7c3RhcnQ9fn5zdGFydDtlbmQ9ZW5kPT09dW5kZWZpbmVkP2xlbjp+fmVuZDtpZihzdGFydDwwKXtzdGFydCs9bGVuO2lmKHN0YXJ0PDApc3RhcnQ9MDt9ZWxzZSBpZihzdGFydD5sZW4pe3N0YXJ0PWxlbjt9aWYoZW5kPDApe2VuZCs9bGVuO2lmKGVuZDwwKWVuZD0wO31lbHNlIGlmKGVuZD5sZW4pe2VuZD1sZW47fWlmKGVuZDxzdGFydCllbmQ9c3RhcnQ7dmFyIG5ld0J1Zj10aGlzLnN1YmFycmF5KHN0YXJ0LGVuZCk7Ly8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2Vcbm5ld0J1Zi5fX3Byb3RvX189QnVmZmVyLnByb3RvdHlwZTtyZXR1cm4gbmV3QnVmO307LypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovZnVuY3Rpb24gY2hlY2tPZmZzZXQob2Zmc2V0LGV4dCxsZW5ndGgpe2lmKG9mZnNldCUxIT09MHx8b2Zmc2V0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpO2lmKG9mZnNldCtleHQ+bGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7fUJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbiByZWFkVUludExFKG9mZnNldCxieXRlTGVuZ3RoLG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtieXRlTGVuZ3RoPWJ5dGVMZW5ndGg+Pj4wO2lmKCFub0Fzc2VydCljaGVja09mZnNldChvZmZzZXQsYnl0ZUxlbmd0aCx0aGlzLmxlbmd0aCk7dmFyIHZhbD10aGlzW29mZnNldF07dmFyIG11bD0xO3ZhciBpPTA7d2hpbGUoKytpPGJ5dGVMZW5ndGgmJihtdWwqPTB4MTAwKSl7dmFsKz10aGlzW29mZnNldCtpXSptdWw7fXJldHVybiB2YWw7fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24gcmVhZFVJbnRCRShvZmZzZXQsYnl0ZUxlbmd0aCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7Ynl0ZUxlbmd0aD1ieXRlTGVuZ3RoPj4+MDtpZighbm9Bc3NlcnQpe2NoZWNrT2Zmc2V0KG9mZnNldCxieXRlTGVuZ3RoLHRoaXMubGVuZ3RoKTt9dmFyIHZhbD10aGlzW29mZnNldCstLWJ5dGVMZW5ndGhdO3ZhciBtdWw9MTt3aGlsZShieXRlTGVuZ3RoPjAmJihtdWwqPTB4MTAwKSl7dmFsKz10aGlzW29mZnNldCstLWJ5dGVMZW5ndGhdKm11bDt9cmV0dXJuIHZhbDt9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChvZmZzZXQsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja09mZnNldChvZmZzZXQsMSx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbb2Zmc2V0XTt9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uIHJlYWRVSW50MTZMRShvZmZzZXQsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja09mZnNldChvZmZzZXQsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbb2Zmc2V0XXx0aGlzW29mZnNldCsxXTw8ODt9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uIHJlYWRVSW50MTZCRShvZmZzZXQsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja09mZnNldChvZmZzZXQsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbb2Zmc2V0XTw8OHx0aGlzW29mZnNldCsxXTt9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uIHJlYWRVSW50MzJMRShvZmZzZXQsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja09mZnNldChvZmZzZXQsNCx0aGlzLmxlbmd0aCk7cmV0dXJuKHRoaXNbb2Zmc2V0XXx0aGlzW29mZnNldCsxXTw8OHx0aGlzW29mZnNldCsyXTw8MTYpK3RoaXNbb2Zmc2V0KzNdKjB4MTAwMDAwMDt9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShvZmZzZXQsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja09mZnNldChvZmZzZXQsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbb2Zmc2V0XSoweDEwMDAwMDArKHRoaXNbb2Zmc2V0KzFdPDwxNnx0aGlzW29mZnNldCsyXTw8OHx0aGlzW29mZnNldCszXSk7fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRT1mdW5jdGlvbiByZWFkSW50TEUob2Zmc2V0LGJ5dGVMZW5ndGgsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2J5dGVMZW5ndGg9Ynl0ZUxlbmd0aD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCxieXRlTGVuZ3RoLHRoaXMubGVuZ3RoKTt2YXIgdmFsPXRoaXNbb2Zmc2V0XTt2YXIgbXVsPTE7dmFyIGk9MDt3aGlsZSgrK2k8Ynl0ZUxlbmd0aCYmKG11bCo9MHgxMDApKXt2YWwrPXRoaXNbb2Zmc2V0K2ldKm11bDt9bXVsKj0weDgwO2lmKHZhbD49bXVsKXZhbC09TWF0aC5wb3coMiw4KmJ5dGVMZW5ndGgpO3JldHVybiB2YWw7fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbiByZWFkSW50QkUob2Zmc2V0LGJ5dGVMZW5ndGgsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2J5dGVMZW5ndGg9Ynl0ZUxlbmd0aD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCxieXRlTGVuZ3RoLHRoaXMubGVuZ3RoKTt2YXIgaT1ieXRlTGVuZ3RoO3ZhciBtdWw9MTt2YXIgdmFsPXRoaXNbb2Zmc2V0Ky0taV07d2hpbGUoaT4wJiYobXVsKj0weDEwMCkpe3ZhbCs9dGhpc1tvZmZzZXQrLS1pXSptdWw7fW11bCo9MHg4MDtpZih2YWw+PW11bCl2YWwtPU1hdGgucG93KDIsOCpieXRlTGVuZ3RoKTtyZXR1cm4gdmFsO307QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbiByZWFkSW50OChvZmZzZXQsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja09mZnNldChvZmZzZXQsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW29mZnNldF0mMHg4MCkpcmV0dXJuIHRoaXNbb2Zmc2V0XTtyZXR1cm4oMHhmZi10aGlzW29mZnNldF0rMSkqLTE7fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCwyLHRoaXMubGVuZ3RoKTt2YXIgdmFsPXRoaXNbb2Zmc2V0XXx0aGlzW29mZnNldCsxXTw8ODtyZXR1cm4gdmFsJjB4ODAwMD92YWx8MHhGRkZGMDAwMDp2YWw7fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCwyLHRoaXMubGVuZ3RoKTt2YXIgdmFsPXRoaXNbb2Zmc2V0KzFdfHRoaXNbb2Zmc2V0XTw8ODtyZXR1cm4gdmFsJjB4ODAwMD92YWx8MHhGRkZGMDAwMDp2YWw7fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tvZmZzZXRdfHRoaXNbb2Zmc2V0KzFdPDw4fHRoaXNbb2Zmc2V0KzJdPDwxNnx0aGlzW29mZnNldCszXTw8MjQ7fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uIHJlYWRJbnQzMkJFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tvZmZzZXRdPDwyNHx0aGlzW29mZnNldCsxXTw8MTZ8dGhpc1tvZmZzZXQrMl08PDh8dGhpc1tvZmZzZXQrM107fTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uIHJlYWRGbG9hdExFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsb2Zmc2V0LHRydWUsMjMsNCk7fTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsb2Zmc2V0LGZhbHNlLDIzLDQpO307QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24gcmVhZERvdWJsZUxFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsb2Zmc2V0LHRydWUsNTIsOCk7fTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbiByZWFkRG91YmxlQkUob2Zmc2V0LG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LDgsdGhpcy5sZW5ndGgpO3JldHVybiBpZWVlNzU0LnJlYWQodGhpcyxvZmZzZXQsZmFsc2UsNTIsOCk7fTtmdW5jdGlvbiBjaGVja0ludChidWYsdmFsdWUsb2Zmc2V0LGV4dCxtYXgsbWluKXtpZighQnVmZmVyLmlzQnVmZmVyKGJ1ZikpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7aWYodmFsdWU+bWF4fHx2YWx1ZTxtaW4pdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYob2Zmc2V0K2V4dD5idWYubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTt9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRSh2YWx1ZSxvZmZzZXQsYnl0ZUxlbmd0aCxub0Fzc2VydCl7dmFsdWU9K3ZhbHVlO29mZnNldD1vZmZzZXQ+Pj4wO2J5dGVMZW5ndGg9Ynl0ZUxlbmd0aD4+PjA7aWYoIW5vQXNzZXJ0KXt2YXIgbWF4Qnl0ZXM9TWF0aC5wb3coMiw4KmJ5dGVMZW5ndGgpLTE7Y2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsYnl0ZUxlbmd0aCxtYXhCeXRlcywwKTt9dmFyIG11bD0xO3ZhciBpPTA7dGhpc1tvZmZzZXRdPXZhbHVlJjB4RkY7d2hpbGUoKytpPGJ5dGVMZW5ndGgmJihtdWwqPTB4MTAwKSl7dGhpc1tvZmZzZXQraV09dmFsdWUvbXVsJjB4RkY7fXJldHVybiBvZmZzZXQrYnl0ZUxlbmd0aDt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24gd3JpdGVVSW50QkUodmFsdWUsb2Zmc2V0LGJ5dGVMZW5ndGgsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtieXRlTGVuZ3RoPWJ5dGVMZW5ndGg+Pj4wO2lmKCFub0Fzc2VydCl7dmFyIG1heEJ5dGVzPU1hdGgucG93KDIsOCpieXRlTGVuZ3RoKS0xO2NoZWNrSW50KHRoaXMsdmFsdWUsb2Zmc2V0LGJ5dGVMZW5ndGgsbWF4Qnl0ZXMsMCk7fXZhciBpPWJ5dGVMZW5ndGgtMTt2YXIgbXVsPTE7dGhpc1tvZmZzZXQraV09dmFsdWUmMHhGRjt3aGlsZSgtLWk+PTAmJihtdWwqPTB4MTAwKSl7dGhpc1tvZmZzZXQraV09dmFsdWUvbXVsJjB4RkY7fXJldHVybiBvZmZzZXQrYnl0ZUxlbmd0aDt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbiB3cml0ZVVJbnQ4KHZhbHVlLG9mZnNldCxub0Fzc2VydCl7dmFsdWU9K3ZhbHVlO29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja0ludCh0aGlzLHZhbHVlLG9mZnNldCwxLDB4ZmYsMCk7dGhpc1tvZmZzZXRdPXZhbHVlJjB4ZmY7cmV0dXJuIG9mZnNldCsxO307QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrSW50KHRoaXMsdmFsdWUsb2Zmc2V0LDIsMHhmZmZmLDApO3RoaXNbb2Zmc2V0XT12YWx1ZSYweGZmO3RoaXNbb2Zmc2V0KzFdPXZhbHVlPj4+ODtyZXR1cm4gb2Zmc2V0KzI7fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24gd3JpdGVVSW50MTZCRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsMiwweGZmZmYsMCk7dGhpc1tvZmZzZXRdPXZhbHVlPj4+ODt0aGlzW29mZnNldCsxXT12YWx1ZSYweGZmO3JldHVybiBvZmZzZXQrMjt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkxFKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7dmFsdWU9K3ZhbHVlO29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja0ludCh0aGlzLHZhbHVlLG9mZnNldCw0LDB4ZmZmZmZmZmYsMCk7dGhpc1tvZmZzZXQrM109dmFsdWU+Pj4yNDt0aGlzW29mZnNldCsyXT12YWx1ZT4+PjE2O3RoaXNbb2Zmc2V0KzFdPXZhbHVlPj4+ODt0aGlzW29mZnNldF09dmFsdWUmMHhmZjtyZXR1cm4gb2Zmc2V0KzQ7fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsNCwweGZmZmZmZmZmLDApO3RoaXNbb2Zmc2V0XT12YWx1ZT4+PjI0O3RoaXNbb2Zmc2V0KzFdPXZhbHVlPj4+MTY7dGhpc1tvZmZzZXQrMl09dmFsdWU+Pj44O3RoaXNbb2Zmc2V0KzNdPXZhbHVlJjB4ZmY7cmV0dXJuIG9mZnNldCs0O307QnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFPWZ1bmN0aW9uIHdyaXRlSW50TEUodmFsdWUsb2Zmc2V0LGJ5dGVMZW5ndGgsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpe3ZhciBsaW1pdD1NYXRoLnBvdygyLDgqYnl0ZUxlbmd0aC0xKTtjaGVja0ludCh0aGlzLHZhbHVlLG9mZnNldCxieXRlTGVuZ3RoLGxpbWl0LTEsLWxpbWl0KTt9dmFyIGk9MDt2YXIgbXVsPTE7dmFyIHN1Yj0wO3RoaXNbb2Zmc2V0XT12YWx1ZSYweEZGO3doaWxlKCsraTxieXRlTGVuZ3RoJiYobXVsKj0weDEwMCkpe2lmKHZhbHVlPDAmJnN1Yj09PTAmJnRoaXNbb2Zmc2V0K2ktMV0hPT0wKXtzdWI9MTt9dGhpc1tvZmZzZXQraV09KHZhbHVlL211bD4+MCktc3ViJjB4RkY7fXJldHVybiBvZmZzZXQrYnl0ZUxlbmd0aDt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbiB3cml0ZUludEJFKHZhbHVlLG9mZnNldCxieXRlTGVuZ3RoLG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KXt2YXIgbGltaXQ9TWF0aC5wb3coMiw4KmJ5dGVMZW5ndGgtMSk7Y2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsYnl0ZUxlbmd0aCxsaW1pdC0xLC1saW1pdCk7fXZhciBpPWJ5dGVMZW5ndGgtMTt2YXIgbXVsPTE7dmFyIHN1Yj0wO3RoaXNbb2Zmc2V0K2ldPXZhbHVlJjB4RkY7d2hpbGUoLS1pPj0wJiYobXVsKj0weDEwMCkpe2lmKHZhbHVlPDAmJnN1Yj09PTAmJnRoaXNbb2Zmc2V0K2krMV0hPT0wKXtzdWI9MTt9dGhpc1tvZmZzZXQraV09KHZhbHVlL211bD4+MCktc3ViJjB4RkY7fXJldHVybiBvZmZzZXQrYnl0ZUxlbmd0aDt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OCh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsMSwweDdmLC0weDgwKTtpZih2YWx1ZTwwKXZhbHVlPTB4ZmYrdmFsdWUrMTt0aGlzW29mZnNldF09dmFsdWUmMHhmZjtyZXR1cm4gb2Zmc2V0KzE7fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrSW50KHRoaXMsdmFsdWUsb2Zmc2V0LDIsMHg3ZmZmLC0weDgwMDApO3RoaXNbb2Zmc2V0XT12YWx1ZSYweGZmO3RoaXNbb2Zmc2V0KzFdPXZhbHVlPj4+ODtyZXR1cm4gb2Zmc2V0KzI7fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbiB3cml0ZUludDE2QkUodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrSW50KHRoaXMsdmFsdWUsb2Zmc2V0LDIsMHg3ZmZmLC0weDgwMDApO3RoaXNbb2Zmc2V0XT12YWx1ZT4+Pjg7dGhpc1tvZmZzZXQrMV09dmFsdWUmMHhmZjtyZXR1cm4gb2Zmc2V0KzI7fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbiB3cml0ZUludDMyTEUodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrSW50KHRoaXMsdmFsdWUsb2Zmc2V0LDQsMHg3ZmZmZmZmZiwtMHg4MDAwMDAwMCk7dGhpc1tvZmZzZXRdPXZhbHVlJjB4ZmY7dGhpc1tvZmZzZXQrMV09dmFsdWU+Pj44O3RoaXNbb2Zmc2V0KzJdPXZhbHVlPj4+MTY7dGhpc1tvZmZzZXQrM109dmFsdWU+Pj4yNDtyZXR1cm4gb2Zmc2V0KzQ7fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbiB3cml0ZUludDMyQkUodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrSW50KHRoaXMsdmFsdWUsb2Zmc2V0LDQsMHg3ZmZmZmZmZiwtMHg4MDAwMDAwMCk7aWYodmFsdWU8MCl2YWx1ZT0weGZmZmZmZmZmK3ZhbHVlKzE7dGhpc1tvZmZzZXRdPXZhbHVlPj4+MjQ7dGhpc1tvZmZzZXQrMV09dmFsdWU+Pj4xNjt0aGlzW29mZnNldCsyXT12YWx1ZT4+Pjg7dGhpc1tvZmZzZXQrM109dmFsdWUmMHhmZjtyZXR1cm4gb2Zmc2V0KzQ7fTtmdW5jdGlvbiBjaGVja0lFRUU3NTQoYnVmLHZhbHVlLG9mZnNldCxleHQsbWF4LG1pbil7aWYob2Zmc2V0K2V4dD5idWYubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtpZihvZmZzZXQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7fWZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpe2NoZWNrSUVFRTc1NChidWYsdmFsdWUsb2Zmc2V0LDQsMy40MDI4MjM0NjYzODUyODg2ZSszOCwtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7fWllZWU3NTQud3JpdGUoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sMjMsNCk7cmV0dXJuIG9mZnNldCs0O31CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbiB3cml0ZUZsb2F0TEUodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLHZhbHVlLG9mZnNldCx0cnVlLG5vQXNzZXJ0KTt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uIHdyaXRlRmxvYXRCRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsdmFsdWUsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KTt9O2Z1bmN0aW9uIHdyaXRlRG91YmxlKGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KXtjaGVja0lFRUU3NTQoYnVmLHZhbHVlLG9mZnNldCw4LDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7fWllZWU3NTQud3JpdGUoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sNTIsOCk7cmV0dXJuIG9mZnNldCs4O31CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLHZhbHVlLG9mZnNldCx0cnVlLG5vQXNzZXJ0KTt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsdmFsdWUsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KTt9Oy8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KHRhcmdldCx0YXJnZXRTdGFydCxzdGFydCxlbmQpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKTtpZighc3RhcnQpc3RhcnQ9MDtpZighZW5kJiZlbmQhPT0wKWVuZD10aGlzLmxlbmd0aDtpZih0YXJnZXRTdGFydD49dGFyZ2V0Lmxlbmd0aCl0YXJnZXRTdGFydD10YXJnZXQubGVuZ3RoO2lmKCF0YXJnZXRTdGFydCl0YXJnZXRTdGFydD0wO2lmKGVuZD4wJiZlbmQ8c3RhcnQpZW5kPXN0YXJ0Oy8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuaWYoZW5kPT09c3RhcnQpcmV0dXJuIDA7aWYodGFyZ2V0Lmxlbmd0aD09PTB8fHRoaXMubGVuZ3RoPT09MClyZXR1cm4gMDsvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG5pZih0YXJnZXRTdGFydDwwKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO31pZihzdGFydDwwfHxzdGFydD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO2lmKGVuZDwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpOy8vIEFyZSB3ZSBvb2I/XG5pZihlbmQ+dGhpcy5sZW5ndGgpZW5kPXRoaXMubGVuZ3RoO2lmKHRhcmdldC5sZW5ndGgtdGFyZ2V0U3RhcnQ8ZW5kLXN0YXJ0KXtlbmQ9dGFyZ2V0Lmxlbmd0aC10YXJnZXRTdGFydCtzdGFydDt9dmFyIGxlbj1lbmQtc3RhcnQ7aWYodGhpcz09PXRhcmdldCYmdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW49PT0nZnVuY3Rpb24nKXsvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG50aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsc3RhcnQsZW5kKTt9ZWxzZSBpZih0aGlzPT09dGFyZ2V0JiZzdGFydDx0YXJnZXRTdGFydCYmdGFyZ2V0U3RhcnQ8ZW5kKXsvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbmZvcih2YXIgaT1sZW4tMTtpPj0wOy0taSl7dGFyZ2V0W2krdGFyZ2V0U3RhcnRdPXRoaXNbaStzdGFydF07fX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHRhcmdldCx0aGlzLnN1YmFycmF5KHN0YXJ0LGVuZCksdGFyZ2V0U3RhcnQpO31yZXR1cm4gbGVuO307Ly8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbCh2YWwsc3RhcnQsZW5kLGVuY29kaW5nKXsvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuaWYodHlwZW9mIHZhbD09PSdzdHJpbmcnKXtpZih0eXBlb2Ygc3RhcnQ9PT0nc3RyaW5nJyl7ZW5jb2Rpbmc9c3RhcnQ7c3RhcnQ9MDtlbmQ9dGhpcy5sZW5ndGg7fWVsc2UgaWYodHlwZW9mIGVuZD09PSdzdHJpbmcnKXtlbmNvZGluZz1lbmQ7ZW5kPXRoaXMubGVuZ3RoO31pZihlbmNvZGluZyE9PXVuZGVmaW5lZCYmdHlwZW9mIGVuY29kaW5nIT09J3N0cmluZycpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKTt9aWYodHlwZW9mIGVuY29kaW5nPT09J3N0cmluZycmJiFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcrZW5jb2RpbmcpO31pZih2YWwubGVuZ3RoPT09MSl7dmFyIGNvZGU9dmFsLmNoYXJDb2RlQXQoMCk7aWYoZW5jb2Rpbmc9PT0ndXRmOCcmJmNvZGU8MTI4fHxlbmNvZGluZz09PSdsYXRpbjEnKXsvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxudmFsPWNvZGU7fX19ZWxzZSBpZih0eXBlb2YgdmFsPT09J251bWJlcicpe3ZhbD12YWwmMjU1O30vLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbmlmKHN0YXJ0PDB8fHRoaXMubGVuZ3RoPHN0YXJ0fHx0aGlzLmxlbmd0aDxlbmQpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKTt9aWYoZW5kPD1zdGFydCl7cmV0dXJuIHRoaXM7fXN0YXJ0PXN0YXJ0Pj4+MDtlbmQ9ZW5kPT09dW5kZWZpbmVkP3RoaXMubGVuZ3RoOmVuZD4+PjA7aWYoIXZhbCl2YWw9MDt2YXIgaTtpZih0eXBlb2YgdmFsPT09J251bWJlcicpe2ZvcihpPXN0YXJ0O2k8ZW5kOysraSl7dGhpc1tpXT12YWw7fX1lbHNle3ZhciBieXRlcz1CdWZmZXIuaXNCdWZmZXIodmFsKT92YWw6QnVmZmVyLmZyb20odmFsLGVuY29kaW5nKTt2YXIgbGVuPWJ5dGVzLmxlbmd0aDtpZihsZW49PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK3ZhbCsnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJyk7fWZvcihpPTA7aTxlbmQtc3RhcnQ7KytpKXt0aGlzW2krc3RhcnRdPWJ5dGVzW2klbGVuXTt9fXJldHVybiB0aGlzO307Ly8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxudmFyIElOVkFMSURfQkFTRTY0X1JFPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gYmFzZTY0Y2xlYW4oc3RyKXsvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG5zdHI9c3RyLnNwbGl0KCc9JylbMF07Ly8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG5zdHI9c3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCcnKTsvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG5pZihzdHIubGVuZ3RoPDIpcmV0dXJuJyc7Ly8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG53aGlsZShzdHIubGVuZ3RoJTQhPT0wKXtzdHI9c3RyKyc9Jzt9cmV0dXJuIHN0cjt9ZnVuY3Rpb24gdG9IZXgobil7aWYobjwxNilyZXR1cm4nMCcrbi50b1N0cmluZygxNik7cmV0dXJuIG4udG9TdHJpbmcoMTYpO31mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHJpbmcsdW5pdHMpe3VuaXRzPXVuaXRzfHxJbmZpbml0eTt2YXIgY29kZVBvaW50O3ZhciBsZW5ndGg9c3RyaW5nLmxlbmd0aDt2YXIgbGVhZFN1cnJvZ2F0ZT1udWxsO3ZhciBieXRlcz1bXTtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe2NvZGVQb2ludD1zdHJpbmcuY2hhckNvZGVBdChpKTsvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG5pZihjb2RlUG9pbnQ+MHhEN0ZGJiZjb2RlUG9pbnQ8MHhFMDAwKXsvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuaWYoIWxlYWRTdXJyb2dhdGUpey8vIG5vIGxlYWQgeWV0XG5pZihjb2RlUG9pbnQ+MHhEQkZGKXsvLyB1bmV4cGVjdGVkIHRyYWlsXG5pZigodW5pdHMtPTMpPi0xKWJ5dGVzLnB1c2goMHhFRiwweEJGLDB4QkQpO2NvbnRpbnVlO31lbHNlIGlmKGkrMT09PWxlbmd0aCl7Ly8gdW5wYWlyZWQgbGVhZFxuaWYoKHVuaXRzLT0zKT4tMSlieXRlcy5wdXNoKDB4RUYsMHhCRiwweEJEKTtjb250aW51ZTt9Ly8gdmFsaWQgbGVhZFxubGVhZFN1cnJvZ2F0ZT1jb2RlUG9pbnQ7Y29udGludWU7fS8vIDIgbGVhZHMgaW4gYSByb3dcbmlmKGNvZGVQb2ludDwweERDMDApe2lmKCh1bml0cy09Myk+LTEpYnl0ZXMucHVzaCgweEVGLDB4QkYsMHhCRCk7bGVhZFN1cnJvZ2F0ZT1jb2RlUG9pbnQ7Y29udGludWU7fS8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG5jb2RlUG9pbnQ9KGxlYWRTdXJyb2dhdGUtMHhEODAwPDwxMHxjb2RlUG9pbnQtMHhEQzAwKSsweDEwMDAwO31lbHNlIGlmKGxlYWRTdXJyb2dhdGUpey8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbmlmKCh1bml0cy09Myk+LTEpYnl0ZXMucHVzaCgweEVGLDB4QkYsMHhCRCk7fWxlYWRTdXJyb2dhdGU9bnVsbDsvLyBlbmNvZGUgdXRmOFxuaWYoY29kZVBvaW50PDB4ODApe2lmKCh1bml0cy09MSk8MClicmVhaztieXRlcy5wdXNoKGNvZGVQb2ludCk7fWVsc2UgaWYoY29kZVBvaW50PDB4ODAwKXtpZigodW5pdHMtPTIpPDApYnJlYWs7Ynl0ZXMucHVzaChjb2RlUG9pbnQ+PjB4NnwweEMwLGNvZGVQb2ludCYweDNGfDB4ODApO31lbHNlIGlmKGNvZGVQb2ludDwweDEwMDAwKXtpZigodW5pdHMtPTMpPDApYnJlYWs7Ynl0ZXMucHVzaChjb2RlUG9pbnQ+PjB4Q3wweEUwLGNvZGVQb2ludD4+MHg2JjB4M0Z8MHg4MCxjb2RlUG9pbnQmMHgzRnwweDgwKTt9ZWxzZSBpZihjb2RlUG9pbnQ8MHgxMTAwMDApe2lmKCh1bml0cy09NCk8MClicmVhaztieXRlcy5wdXNoKGNvZGVQb2ludD4+MHgxMnwweEYwLGNvZGVQb2ludD4+MHhDJjB4M0Z8MHg4MCxjb2RlUG9pbnQ+PjB4NiYweDNGfDB4ODAsY29kZVBvaW50JjB4M0Z8MHg4MCk7fWVsc2V7dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKTt9fXJldHVybiBieXRlczt9ZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cil7dmFyIGJ5dGVBcnJheT1bXTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXsvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbmJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpJjB4RkYpO31yZXR1cm4gYnl0ZUFycmF5O31mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhzdHIsdW5pdHMpe3ZhciBjLGhpLGxvO3ZhciBieXRlQXJyYXk9W107Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7aWYoKHVuaXRzLT0yKTwwKWJyZWFrO2M9c3RyLmNoYXJDb2RlQXQoaSk7aGk9Yz4+ODtsbz1jJTI1NjtieXRlQXJyYXkucHVzaChsbyk7Ynl0ZUFycmF5LnB1c2goaGkpO31yZXR1cm4gYnl0ZUFycmF5O31mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cil7cmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKTt9ZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsZHN0LG9mZnNldCxsZW5ndGgpe2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7aWYoaStvZmZzZXQ+PWRzdC5sZW5ndGh8fGk+PXNyYy5sZW5ndGgpYnJlYWs7ZHN0W2krb2Zmc2V0XT1zcmNbaV07fXJldHVybiBpO30vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2Uob2JqLHR5cGUpe3JldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlfHxvYmohPW51bGwmJm9iai5jb25zdHJ1Y3RvciE9bnVsbCYmb2JqLmNvbnN0cnVjdG9yLm5hbWUhPW51bGwmJm9iai5jb25zdHJ1Y3Rvci5uYW1lPT09dHlwZS5uYW1lO31mdW5jdGlvbiBudW1iZXJJc05hTihvYmopey8vIEZvciBJRTExIHN1cHBvcnRcbnJldHVybiBvYmohPT1vYmo7Ly8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn19KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpO30se1wiYmFzZTY0LWpzXCI6MSxcImJ1ZmZlclwiOjMsXCJpZWVlNzU0XCI6MzJ9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz17XCJlbGVtZW50TmFtZXNcIjp7XCJhbHRnbHlwaFwiOlwiYWx0R2x5cGhcIixcImFsdGdseXBoZGVmXCI6XCJhbHRHbHlwaERlZlwiLFwiYWx0Z2x5cGhpdGVtXCI6XCJhbHRHbHlwaEl0ZW1cIixcImFuaW1hdGVjb2xvclwiOlwiYW5pbWF0ZUNvbG9yXCIsXCJhbmltYXRlbW90aW9uXCI6XCJhbmltYXRlTW90aW9uXCIsXCJhbmltYXRldHJhbnNmb3JtXCI6XCJhbmltYXRlVHJhbnNmb3JtXCIsXCJjbGlwcGF0aFwiOlwiY2xpcFBhdGhcIixcImZlYmxlbmRcIjpcImZlQmxlbmRcIixcImZlY29sb3JtYXRyaXhcIjpcImZlQ29sb3JNYXRyaXhcIixcImZlY29tcG9uZW50dHJhbnNmZXJcIjpcImZlQ29tcG9uZW50VHJhbnNmZXJcIixcImZlY29tcG9zaXRlXCI6XCJmZUNvbXBvc2l0ZVwiLFwiZmVjb252b2x2ZW1hdHJpeFwiOlwiZmVDb252b2x2ZU1hdHJpeFwiLFwiZmVkaWZmdXNlbGlnaHRpbmdcIjpcImZlRGlmZnVzZUxpZ2h0aW5nXCIsXCJmZWRpc3BsYWNlbWVudG1hcFwiOlwiZmVEaXNwbGFjZW1lbnRNYXBcIixcImZlZGlzdGFudGxpZ2h0XCI6XCJmZURpc3RhbnRMaWdodFwiLFwiZmVkcm9wc2hhZG93XCI6XCJmZURyb3BTaGFkb3dcIixcImZlZmxvb2RcIjpcImZlRmxvb2RcIixcImZlZnVuY2FcIjpcImZlRnVuY0FcIixcImZlZnVuY2JcIjpcImZlRnVuY0JcIixcImZlZnVuY2dcIjpcImZlRnVuY0dcIixcImZlZnVuY3JcIjpcImZlRnVuY1JcIixcImZlZ2F1c3NpYW5ibHVyXCI6XCJmZUdhdXNzaWFuQmx1clwiLFwiZmVpbWFnZVwiOlwiZmVJbWFnZVwiLFwiZmVtZXJnZVwiOlwiZmVNZXJnZVwiLFwiZmVtZXJnZW5vZGVcIjpcImZlTWVyZ2VOb2RlXCIsXCJmZW1vcnBob2xvZ3lcIjpcImZlTW9ycGhvbG9neVwiLFwiZmVvZmZzZXRcIjpcImZlT2Zmc2V0XCIsXCJmZXBvaW50bGlnaHRcIjpcImZlUG9pbnRMaWdodFwiLFwiZmVzcGVjdWxhcmxpZ2h0aW5nXCI6XCJmZVNwZWN1bGFyTGlnaHRpbmdcIixcImZlc3BvdGxpZ2h0XCI6XCJmZVNwb3RMaWdodFwiLFwiZmV0aWxlXCI6XCJmZVRpbGVcIixcImZldHVyYnVsZW5jZVwiOlwiZmVUdXJidWxlbmNlXCIsXCJmb3JlaWdub2JqZWN0XCI6XCJmb3JlaWduT2JqZWN0XCIsXCJnbHlwaHJlZlwiOlwiZ2x5cGhSZWZcIixcImxpbmVhcmdyYWRpZW50XCI6XCJsaW5lYXJHcmFkaWVudFwiLFwicmFkaWFsZ3JhZGllbnRcIjpcInJhZGlhbEdyYWRpZW50XCIsXCJ0ZXh0cGF0aFwiOlwidGV4dFBhdGhcIn0sXCJhdHRyaWJ1dGVOYW1lc1wiOntcImRlZmluaXRpb251cmxcIjpcImRlZmluaXRpb25VUkxcIixcImF0dHJpYnV0ZW5hbWVcIjpcImF0dHJpYnV0ZU5hbWVcIixcImF0dHJpYnV0ZXR5cGVcIjpcImF0dHJpYnV0ZVR5cGVcIixcImJhc2VmcmVxdWVuY3lcIjpcImJhc2VGcmVxdWVuY3lcIixcImJhc2Vwcm9maWxlXCI6XCJiYXNlUHJvZmlsZVwiLFwiY2FsY21vZGVcIjpcImNhbGNNb2RlXCIsXCJjbGlwcGF0aHVuaXRzXCI6XCJjbGlwUGF0aFVuaXRzXCIsXCJkaWZmdXNlY29uc3RhbnRcIjpcImRpZmZ1c2VDb25zdGFudFwiLFwiZWRnZW1vZGVcIjpcImVkZ2VNb2RlXCIsXCJmaWx0ZXJ1bml0c1wiOlwiZmlsdGVyVW5pdHNcIixcImdseXBocmVmXCI6XCJnbHlwaFJlZlwiLFwiZ3JhZGllbnR0cmFuc2Zvcm1cIjpcImdyYWRpZW50VHJhbnNmb3JtXCIsXCJncmFkaWVudHVuaXRzXCI6XCJncmFkaWVudFVuaXRzXCIsXCJrZXJuZWxtYXRyaXhcIjpcImtlcm5lbE1hdHJpeFwiLFwia2VybmVsdW5pdGxlbmd0aFwiOlwia2VybmVsVW5pdExlbmd0aFwiLFwia2V5cG9pbnRzXCI6XCJrZXlQb2ludHNcIixcImtleXNwbGluZXNcIjpcImtleVNwbGluZXNcIixcImtleXRpbWVzXCI6XCJrZXlUaW1lc1wiLFwibGVuZ3RoYWRqdXN0XCI6XCJsZW5ndGhBZGp1c3RcIixcImxpbWl0aW5nY29uZWFuZ2xlXCI6XCJsaW1pdGluZ0NvbmVBbmdsZVwiLFwibWFya2VyaGVpZ2h0XCI6XCJtYXJrZXJIZWlnaHRcIixcIm1hcmtlcnVuaXRzXCI6XCJtYXJrZXJVbml0c1wiLFwibWFya2Vyd2lkdGhcIjpcIm1hcmtlcldpZHRoXCIsXCJtYXNrY29udGVudHVuaXRzXCI6XCJtYXNrQ29udGVudFVuaXRzXCIsXCJtYXNrdW5pdHNcIjpcIm1hc2tVbml0c1wiLFwibnVtb2N0YXZlc1wiOlwibnVtT2N0YXZlc1wiLFwicGF0aGxlbmd0aFwiOlwicGF0aExlbmd0aFwiLFwicGF0dGVybmNvbnRlbnR1bml0c1wiOlwicGF0dGVybkNvbnRlbnRVbml0c1wiLFwicGF0dGVybnRyYW5zZm9ybVwiOlwicGF0dGVyblRyYW5zZm9ybVwiLFwicGF0dGVybnVuaXRzXCI6XCJwYXR0ZXJuVW5pdHNcIixcInBvaW50c2F0eFwiOlwicG9pbnRzQXRYXCIsXCJwb2ludHNhdHlcIjpcInBvaW50c0F0WVwiLFwicG9pbnRzYXR6XCI6XCJwb2ludHNBdFpcIixcInByZXNlcnZlYWxwaGFcIjpcInByZXNlcnZlQWxwaGFcIixcInByZXNlcnZlYXNwZWN0cmF0aW9cIjpcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcInByaW1pdGl2ZXVuaXRzXCI6XCJwcmltaXRpdmVVbml0c1wiLFwicmVmeFwiOlwicmVmWFwiLFwicmVmeVwiOlwicmVmWVwiLFwicmVwZWF0Y291bnRcIjpcInJlcGVhdENvdW50XCIsXCJyZXBlYXRkdXJcIjpcInJlcGVhdER1clwiLFwicmVxdWlyZWRleHRlbnNpb25zXCI6XCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcInJlcXVpcmVkZmVhdHVyZXNcIjpcInJlcXVpcmVkRmVhdHVyZXNcIixcInNwZWN1bGFyY29uc3RhbnRcIjpcInNwZWN1bGFyQ29uc3RhbnRcIixcInNwZWN1bGFyZXhwb25lbnRcIjpcInNwZWN1bGFyRXhwb25lbnRcIixcInNwcmVhZG1ldGhvZFwiOlwic3ByZWFkTWV0aG9kXCIsXCJzdGFydG9mZnNldFwiOlwic3RhcnRPZmZzZXRcIixcInN0ZGRldmlhdGlvblwiOlwic3RkRGV2aWF0aW9uXCIsXCJzdGl0Y2h0aWxlc1wiOlwic3RpdGNoVGlsZXNcIixcInN1cmZhY2VzY2FsZVwiOlwic3VyZmFjZVNjYWxlXCIsXCJzeXN0ZW1sYW5ndWFnZVwiOlwic3lzdGVtTGFuZ3VhZ2VcIixcInRhYmxldmFsdWVzXCI6XCJ0YWJsZVZhbHVlc1wiLFwidGFyZ2V0eFwiOlwidGFyZ2V0WFwiLFwidGFyZ2V0eVwiOlwidGFyZ2V0WVwiLFwidGV4dGxlbmd0aFwiOlwidGV4dExlbmd0aFwiLFwidmlld2JveFwiOlwidmlld0JveFwiLFwidmlld3RhcmdldFwiOlwidmlld1RhcmdldFwiLFwieGNoYW5uZWxzZWxlY3RvclwiOlwieENoYW5uZWxTZWxlY3RvclwiLFwieWNoYW5uZWxzZWxlY3RvclwiOlwieUNoYW5uZWxTZWxlY3RvclwiLFwiem9vbWFuZHBhblwiOlwiem9vbUFuZFBhblwifX07fSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LypcbiAgTW9kdWxlIGRlcGVuZGVuY2llc1xuKi92YXIgRWxlbWVudFR5cGU9cmVxdWlyZSgnZG9tZWxlbWVudHR5cGUnKTt2YXIgZW50aXRpZXM9cmVxdWlyZSgnZW50aXRpZXMnKTsvKiBtaXhlZC1jYXNlIFNWRyBhbmQgTWF0aE1MIHRhZ3MgJiBhdHRyaWJ1dGVzXG4gICByZWNvZ25pemVkIGJ5IHRoZSBIVE1MIHBhcnNlciwgc2VlXG4gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjcGFyc2luZy1tYWluLWluZm9yZWlnblxuKi92YXIgZm9yZWlnbk5hbWVzPXJlcXVpcmUoJy4vZm9yZWlnbk5hbWVzLmpzb24nKTtmb3JlaWduTmFtZXMuZWxlbWVudE5hbWVzLl9fcHJvdG9fXz1udWxsOy8qIHVzZSBhcyBhIHNpbXBsZSBkaWN0aW9uYXJ5ICovZm9yZWlnbk5hbWVzLmF0dHJpYnV0ZU5hbWVzLl9fcHJvdG9fXz1udWxsO3ZhciB1bmVuY29kZWRFbGVtZW50cz17X19wcm90b19fOm51bGwsc3R5bGU6dHJ1ZSxzY3JpcHQ6dHJ1ZSx4bXA6dHJ1ZSxpZnJhbWU6dHJ1ZSxub2VtYmVkOnRydWUsbm9mcmFtZXM6dHJ1ZSxwbGFpbnRleHQ6dHJ1ZSxub3NjcmlwdDp0cnVlfTsvKlxuICBGb3JtYXQgYXR0cmlidXRlc1xuKi9mdW5jdGlvbiBmb3JtYXRBdHRycyhhdHRyaWJ1dGVzLG9wdHMpe2lmKCFhdHRyaWJ1dGVzKXJldHVybjt2YXIgb3V0cHV0PScnO3ZhciB2YWx1ZTsvLyBMb29wIHRocm91Z2ggdGhlIGF0dHJpYnV0ZXNcbmZvcih2YXIga2V5IGluIGF0dHJpYnV0ZXMpe3ZhbHVlPWF0dHJpYnV0ZXNba2V5XTtpZihvdXRwdXQpe291dHB1dCs9JyAnO31pZihvcHRzLnhtbE1vZGU9PT0nZm9yZWlnbicpey8qIGZpeCB1cCBtaXhlZC1jYXNlIGF0dHJpYnV0ZSBuYW1lcyAqL2tleT1mb3JlaWduTmFtZXMuYXR0cmlidXRlTmFtZXNba2V5XXx8a2V5O31vdXRwdXQrPWtleTtpZih2YWx1ZSE9PW51bGwmJnZhbHVlIT09Jyd8fG9wdHMueG1sTW9kZSl7b3V0cHV0Kz0nPVwiJysob3B0cy5kZWNvZGVFbnRpdGllcz9lbnRpdGllcy5lbmNvZGVYTUwodmFsdWUpOnZhbHVlLnJlcGxhY2UoL1xcXCIvZywnJnF1b3Q7JykpKydcIic7fX1yZXR1cm4gb3V0cHV0O30vKlxuICBTZWxmLWVuY2xvc2luZyB0YWdzIChzdG9sZW4gZnJvbSBub2RlLWh0bWxwYXJzZXIpXG4qL3ZhciBzaW5nbGVUYWc9e19fcHJvdG9fXzpudWxsLGFyZWE6dHJ1ZSxiYXNlOnRydWUsYmFzZWZvbnQ6dHJ1ZSxicjp0cnVlLGNvbDp0cnVlLGNvbW1hbmQ6dHJ1ZSxlbWJlZDp0cnVlLGZyYW1lOnRydWUsaHI6dHJ1ZSxpbWc6dHJ1ZSxpbnB1dDp0cnVlLGlzaW5kZXg6dHJ1ZSxrZXlnZW46dHJ1ZSxsaW5rOnRydWUsbWV0YTp0cnVlLHBhcmFtOnRydWUsc291cmNlOnRydWUsdHJhY2s6dHJ1ZSx3YnI6dHJ1ZX07dmFyIHJlbmRlcj1tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihkb20sb3B0cyl7aWYoIUFycmF5LmlzQXJyYXkoZG9tKSYmIWRvbS5jaGVlcmlvKWRvbT1bZG9tXTtvcHRzPW9wdHN8fHt9O3ZhciBvdXRwdXQ9Jyc7Zm9yKHZhciBpPTA7aTxkb20ubGVuZ3RoO2krKyl7dmFyIGVsZW09ZG9tW2ldO2lmKGVsZW0udHlwZT09PSdyb290JylvdXRwdXQrPXJlbmRlcihlbGVtLmNoaWxkcmVuLG9wdHMpO2Vsc2UgaWYoRWxlbWVudFR5cGUuaXNUYWcoZWxlbSkpb3V0cHV0Kz1yZW5kZXJUYWcoZWxlbSxvcHRzKTtlbHNlIGlmKGVsZW0udHlwZT09PUVsZW1lbnRUeXBlLkRpcmVjdGl2ZSlvdXRwdXQrPXJlbmRlckRpcmVjdGl2ZShlbGVtKTtlbHNlIGlmKGVsZW0udHlwZT09PUVsZW1lbnRUeXBlLkNvbW1lbnQpb3V0cHV0Kz1yZW5kZXJDb21tZW50KGVsZW0pO2Vsc2UgaWYoZWxlbS50eXBlPT09RWxlbWVudFR5cGUuQ0RBVEEpb3V0cHV0Kz1yZW5kZXJDZGF0YShlbGVtKTtlbHNlIG91dHB1dCs9cmVuZGVyVGV4dChlbGVtLG9wdHMpO31yZXR1cm4gb3V0cHV0O307dmFyIGZvcmVpZ25Nb2RlSW50ZWdyYXRpb25Qb2ludHM9WydtaScsJ21vJywnbW4nLCdtcycsJ210ZXh0JywnYW5ub3RhdGlvbi14bWwnLCdmb3JlaWduT2JqZWN0JywnZGVzYycsJ3RpdGxlJ107ZnVuY3Rpb24gcmVuZGVyVGFnKGVsZW0sb3B0cyl7Ly8gSGFuZGxlIFNWRyAvIE1hdGhNTCBpbiBIVE1MXG5pZihvcHRzLnhtbE1vZGU9PT0nZm9yZWlnbicpey8qIGZpeCB1cCBtaXhlZC1jYXNlIGVsZW1lbnQgbmFtZXMgKi9lbGVtLm5hbWU9Zm9yZWlnbk5hbWVzLmVsZW1lbnROYW1lc1tlbGVtLm5hbWVdfHxlbGVtLm5hbWU7LyogZXhpdCBmb3JlaWduIG1vZGUgYXQgaW50ZWdyYXRpb24gcG9pbnRzICovaWYoZWxlbS5wYXJlbnQmJmZvcmVpZ25Nb2RlSW50ZWdyYXRpb25Qb2ludHMuaW5kZXhPZihlbGVtLnBhcmVudC5uYW1lKT49MClvcHRzPU9iamVjdC5hc3NpZ24oe30sb3B0cyx7eG1sTW9kZTpmYWxzZX0pO31pZighb3B0cy54bWxNb2RlJiZbJ3N2ZycsJ21hdGgnXS5pbmRleE9mKGVsZW0ubmFtZSk+PTApe29wdHM9T2JqZWN0LmFzc2lnbih7fSxvcHRzLHt4bWxNb2RlOidmb3JlaWduJ30pO312YXIgdGFnPSc8JytlbGVtLm5hbWU7dmFyIGF0dHJpYnM9Zm9ybWF0QXR0cnMoZWxlbS5hdHRyaWJzLG9wdHMpO2lmKGF0dHJpYnMpe3RhZys9JyAnK2F0dHJpYnM7fWlmKG9wdHMueG1sTW9kZSYmKCFlbGVtLmNoaWxkcmVufHxlbGVtLmNoaWxkcmVuLmxlbmd0aD09PTApKXt0YWcrPScvPic7fWVsc2V7dGFnKz0nPic7aWYoZWxlbS5jaGlsZHJlbil7dGFnKz1yZW5kZXIoZWxlbS5jaGlsZHJlbixvcHRzKTt9aWYoIXNpbmdsZVRhZ1tlbGVtLm5hbWVdfHxvcHRzLnhtbE1vZGUpe3RhZys9JzwvJytlbGVtLm5hbWUrJz4nO319cmV0dXJuIHRhZzt9ZnVuY3Rpb24gcmVuZGVyRGlyZWN0aXZlKGVsZW0pe3JldHVybic8JytlbGVtLmRhdGErJz4nO31mdW5jdGlvbiByZW5kZXJUZXh0KGVsZW0sb3B0cyl7dmFyIGRhdGE9ZWxlbS5kYXRhfHwnJzsvLyBpZiBlbnRpdGllcyB3ZXJlbid0IGRlY29kZWQsIG5vIG5lZWQgdG8gZW5jb2RlIHRoZW0gYmFja1xuaWYob3B0cy5kZWNvZGVFbnRpdGllcyYmIShlbGVtLnBhcmVudCYmZWxlbS5wYXJlbnQubmFtZSBpbiB1bmVuY29kZWRFbGVtZW50cykpe2RhdGE9ZW50aXRpZXMuZW5jb2RlWE1MKGRhdGEpO31yZXR1cm4gZGF0YTt9ZnVuY3Rpb24gcmVuZGVyQ2RhdGEoZWxlbSl7cmV0dXJuJzwhW0NEQVRBWycrZWxlbS5jaGlsZHJlblswXS5kYXRhKyddXT4nO31mdW5jdGlvbiByZW5kZXJDb21tZW50KGVsZW0pe3JldHVybic8IS0tJytlbGVtLmRhdGErJy0tPic7fX0se1wiLi9mb3JlaWduTmFtZXMuanNvblwiOjQsXCJkb21lbGVtZW50dHlwZVwiOjYsXCJlbnRpdGllc1wiOjIwfV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTsvKipcbiAqIFRlc3RzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhIHRhZyBvciBub3QuXG4gKlxuICogQHBhcmFtIGVsZW0gRWxlbWVudCB0byB0ZXN0XG4gKi9mdW5jdGlvbiBpc1RhZyhlbGVtKXtyZXR1cm4gZWxlbS50eXBlPT09XCJ0YWdcIi8qIFRhZyAqL3x8ZWxlbS50eXBlPT09XCJzY3JpcHRcIi8qIFNjcmlwdCAqL3x8ZWxlbS50eXBlPT09XCJzdHlsZVwiLyogU3R5bGUgKi87fWV4cG9ydHMuaXNUYWc9aXNUYWc7Ly8gRXhwb3J0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmV4cG9ydHMuVGV4dD1cInRleHRcIi8qIFRleHQgKi87Ly9UZXh0XG5leHBvcnRzLkRpcmVjdGl2ZT1cImRpcmVjdGl2ZVwiLyogRGlyZWN0aXZlICovOy8vPD8gLi4uID8+XG5leHBvcnRzLkNvbW1lbnQ9XCJjb21tZW50XCIvKiBDb21tZW50ICovOy8vPCEtLSAuLi4gLS0+XG5leHBvcnRzLlNjcmlwdD1cInNjcmlwdFwiLyogU2NyaXB0ICovOy8vPHNjcmlwdD4gdGFnc1xuZXhwb3J0cy5TdHlsZT1cInN0eWxlXCIvKiBTdHlsZSAqLzsvLzxzdHlsZT4gdGFnc1xuZXhwb3J0cy5UYWc9XCJ0YWdcIi8qIFRhZyAqLzsvL0FueSB0YWdcbmV4cG9ydHMuQ0RBVEE9XCJjZGF0YVwiLyogQ0RBVEEgKi87Ly88IVtDREFUQVsgLi4uIF1dPlxuZXhwb3J0cy5Eb2N0eXBlPVwiZG9jdHlwZVwiLyogRG9jdHlwZSAqLzt9LHt9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciBub2RlXzE9cmVxdWlyZShcIi4vbm9kZVwiKTtleHBvcnRzLk5vZGU9bm9kZV8xLk5vZGU7ZXhwb3J0cy5FbGVtZW50PW5vZGVfMS5FbGVtZW50O2V4cG9ydHMuRGF0YU5vZGU9bm9kZV8xLkRhdGFOb2RlO2V4cG9ydHMuTm9kZVdpdGhDaGlsZHJlbj1ub2RlXzEuTm9kZVdpdGhDaGlsZHJlbjt2YXIgcmVXaGl0ZXNwYWNlPS9cXHMrL2c7Ly8gRGVmYXVsdCBvcHRpb25zXG52YXIgZGVmYXVsdE9wdHM9e25vcm1hbGl6ZVdoaXRlc3BhY2U6ZmFsc2Usd2l0aFN0YXJ0SW5kaWNlczpmYWxzZSx3aXRoRW5kSW5kaWNlczpmYWxzZX07dmFyIERvbUhhbmRsZXI9LyoqIEBjbGFzcyAqL2Z1bmN0aW9uKCl7LyoqXG4gICAgICogSW5pdGlhdGUgYSBuZXcgRG9tSGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBDYWxsZWQgb25jZSBwYXJzaW5nIGhhcyBjb21wbGV0ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU2V0dGluZ3MgZm9yIHRoZSBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSBlbGVtZW50Q0IgQ2FsbGJhY2sgd2hlbmV2ZXIgYSB0YWcgaXMgY2xvc2VkLlxuICAgICAqL2Z1bmN0aW9uIERvbUhhbmRsZXIoY2FsbGJhY2ssb3B0aW9ucyxlbGVtZW50Q0Ipey8qKiBUaGUgY29uc3RydWN0ZWQgRE9NICovdGhpcy5kb209W107LyoqIEluZGljYXRlZCB3aGV0aGVyIHBhcnNpbmcgaGFzIGJlZW4gY29tcGxldGVkLiAqL3RoaXMuX2RvbmU9ZmFsc2U7LyoqIFN0YWNrIG9mIG9wZW4gdGFncy4gKi90aGlzLl90YWdTdGFjaz1bXTsvKiogQSBkYXRhIG5vZGUgdGhhdCBpcyBzdGlsbCBiZWluZyB3cml0dGVuIHRvLiAqL3RoaXMuX2xhc3ROb2RlPW51bGw7LyoqIFJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIGluc3RhbmNlLiBVc2VkIGZvciBsb2NhdGlvbiBpbmZvcm1hdGlvbi4gKi90aGlzLl9wYXJzZXI9bnVsbDsvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIHNraXAgYXJndW1lbnRzLCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbmlmKHR5cGVvZiBvcHRpb25zPT09XCJmdW5jdGlvblwiKXtlbGVtZW50Q0I9b3B0aW9ucztvcHRpb25zPWRlZmF1bHRPcHRzO31pZihfdHlwZW9mKGNhbGxiYWNrKT09PVwib2JqZWN0XCIpe29wdGlvbnM9Y2FsbGJhY2s7Y2FsbGJhY2s9dW5kZWZpbmVkO310aGlzLl9jYWxsYmFjaz1jYWxsYmFja3x8bnVsbDt0aGlzLl9vcHRpb25zPW9wdGlvbnN8fGRlZmF1bHRPcHRzO3RoaXMuX2VsZW1lbnRDQj1lbGVtZW50Q0J8fG51bGw7fURvbUhhbmRsZXIucHJvdG90eXBlLm9ucGFyc2VyaW5pdD1mdW5jdGlvbihwYXJzZXIpe3RoaXMuX3BhcnNlcj1wYXJzZXI7fTsvLyBSZXNldHMgdGhlIGhhbmRsZXIgYmFjayB0byBzdGFydGluZyBzdGF0ZVxuRG9tSGFuZGxlci5wcm90b3R5cGUub25yZXNldD1mdW5jdGlvbigpe3RoaXMuZG9tPVtdO3RoaXMuX2RvbmU9ZmFsc2U7dGhpcy5fdGFnU3RhY2s9W107dGhpcy5fbGFzdE5vZGU9bnVsbDt0aGlzLl9wYXJzZXI9dGhpcy5fcGFyc2VyfHxudWxsO307Ly8gU2lnbmFscyB0aGUgaGFuZGxlciB0aGF0IHBhcnNpbmcgaXMgZG9uZVxuRG9tSGFuZGxlci5wcm90b3R5cGUub25lbmQ9ZnVuY3Rpb24oKXtpZih0aGlzLl9kb25lKXJldHVybjt0aGlzLl9kb25lPXRydWU7dGhpcy5fcGFyc2VyPW51bGw7dGhpcy5oYW5kbGVDYWxsYmFjayhudWxsKTt9O0RvbUhhbmRsZXIucHJvdG90eXBlLm9uZXJyb3I9ZnVuY3Rpb24oZXJyb3Ipe3RoaXMuaGFuZGxlQ2FsbGJhY2soZXJyb3IpO307RG9tSGFuZGxlci5wcm90b3R5cGUub25jbG9zZXRhZz1mdW5jdGlvbigpe3RoaXMuX2xhc3ROb2RlPW51bGw7Ly8gSWYodGhpcy5fdGFnU3RhY2sucG9wKCkubmFtZSAhPT0gbmFtZSkgdGhpcy5oYW5kbGVDYWxsYmFjayhFcnJvcihcIlRhZ25hbWUgZGlkbid0IG1hdGNoIVwiKSk7XG52YXIgZWxlbT10aGlzLl90YWdTdGFjay5wb3AoKTtpZighZWxlbXx8IXRoaXMuX3BhcnNlcil7cmV0dXJuO31pZih0aGlzLl9vcHRpb25zLndpdGhFbmRJbmRpY2VzKXtlbGVtLmVuZEluZGV4PXRoaXMuX3BhcnNlci5lbmRJbmRleDt9aWYodGhpcy5fZWxlbWVudENCKXRoaXMuX2VsZW1lbnRDQihlbGVtKTt9O0RvbUhhbmRsZXIucHJvdG90eXBlLm9ub3BlbnRhZz1mdW5jdGlvbihuYW1lLGF0dHJpYnMpe3ZhciBlbGVtZW50PW5ldyBub2RlXzEuRWxlbWVudChuYW1lLGF0dHJpYnMpO3RoaXMuYWRkTm9kZShlbGVtZW50KTt0aGlzLl90YWdTdGFjay5wdXNoKGVsZW1lbnQpO307RG9tSGFuZGxlci5wcm90b3R5cGUub250ZXh0PWZ1bmN0aW9uKGRhdGEpe3ZhciBub3JtYWxpemU9dGhpcy5fb3B0aW9ucy5ub3JtYWxpemVXaGl0ZXNwYWNlO3ZhciBfbGFzdE5vZGU9dGhpcy5fbGFzdE5vZGU7aWYoX2xhc3ROb2RlJiZfbGFzdE5vZGUudHlwZT09PVwidGV4dFwiLyogVGV4dCAqLyl7aWYobm9ybWFsaXplKXtfbGFzdE5vZGUuZGF0YT0oX2xhc3ROb2RlLmRhdGErZGF0YSkucmVwbGFjZShyZVdoaXRlc3BhY2UsXCIgXCIpO31lbHNle19sYXN0Tm9kZS5kYXRhKz1kYXRhO319ZWxzZXtpZihub3JtYWxpemUpe2RhdGE9ZGF0YS5yZXBsYWNlKHJlV2hpdGVzcGFjZSxcIiBcIik7fXZhciBub2RlPW5ldyBub2RlXzEuRGF0YU5vZGUoXCJ0ZXh0XCIvKiBUZXh0ICovLGRhdGEpO3RoaXMuYWRkTm9kZShub2RlKTt0aGlzLl9sYXN0Tm9kZT1ub2RlO319O0RvbUhhbmRsZXIucHJvdG90eXBlLm9uY29tbWVudD1mdW5jdGlvbihkYXRhKXtpZih0aGlzLl9sYXN0Tm9kZSYmdGhpcy5fbGFzdE5vZGUudHlwZT09PVwiY29tbWVudFwiLyogQ29tbWVudCAqLyl7dGhpcy5fbGFzdE5vZGUuZGF0YSs9ZGF0YTtyZXR1cm47fXZhciBub2RlPW5ldyBub2RlXzEuRGF0YU5vZGUoXCJjb21tZW50XCIvKiBDb21tZW50ICovLGRhdGEpO3RoaXMuYWRkTm9kZShub2RlKTt0aGlzLl9sYXN0Tm9kZT1ub2RlO307RG9tSGFuZGxlci5wcm90b3R5cGUub25jb21tZW50ZW5kPWZ1bmN0aW9uKCl7dGhpcy5fbGFzdE5vZGU9bnVsbDt9O0RvbUhhbmRsZXIucHJvdG90eXBlLm9uY2RhdGFzdGFydD1mdW5jdGlvbigpe3ZhciB0ZXh0PW5ldyBub2RlXzEuRGF0YU5vZGUoXCJ0ZXh0XCIvKiBUZXh0ICovLFwiXCIpO3ZhciBub2RlPW5ldyBub2RlXzEuTm9kZVdpdGhDaGlsZHJlbihcImNkYXRhXCIvKiBDREFUQSAqLyxbdGV4dF0pO3RoaXMuYWRkTm9kZShub2RlKTt0ZXh0LnBhcmVudD1ub2RlO3RoaXMuX2xhc3ROb2RlPXRleHQ7fTtEb21IYW5kbGVyLnByb3RvdHlwZS5vbmNkYXRhZW5kPWZ1bmN0aW9uKCl7dGhpcy5fbGFzdE5vZGU9bnVsbDt9O0RvbUhhbmRsZXIucHJvdG90eXBlLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uPWZ1bmN0aW9uKG5hbWUsZGF0YSl7dmFyIG5vZGU9bmV3IG5vZGVfMS5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obmFtZSxkYXRhKTt0aGlzLmFkZE5vZGUobm9kZSk7fTtEb21IYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVDYWxsYmFjaz1mdW5jdGlvbihlcnJvcil7aWYodHlwZW9mIHRoaXMuX2NhbGxiYWNrPT09XCJmdW5jdGlvblwiKXt0aGlzLl9jYWxsYmFjayhlcnJvcix0aGlzLmRvbSk7fWVsc2UgaWYoZXJyb3Ipe3Rocm93IGVycm9yO319O0RvbUhhbmRsZXIucHJvdG90eXBlLmFkZE5vZGU9ZnVuY3Rpb24obm9kZSl7dmFyIHBhcmVudD10aGlzLl90YWdTdGFja1t0aGlzLl90YWdTdGFjay5sZW5ndGgtMV07dmFyIHNpYmxpbmdzPXBhcmVudD9wYXJlbnQuY2hpbGRyZW46dGhpcy5kb207dmFyIHByZXZpb3VzU2libGluZz1zaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGgtMV07aWYodGhpcy5fcGFyc2VyKXtpZih0aGlzLl9vcHRpb25zLndpdGhTdGFydEluZGljZXMpe25vZGUuc3RhcnRJbmRleD10aGlzLl9wYXJzZXIuc3RhcnRJbmRleDt9aWYodGhpcy5fb3B0aW9ucy53aXRoRW5kSW5kaWNlcyl7bm9kZS5lbmRJbmRleD10aGlzLl9wYXJzZXIuZW5kSW5kZXg7fX1zaWJsaW5ncy5wdXNoKG5vZGUpO2lmKHByZXZpb3VzU2libGluZyl7bm9kZS5wcmV2PXByZXZpb3VzU2libGluZztwcmV2aW91c1NpYmxpbmcubmV4dD1ub2RlO31pZihwYXJlbnQpe25vZGUucGFyZW50PXBhcmVudDt9dGhpcy5fbGFzdE5vZGU9bnVsbDt9O0RvbUhhbmRsZXIucHJvdG90eXBlLmFkZERhdGFOb2RlPWZ1bmN0aW9uKG5vZGUpe3RoaXMuYWRkTm9kZShub2RlKTt0aGlzLl9sYXN0Tm9kZT1ub2RlO307cmV0dXJuIERvbUhhbmRsZXI7fSgpO2V4cG9ydHMuRG9tSGFuZGxlcj1Eb21IYW5kbGVyO2V4cG9ydHNbXCJkZWZhdWx0XCJdPURvbUhhbmRsZXI7fSx7XCIuL25vZGVcIjo4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fZXh0ZW5kcz10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgX2V4dGVuZFN0YXRpY3M9ZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLGIpe19leHRlbmRTdGF0aWNzPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihkLGIpe2QuX19wcm90b19fPWI7fXx8ZnVuY3Rpb24oZCxiKXtmb3IodmFyIHAgaW4gYil7aWYoYi5oYXNPd25Qcm9wZXJ0eShwKSlkW3BdPWJbcF07fX07cmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsYik7fTtyZXR1cm4gZnVuY3Rpb24oZCxiKXtfZXh0ZW5kU3RhdGljcyhkLGIpO2Z1bmN0aW9uIF9fKCl7dGhpcy5jb25zdHJ1Y3Rvcj1kO31kLnByb3RvdHlwZT1iPT09bnVsbD9PYmplY3QuY3JlYXRlKGIpOihfXy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsbmV3IF9fKCkpO307fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIG5vZGVUeXBlcz1uZXcgTWFwKFtbXCJ0YWdcIi8qIFRhZyAqLywxXSxbXCJzY3JpcHRcIi8qIFNjcmlwdCAqLywxXSxbXCJzdHlsZVwiLyogU3R5bGUgKi8sMV0sW1wiZGlyZWN0aXZlXCIvKiBEaXJlY3RpdmUgKi8sMV0sW1widGV4dFwiLyogVGV4dCAqLywzXSxbXCJjZGF0YVwiLyogQ0RBVEEgKi8sNF0sW1wiY29tbWVudFwiLyogQ29tbWVudCAqLyw4XV0pOy8vIFRoaXMgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyB0aGUgcHJvdG90eXBlIGZvciBOb2RlcyB3aGVuIGNyZWF0aW5nIGFcbi8vIERPTS1MZXZlbC0xLWNvbXBsaWFudCBzdHJ1Y3R1cmUuXG52YXIgTm9kZT0vKiogQGNsYXNzICovZnVuY3Rpb24oKXsvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBub2RlLlxuICAgICAqL2Z1bmN0aW9uIE5vZGUodHlwZSl7dGhpcy50eXBlPXR5cGU7LyoqIFBhcmVudCBvZiB0aGUgbm9kZSAqL3RoaXMucGFyZW50PW51bGw7LyoqIFByZXZpb3VzIHNpYmxpbmcgKi90aGlzLnByZXY9bnVsbDsvKiogTmV4dCBzaWJsaW5nICovdGhpcy5uZXh0PW51bGw7LyoqIFRoZSBzdGFydCBpbmRleCBvZiB0aGUgbm9kZS4gUmVxdWlyZXMgYHdpdGhTdGFydEluZGljZXNgIG9uIHRoZSBoYW5kbGVyIHRvIGJlIGB0cnVlLiAqL3RoaXMuc3RhcnRJbmRleD1udWxsOy8qKiBUaGUgZW5kIGluZGV4IG9mIHRoZSBub2RlLiBSZXF1aXJlcyBgd2l0aEVuZEluZGljZXNgIG9uIHRoZSBoYW5kbGVyIHRvIGJlIGB0cnVlLiAqL3RoaXMuZW5kSW5kZXg9bnVsbDt9T2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLFwibm9kZVR5cGVcIix7Ly8gUmVhZC1vbmx5IGFsaWFzZXNcbmdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gbm9kZVR5cGVzLmdldCh0aGlzLnR5cGUpfHwxO30sZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLFwicGFyZW50Tm9kZVwiLHsvLyBSZWFkLXdyaXRlIGFsaWFzZXMgZm9yIHByb3BlcnRpZXNcbmdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5wYXJlbnR8fG51bGw7fSxzZXQ6ZnVuY3Rpb24gc2V0KHBhcmVudCl7dGhpcy5wYXJlbnQ9cGFyZW50O30sZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLFwicHJldmlvdXNTaWJsaW5nXCIse2dldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5wcmV2fHxudWxsO30sc2V0OmZ1bmN0aW9uIHNldChwcmV2KXt0aGlzLnByZXY9cHJldjt9LGVudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSxcIm5leHRTaWJsaW5nXCIse2dldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5uZXh0fHxudWxsO30sc2V0OmZ1bmN0aW9uIHNldChuZXh0KXt0aGlzLm5leHQ9bmV4dDt9LGVudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBOb2RlO30oKTtleHBvcnRzLk5vZGU9Tm9kZTt2YXIgRGF0YU5vZGU9LyoqIEBjbGFzcyAqL2Z1bmN0aW9uKF9zdXBlcil7X19leHRlbmRzKERhdGFOb2RlLF9zdXBlcik7LyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBjb250ZW50IG9mIHRoZSBkYXRhIG5vZGVcbiAgICAgKi9mdW5jdGlvbiBEYXRhTm9kZSh0eXBlLGRhdGEpe3ZhciBfdGhpcz1fc3VwZXIuY2FsbCh0aGlzLHR5cGUpfHx0aGlzO190aGlzLmRhdGE9ZGF0YTtyZXR1cm4gX3RoaXM7fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsXCJub2RlVmFsdWVcIix7Z2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLmRhdGE7fSxzZXQ6ZnVuY3Rpb24gc2V0KGRhdGEpe3RoaXMuZGF0YT1kYXRhO30sZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIERhdGFOb2RlO30oTm9kZSk7ZXhwb3J0cy5EYXRhTm9kZT1EYXRhTm9kZTt2YXIgUHJvY2Vzc2luZ0luc3RydWN0aW9uPS8qKiBAY2xhc3MgKi9mdW5jdGlvbihfc3VwZXIpe19fZXh0ZW5kcyhQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sX3N1cGVyKTtmdW5jdGlvbiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obmFtZSxkYXRhKXt2YXIgX3RoaXM9X3N1cGVyLmNhbGwodGhpcyxcImRpcmVjdGl2ZVwiLyogRGlyZWN0aXZlICovLGRhdGEpfHx0aGlzO190aGlzLm5hbWU9bmFtZTtyZXR1cm4gX3RoaXM7fXJldHVybiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb247fShEYXRhTm9kZSk7ZXhwb3J0cy5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb249UHJvY2Vzc2luZ0luc3RydWN0aW9uO3ZhciBOb2RlV2l0aENoaWxkcmVuPS8qKiBAY2xhc3MgKi9mdW5jdGlvbihfc3VwZXIpe19fZXh0ZW5kcyhOb2RlV2l0aENoaWxkcmVuLF9zdXBlcik7LyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSBUeXBlIG9mIHRoZSBub2RlLlxuICAgICAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiBvZiB0aGUgbm9kZS4gT25seSBjZXJ0YWluIG5vZGUgdHlwZXMgY2FuIGhhdmUgY2hpbGRyZW4uXG4gICAgICovZnVuY3Rpb24gTm9kZVdpdGhDaGlsZHJlbih0eXBlLGNoaWxkcmVuKXt2YXIgX3RoaXM9X3N1cGVyLmNhbGwodGhpcyx0eXBlKXx8dGhpcztfdGhpcy5jaGlsZHJlbj1jaGlsZHJlbjtyZXR1cm4gX3RoaXM7fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlV2l0aENoaWxkcmVuLnByb3RvdHlwZSxcImZpcnN0Q2hpbGRcIix7Ly8gQWxpYXNlc1xuZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLmNoaWxkcmVuWzBdfHxudWxsO30sZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGVXaXRoQ2hpbGRyZW4ucHJvdG90eXBlLFwibGFzdENoaWxkXCIse2dldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aC0xXXx8bnVsbDt9LGVudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlV2l0aENoaWxkcmVuLnByb3RvdHlwZSxcImNoaWxkTm9kZXNcIix7Z2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLmNoaWxkcmVuO30sc2V0OmZ1bmN0aW9uIHNldChjaGlsZHJlbil7dGhpcy5jaGlsZHJlbj1jaGlsZHJlbjt9LGVudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBOb2RlV2l0aENoaWxkcmVuO30oTm9kZSk7ZXhwb3J0cy5Ob2RlV2l0aENoaWxkcmVuPU5vZGVXaXRoQ2hpbGRyZW47dmFyIEVsZW1lbnQ9LyoqIEBjbGFzcyAqL2Z1bmN0aW9uKF9zdXBlcil7X19leHRlbmRzKEVsZW1lbnQsX3N1cGVyKTsvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHRhZywgZWcuIGBkaXZgLCBgc3BhbmBcbiAgICAgKiBAcGFyYW0gYXR0cmlicyBPYmplY3QgbWFwcGluZyBhdHRyaWJ1dGUgbmFtZXMgdG8gYXR0cmlidXRlIHZhbHVlc1xuICAgICAqL2Z1bmN0aW9uIEVsZW1lbnQobmFtZSxhdHRyaWJzKXt2YXIgX3RoaXM9X3N1cGVyLmNhbGwodGhpcyxuYW1lPT09XCJzY3JpcHRcIj9cInNjcmlwdFwiLyogU2NyaXB0ICovOm5hbWU9PT1cInN0eWxlXCI/XCJzdHlsZVwiLyogU3R5bGUgKi86XCJ0YWdcIi8qIFRhZyAqLyxbXSl8fHRoaXM7X3RoaXMubmFtZT1uYW1lO190aGlzLmF0dHJpYnM9YXR0cmlicztfdGhpcy5hdHRyaWJzPWF0dHJpYnM7cmV0dXJuIF90aGlzO31PYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudC5wcm90b3R5cGUsXCJ0YWdOYW1lXCIsey8vIERPTSBMZXZlbCAxIGFsaWFzZXNcbmdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5uYW1lO30sc2V0OmZ1bmN0aW9uIHNldChuYW1lKXt0aGlzLm5hbWU9bmFtZTt9LGVudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBFbGVtZW50O30oTm9kZVdpdGhDaGlsZHJlbik7ZXhwb3J0cy5FbGVtZW50PUVsZW1lbnQ7fSx7fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgdGFndHlwZXNfMT1yZXF1aXJlKFwiLi90YWd0eXBlc1wiKTsvKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIG5vZGVzLCByZW1vdmUgYW55IG1lbWJlciB0aGF0IGlzIGNvbnRhaW5lZCBieSBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSBub2RlcyBOb2RlcyB0byBmaWx0ZXIuXG4gKi9mdW5jdGlvbiByZW1vdmVTdWJzZXRzKG5vZGVzKXt2YXIgaWR4PW5vZGVzLmxlbmd0aDsvLyBDaGVjayBpZiBlYWNoIG5vZGUgKG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzKSBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGVcbi8vIGFycmF5Llxud2hpbGUoLS1pZHg+PTApe3ZhciBub2RlPW5vZGVzW2lkeF07Ly8gUmVtb3ZlIHRoZSBub2RlIGlmIGl0IGlzIG5vdCB1bmlxdWUuXG4vLyBXZSBhcmUgZ29pbmcgdGhyb3VnaCB0aGUgYXJyYXkgZnJvbSB0aGUgZW5kLCBzbyB3ZSBvbmx5XG4vLyBoYXZlIHRvIGNoZWNrIG5vZGVzIHRoYXQgcHJlY2VlZCB0aGUgbm9kZSB1bmRlciBjb25zaWRlcmF0aW9uIGluIHRoZSBhcnJheS5cbmlmKGlkeD4wJiZub2Rlcy5sYXN0SW5kZXhPZihub2RlLGlkeC0xKT49MCl7bm9kZXMuc3BsaWNlKGlkeCwxKTtjb250aW51ZTt9Zm9yKHZhciBhbmNlc3Rvcj1ub2RlLnBhcmVudDthbmNlc3RvcjthbmNlc3Rvcj1hbmNlc3Rvci5wYXJlbnQpe2lmKG5vZGVzLmluZGV4T2YoYW5jZXN0b3IpPi0xKXtub2Rlcy5zcGxpY2UoaWR4LDEpO2JyZWFrO319fXJldHVybiBub2Rlczt9ZXhwb3J0cy5yZW1vdmVTdWJzZXRzPXJlbW92ZVN1YnNldHM7LyoqKlxuICogQ29tcGFyZSB0aGUgcG9zaXRpb24gb2Ygb25lIG5vZGUgYWdhaW5zdCBhbm90aGVyIG5vZGUgaW4gYW55IG90aGVyIGRvY3VtZW50LlxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhIGJpdG1hc2sgd2l0aCB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqXG4gKiBkb2N1bWVudCBvcmRlcjpcbiAqID4gVGhlcmUgaXMgYW4gb3JkZXJpbmcsIGRvY3VtZW50IG9yZGVyLCBkZWZpbmVkIG9uIGFsbCB0aGUgbm9kZXMgaW4gdGhlXG4gKiA+IGRvY3VtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gKiA+IFhNTCByZXByZXNlbnRhdGlvbiBvZiBlYWNoIG5vZGUgb2NjdXJzIGluIHRoZSBYTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gKiA+IGRvY3VtZW50IGFmdGVyIGV4cGFuc2lvbiBvZiBnZW5lcmFsIGVudGl0aWVzLiBUaHVzLCB0aGUgZG9jdW1lbnQgZWxlbWVudFxuICogPiBub2RlIHdpbGwgYmUgdGhlIGZpcnN0IG5vZGUuIEVsZW1lbnQgbm9kZXMgb2NjdXIgYmVmb3JlIHRoZWlyIGNoaWxkcmVuLlxuICogPiBUaHVzLCBkb2N1bWVudCBvcmRlciBvcmRlcnMgZWxlbWVudCBub2RlcyBpbiBvcmRlciBvZiB0aGUgb2NjdXJyZW5jZSBvZlxuICogPiB0aGVpciBzdGFydC10YWcgaW4gdGhlIFhNTCAoYWZ0ZXIgZXhwYW5zaW9uIG9mIGVudGl0aWVzKS4gVGhlIGF0dHJpYnV0ZVxuICogPiBub2RlcyBvZiBhbiBlbGVtZW50IG9jY3VyIGFmdGVyIHRoZSBlbGVtZW50IGFuZCBiZWZvcmUgaXRzIGNoaWxkcmVuLiBUaGVcbiAqID4gcmVsYXRpdmUgb3JkZXIgb2YgYXR0cmlidXRlIG5vZGVzIGlzIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudC4vXG4gKlxuICogU291cmNlOlxuICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9nbG9zc2FyeS5odG1sI2R0LWRvY3VtZW50LW9yZGVyXG4gKiBAcGFyYW0gbm9kYUEgVGhlIGZpcnN0IG5vZGUgdG8gdXNlIGluIHRoZSBjb21wYXJpc29uXG4gKiBAcGFyYW0gbm9kZUIgVGhlIHNlY29uZCBub2RlIHRvIHVzZSBpbiB0aGUgY29tcGFyaXNvblxuICpcbiAqIEByZXR1cm4gQSBiaXRtYXNrIGRlc2NyaWJpbmcgdGhlIGlucHV0IG5vZGVzJyByZWxhdGl2ZSBwb3NpdGlvbi5cbiAqXG4gKiAgICAgICAgU2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tbm9kZS1jb21wYXJlZG9jdW1lbnRwb3NpdGlvbiBmb3JcbiAqICAgICAgICBhIGRlc2NyaXB0aW9uIG9mIHRoZXNlIHZhbHVlcy5cbiAqL2Z1bmN0aW9uIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGVBLG5vZGVCKXt2YXIgYVBhcmVudHM9W107dmFyIGJQYXJlbnRzPVtdO2lmKG5vZGVBPT09bm9kZUIpe3JldHVybiAwO312YXIgY3VycmVudD10YWd0eXBlc18xLmhhc0NoaWxkcmVuKG5vZGVBKT9ub2RlQTpub2RlQS5wYXJlbnQ7d2hpbGUoY3VycmVudCl7YVBhcmVudHMudW5zaGlmdChjdXJyZW50KTtjdXJyZW50PWN1cnJlbnQucGFyZW50O31jdXJyZW50PXRhZ3R5cGVzXzEuaGFzQ2hpbGRyZW4obm9kZUIpP25vZGVCOm5vZGVCLnBhcmVudDt3aGlsZShjdXJyZW50KXtiUGFyZW50cy51bnNoaWZ0KGN1cnJlbnQpO2N1cnJlbnQ9Y3VycmVudC5wYXJlbnQ7fXZhciBpZHg9MDt3aGlsZShhUGFyZW50c1tpZHhdPT09YlBhcmVudHNbaWR4XSl7aWR4Kys7fWlmKGlkeD09PTApe3JldHVybiAxLyogRElTQ09OTkVDVEVEICovO312YXIgc2hhcmVkUGFyZW50PWFQYXJlbnRzW2lkeC0xXTt2YXIgc2libGluZ3M9c2hhcmVkUGFyZW50LmNoaWxkcmVuO3ZhciBhU2libGluZz1hUGFyZW50c1tpZHhdO3ZhciBiU2libGluZz1iUGFyZW50c1tpZHhdO2lmKHNpYmxpbmdzLmluZGV4T2YoYVNpYmxpbmcpPnNpYmxpbmdzLmluZGV4T2YoYlNpYmxpbmcpKXtpZihzaGFyZWRQYXJlbnQ9PT1ub2RlQil7cmV0dXJuIDQvKiBGT0xMT1dJTkcgKi98MTYvKiBDT05UQUlORURfQlkgKi87fXJldHVybiA0LyogRk9MTE9XSU5HICovO31lbHNle2lmKHNoYXJlZFBhcmVudD09PW5vZGVBKXtyZXR1cm4gMi8qIFBSRUNFRElORyAqL3w4LyogQ09OVEFJTlMgKi87fXJldHVybiAyLyogUFJFQ0VESU5HICovO319ZXhwb3J0cy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj1jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjsvKioqXG4gKiBTb3J0IGFuIGFycmF5IG9mIG5vZGVzIGJhc2VkIG9uIHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBhbmRcbiAqIHJlbW92ZSBhbnkgZHVwbGljYXRlIG5vZGVzLiBJZiB0aGUgYXJyYXkgY29udGFpbnMgbm9kZXMgdGhhdCBkbyBub3QgYmVsb25nXG4gKiB0byB0aGUgc2FtZSBkb2N1bWVudCwgc29ydCBvcmRlciBpcyB1bnNwZWNpZmllZC5cbiAqXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcmV0dXJucyBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBub2Rlcywgc29ydGVkIGluIGRvY3VtZW50IG9yZGVyXG4gKi9mdW5jdGlvbiB1bmlxdWVTb3J0KG5vZGVzKXtub2Rlcz1ub2Rlcy5maWx0ZXIoZnVuY3Rpb24obm9kZSxpLGFycil7cmV0dXJuIWFyci5pbmNsdWRlcyhub2RlLGkrMSk7fSk7bm9kZXMuc29ydChmdW5jdGlvbihhLGIpe3ZhciByZWxhdGl2ZT1jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhLGIpO2lmKHJlbGF0aXZlJjIvKiBQUkVDRURJTkcgKi8pe3JldHVybi0xO31lbHNlIGlmKHJlbGF0aXZlJjQvKiBGT0xMT1dJTkcgKi8pe3JldHVybiAxO31yZXR1cm4gMDt9KTtyZXR1cm4gbm9kZXM7fWV4cG9ydHMudW5pcXVlU29ydD11bmlxdWVTb3J0O30se1wiLi90YWd0eXBlc1wiOjE1fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9fZXhwb3J0KG0pe2Zvcih2YXIgcCBpbiBtKXtpZighZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSlleHBvcnRzW3BdPW1bcF07fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO19fZXhwb3J0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeVwiKSk7X19leHBvcnQocmVxdWlyZShcIi4vdHJhdmVyc2FsXCIpKTtfX2V4cG9ydChyZXF1aXJlKFwiLi9tYW5pcHVsYXRpb25cIikpO19fZXhwb3J0KHJlcXVpcmUoXCIuL3F1ZXJ5aW5nXCIpKTtfX2V4cG9ydChyZXF1aXJlKFwiLi9sZWdhY3lcIikpO19fZXhwb3J0KHJlcXVpcmUoXCIuL2hlbHBlcnNcIikpO19fZXhwb3J0KHJlcXVpcmUoXCIuL3RhZ3R5cGVzXCIpKTt9LHtcIi4vaGVscGVyc1wiOjksXCIuL2xlZ2FjeVwiOjExLFwiLi9tYW5pcHVsYXRpb25cIjoxMixcIi4vcXVlcnlpbmdcIjoxMyxcIi4vc3RyaW5naWZ5XCI6MTQsXCIuL3RhZ3R5cGVzXCI6MTUsXCIuL3RyYXZlcnNhbFwiOjE2fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIHF1ZXJ5aW5nXzE9cmVxdWlyZShcIi4vcXVlcnlpbmdcIik7dmFyIHRhZ3R5cGVzXzE9cmVxdWlyZShcIi4vdGFndHlwZXNcIik7ZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKXtyZXR1cm4gbm9kZS50eXBlPT09XCJ0ZXh0XCIvKiBUZXh0ICovO30vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlICovdmFyIENoZWNrcz17dGFnX25hbWU6ZnVuY3Rpb24gdGFnX25hbWUobmFtZSl7aWYodHlwZW9mIG5hbWU9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBmdW5jdGlvbihlbGVtKXtyZXR1cm4gdGFndHlwZXNfMS5pc1RhZyhlbGVtKSYmbmFtZShlbGVtLm5hbWUpO307fWVsc2UgaWYobmFtZT09PVwiKlwiKXtyZXR1cm4gdGFndHlwZXNfMS5pc1RhZzt9ZWxzZXtyZXR1cm4gZnVuY3Rpb24oZWxlbSl7cmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWcoZWxlbSkmJmVsZW0ubmFtZT09PW5hbWU7fTt9fSx0YWdfdHlwZTpmdW5jdGlvbiB0YWdfdHlwZSh0eXBlKXtpZih0eXBlb2YgdHlwZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZ1bmN0aW9uKGVsZW0pe3JldHVybiB0eXBlKGVsZW0udHlwZSk7fTt9ZWxzZXtyZXR1cm4gZnVuY3Rpb24oZWxlbSl7cmV0dXJuIGVsZW0udHlwZT09PXR5cGU7fTt9fSx0YWdfY29udGFpbnM6ZnVuY3Rpb24gdGFnX2NvbnRhaW5zKGRhdGEpe2lmKHR5cGVvZiBkYXRhPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZnVuY3Rpb24oZWxlbSl7cmV0dXJuIGlzVGV4dE5vZGUoZWxlbSkmJmRhdGEoZWxlbS5kYXRhKTt9O31lbHNle3JldHVybiBmdW5jdGlvbihlbGVtKXtyZXR1cm4gaXNUZXh0Tm9kZShlbGVtKSYmZWxlbS5kYXRhPT09ZGF0YTt9O319fTsvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9jYW1lbGNhc2UgKi9mdW5jdGlvbiBnZXRBdHRyaWJDaGVjayhhdHRyaWIsdmFsdWUpe2lmKHR5cGVvZiB2YWx1ZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZ1bmN0aW9uKGVsZW0pe3JldHVybiB0YWd0eXBlc18xLmlzVGFnKGVsZW0pJiZ2YWx1ZShlbGVtLmF0dHJpYnNbYXR0cmliXSk7fTt9ZWxzZXtyZXR1cm4gZnVuY3Rpb24oZWxlbSl7cmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWcoZWxlbSkmJmVsZW0uYXR0cmlic1thdHRyaWJdPT09dmFsdWU7fTt9fWZ1bmN0aW9uIGNvbWJpbmVGdW5jcyhhLGIpe3JldHVybiBmdW5jdGlvbihlbGVtKXtyZXR1cm4gYShlbGVtKXx8YihlbGVtKTt9O31mdW5jdGlvbiBjb21waWxlVGVzdChvcHRpb25zKXt2YXIgZnVuY3M9T2JqZWN0LmtleXMob3B0aW9ucykubWFwKGZ1bmN0aW9uKGtleSl7dmFyIHZhbHVlPW9wdGlvbnNba2V5XTtyZXR1cm4ga2V5IGluIENoZWNrcz9DaGVja3Nba2V5XSh2YWx1ZSk6Z2V0QXR0cmliQ2hlY2soa2V5LHZhbHVlKTt9KTtyZXR1cm4gZnVuY3MubGVuZ3RoPT09MD9udWxsOmZ1bmNzLnJlZHVjZShjb21iaW5lRnVuY3MpO31mdW5jdGlvbiB0ZXN0RWxlbWVudChvcHRpb25zLGVsZW1lbnQpe3ZhciB0ZXN0PWNvbXBpbGVUZXN0KG9wdGlvbnMpO3JldHVybiB0ZXN0P3Rlc3QoZWxlbWVudCk6dHJ1ZTt9ZXhwb3J0cy50ZXN0RWxlbWVudD10ZXN0RWxlbWVudDtmdW5jdGlvbiBnZXRFbGVtZW50cyhvcHRpb25zLGVsZW1lbnQscmVjdXJzZSxsaW1pdCl7aWYobGltaXQ9PT12b2lkIDApe2xpbWl0PUluZmluaXR5O312YXIgdGVzdD1jb21waWxlVGVzdChvcHRpb25zKTtyZXR1cm4gdGVzdD9xdWVyeWluZ18xLmZpbHRlcih0ZXN0LGVsZW1lbnQscmVjdXJzZSxsaW1pdCk6W107fWV4cG9ydHMuZ2V0RWxlbWVudHM9Z2V0RWxlbWVudHM7ZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQsZWxlbWVudCxyZWN1cnNlKXtpZihyZWN1cnNlPT09dm9pZCAwKXtyZWN1cnNlPXRydWU7fWlmKCFBcnJheS5pc0FycmF5KGVsZW1lbnQpKWVsZW1lbnQ9W2VsZW1lbnRdO3JldHVybiBxdWVyeWluZ18xLmZpbmRPbmUoZ2V0QXR0cmliQ2hlY2soXCJpZFwiLGlkKSxlbGVtZW50LHJlY3Vyc2UpO31leHBvcnRzLmdldEVsZW1lbnRCeUlkPWdldEVsZW1lbnRCeUlkO2Z1bmN0aW9uIGdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUsZWxlbWVudCxyZWN1cnNlLGxpbWl0KXtpZihsaW1pdD09PXZvaWQgMCl7bGltaXQ9SW5maW5pdHk7fXJldHVybiBxdWVyeWluZ18xLmZpbHRlcihDaGVja3MudGFnX25hbWUobmFtZSksZWxlbWVudCxyZWN1cnNlLGxpbWl0KTt9ZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnTmFtZT1nZXRFbGVtZW50c0J5VGFnTmFtZTtmdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnVHlwZSh0eXBlLGVsZW1lbnQscmVjdXJzZSxsaW1pdCl7aWYocmVjdXJzZT09PXZvaWQgMCl7cmVjdXJzZT10cnVlO31pZihsaW1pdD09PXZvaWQgMCl7bGltaXQ9SW5maW5pdHk7fXJldHVybiBxdWVyeWluZ18xLmZpbHRlcihDaGVja3MudGFnX3R5cGUodHlwZSksZWxlbWVudCxyZWN1cnNlLGxpbWl0KTt9ZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnVHlwZT1nZXRFbGVtZW50c0J5VGFnVHlwZTt9LHtcIi4vcXVlcnlpbmdcIjoxMyxcIi4vdGFndHlwZXNcIjoxNX1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pOy8qKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIGRvbVxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGJlIHJlbW92ZWRcbiAqL2Z1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWxlbSl7aWYoZWxlbS5wcmV2KWVsZW0ucHJldi5uZXh0PWVsZW0ubmV4dDtpZihlbGVtLm5leHQpZWxlbS5uZXh0LnByZXY9ZWxlbS5wcmV2O2lmKGVsZW0ucGFyZW50KXt2YXIgY2hpbGRzPWVsZW0ucGFyZW50LmNoaWxkcmVuO2NoaWxkcy5zcGxpY2UoY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pLDEpO319ZXhwb3J0cy5yZW1vdmVFbGVtZW50PXJlbW92ZUVsZW1lbnQ7LyoqKlxuICogUmVwbGFjZSBhbiBlbGVtZW50IGluIHRoZSBkb21cbiAqXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBiZSByZXBsYWNlZFxuICogQHBhcmFtIHJlcGxhY2VtZW50IFRoZSBlbGVtZW50IHRvIGJlIGFkZGVkXG4gKi9mdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtLHJlcGxhY2VtZW50KXt2YXIgcHJldj1yZXBsYWNlbWVudC5wcmV2PWVsZW0ucHJldjtpZihwcmV2KXtwcmV2Lm5leHQ9cmVwbGFjZW1lbnQ7fXZhciBuZXh0PXJlcGxhY2VtZW50Lm5leHQ9ZWxlbS5uZXh0O2lmKG5leHQpe25leHQucHJldj1yZXBsYWNlbWVudDt9dmFyIHBhcmVudD1yZXBsYWNlbWVudC5wYXJlbnQ9ZWxlbS5wYXJlbnQ7aWYocGFyZW50KXt2YXIgY2hpbGRzPXBhcmVudC5jaGlsZHJlbjtjaGlsZHNbY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pXT1yZXBsYWNlbWVudDt9fWV4cG9ydHMucmVwbGFjZUVsZW1lbnQ9cmVwbGFjZUVsZW1lbnQ7LyoqKlxuICogQXBwZW5kIGEgY2hpbGQgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGFwcGVuZCB0b1xuICogQHBhcmFtIGNoaWxkIFRoZSBlbGVtZW50IHRvIGJlIGFkZGVkIGFzIGEgY2hpbGRcbiAqL2Z1bmN0aW9uIGFwcGVuZENoaWxkKGVsZW0sY2hpbGQpe2NoaWxkLnBhcmVudD1lbGVtO2lmKGVsZW0uY2hpbGRyZW4ucHVzaChjaGlsZCkhPT0xKXt2YXIgc2libGluZz1lbGVtLmNoaWxkcmVuW2VsZW0uY2hpbGRyZW4ubGVuZ3RoLTJdO3NpYmxpbmcubmV4dD1jaGlsZDtjaGlsZC5wcmV2PXNpYmxpbmc7Y2hpbGQubmV4dD1udWxsO319ZXhwb3J0cy5hcHBlbmRDaGlsZD1hcHBlbmRDaGlsZDsvKioqXG4gKiBBcHBlbmQgYW4gZWxlbWVudCBhZnRlciBhbm90aGVyXG4gKlxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gYXBwZW5kIHRvXG4gKiBAcGFyYW0gbmV4dCBUaGUgZWxlbWVudCBiZSBhZGRlZFxuICovZnVuY3Rpb24gYXBwZW5kKGVsZW0sbmV4dCl7dmFyIHBhcmVudD1lbGVtLnBhcmVudDt2YXIgY3Vyck5leHQ9ZWxlbS5uZXh0O25leHQubmV4dD1jdXJyTmV4dDtuZXh0LnByZXY9ZWxlbTtlbGVtLm5leHQ9bmV4dDtuZXh0LnBhcmVudD1wYXJlbnQ7aWYoY3Vyck5leHQpe2N1cnJOZXh0LnByZXY9bmV4dDtpZihwYXJlbnQpe3ZhciBjaGlsZHM9cGFyZW50LmNoaWxkcmVuO2NoaWxkcy5zcGxpY2UoY2hpbGRzLmxhc3RJbmRleE9mKGN1cnJOZXh0KSwwLG5leHQpO319ZWxzZSBpZihwYXJlbnQpe3BhcmVudC5jaGlsZHJlbi5wdXNoKG5leHQpO319ZXhwb3J0cy5hcHBlbmQ9YXBwZW5kOy8qKipcbiAqIFByZXBlbmQgYW4gZWxlbWVudCBiZWZvcmUgYW5vdGhlclxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGFwcGVuZCB0b1xuICogQHBhcmFtIHByZXYgVGhlIGVsZW1lbnQgYmUgYWRkZWRcbiAqL2Z1bmN0aW9uIHByZXBlbmQoZWxlbSxwcmV2KXt2YXIgcGFyZW50PWVsZW0ucGFyZW50O2lmKHBhcmVudCl7dmFyIGNoaWxkcz1wYXJlbnQuY2hpbGRyZW47Y2hpbGRzLnNwbGljZShjaGlsZHMubGFzdEluZGV4T2YoZWxlbSksMCxwcmV2KTt9aWYoZWxlbS5wcmV2KXtlbGVtLnByZXYubmV4dD1wcmV2O31wcmV2LnBhcmVudD1wYXJlbnQ7cHJldi5wcmV2PWVsZW0ucHJldjtwcmV2Lm5leHQ9ZWxlbTtlbGVtLnByZXY9cHJldjt9ZXhwb3J0cy5wcmVwZW5kPXByZXBlbmQ7fSx7fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIHRhZ3R5cGVzXzE9cmVxdWlyZShcIi4vdGFndHlwZXNcIik7LyoqXG4gKiBTZWFyY2ggYSBub2RlIGFuZCBpdHMgY2hpbGRyZW4gZm9yIG5vZGVzIHBhc3NpbmcgYSB0ZXN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB0ZXN0IEZ1bmN0aW9uIHRvIHRlc3Qgbm9kZXMgb24uXG4gKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIHNlYXJjaC4gV2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldCBpZiBpdCBtYXRjaGVzLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKi9mdW5jdGlvbiBmaWx0ZXIodGVzdCxub2RlLHJlY3Vyc2UsbGltaXQpe2lmKHJlY3Vyc2U9PT12b2lkIDApe3JlY3Vyc2U9dHJ1ZTt9aWYobGltaXQ9PT12b2lkIDApe2xpbWl0PUluZmluaXR5O31pZighQXJyYXkuaXNBcnJheShub2RlKSlub2RlPVtub2RlXTtyZXR1cm4gZmluZCh0ZXN0LG5vZGUscmVjdXJzZSxsaW1pdCk7fWV4cG9ydHMuZmlsdGVyPWZpbHRlcjsvKipcbiAqIExpa2UgYGZpbHRlcmAsIGJ1dCBvbmx5IHdvcmtzIG9uIGFuIGFycmF5IG9mIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB0ZXN0IEZ1bmN0aW9uIHRvIHRlc3Qgbm9kZXMgb24uXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdG8gc2VhcmNoLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKi9mdW5jdGlvbiBmaW5kKHRlc3Qsbm9kZXMscmVjdXJzZSxsaW1pdCl7dmFyIHJlc3VsdD1bXTtmb3IodmFyIF9pPTAsbm9kZXNfMT1ub2RlcztfaTxub2Rlc18xLmxlbmd0aDtfaSsrKXt2YXIgZWxlbT1ub2Rlc18xW19pXTtpZih0ZXN0KGVsZW0pKXtyZXN1bHQucHVzaChlbGVtKTtpZigtLWxpbWl0PD0wKWJyZWFrO31pZihyZWN1cnNlJiZ0YWd0eXBlc18xLmhhc0NoaWxkcmVuKGVsZW0pJiZlbGVtLmNoaWxkcmVuLmxlbmd0aD4wKXt2YXIgY2hpbGRyZW49ZmluZCh0ZXN0LGVsZW0uY2hpbGRyZW4scmVjdXJzZSxsaW1pdCk7cmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LGNoaWxkcmVuKTtsaW1pdC09Y2hpbGRyZW4ubGVuZ3RoO2lmKGxpbWl0PD0wKWJyZWFrO319cmV0dXJuIHJlc3VsdDt9ZXhwb3J0cy5maW5kPWZpbmQ7LyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgZWxlbWVudCBpbnNpZGUgb2YgYW4gYXJyYXkgdGhhdCBtYXRjaGVzIGEgdGVzdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqL2Z1bmN0aW9uIGZpbmRPbmVDaGlsZCh0ZXN0LG5vZGVzKXtyZXR1cm4gbm9kZXMuZmluZCh0ZXN0KTt9ZXhwb3J0cy5maW5kT25lQ2hpbGQ9ZmluZE9uZUNoaWxkOy8qKlxuICogRmluZHMgb25lIGVsZW1lbnQgaW4gYSB0cmVlIHRoYXQgcGFzc2VzIGEgdGVzdC5cbiAqXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKi9mdW5jdGlvbiBmaW5kT25lKHRlc3Qsbm9kZXMscmVjdXJzZSl7aWYocmVjdXJzZT09PXZvaWQgMCl7cmVjdXJzZT10cnVlO312YXIgZWxlbT1udWxsO2Zvcih2YXIgaT0wO2k8bm9kZXMubGVuZ3RoJiYhZWxlbTtpKyspe3ZhciBjaGVja2VkPW5vZGVzW2ldO2lmKCF0YWd0eXBlc18xLmlzVGFnKGNoZWNrZWQpKXtjb250aW51ZTt9ZWxzZSBpZih0ZXN0KGNoZWNrZWQpKXtlbGVtPWNoZWNrZWQ7fWVsc2UgaWYocmVjdXJzZSYmY2hlY2tlZC5jaGlsZHJlbi5sZW5ndGg+MCl7ZWxlbT1maW5kT25lKHRlc3QsY2hlY2tlZC5jaGlsZHJlbik7fX1yZXR1cm4gZWxlbTt9ZXhwb3J0cy5maW5kT25lPWZpbmRPbmU7LyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB0cmVlIG9mIG5vZGVzIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBub2RlIHBhc3NpbmcgYSB0ZXN0LlxuICpcbiAqIEBwYXJhbSB0ZXN0IEZ1bmN0aW9uIHRvIHRlc3Qgbm9kZXMgb24uXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdG8gc2VhcmNoLlxuICovZnVuY3Rpb24gZXhpc3RzT25lKHRlc3Qsbm9kZXMpe3JldHVybiBub2Rlcy5zb21lKGZ1bmN0aW9uKGNoZWNrZWQpe3JldHVybiB0YWd0eXBlc18xLmlzVGFnKGNoZWNrZWQpJiYodGVzdChjaGVja2VkKXx8Y2hlY2tlZC5jaGlsZHJlbi5sZW5ndGg+MCYmZXhpc3RzT25lKHRlc3QsY2hlY2tlZC5jaGlsZHJlbikpO30pO31leHBvcnRzLmV4aXN0c09uZT1leGlzdHNPbmU7LyoqXG4gKiBTZWFyY2ggYW5kIGFycmF5IG9mIG5vZGVzIGFuZCBpdHMgY2hpbGRyZW4gZm9yIG5vZGVzIHBhc3NpbmcgYSB0ZXN0IGZ1bmN0aW9uLlxuICpcbiAqIFNhbWUgYXMgYGZpbmRgLCBvbmx5IHdpdGggbGVzcyBvcHRpb25zLCBsZWFkaW5nIHRvIHJlZHVjZWQgY29tcGxleGl0eS5cbiAqXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqL2Z1bmN0aW9uIGZpbmRBbGwodGVzdCxub2Rlcyl7dmFyIF9hO3ZhciByZXN1bHQ9W107dmFyIHN0YWNrPW5vZGVzLmZpbHRlcih0YWd0eXBlc18xLmlzVGFnKTt2YXIgZWxlbTt3aGlsZShlbGVtPXN0YWNrLnNoaWZ0KCkpe3ZhciBjaGlsZHJlbj0oX2E9ZWxlbS5jaGlsZHJlbik9PT1udWxsfHxfYT09PXZvaWQgMD92b2lkIDA6X2EuZmlsdGVyKHRhZ3R5cGVzXzEuaXNUYWcpO2lmKGNoaWxkcmVuJiZjaGlsZHJlbi5sZW5ndGg+MCl7c3RhY2sudW5zaGlmdC5hcHBseShzdGFjayxjaGlsZHJlbik7fWlmKHRlc3QoZWxlbSkpcmVzdWx0LnB1c2goZWxlbSk7fXJldHVybiByZXN1bHQ7fWV4cG9ydHMuZmluZEFsbD1maW5kQWxsO30se1wiLi90YWd0eXBlc1wiOjE1fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOntcImRlZmF1bHRcIjptb2R9O307T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgdGFndHlwZXNfMT1yZXF1aXJlKFwiLi90YWd0eXBlc1wiKTt2YXIgZG9tX3NlcmlhbGl6ZXJfMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRvbS1zZXJpYWxpemVyXCIpKTtmdW5jdGlvbiBnZXRPdXRlckhUTUwobm9kZSxvcHRpb25zKXtyZXR1cm4gZG9tX3NlcmlhbGl6ZXJfMVtcImRlZmF1bHRcIl0obm9kZSxvcHRpb25zKTt9ZXhwb3J0cy5nZXRPdXRlckhUTUw9Z2V0T3V0ZXJIVE1MO2Z1bmN0aW9uIGdldElubmVySFRNTChub2RlLG9wdGlvbnMpe3JldHVybiB0YWd0eXBlc18xLmhhc0NoaWxkcmVuKG5vZGUpP25vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKG5vZGUpe3JldHVybiBnZXRPdXRlckhUTUwobm9kZSxvcHRpb25zKTt9KS5qb2luKFwiXCIpOlwiXCI7fWV4cG9ydHMuZ2V0SW5uZXJIVE1MPWdldElubmVySFRNTDtmdW5jdGlvbiBnZXRUZXh0KG5vZGUpe2lmKEFycmF5LmlzQXJyYXkobm9kZSkpcmV0dXJuIG5vZGUubWFwKGdldFRleHQpLmpvaW4oXCJcIik7aWYodGFndHlwZXNfMS5pc1RhZyhub2RlKSlyZXR1cm4gbm9kZS5uYW1lPT09XCJiclwiP1wiXFxuXCI6Z2V0VGV4dChub2RlLmNoaWxkcmVuKTtpZih0YWd0eXBlc18xLmlzQ0RBVEEobm9kZSkpcmV0dXJuIGdldFRleHQobm9kZS5jaGlsZHJlbik7aWYodGFndHlwZXNfMS5pc1RleHQobm9kZSkpcmV0dXJuIG5vZGUuZGF0YTtyZXR1cm5cIlwiO31leHBvcnRzLmdldFRleHQ9Z2V0VGV4dDt9LHtcIi4vdGFndHlwZXNcIjoxNSxcImRvbS1zZXJpYWxpemVyXCI6NX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciBkb21lbGVtZW50dHlwZV8xPXJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKTtmdW5jdGlvbiBpc1RhZyhub2RlKXtyZXR1cm4gZG9tZWxlbWVudHR5cGVfMS5pc1RhZyhub2RlKTt9ZXhwb3J0cy5pc1RhZz1pc1RhZztmdW5jdGlvbiBpc0NEQVRBKG5vZGUpe3JldHVybiBub2RlLnR5cGU9PT1cImNkYXRhXCIvKiBDREFUQSAqLzt9ZXhwb3J0cy5pc0NEQVRBPWlzQ0RBVEE7ZnVuY3Rpb24gaXNUZXh0KG5vZGUpe3JldHVybiBub2RlLnR5cGU9PT1cInRleHRcIi8qIFRleHQgKi87fWV4cG9ydHMuaXNUZXh0PWlzVGV4dDtmdW5jdGlvbiBpc0NvbW1lbnQobm9kZSl7cmV0dXJuIG5vZGUudHlwZT09PVwiY29tbWVudFwiLyogQ29tbWVudCAqLzt9ZXhwb3J0cy5pc0NvbW1lbnQ9aXNDb21tZW50O2Z1bmN0aW9uIGhhc0NoaWxkcmVuKG5vZGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSxcImNoaWxkcmVuXCIpO31leHBvcnRzLmhhc0NoaWxkcmVuPWhhc0NoaWxkcmVuO30se1wiZG9tZWxlbWVudHR5cGVcIjo2fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oZWxlbSl7cmV0dXJuIGVsZW0uY2hpbGRyZW58fG51bGw7fWV4cG9ydHMuZ2V0Q2hpbGRyZW49Z2V0Q2hpbGRyZW47ZnVuY3Rpb24gZ2V0UGFyZW50KGVsZW0pe3JldHVybiBlbGVtLnBhcmVudHx8bnVsbDt9ZXhwb3J0cy5nZXRQYXJlbnQ9Z2V0UGFyZW50O2Z1bmN0aW9uIGdldFNpYmxpbmdzKGVsZW0pe3ZhciBwYXJlbnQ9Z2V0UGFyZW50KGVsZW0pO3JldHVybiBwYXJlbnQ/Z2V0Q2hpbGRyZW4ocGFyZW50KTpbZWxlbV07fWV4cG9ydHMuZ2V0U2libGluZ3M9Z2V0U2libGluZ3M7ZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSxuYW1lKXt2YXIgX2E7cmV0dXJuKF9hPWVsZW0uYXR0cmlicyk9PT1udWxsfHxfYT09PXZvaWQgMD92b2lkIDA6X2FbbmFtZV07fWV4cG9ydHMuZ2V0QXR0cmlidXRlVmFsdWU9Z2V0QXR0cmlidXRlVmFsdWU7ZnVuY3Rpb24gaGFzQXR0cmliKGVsZW0sbmFtZSl7cmV0dXJuISFlbGVtLmF0dHJpYnMmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbGVtLmF0dHJpYnMsbmFtZSkmJmVsZW0uYXR0cmlic1tuYW1lXSE9bnVsbDt9ZXhwb3J0cy5oYXNBdHRyaWI9aGFzQXR0cmliOy8qKipcbiAqIFJldHVybnMgdGhlIG5hbWUgcHJvcGVydHkgb2YgYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGdldCB0aGUgbmFtZSBmb3JcbiAqL2Z1bmN0aW9uIGdldE5hbWUoZWxlbSl7cmV0dXJuIGVsZW0ubmFtZTt9ZXhwb3J0cy5nZXROYW1lPWdldE5hbWU7fSx7fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOntcImRlZmF1bHRcIjptb2R9O307T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgZW50aXRpZXNfanNvbl8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL2VudGl0aWVzLmpzb25cIikpO3ZhciBsZWdhY3lfanNvbl8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL2xlZ2FjeS5qc29uXCIpKTt2YXIgeG1sX2pzb25fMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy94bWwuanNvblwiKSk7dmFyIGRlY29kZV9jb2RlcG9pbnRfMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZGVjb2RlX2NvZGVwb2ludFwiKSk7ZXhwb3J0cy5kZWNvZGVYTUw9Z2V0U3RyaWN0RGVjb2Rlcih4bWxfanNvbl8xW1wiZGVmYXVsdFwiXSk7ZXhwb3J0cy5kZWNvZGVIVE1MU3RyaWN0PWdldFN0cmljdERlY29kZXIoZW50aXRpZXNfanNvbl8xW1wiZGVmYXVsdFwiXSk7ZnVuY3Rpb24gZ2V0U3RyaWN0RGVjb2RlcihtYXApe3ZhciBrZXlzPU9iamVjdC5rZXlzKG1hcCkuam9pbihcInxcIik7dmFyIHJlcGxhY2U9Z2V0UmVwbGFjZXIobWFwKTtrZXlzKz1cInwjW3hYXVtcXFxcZGEtZkEtRl0rfCNcXFxcZCtcIjt2YXIgcmU9bmV3IFJlZ0V4cChcIiYoPzpcIitrZXlzK1wiKTtcIixcImdcIik7cmV0dXJuIGZ1bmN0aW9uKHN0cil7cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUscmVwbGFjZSk7fTt9dmFyIHNvcnRlcj1mdW5jdGlvbiBzb3J0ZXIoYSxiKXtyZXR1cm4gYTxiPzE6LTE7fTtleHBvcnRzLmRlY29kZUhUTUw9ZnVuY3Rpb24oKXt2YXIgbGVnYWN5PU9iamVjdC5rZXlzKGxlZ2FjeV9qc29uXzFbXCJkZWZhdWx0XCJdKS5zb3J0KHNvcnRlcik7dmFyIGtleXM9T2JqZWN0LmtleXMoZW50aXRpZXNfanNvbl8xW1wiZGVmYXVsdFwiXSkuc29ydChzb3J0ZXIpO2Zvcih2YXIgaT0wLGo9MDtpPGtleXMubGVuZ3RoO2krKyl7aWYobGVnYWN5W2pdPT09a2V5c1tpXSl7a2V5c1tpXSs9XCI7P1wiO2orKzt9ZWxzZXtrZXlzW2ldKz1cIjtcIjt9fXZhciByZT1uZXcgUmVnRXhwKFwiJig/OlwiK2tleXMuam9pbihcInxcIikrXCJ8I1t4WF1bXFxcXGRhLWZBLUZdKzs/fCNcXFxcZCs7PylcIixcImdcIik7dmFyIHJlcGxhY2U9Z2V0UmVwbGFjZXIoZW50aXRpZXNfanNvbl8xW1wiZGVmYXVsdFwiXSk7ZnVuY3Rpb24gcmVwbGFjZXIoc3RyKXtpZihzdHIuc3Vic3RyKC0xKSE9PVwiO1wiKXN0cis9XCI7XCI7cmV0dXJuIHJlcGxhY2Uoc3RyKTt9Ly9UT0RPIGNvbnNpZGVyIGNyZWF0aW5nIGEgbWVyZ2VkIG1hcFxucmV0dXJuIGZ1bmN0aW9uKHN0cil7cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUscmVwbGFjZXIpO307fSgpO2Z1bmN0aW9uIGdldFJlcGxhY2VyKG1hcCl7cmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2Uoc3RyKXtpZihzdHIuY2hhckF0KDEpPT09XCIjXCIpe3ZhciBzZWNvbmRDaGFyPXN0ci5jaGFyQXQoMik7aWYoc2Vjb25kQ2hhcj09PVwiWFwifHxzZWNvbmRDaGFyPT09XCJ4XCIpe3JldHVybiBkZWNvZGVfY29kZXBvaW50XzFbXCJkZWZhdWx0XCJdKHBhcnNlSW50KHN0ci5zdWJzdHIoMyksMTYpKTt9cmV0dXJuIGRlY29kZV9jb2RlcG9pbnRfMVtcImRlZmF1bHRcIl0ocGFyc2VJbnQoc3RyLnN1YnN0cigyKSwxMCkpO31yZXR1cm4gbWFwW3N0ci5zbGljZSgxLC0xKV07fTt9fSx7XCIuL2RlY29kZV9jb2RlcG9pbnRcIjoxOCxcIi4vbWFwcy9lbnRpdGllcy5qc29uXCI6MjIsXCIuL21hcHMvbGVnYWN5Lmpzb25cIjoyMyxcIi4vbWFwcy94bWwuanNvblwiOjI0fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOntcImRlZmF1bHRcIjptb2R9O307T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgZGVjb2RlX2pzb25fMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy9kZWNvZGUuanNvblwiKSk7Ly8gbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9oZS9ibG9iL21hc3Rlci9zcmMvaGUuanMjTDk0LUwxMTlcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludChjb2RlUG9pbnQpe2lmKGNvZGVQb2ludD49MHhkODAwJiZjb2RlUG9pbnQ8PTB4ZGZmZnx8Y29kZVBvaW50PjB4MTBmZmZmKXtyZXR1cm5cIlxcdUZGRkRcIjt9aWYoY29kZVBvaW50IGluIGRlY29kZV9qc29uXzFbXCJkZWZhdWx0XCJdKXtjb2RlUG9pbnQ9ZGVjb2RlX2pzb25fMVtcImRlZmF1bHRcIl1bY29kZVBvaW50XTt9dmFyIG91dHB1dD1cIlwiO2lmKGNvZGVQb2ludD4weGZmZmYpe2NvZGVQb2ludC09MHgxMDAwMDtvdXRwdXQrPVN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50Pj4+MTAmMHgzZmZ8MHhkODAwKTtjb2RlUG9pbnQ9MHhkYzAwfGNvZGVQb2ludCYweDNmZjt9b3V0cHV0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7cmV0dXJuIG91dHB1dDt9ZXhwb3J0c1tcImRlZmF1bHRcIl09ZGVjb2RlQ29kZVBvaW50O30se1wiLi9tYXBzL2RlY29kZS5qc29uXCI6MjF9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIF9faW1wb3J0RGVmYXVsdD10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24obW9kKXtyZXR1cm4gbW9kJiZtb2QuX19lc01vZHVsZT9tb2Q6e1wiZGVmYXVsdFwiOm1vZH07fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciB4bWxfanNvbl8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL3htbC5qc29uXCIpKTt2YXIgaW52ZXJzZVhNTD1nZXRJbnZlcnNlT2JqKHhtbF9qc29uXzFbXCJkZWZhdWx0XCJdKTt2YXIgeG1sUmVwbGFjZXI9Z2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VYTUwpO2V4cG9ydHMuZW5jb2RlWE1MPWdldEludmVyc2UoaW52ZXJzZVhNTCx4bWxSZXBsYWNlcik7dmFyIGVudGl0aWVzX2pzb25fMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy9lbnRpdGllcy5qc29uXCIpKTt2YXIgaW52ZXJzZUhUTUw9Z2V0SW52ZXJzZU9iaihlbnRpdGllc19qc29uXzFbXCJkZWZhdWx0XCJdKTt2YXIgaHRtbFJlcGxhY2VyPWdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlSFRNTCk7ZXhwb3J0cy5lbmNvZGVIVE1MPWdldEludmVyc2UoaW52ZXJzZUhUTUwsaHRtbFJlcGxhY2VyKTtmdW5jdGlvbiBnZXRJbnZlcnNlT2JqKG9iail7cmV0dXJuIE9iamVjdC5rZXlzKG9iaikuc29ydCgpLnJlZHVjZShmdW5jdGlvbihpbnZlcnNlLG5hbWUpe2ludmVyc2Vbb2JqW25hbWVdXT1cIiZcIituYW1lK1wiO1wiO3JldHVybiBpbnZlcnNlO30se30pO31mdW5jdGlvbiBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZSl7dmFyIHNpbmdsZT1bXTt2YXIgbXVsdGlwbGU9W107Zm9yKHZhciBfaT0wLF9hPU9iamVjdC5rZXlzKGludmVyc2UpO19pPF9hLmxlbmd0aDtfaSsrKXt2YXIgaz1fYVtfaV07aWYoay5sZW5ndGg9PT0xKXsvLyBBZGQgdmFsdWUgdG8gc2luZ2xlIGFycmF5XG5zaW5nbGUucHVzaChcIlxcXFxcIitrKTt9ZWxzZXsvLyBBZGQgdmFsdWUgdG8gbXVsdGlwbGUgYXJyYXlcbm11bHRpcGxlLnB1c2goayk7fX0vLyBBZGQgcmFuZ2VzIHRvIHNpbmdsZSBjaGFyYWN0ZXJzLlxuc2luZ2xlLnNvcnQoKTtmb3IodmFyIHN0YXJ0PTA7c3RhcnQ8c2luZ2xlLmxlbmd0aC0xO3N0YXJ0Kyspey8vIEZpbmQgdGhlIGVuZCBvZiBhIHJ1biBvZiBjaGFyYWN0ZXJzXG52YXIgZW5kPXN0YXJ0O3doaWxlKGVuZDxzaW5nbGUubGVuZ3RoLTEmJnNpbmdsZVtlbmRdLmNoYXJDb2RlQXQoMSkrMT09PXNpbmdsZVtlbmQrMV0uY2hhckNvZGVBdCgxKSl7ZW5kKz0xO312YXIgY291bnQ9MStlbmQtc3RhcnQ7Ly8gV2Ugd2FudCB0byByZXBsYWNlIGF0IGxlYXN0IHRocmVlIGNoYXJhY3RlcnNcbmlmKGNvdW50PDMpY29udGludWU7c2luZ2xlLnNwbGljZShzdGFydCxjb3VudCxzaW5nbGVbc3RhcnRdK1wiLVwiK3NpbmdsZVtlbmRdKTt9bXVsdGlwbGUudW5zaGlmdChcIltcIitzaW5nbGUuam9pbihcIlwiKStcIl1cIik7cmV0dXJuIG5ldyBSZWdFeHAobXVsdGlwbGUuam9pbihcInxcIiksXCJnXCIpO312YXIgcmVOb25BU0NJST0vKD86W1xceDgwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pL2c7ZnVuY3Rpb24gc2luZ2xlQ2hhclJlcGxhY2VyKGMpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG5yZXR1cm5cIiYjeFwiK2MuY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkrXCI7XCI7fWZ1bmN0aW9uIGdldEludmVyc2UoaW52ZXJzZSxyZSl7cmV0dXJuIGZ1bmN0aW9uKGRhdGEpe3JldHVybiBkYXRhLnJlcGxhY2UocmUsZnVuY3Rpb24obmFtZSl7cmV0dXJuIGludmVyc2VbbmFtZV07fSkucmVwbGFjZShyZU5vbkFTQ0lJLHNpbmdsZUNoYXJSZXBsYWNlcik7fTt9dmFyIHJlWG1sQ2hhcnM9Z2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VYTUwpO2Z1bmN0aW9uIGVzY2FwZShkYXRhKXtyZXR1cm4gZGF0YS5yZXBsYWNlKHJlWG1sQ2hhcnMsc2luZ2xlQ2hhclJlcGxhY2VyKS5yZXBsYWNlKHJlTm9uQVNDSUksc2luZ2xlQ2hhclJlcGxhY2VyKTt9ZXhwb3J0cy5lc2NhcGU9ZXNjYXBlO30se1wiLi9tYXBzL2VudGl0aWVzLmpzb25cIjoyMixcIi4vbWFwcy94bWwuanNvblwiOjI0fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIGRlY29kZV8xPXJlcXVpcmUoXCIuL2RlY29kZVwiKTt2YXIgZW5jb2RlXzE9cmVxdWlyZShcIi4vZW5jb2RlXCIpOy8qKlxuICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICovZnVuY3Rpb24gZGVjb2RlKGRhdGEsbGV2ZWwpe3JldHVybighbGV2ZWx8fGxldmVsPD0wP2RlY29kZV8xLmRlY29kZVhNTDpkZWNvZGVfMS5kZWNvZGVIVE1MKShkYXRhKTt9ZXhwb3J0cy5kZWNvZGU9ZGVjb2RlOy8qKlxuICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLiBEb2VzIG5vdCBhbGxvdyBtaXNzaW5nIHRyYWlsaW5nIHNlbWljb2xvbnMgZm9yIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICovZnVuY3Rpb24gZGVjb2RlU3RyaWN0KGRhdGEsbGV2ZWwpe3JldHVybighbGV2ZWx8fGxldmVsPD0wP2RlY29kZV8xLmRlY29kZVhNTDpkZWNvZGVfMS5kZWNvZGVIVE1MU3RyaWN0KShkYXRhKTt9ZXhwb3J0cy5kZWNvZGVTdHJpY3Q9ZGVjb2RlU3RyaWN0Oy8qKlxuICogRW5jb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZW5jb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICovZnVuY3Rpb24gZW5jb2RlKGRhdGEsbGV2ZWwpe3JldHVybighbGV2ZWx8fGxldmVsPD0wP2VuY29kZV8xLmVuY29kZVhNTDplbmNvZGVfMS5lbmNvZGVIVE1MKShkYXRhKTt9ZXhwb3J0cy5lbmNvZGU9ZW5jb2RlO3ZhciBlbmNvZGVfMj1yZXF1aXJlKFwiLi9lbmNvZGVcIik7ZXhwb3J0cy5lbmNvZGVYTUw9ZW5jb2RlXzIuZW5jb2RlWE1MO2V4cG9ydHMuZW5jb2RlSFRNTD1lbmNvZGVfMi5lbmNvZGVIVE1MO2V4cG9ydHMuZXNjYXBlPWVuY29kZV8yLmVzY2FwZTsvLyBMZWdhY3kgYWxpYXNlc1xuZXhwb3J0cy5lbmNvZGVIVE1MND1lbmNvZGVfMi5lbmNvZGVIVE1MO2V4cG9ydHMuZW5jb2RlSFRNTDU9ZW5jb2RlXzIuZW5jb2RlSFRNTDt2YXIgZGVjb2RlXzI9cmVxdWlyZShcIi4vZGVjb2RlXCIpO2V4cG9ydHMuZGVjb2RlWE1MPWRlY29kZV8yLmRlY29kZVhNTDtleHBvcnRzLmRlY29kZUhUTUw9ZGVjb2RlXzIuZGVjb2RlSFRNTDtleHBvcnRzLmRlY29kZUhUTUxTdHJpY3Q9ZGVjb2RlXzIuZGVjb2RlSFRNTFN0cmljdDsvLyBMZWdhY3kgYWxpYXNlc1xuZXhwb3J0cy5kZWNvZGVIVE1MND1kZWNvZGVfMi5kZWNvZGVIVE1MO2V4cG9ydHMuZGVjb2RlSFRNTDU9ZGVjb2RlXzIuZGVjb2RlSFRNTDtleHBvcnRzLmRlY29kZUhUTUw0U3RyaWN0PWRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7ZXhwb3J0cy5kZWNvZGVIVE1MNVN0cmljdD1kZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0O2V4cG9ydHMuZGVjb2RlWE1MU3RyaWN0PWRlY29kZV8yLmRlY29kZVhNTDt9LHtcIi4vZGVjb2RlXCI6MTcsXCIuL2VuY29kZVwiOjE5fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPXtcIjBcIjo2NTUzMyxcIjEyOFwiOjgzNjQsXCIxMzBcIjo4MjE4LFwiMTMxXCI6NDAyLFwiMTMyXCI6ODIyMixcIjEzM1wiOjgyMzAsXCIxMzRcIjo4MjI0LFwiMTM1XCI6ODIyNSxcIjEzNlwiOjcxMCxcIjEzN1wiOjgyNDAsXCIxMzhcIjozNTIsXCIxMzlcIjo4MjQ5LFwiMTQwXCI6MzM4LFwiMTQyXCI6MzgxLFwiMTQ1XCI6ODIxNixcIjE0NlwiOjgyMTcsXCIxNDdcIjo4MjIwLFwiMTQ4XCI6ODIyMSxcIjE0OVwiOjgyMjYsXCIxNTBcIjo4MjExLFwiMTUxXCI6ODIxMixcIjE1MlwiOjczMixcIjE1M1wiOjg0ODIsXCIxNTRcIjozNTMsXCIxNTVcIjo4MjUwLFwiMTU2XCI6MzM5LFwiMTU4XCI6MzgyLFwiMTU5XCI6Mzc2fTt9LHt9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9e1wiQWFjdXRlXCI6XCJcXHhDMVwiLFwiYWFjdXRlXCI6XCJcXHhFMVwiLFwiQWJyZXZlXCI6XCJcXHUwMTAyXCIsXCJhYnJldmVcIjpcIlxcdTAxMDNcIixcImFjXCI6XCJcXHUyMjNFXCIsXCJhY2RcIjpcIlxcdTIyM0ZcIixcImFjRVwiOlwiXFx1MjIzRVxcdTAzMzNcIixcIkFjaXJjXCI6XCJcXHhDMlwiLFwiYWNpcmNcIjpcIlxceEUyXCIsXCJhY3V0ZVwiOlwiXFx4QjRcIixcIkFjeVwiOlwiXFx1MDQxMFwiLFwiYWN5XCI6XCJcXHUwNDMwXCIsXCJBRWxpZ1wiOlwiXFx4QzZcIixcImFlbGlnXCI6XCJcXHhFNlwiLFwiYWZcIjpcIlxcdTIwNjFcIixcIkFmclwiOlwiXFx1RDgzNVxcdUREMDRcIixcImFmclwiOlwiXFx1RDgzNVxcdUREMUVcIixcIkFncmF2ZVwiOlwiXFx4QzBcIixcImFncmF2ZVwiOlwiXFx4RTBcIixcImFsZWZzeW1cIjpcIlxcdTIxMzVcIixcImFsZXBoXCI6XCJcXHUyMTM1XCIsXCJBbHBoYVwiOlwiXFx1MDM5MVwiLFwiYWxwaGFcIjpcIlxcdTAzQjFcIixcIkFtYWNyXCI6XCJcXHUwMTAwXCIsXCJhbWFjclwiOlwiXFx1MDEwMVwiLFwiYW1hbGdcIjpcIlxcdTJBM0ZcIixcImFtcFwiOlwiJlwiLFwiQU1QXCI6XCImXCIsXCJhbmRhbmRcIjpcIlxcdTJBNTVcIixcIkFuZFwiOlwiXFx1MkE1M1wiLFwiYW5kXCI6XCJcXHUyMjI3XCIsXCJhbmRkXCI6XCJcXHUyQTVDXCIsXCJhbmRzbG9wZVwiOlwiXFx1MkE1OFwiLFwiYW5kdlwiOlwiXFx1MkE1QVwiLFwiYW5nXCI6XCJcXHUyMjIwXCIsXCJhbmdlXCI6XCJcXHUyOUE0XCIsXCJhbmdsZVwiOlwiXFx1MjIyMFwiLFwiYW5nbXNkYWFcIjpcIlxcdTI5QThcIixcImFuZ21zZGFiXCI6XCJcXHUyOUE5XCIsXCJhbmdtc2RhY1wiOlwiXFx1MjlBQVwiLFwiYW5nbXNkYWRcIjpcIlxcdTI5QUJcIixcImFuZ21zZGFlXCI6XCJcXHUyOUFDXCIsXCJhbmdtc2RhZlwiOlwiXFx1MjlBRFwiLFwiYW5nbXNkYWdcIjpcIlxcdTI5QUVcIixcImFuZ21zZGFoXCI6XCJcXHUyOUFGXCIsXCJhbmdtc2RcIjpcIlxcdTIyMjFcIixcImFuZ3J0XCI6XCJcXHUyMjFGXCIsXCJhbmdydHZiXCI6XCJcXHUyMkJFXCIsXCJhbmdydHZiZFwiOlwiXFx1Mjk5RFwiLFwiYW5nc3BoXCI6XCJcXHUyMjIyXCIsXCJhbmdzdFwiOlwiXFx4QzVcIixcImFuZ3phcnJcIjpcIlxcdTIzN0NcIixcIkFvZ29uXCI6XCJcXHUwMTA0XCIsXCJhb2dvblwiOlwiXFx1MDEwNVwiLFwiQW9wZlwiOlwiXFx1RDgzNVxcdUREMzhcIixcImFvcGZcIjpcIlxcdUQ4MzVcXHVERDUyXCIsXCJhcGFjaXJcIjpcIlxcdTJBNkZcIixcImFwXCI6XCJcXHUyMjQ4XCIsXCJhcEVcIjpcIlxcdTJBNzBcIixcImFwZVwiOlwiXFx1MjI0QVwiLFwiYXBpZFwiOlwiXFx1MjI0QlwiLFwiYXBvc1wiOlwiJ1wiLFwiQXBwbHlGdW5jdGlvblwiOlwiXFx1MjA2MVwiLFwiYXBwcm94XCI6XCJcXHUyMjQ4XCIsXCJhcHByb3hlcVwiOlwiXFx1MjI0QVwiLFwiQXJpbmdcIjpcIlxceEM1XCIsXCJhcmluZ1wiOlwiXFx4RTVcIixcIkFzY3JcIjpcIlxcdUQ4MzVcXHVEQzlDXCIsXCJhc2NyXCI6XCJcXHVEODM1XFx1RENCNlwiLFwiQXNzaWduXCI6XCJcXHUyMjU0XCIsXCJhc3RcIjpcIipcIixcImFzeW1wXCI6XCJcXHUyMjQ4XCIsXCJhc3ltcGVxXCI6XCJcXHUyMjREXCIsXCJBdGlsZGVcIjpcIlxceEMzXCIsXCJhdGlsZGVcIjpcIlxceEUzXCIsXCJBdW1sXCI6XCJcXHhDNFwiLFwiYXVtbFwiOlwiXFx4RTRcIixcImF3Y29uaW50XCI6XCJcXHUyMjMzXCIsXCJhd2ludFwiOlwiXFx1MkExMVwiLFwiYmFja2NvbmdcIjpcIlxcdTIyNENcIixcImJhY2tlcHNpbG9uXCI6XCJcXHUwM0Y2XCIsXCJiYWNrcHJpbWVcIjpcIlxcdTIwMzVcIixcImJhY2tzaW1cIjpcIlxcdTIyM0RcIixcImJhY2tzaW1lcVwiOlwiXFx1MjJDRFwiLFwiQmFja3NsYXNoXCI6XCJcXHUyMjE2XCIsXCJCYXJ2XCI6XCJcXHUyQUU3XCIsXCJiYXJ2ZWVcIjpcIlxcdTIyQkRcIixcImJhcndlZFwiOlwiXFx1MjMwNVwiLFwiQmFyd2VkXCI6XCJcXHUyMzA2XCIsXCJiYXJ3ZWRnZVwiOlwiXFx1MjMwNVwiLFwiYmJya1wiOlwiXFx1MjNCNVwiLFwiYmJya3RicmtcIjpcIlxcdTIzQjZcIixcImJjb25nXCI6XCJcXHUyMjRDXCIsXCJCY3lcIjpcIlxcdTA0MTFcIixcImJjeVwiOlwiXFx1MDQzMVwiLFwiYmRxdW9cIjpcIlxcdTIwMUVcIixcImJlY2F1c1wiOlwiXFx1MjIzNVwiLFwiYmVjYXVzZVwiOlwiXFx1MjIzNVwiLFwiQmVjYXVzZVwiOlwiXFx1MjIzNVwiLFwiYmVtcHR5dlwiOlwiXFx1MjlCMFwiLFwiYmVwc2lcIjpcIlxcdTAzRjZcIixcImJlcm5vdVwiOlwiXFx1MjEyQ1wiLFwiQmVybm91bGxpc1wiOlwiXFx1MjEyQ1wiLFwiQmV0YVwiOlwiXFx1MDM5MlwiLFwiYmV0YVwiOlwiXFx1MDNCMlwiLFwiYmV0aFwiOlwiXFx1MjEzNlwiLFwiYmV0d2VlblwiOlwiXFx1MjI2Q1wiLFwiQmZyXCI6XCJcXHVEODM1XFx1REQwNVwiLFwiYmZyXCI6XCJcXHVEODM1XFx1REQxRlwiLFwiYmlnY2FwXCI6XCJcXHUyMkMyXCIsXCJiaWdjaXJjXCI6XCJcXHUyNUVGXCIsXCJiaWdjdXBcIjpcIlxcdTIyQzNcIixcImJpZ29kb3RcIjpcIlxcdTJBMDBcIixcImJpZ29wbHVzXCI6XCJcXHUyQTAxXCIsXCJiaWdvdGltZXNcIjpcIlxcdTJBMDJcIixcImJpZ3NxY3VwXCI6XCJcXHUyQTA2XCIsXCJiaWdzdGFyXCI6XCJcXHUyNjA1XCIsXCJiaWd0cmlhbmdsZWRvd25cIjpcIlxcdTI1QkRcIixcImJpZ3RyaWFuZ2xldXBcIjpcIlxcdTI1QjNcIixcImJpZ3VwbHVzXCI6XCJcXHUyQTA0XCIsXCJiaWd2ZWVcIjpcIlxcdTIyQzFcIixcImJpZ3dlZGdlXCI6XCJcXHUyMkMwXCIsXCJia2Fyb3dcIjpcIlxcdTI5MERcIixcImJsYWNrbG96ZW5nZVwiOlwiXFx1MjlFQlwiLFwiYmxhY2tzcXVhcmVcIjpcIlxcdTI1QUFcIixcImJsYWNrdHJpYW5nbGVcIjpcIlxcdTI1QjRcIixcImJsYWNrdHJpYW5nbGVkb3duXCI6XCJcXHUyNUJFXCIsXCJibGFja3RyaWFuZ2xlbGVmdFwiOlwiXFx1MjVDMlwiLFwiYmxhY2t0cmlhbmdsZXJpZ2h0XCI6XCJcXHUyNUI4XCIsXCJibGFua1wiOlwiXFx1MjQyM1wiLFwiYmxrMTJcIjpcIlxcdTI1OTJcIixcImJsazE0XCI6XCJcXHUyNTkxXCIsXCJibGszNFwiOlwiXFx1MjU5M1wiLFwiYmxvY2tcIjpcIlxcdTI1ODhcIixcImJuZVwiOlwiPVxcdTIwRTVcIixcImJuZXF1aXZcIjpcIlxcdTIyNjFcXHUyMEU1XCIsXCJiTm90XCI6XCJcXHUyQUVEXCIsXCJibm90XCI6XCJcXHUyMzEwXCIsXCJCb3BmXCI6XCJcXHVEODM1XFx1REQzOVwiLFwiYm9wZlwiOlwiXFx1RDgzNVxcdURENTNcIixcImJvdFwiOlwiXFx1MjJBNVwiLFwiYm90dG9tXCI6XCJcXHUyMkE1XCIsXCJib3d0aWVcIjpcIlxcdTIyQzhcIixcImJveGJveFwiOlwiXFx1MjlDOVwiLFwiYm94ZGxcIjpcIlxcdTI1MTBcIixcImJveGRMXCI6XCJcXHUyNTU1XCIsXCJib3hEbFwiOlwiXFx1MjU1NlwiLFwiYm94RExcIjpcIlxcdTI1NTdcIixcImJveGRyXCI6XCJcXHUyNTBDXCIsXCJib3hkUlwiOlwiXFx1MjU1MlwiLFwiYm94RHJcIjpcIlxcdTI1NTNcIixcImJveERSXCI6XCJcXHUyNTU0XCIsXCJib3hoXCI6XCJcXHUyNTAwXCIsXCJib3hIXCI6XCJcXHUyNTUwXCIsXCJib3hoZFwiOlwiXFx1MjUyQ1wiLFwiYm94SGRcIjpcIlxcdTI1NjRcIixcImJveGhEXCI6XCJcXHUyNTY1XCIsXCJib3hIRFwiOlwiXFx1MjU2NlwiLFwiYm94aHVcIjpcIlxcdTI1MzRcIixcImJveEh1XCI6XCJcXHUyNTY3XCIsXCJib3hoVVwiOlwiXFx1MjU2OFwiLFwiYm94SFVcIjpcIlxcdTI1NjlcIixcImJveG1pbnVzXCI6XCJcXHUyMjlGXCIsXCJib3hwbHVzXCI6XCJcXHUyMjlFXCIsXCJib3h0aW1lc1wiOlwiXFx1MjJBMFwiLFwiYm94dWxcIjpcIlxcdTI1MThcIixcImJveHVMXCI6XCJcXHUyNTVCXCIsXCJib3hVbFwiOlwiXFx1MjU1Q1wiLFwiYm94VUxcIjpcIlxcdTI1NURcIixcImJveHVyXCI6XCJcXHUyNTE0XCIsXCJib3h1UlwiOlwiXFx1MjU1OFwiLFwiYm94VXJcIjpcIlxcdTI1NTlcIixcImJveFVSXCI6XCJcXHUyNTVBXCIsXCJib3h2XCI6XCJcXHUyNTAyXCIsXCJib3hWXCI6XCJcXHUyNTUxXCIsXCJib3h2aFwiOlwiXFx1MjUzQ1wiLFwiYm94dkhcIjpcIlxcdTI1NkFcIixcImJveFZoXCI6XCJcXHUyNTZCXCIsXCJib3hWSFwiOlwiXFx1MjU2Q1wiLFwiYm94dmxcIjpcIlxcdTI1MjRcIixcImJveHZMXCI6XCJcXHUyNTYxXCIsXCJib3hWbFwiOlwiXFx1MjU2MlwiLFwiYm94VkxcIjpcIlxcdTI1NjNcIixcImJveHZyXCI6XCJcXHUyNTFDXCIsXCJib3h2UlwiOlwiXFx1MjU1RVwiLFwiYm94VnJcIjpcIlxcdTI1NUZcIixcImJveFZSXCI6XCJcXHUyNTYwXCIsXCJicHJpbWVcIjpcIlxcdTIwMzVcIixcImJyZXZlXCI6XCJcXHUwMkQ4XCIsXCJCcmV2ZVwiOlwiXFx1MDJEOFwiLFwiYnJ2YmFyXCI6XCJcXHhBNlwiLFwiYnNjclwiOlwiXFx1RDgzNVxcdURDQjdcIixcIkJzY3JcIjpcIlxcdTIxMkNcIixcImJzZW1pXCI6XCJcXHUyMDRGXCIsXCJic2ltXCI6XCJcXHUyMjNEXCIsXCJic2ltZVwiOlwiXFx1MjJDRFwiLFwiYnNvbGJcIjpcIlxcdTI5QzVcIixcImJzb2xcIjpcIlxcXFxcIixcImJzb2xoc3ViXCI6XCJcXHUyN0M4XCIsXCJidWxsXCI6XCJcXHUyMDIyXCIsXCJidWxsZXRcIjpcIlxcdTIwMjJcIixcImJ1bXBcIjpcIlxcdTIyNEVcIixcImJ1bXBFXCI6XCJcXHUyQUFFXCIsXCJidW1wZVwiOlwiXFx1MjI0RlwiLFwiQnVtcGVxXCI6XCJcXHUyMjRFXCIsXCJidW1wZXFcIjpcIlxcdTIyNEZcIixcIkNhY3V0ZVwiOlwiXFx1MDEwNlwiLFwiY2FjdXRlXCI6XCJcXHUwMTA3XCIsXCJjYXBhbmRcIjpcIlxcdTJBNDRcIixcImNhcGJyY3VwXCI6XCJcXHUyQTQ5XCIsXCJjYXBjYXBcIjpcIlxcdTJBNEJcIixcImNhcFwiOlwiXFx1MjIyOVwiLFwiQ2FwXCI6XCJcXHUyMkQyXCIsXCJjYXBjdXBcIjpcIlxcdTJBNDdcIixcImNhcGRvdFwiOlwiXFx1MkE0MFwiLFwiQ2FwaXRhbERpZmZlcmVudGlhbERcIjpcIlxcdTIxNDVcIixcImNhcHNcIjpcIlxcdTIyMjlcXHVGRTAwXCIsXCJjYXJldFwiOlwiXFx1MjA0MVwiLFwiY2Fyb25cIjpcIlxcdTAyQzdcIixcIkNheWxleXNcIjpcIlxcdTIxMkRcIixcImNjYXBzXCI6XCJcXHUyQTREXCIsXCJDY2Fyb25cIjpcIlxcdTAxMENcIixcImNjYXJvblwiOlwiXFx1MDEwRFwiLFwiQ2NlZGlsXCI6XCJcXHhDN1wiLFwiY2NlZGlsXCI6XCJcXHhFN1wiLFwiQ2NpcmNcIjpcIlxcdTAxMDhcIixcImNjaXJjXCI6XCJcXHUwMTA5XCIsXCJDY29uaW50XCI6XCJcXHUyMjMwXCIsXCJjY3Vwc1wiOlwiXFx1MkE0Q1wiLFwiY2N1cHNzbVwiOlwiXFx1MkE1MFwiLFwiQ2RvdFwiOlwiXFx1MDEwQVwiLFwiY2RvdFwiOlwiXFx1MDEwQlwiLFwiY2VkaWxcIjpcIlxceEI4XCIsXCJDZWRpbGxhXCI6XCJcXHhCOFwiLFwiY2VtcHR5dlwiOlwiXFx1MjlCMlwiLFwiY2VudFwiOlwiXFx4QTJcIixcImNlbnRlcmRvdFwiOlwiXFx4QjdcIixcIkNlbnRlckRvdFwiOlwiXFx4QjdcIixcImNmclwiOlwiXFx1RDgzNVxcdUREMjBcIixcIkNmclwiOlwiXFx1MjEyRFwiLFwiQ0hjeVwiOlwiXFx1MDQyN1wiLFwiY2hjeVwiOlwiXFx1MDQ0N1wiLFwiY2hlY2tcIjpcIlxcdTI3MTNcIixcImNoZWNrbWFya1wiOlwiXFx1MjcxM1wiLFwiQ2hpXCI6XCJcXHUwM0E3XCIsXCJjaGlcIjpcIlxcdTAzQzdcIixcImNpcmNcIjpcIlxcdTAyQzZcIixcImNpcmNlcVwiOlwiXFx1MjI1N1wiLFwiY2lyY2xlYXJyb3dsZWZ0XCI6XCJcXHUyMUJBXCIsXCJjaXJjbGVhcnJvd3JpZ2h0XCI6XCJcXHUyMUJCXCIsXCJjaXJjbGVkYXN0XCI6XCJcXHUyMjlCXCIsXCJjaXJjbGVkY2lyY1wiOlwiXFx1MjI5QVwiLFwiY2lyY2xlZGRhc2hcIjpcIlxcdTIyOURcIixcIkNpcmNsZURvdFwiOlwiXFx1MjI5OVwiLFwiY2lyY2xlZFJcIjpcIlxceEFFXCIsXCJjaXJjbGVkU1wiOlwiXFx1MjRDOFwiLFwiQ2lyY2xlTWludXNcIjpcIlxcdTIyOTZcIixcIkNpcmNsZVBsdXNcIjpcIlxcdTIyOTVcIixcIkNpcmNsZVRpbWVzXCI6XCJcXHUyMjk3XCIsXCJjaXJcIjpcIlxcdTI1Q0JcIixcImNpckVcIjpcIlxcdTI5QzNcIixcImNpcmVcIjpcIlxcdTIyNTdcIixcImNpcmZuaW50XCI6XCJcXHUyQTEwXCIsXCJjaXJtaWRcIjpcIlxcdTJBRUZcIixcImNpcnNjaXJcIjpcIlxcdTI5QzJcIixcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwiXFx1MjIzMlwiLFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6XCJcXHUyMDFEXCIsXCJDbG9zZUN1cmx5UXVvdGVcIjpcIlxcdTIwMTlcIixcImNsdWJzXCI6XCJcXHUyNjYzXCIsXCJjbHVic3VpdFwiOlwiXFx1MjY2M1wiLFwiY29sb25cIjpcIjpcIixcIkNvbG9uXCI6XCJcXHUyMjM3XCIsXCJDb2xvbmVcIjpcIlxcdTJBNzRcIixcImNvbG9uZVwiOlwiXFx1MjI1NFwiLFwiY29sb25lcVwiOlwiXFx1MjI1NFwiLFwiY29tbWFcIjpcIixcIixcImNvbW1hdFwiOlwiQFwiLFwiY29tcFwiOlwiXFx1MjIwMVwiLFwiY29tcGZuXCI6XCJcXHUyMjE4XCIsXCJjb21wbGVtZW50XCI6XCJcXHUyMjAxXCIsXCJjb21wbGV4ZXNcIjpcIlxcdTIxMDJcIixcImNvbmdcIjpcIlxcdTIyNDVcIixcImNvbmdkb3RcIjpcIlxcdTJBNkRcIixcIkNvbmdydWVudFwiOlwiXFx1MjI2MVwiLFwiY29uaW50XCI6XCJcXHUyMjJFXCIsXCJDb25pbnRcIjpcIlxcdTIyMkZcIixcIkNvbnRvdXJJbnRlZ3JhbFwiOlwiXFx1MjIyRVwiLFwiY29wZlwiOlwiXFx1RDgzNVxcdURENTRcIixcIkNvcGZcIjpcIlxcdTIxMDJcIixcImNvcHJvZFwiOlwiXFx1MjIxMFwiLFwiQ29wcm9kdWN0XCI6XCJcXHUyMjEwXCIsXCJjb3B5XCI6XCJcXHhBOVwiLFwiQ09QWVwiOlwiXFx4QTlcIixcImNvcHlzclwiOlwiXFx1MjExN1wiLFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwiXFx1MjIzM1wiLFwiY3JhcnJcIjpcIlxcdTIxQjVcIixcImNyb3NzXCI6XCJcXHUyNzE3XCIsXCJDcm9zc1wiOlwiXFx1MkEyRlwiLFwiQ3NjclwiOlwiXFx1RDgzNVxcdURDOUVcIixcImNzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I4XCIsXCJjc3ViXCI6XCJcXHUyQUNGXCIsXCJjc3ViZVwiOlwiXFx1MkFEMVwiLFwiY3N1cFwiOlwiXFx1MkFEMFwiLFwiY3N1cGVcIjpcIlxcdTJBRDJcIixcImN0ZG90XCI6XCJcXHUyMkVGXCIsXCJjdWRhcnJsXCI6XCJcXHUyOTM4XCIsXCJjdWRhcnJyXCI6XCJcXHUyOTM1XCIsXCJjdWVwclwiOlwiXFx1MjJERVwiLFwiY3Vlc2NcIjpcIlxcdTIyREZcIixcImN1bGFyclwiOlwiXFx1MjFCNlwiLFwiY3VsYXJycFwiOlwiXFx1MjkzRFwiLFwiY3VwYnJjYXBcIjpcIlxcdTJBNDhcIixcImN1cGNhcFwiOlwiXFx1MkE0NlwiLFwiQ3VwQ2FwXCI6XCJcXHUyMjREXCIsXCJjdXBcIjpcIlxcdTIyMkFcIixcIkN1cFwiOlwiXFx1MjJEM1wiLFwiY3VwY3VwXCI6XCJcXHUyQTRBXCIsXCJjdXBkb3RcIjpcIlxcdTIyOERcIixcImN1cG9yXCI6XCJcXHUyQTQ1XCIsXCJjdXBzXCI6XCJcXHUyMjJBXFx1RkUwMFwiLFwiY3VyYXJyXCI6XCJcXHUyMUI3XCIsXCJjdXJhcnJtXCI6XCJcXHUyOTNDXCIsXCJjdXJseWVxcHJlY1wiOlwiXFx1MjJERVwiLFwiY3VybHllcXN1Y2NcIjpcIlxcdTIyREZcIixcImN1cmx5dmVlXCI6XCJcXHUyMkNFXCIsXCJjdXJseXdlZGdlXCI6XCJcXHUyMkNGXCIsXCJjdXJyZW5cIjpcIlxceEE0XCIsXCJjdXJ2ZWFycm93bGVmdFwiOlwiXFx1MjFCNlwiLFwiY3VydmVhcnJvd3JpZ2h0XCI6XCJcXHUyMUI3XCIsXCJjdXZlZVwiOlwiXFx1MjJDRVwiLFwiY3V3ZWRcIjpcIlxcdTIyQ0ZcIixcImN3Y29uaW50XCI6XCJcXHUyMjMyXCIsXCJjd2ludFwiOlwiXFx1MjIzMVwiLFwiY3lsY3R5XCI6XCJcXHUyMzJEXCIsXCJkYWdnZXJcIjpcIlxcdTIwMjBcIixcIkRhZ2dlclwiOlwiXFx1MjAyMVwiLFwiZGFsZXRoXCI6XCJcXHUyMTM4XCIsXCJkYXJyXCI6XCJcXHUyMTkzXCIsXCJEYXJyXCI6XCJcXHUyMUExXCIsXCJkQXJyXCI6XCJcXHUyMUQzXCIsXCJkYXNoXCI6XCJcXHUyMDEwXCIsXCJEYXNodlwiOlwiXFx1MkFFNFwiLFwiZGFzaHZcIjpcIlxcdTIyQTNcIixcImRia2Fyb3dcIjpcIlxcdTI5MEZcIixcImRibGFjXCI6XCJcXHUwMkREXCIsXCJEY2Fyb25cIjpcIlxcdTAxMEVcIixcImRjYXJvblwiOlwiXFx1MDEwRlwiLFwiRGN5XCI6XCJcXHUwNDE0XCIsXCJkY3lcIjpcIlxcdTA0MzRcIixcImRkYWdnZXJcIjpcIlxcdTIwMjFcIixcImRkYXJyXCI6XCJcXHUyMUNBXCIsXCJERFwiOlwiXFx1MjE0NVwiLFwiZGRcIjpcIlxcdTIxNDZcIixcIkREb3RyYWhkXCI6XCJcXHUyOTExXCIsXCJkZG90c2VxXCI6XCJcXHUyQTc3XCIsXCJkZWdcIjpcIlxceEIwXCIsXCJEZWxcIjpcIlxcdTIyMDdcIixcIkRlbHRhXCI6XCJcXHUwMzk0XCIsXCJkZWx0YVwiOlwiXFx1MDNCNFwiLFwiZGVtcHR5dlwiOlwiXFx1MjlCMVwiLFwiZGZpc2h0XCI6XCJcXHUyOTdGXCIsXCJEZnJcIjpcIlxcdUQ4MzVcXHVERDA3XCIsXCJkZnJcIjpcIlxcdUQ4MzVcXHVERDIxXCIsXCJkSGFyXCI6XCJcXHUyOTY1XCIsXCJkaGFybFwiOlwiXFx1MjFDM1wiLFwiZGhhcnJcIjpcIlxcdTIxQzJcIixcIkRpYWNyaXRpY2FsQWN1dGVcIjpcIlxceEI0XCIsXCJEaWFjcml0aWNhbERvdFwiOlwiXFx1MDJEOVwiLFwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZVwiOlwiXFx1MDJERFwiLFwiRGlhY3JpdGljYWxHcmF2ZVwiOlwiYFwiLFwiRGlhY3JpdGljYWxUaWxkZVwiOlwiXFx1MDJEQ1wiLFwiZGlhbVwiOlwiXFx1MjJDNFwiLFwiZGlhbW9uZFwiOlwiXFx1MjJDNFwiLFwiRGlhbW9uZFwiOlwiXFx1MjJDNFwiLFwiZGlhbW9uZHN1aXRcIjpcIlxcdTI2NjZcIixcImRpYW1zXCI6XCJcXHUyNjY2XCIsXCJkaWVcIjpcIlxceEE4XCIsXCJEaWZmZXJlbnRpYWxEXCI6XCJcXHUyMTQ2XCIsXCJkaWdhbW1hXCI6XCJcXHUwM0REXCIsXCJkaXNpblwiOlwiXFx1MjJGMlwiLFwiZGl2XCI6XCJcXHhGN1wiLFwiZGl2aWRlXCI6XCJcXHhGN1wiLFwiZGl2aWRlb250aW1lc1wiOlwiXFx1MjJDN1wiLFwiZGl2b254XCI6XCJcXHUyMkM3XCIsXCJESmN5XCI6XCJcXHUwNDAyXCIsXCJkamN5XCI6XCJcXHUwNDUyXCIsXCJkbGNvcm5cIjpcIlxcdTIzMUVcIixcImRsY3JvcFwiOlwiXFx1MjMwRFwiLFwiZG9sbGFyXCI6XCIkXCIsXCJEb3BmXCI6XCJcXHVEODM1XFx1REQzQlwiLFwiZG9wZlwiOlwiXFx1RDgzNVxcdURENTVcIixcIkRvdFwiOlwiXFx4QThcIixcImRvdFwiOlwiXFx1MDJEOVwiLFwiRG90RG90XCI6XCJcXHUyMERDXCIsXCJkb3RlcVwiOlwiXFx1MjI1MFwiLFwiZG90ZXFkb3RcIjpcIlxcdTIyNTFcIixcIkRvdEVxdWFsXCI6XCJcXHUyMjUwXCIsXCJkb3RtaW51c1wiOlwiXFx1MjIzOFwiLFwiZG90cGx1c1wiOlwiXFx1MjIxNFwiLFwiZG90c3F1YXJlXCI6XCJcXHUyMkExXCIsXCJkb3VibGViYXJ3ZWRnZVwiOlwiXFx1MjMwNlwiLFwiRG91YmxlQ29udG91ckludGVncmFsXCI6XCJcXHUyMjJGXCIsXCJEb3VibGVEb3RcIjpcIlxceEE4XCIsXCJEb3VibGVEb3duQXJyb3dcIjpcIlxcdTIxRDNcIixcIkRvdWJsZUxlZnRBcnJvd1wiOlwiXFx1MjFEMFwiLFwiRG91YmxlTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTIxRDRcIixcIkRvdWJsZUxlZnRUZWVcIjpcIlxcdTJBRTRcIixcIkRvdWJsZUxvbmdMZWZ0QXJyb3dcIjpcIlxcdTI3RjhcIixcIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjdGQVwiLFwiRG91YmxlTG9uZ1JpZ2h0QXJyb3dcIjpcIlxcdTI3RjlcIixcIkRvdWJsZVJpZ2h0QXJyb3dcIjpcIlxcdTIxRDJcIixcIkRvdWJsZVJpZ2h0VGVlXCI6XCJcXHUyMkE4XCIsXCJEb3VibGVVcEFycm93XCI6XCJcXHUyMUQxXCIsXCJEb3VibGVVcERvd25BcnJvd1wiOlwiXFx1MjFENVwiLFwiRG91YmxlVmVydGljYWxCYXJcIjpcIlxcdTIyMjVcIixcIkRvd25BcnJvd0JhclwiOlwiXFx1MjkxM1wiLFwiZG93bmFycm93XCI6XCJcXHUyMTkzXCIsXCJEb3duQXJyb3dcIjpcIlxcdTIxOTNcIixcIkRvd25hcnJvd1wiOlwiXFx1MjFEM1wiLFwiRG93bkFycm93VXBBcnJvd1wiOlwiXFx1MjFGNVwiLFwiRG93bkJyZXZlXCI6XCJcXHUwMzExXCIsXCJkb3duZG93bmFycm93c1wiOlwiXFx1MjFDQVwiLFwiZG93bmhhcnBvb25sZWZ0XCI6XCJcXHUyMUMzXCIsXCJkb3duaGFycG9vbnJpZ2h0XCI6XCJcXHUyMUMyXCIsXCJEb3duTGVmdFJpZ2h0VmVjdG9yXCI6XCJcXHUyOTUwXCIsXCJEb3duTGVmdFRlZVZlY3RvclwiOlwiXFx1Mjk1RVwiLFwiRG93bkxlZnRWZWN0b3JCYXJcIjpcIlxcdTI5NTZcIixcIkRvd25MZWZ0VmVjdG9yXCI6XCJcXHUyMUJEXCIsXCJEb3duUmlnaHRUZWVWZWN0b3JcIjpcIlxcdTI5NUZcIixcIkRvd25SaWdodFZlY3RvckJhclwiOlwiXFx1Mjk1N1wiLFwiRG93blJpZ2h0VmVjdG9yXCI6XCJcXHUyMUMxXCIsXCJEb3duVGVlQXJyb3dcIjpcIlxcdTIxQTdcIixcIkRvd25UZWVcIjpcIlxcdTIyQTRcIixcImRyYmthcm93XCI6XCJcXHUyOTEwXCIsXCJkcmNvcm5cIjpcIlxcdTIzMUZcIixcImRyY3JvcFwiOlwiXFx1MjMwQ1wiLFwiRHNjclwiOlwiXFx1RDgzNVxcdURDOUZcIixcImRzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I5XCIsXCJEU2N5XCI6XCJcXHUwNDA1XCIsXCJkc2N5XCI6XCJcXHUwNDU1XCIsXCJkc29sXCI6XCJcXHUyOUY2XCIsXCJEc3Ryb2tcIjpcIlxcdTAxMTBcIixcImRzdHJva1wiOlwiXFx1MDExMVwiLFwiZHRkb3RcIjpcIlxcdTIyRjFcIixcImR0cmlcIjpcIlxcdTI1QkZcIixcImR0cmlmXCI6XCJcXHUyNUJFXCIsXCJkdWFyclwiOlwiXFx1MjFGNVwiLFwiZHVoYXJcIjpcIlxcdTI5NkZcIixcImR3YW5nbGVcIjpcIlxcdTI5QTZcIixcIkRaY3lcIjpcIlxcdTA0MEZcIixcImR6Y3lcIjpcIlxcdTA0NUZcIixcImR6aWdyYXJyXCI6XCJcXHUyN0ZGXCIsXCJFYWN1dGVcIjpcIlxceEM5XCIsXCJlYWN1dGVcIjpcIlxceEU5XCIsXCJlYXN0ZXJcIjpcIlxcdTJBNkVcIixcIkVjYXJvblwiOlwiXFx1MDExQVwiLFwiZWNhcm9uXCI6XCJcXHUwMTFCXCIsXCJFY2lyY1wiOlwiXFx4Q0FcIixcImVjaXJjXCI6XCJcXHhFQVwiLFwiZWNpclwiOlwiXFx1MjI1NlwiLFwiZWNvbG9uXCI6XCJcXHUyMjU1XCIsXCJFY3lcIjpcIlxcdTA0MkRcIixcImVjeVwiOlwiXFx1MDQ0RFwiLFwiZUREb3RcIjpcIlxcdTJBNzdcIixcIkVkb3RcIjpcIlxcdTAxMTZcIixcImVkb3RcIjpcIlxcdTAxMTdcIixcImVEb3RcIjpcIlxcdTIyNTFcIixcImVlXCI6XCJcXHUyMTQ3XCIsXCJlZkRvdFwiOlwiXFx1MjI1MlwiLFwiRWZyXCI6XCJcXHVEODM1XFx1REQwOFwiLFwiZWZyXCI6XCJcXHVEODM1XFx1REQyMlwiLFwiZWdcIjpcIlxcdTJBOUFcIixcIkVncmF2ZVwiOlwiXFx4QzhcIixcImVncmF2ZVwiOlwiXFx4RThcIixcImVnc1wiOlwiXFx1MkE5NlwiLFwiZWdzZG90XCI6XCJcXHUyQTk4XCIsXCJlbFwiOlwiXFx1MkE5OVwiLFwiRWxlbWVudFwiOlwiXFx1MjIwOFwiLFwiZWxpbnRlcnNcIjpcIlxcdTIzRTdcIixcImVsbFwiOlwiXFx1MjExM1wiLFwiZWxzXCI6XCJcXHUyQTk1XCIsXCJlbHNkb3RcIjpcIlxcdTJBOTdcIixcIkVtYWNyXCI6XCJcXHUwMTEyXCIsXCJlbWFjclwiOlwiXFx1MDExM1wiLFwiZW1wdHlcIjpcIlxcdTIyMDVcIixcImVtcHR5c2V0XCI6XCJcXHUyMjA1XCIsXCJFbXB0eVNtYWxsU3F1YXJlXCI6XCJcXHUyNUZCXCIsXCJlbXB0eXZcIjpcIlxcdTIyMDVcIixcIkVtcHR5VmVyeVNtYWxsU3F1YXJlXCI6XCJcXHUyNUFCXCIsXCJlbXNwMTNcIjpcIlxcdTIwMDRcIixcImVtc3AxNFwiOlwiXFx1MjAwNVwiLFwiZW1zcFwiOlwiXFx1MjAwM1wiLFwiRU5HXCI6XCJcXHUwMTRBXCIsXCJlbmdcIjpcIlxcdTAxNEJcIixcImVuc3BcIjpcIlxcdTIwMDJcIixcIkVvZ29uXCI6XCJcXHUwMTE4XCIsXCJlb2dvblwiOlwiXFx1MDExOVwiLFwiRW9wZlwiOlwiXFx1RDgzNVxcdUREM0NcIixcImVvcGZcIjpcIlxcdUQ4MzVcXHVERDU2XCIsXCJlcGFyXCI6XCJcXHUyMkQ1XCIsXCJlcGFyc2xcIjpcIlxcdTI5RTNcIixcImVwbHVzXCI6XCJcXHUyQTcxXCIsXCJlcHNpXCI6XCJcXHUwM0I1XCIsXCJFcHNpbG9uXCI6XCJcXHUwMzk1XCIsXCJlcHNpbG9uXCI6XCJcXHUwM0I1XCIsXCJlcHNpdlwiOlwiXFx1MDNGNVwiLFwiZXFjaXJjXCI6XCJcXHUyMjU2XCIsXCJlcWNvbG9uXCI6XCJcXHUyMjU1XCIsXCJlcXNpbVwiOlwiXFx1MjI0MlwiLFwiZXFzbGFudGd0clwiOlwiXFx1MkE5NlwiLFwiZXFzbGFudGxlc3NcIjpcIlxcdTJBOTVcIixcIkVxdWFsXCI6XCJcXHUyQTc1XCIsXCJlcXVhbHNcIjpcIj1cIixcIkVxdWFsVGlsZGVcIjpcIlxcdTIyNDJcIixcImVxdWVzdFwiOlwiXFx1MjI1RlwiLFwiRXF1aWxpYnJpdW1cIjpcIlxcdTIxQ0NcIixcImVxdWl2XCI6XCJcXHUyMjYxXCIsXCJlcXVpdkREXCI6XCJcXHUyQTc4XCIsXCJlcXZwYXJzbFwiOlwiXFx1MjlFNVwiLFwiZXJhcnJcIjpcIlxcdTI5NzFcIixcImVyRG90XCI6XCJcXHUyMjUzXCIsXCJlc2NyXCI6XCJcXHUyMTJGXCIsXCJFc2NyXCI6XCJcXHUyMTMwXCIsXCJlc2RvdFwiOlwiXFx1MjI1MFwiLFwiRXNpbVwiOlwiXFx1MkE3M1wiLFwiZXNpbVwiOlwiXFx1MjI0MlwiLFwiRXRhXCI6XCJcXHUwMzk3XCIsXCJldGFcIjpcIlxcdTAzQjdcIixcIkVUSFwiOlwiXFx4RDBcIixcImV0aFwiOlwiXFx4RjBcIixcIkV1bWxcIjpcIlxceENCXCIsXCJldW1sXCI6XCJcXHhFQlwiLFwiZXVyb1wiOlwiXFx1MjBBQ1wiLFwiZXhjbFwiOlwiIVwiLFwiZXhpc3RcIjpcIlxcdTIyMDNcIixcIkV4aXN0c1wiOlwiXFx1MjIwM1wiLFwiZXhwZWN0YXRpb25cIjpcIlxcdTIxMzBcIixcImV4cG9uZW50aWFsZVwiOlwiXFx1MjE0N1wiLFwiRXhwb25lbnRpYWxFXCI6XCJcXHUyMTQ3XCIsXCJmYWxsaW5nZG90c2VxXCI6XCJcXHUyMjUyXCIsXCJGY3lcIjpcIlxcdTA0MjRcIixcImZjeVwiOlwiXFx1MDQ0NFwiLFwiZmVtYWxlXCI6XCJcXHUyNjQwXCIsXCJmZmlsaWdcIjpcIlxcdUZCMDNcIixcImZmbGlnXCI6XCJcXHVGQjAwXCIsXCJmZmxsaWdcIjpcIlxcdUZCMDRcIixcIkZmclwiOlwiXFx1RDgzNVxcdUREMDlcIixcImZmclwiOlwiXFx1RDgzNVxcdUREMjNcIixcImZpbGlnXCI6XCJcXHVGQjAxXCIsXCJGaWxsZWRTbWFsbFNxdWFyZVwiOlwiXFx1MjVGQ1wiLFwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlXCI6XCJcXHUyNUFBXCIsXCJmamxpZ1wiOlwiZmpcIixcImZsYXRcIjpcIlxcdTI2NkRcIixcImZsbGlnXCI6XCJcXHVGQjAyXCIsXCJmbHRuc1wiOlwiXFx1MjVCMVwiLFwiZm5vZlwiOlwiXFx1MDE5MlwiLFwiRm9wZlwiOlwiXFx1RDgzNVxcdUREM0RcIixcImZvcGZcIjpcIlxcdUQ4MzVcXHVERDU3XCIsXCJmb3JhbGxcIjpcIlxcdTIyMDBcIixcIkZvckFsbFwiOlwiXFx1MjIwMFwiLFwiZm9ya1wiOlwiXFx1MjJENFwiLFwiZm9ya3ZcIjpcIlxcdTJBRDlcIixcIkZvdXJpZXJ0cmZcIjpcIlxcdTIxMzFcIixcImZwYXJ0aW50XCI6XCJcXHUyQTBEXCIsXCJmcmFjMTJcIjpcIlxceEJEXCIsXCJmcmFjMTNcIjpcIlxcdTIxNTNcIixcImZyYWMxNFwiOlwiXFx4QkNcIixcImZyYWMxNVwiOlwiXFx1MjE1NVwiLFwiZnJhYzE2XCI6XCJcXHUyMTU5XCIsXCJmcmFjMThcIjpcIlxcdTIxNUJcIixcImZyYWMyM1wiOlwiXFx1MjE1NFwiLFwiZnJhYzI1XCI6XCJcXHUyMTU2XCIsXCJmcmFjMzRcIjpcIlxceEJFXCIsXCJmcmFjMzVcIjpcIlxcdTIxNTdcIixcImZyYWMzOFwiOlwiXFx1MjE1Q1wiLFwiZnJhYzQ1XCI6XCJcXHUyMTU4XCIsXCJmcmFjNTZcIjpcIlxcdTIxNUFcIixcImZyYWM1OFwiOlwiXFx1MjE1RFwiLFwiZnJhYzc4XCI6XCJcXHUyMTVFXCIsXCJmcmFzbFwiOlwiXFx1MjA0NFwiLFwiZnJvd25cIjpcIlxcdTIzMjJcIixcImZzY3JcIjpcIlxcdUQ4MzVcXHVEQ0JCXCIsXCJGc2NyXCI6XCJcXHUyMTMxXCIsXCJnYWN1dGVcIjpcIlxcdTAxRjVcIixcIkdhbW1hXCI6XCJcXHUwMzkzXCIsXCJnYW1tYVwiOlwiXFx1MDNCM1wiLFwiR2FtbWFkXCI6XCJcXHUwM0RDXCIsXCJnYW1tYWRcIjpcIlxcdTAzRERcIixcImdhcFwiOlwiXFx1MkE4NlwiLFwiR2JyZXZlXCI6XCJcXHUwMTFFXCIsXCJnYnJldmVcIjpcIlxcdTAxMUZcIixcIkdjZWRpbFwiOlwiXFx1MDEyMlwiLFwiR2NpcmNcIjpcIlxcdTAxMUNcIixcImdjaXJjXCI6XCJcXHUwMTFEXCIsXCJHY3lcIjpcIlxcdTA0MTNcIixcImdjeVwiOlwiXFx1MDQzM1wiLFwiR2RvdFwiOlwiXFx1MDEyMFwiLFwiZ2RvdFwiOlwiXFx1MDEyMVwiLFwiZ2VcIjpcIlxcdTIyNjVcIixcImdFXCI6XCJcXHUyMjY3XCIsXCJnRWxcIjpcIlxcdTJBOENcIixcImdlbFwiOlwiXFx1MjJEQlwiLFwiZ2VxXCI6XCJcXHUyMjY1XCIsXCJnZXFxXCI6XCJcXHUyMjY3XCIsXCJnZXFzbGFudFwiOlwiXFx1MkE3RVwiLFwiZ2VzY2NcIjpcIlxcdTJBQTlcIixcImdlc1wiOlwiXFx1MkE3RVwiLFwiZ2VzZG90XCI6XCJcXHUyQTgwXCIsXCJnZXNkb3RvXCI6XCJcXHUyQTgyXCIsXCJnZXNkb3RvbFwiOlwiXFx1MkE4NFwiLFwiZ2VzbFwiOlwiXFx1MjJEQlxcdUZFMDBcIixcImdlc2xlc1wiOlwiXFx1MkE5NFwiLFwiR2ZyXCI6XCJcXHVEODM1XFx1REQwQVwiLFwiZ2ZyXCI6XCJcXHVEODM1XFx1REQyNFwiLFwiZ2dcIjpcIlxcdTIyNkJcIixcIkdnXCI6XCJcXHUyMkQ5XCIsXCJnZ2dcIjpcIlxcdTIyRDlcIixcImdpbWVsXCI6XCJcXHUyMTM3XCIsXCJHSmN5XCI6XCJcXHUwNDAzXCIsXCJnamN5XCI6XCJcXHUwNDUzXCIsXCJnbGFcIjpcIlxcdTJBQTVcIixcImdsXCI6XCJcXHUyMjc3XCIsXCJnbEVcIjpcIlxcdTJBOTJcIixcImdsalwiOlwiXFx1MkFBNFwiLFwiZ25hcFwiOlwiXFx1MkE4QVwiLFwiZ25hcHByb3hcIjpcIlxcdTJBOEFcIixcImduZVwiOlwiXFx1MkE4OFwiLFwiZ25FXCI6XCJcXHUyMjY5XCIsXCJnbmVxXCI6XCJcXHUyQTg4XCIsXCJnbmVxcVwiOlwiXFx1MjI2OVwiLFwiZ25zaW1cIjpcIlxcdTIyRTdcIixcIkdvcGZcIjpcIlxcdUQ4MzVcXHVERDNFXCIsXCJnb3BmXCI6XCJcXHVEODM1XFx1REQ1OFwiLFwiZ3JhdmVcIjpcImBcIixcIkdyZWF0ZXJFcXVhbFwiOlwiXFx1MjI2NVwiLFwiR3JlYXRlckVxdWFsTGVzc1wiOlwiXFx1MjJEQlwiLFwiR3JlYXRlckZ1bGxFcXVhbFwiOlwiXFx1MjI2N1wiLFwiR3JlYXRlckdyZWF0ZXJcIjpcIlxcdTJBQTJcIixcIkdyZWF0ZXJMZXNzXCI6XCJcXHUyMjc3XCIsXCJHcmVhdGVyU2xhbnRFcXVhbFwiOlwiXFx1MkE3RVwiLFwiR3JlYXRlclRpbGRlXCI6XCJcXHUyMjczXCIsXCJHc2NyXCI6XCJcXHVEODM1XFx1RENBMlwiLFwiZ3NjclwiOlwiXFx1MjEwQVwiLFwiZ3NpbVwiOlwiXFx1MjI3M1wiLFwiZ3NpbWVcIjpcIlxcdTJBOEVcIixcImdzaW1sXCI6XCJcXHUyQTkwXCIsXCJndGNjXCI6XCJcXHUyQUE3XCIsXCJndGNpclwiOlwiXFx1MkE3QVwiLFwiZ3RcIjpcIj5cIixcIkdUXCI6XCI+XCIsXCJHdFwiOlwiXFx1MjI2QlwiLFwiZ3Rkb3RcIjpcIlxcdTIyRDdcIixcImd0bFBhclwiOlwiXFx1Mjk5NVwiLFwiZ3RxdWVzdFwiOlwiXFx1MkE3Q1wiLFwiZ3RyYXBwcm94XCI6XCJcXHUyQTg2XCIsXCJndHJhcnJcIjpcIlxcdTI5NzhcIixcImd0cmRvdFwiOlwiXFx1MjJEN1wiLFwiZ3RyZXFsZXNzXCI6XCJcXHUyMkRCXCIsXCJndHJlcXFsZXNzXCI6XCJcXHUyQThDXCIsXCJndHJsZXNzXCI6XCJcXHUyMjc3XCIsXCJndHJzaW1cIjpcIlxcdTIyNzNcIixcImd2ZXJ0bmVxcVwiOlwiXFx1MjI2OVxcdUZFMDBcIixcImd2bkVcIjpcIlxcdTIyNjlcXHVGRTAwXCIsXCJIYWNla1wiOlwiXFx1MDJDN1wiLFwiaGFpcnNwXCI6XCJcXHUyMDBBXCIsXCJoYWxmXCI6XCJcXHhCRFwiLFwiaGFtaWx0XCI6XCJcXHUyMTBCXCIsXCJIQVJEY3lcIjpcIlxcdTA0MkFcIixcImhhcmRjeVwiOlwiXFx1MDQ0QVwiLFwiaGFycmNpclwiOlwiXFx1Mjk0OFwiLFwiaGFyclwiOlwiXFx1MjE5NFwiLFwiaEFyclwiOlwiXFx1MjFENFwiLFwiaGFycndcIjpcIlxcdTIxQURcIixcIkhhdFwiOlwiXlwiLFwiaGJhclwiOlwiXFx1MjEwRlwiLFwiSGNpcmNcIjpcIlxcdTAxMjRcIixcImhjaXJjXCI6XCJcXHUwMTI1XCIsXCJoZWFydHNcIjpcIlxcdTI2NjVcIixcImhlYXJ0c3VpdFwiOlwiXFx1MjY2NVwiLFwiaGVsbGlwXCI6XCJcXHUyMDI2XCIsXCJoZXJjb25cIjpcIlxcdTIyQjlcIixcImhmclwiOlwiXFx1RDgzNVxcdUREMjVcIixcIkhmclwiOlwiXFx1MjEwQ1wiLFwiSGlsYmVydFNwYWNlXCI6XCJcXHUyMTBCXCIsXCJoa3NlYXJvd1wiOlwiXFx1MjkyNVwiLFwiaGtzd2Fyb3dcIjpcIlxcdTI5MjZcIixcImhvYXJyXCI6XCJcXHUyMUZGXCIsXCJob210aHRcIjpcIlxcdTIyM0JcIixcImhvb2tsZWZ0YXJyb3dcIjpcIlxcdTIxQTlcIixcImhvb2tyaWdodGFycm93XCI6XCJcXHUyMUFBXCIsXCJob3BmXCI6XCJcXHVEODM1XFx1REQ1OVwiLFwiSG9wZlwiOlwiXFx1MjEwRFwiLFwiaG9yYmFyXCI6XCJcXHUyMDE1XCIsXCJIb3Jpem9udGFsTGluZVwiOlwiXFx1MjUwMFwiLFwiaHNjclwiOlwiXFx1RDgzNVxcdURDQkRcIixcIkhzY3JcIjpcIlxcdTIxMEJcIixcImhzbGFzaFwiOlwiXFx1MjEwRlwiLFwiSHN0cm9rXCI6XCJcXHUwMTI2XCIsXCJoc3Ryb2tcIjpcIlxcdTAxMjdcIixcIkh1bXBEb3duSHVtcFwiOlwiXFx1MjI0RVwiLFwiSHVtcEVxdWFsXCI6XCJcXHUyMjRGXCIsXCJoeWJ1bGxcIjpcIlxcdTIwNDNcIixcImh5cGhlblwiOlwiXFx1MjAxMFwiLFwiSWFjdXRlXCI6XCJcXHhDRFwiLFwiaWFjdXRlXCI6XCJcXHhFRFwiLFwiaWNcIjpcIlxcdTIwNjNcIixcIkljaXJjXCI6XCJcXHhDRVwiLFwiaWNpcmNcIjpcIlxceEVFXCIsXCJJY3lcIjpcIlxcdTA0MThcIixcImljeVwiOlwiXFx1MDQzOFwiLFwiSWRvdFwiOlwiXFx1MDEzMFwiLFwiSUVjeVwiOlwiXFx1MDQxNVwiLFwiaWVjeVwiOlwiXFx1MDQzNVwiLFwiaWV4Y2xcIjpcIlxceEExXCIsXCJpZmZcIjpcIlxcdTIxRDRcIixcImlmclwiOlwiXFx1RDgzNVxcdUREMjZcIixcIklmclwiOlwiXFx1MjExMVwiLFwiSWdyYXZlXCI6XCJcXHhDQ1wiLFwiaWdyYXZlXCI6XCJcXHhFQ1wiLFwiaWlcIjpcIlxcdTIxNDhcIixcImlpaWludFwiOlwiXFx1MkEwQ1wiLFwiaWlpbnRcIjpcIlxcdTIyMkRcIixcImlpbmZpblwiOlwiXFx1MjlEQ1wiLFwiaWlvdGFcIjpcIlxcdTIxMjlcIixcIklKbGlnXCI6XCJcXHUwMTMyXCIsXCJpamxpZ1wiOlwiXFx1MDEzM1wiLFwiSW1hY3JcIjpcIlxcdTAxMkFcIixcImltYWNyXCI6XCJcXHUwMTJCXCIsXCJpbWFnZVwiOlwiXFx1MjExMVwiLFwiSW1hZ2luYXJ5SVwiOlwiXFx1MjE0OFwiLFwiaW1hZ2xpbmVcIjpcIlxcdTIxMTBcIixcImltYWdwYXJ0XCI6XCJcXHUyMTExXCIsXCJpbWF0aFwiOlwiXFx1MDEzMVwiLFwiSW1cIjpcIlxcdTIxMTFcIixcImltb2ZcIjpcIlxcdTIyQjdcIixcImltcGVkXCI6XCJcXHUwMUI1XCIsXCJJbXBsaWVzXCI6XCJcXHUyMUQyXCIsXCJpbmNhcmVcIjpcIlxcdTIxMDVcIixcImluXCI6XCJcXHUyMjA4XCIsXCJpbmZpblwiOlwiXFx1MjIxRVwiLFwiaW5maW50aWVcIjpcIlxcdTI5RERcIixcImlub2RvdFwiOlwiXFx1MDEzMVwiLFwiaW50Y2FsXCI6XCJcXHUyMkJBXCIsXCJpbnRcIjpcIlxcdTIyMkJcIixcIkludFwiOlwiXFx1MjIyQ1wiLFwiaW50ZWdlcnNcIjpcIlxcdTIxMjRcIixcIkludGVncmFsXCI6XCJcXHUyMjJCXCIsXCJpbnRlcmNhbFwiOlwiXFx1MjJCQVwiLFwiSW50ZXJzZWN0aW9uXCI6XCJcXHUyMkMyXCIsXCJpbnRsYXJoa1wiOlwiXFx1MkExN1wiLFwiaW50cHJvZFwiOlwiXFx1MkEzQ1wiLFwiSW52aXNpYmxlQ29tbWFcIjpcIlxcdTIwNjNcIixcIkludmlzaWJsZVRpbWVzXCI6XCJcXHUyMDYyXCIsXCJJT2N5XCI6XCJcXHUwNDAxXCIsXCJpb2N5XCI6XCJcXHUwNDUxXCIsXCJJb2dvblwiOlwiXFx1MDEyRVwiLFwiaW9nb25cIjpcIlxcdTAxMkZcIixcIklvcGZcIjpcIlxcdUQ4MzVcXHVERDQwXCIsXCJpb3BmXCI6XCJcXHVEODM1XFx1REQ1QVwiLFwiSW90YVwiOlwiXFx1MDM5OVwiLFwiaW90YVwiOlwiXFx1MDNCOVwiLFwiaXByb2RcIjpcIlxcdTJBM0NcIixcImlxdWVzdFwiOlwiXFx4QkZcIixcImlzY3JcIjpcIlxcdUQ4MzVcXHVEQ0JFXCIsXCJJc2NyXCI6XCJcXHUyMTEwXCIsXCJpc2luXCI6XCJcXHUyMjA4XCIsXCJpc2luZG90XCI6XCJcXHUyMkY1XCIsXCJpc2luRVwiOlwiXFx1MjJGOVwiLFwiaXNpbnNcIjpcIlxcdTIyRjRcIixcImlzaW5zdlwiOlwiXFx1MjJGM1wiLFwiaXNpbnZcIjpcIlxcdTIyMDhcIixcIml0XCI6XCJcXHUyMDYyXCIsXCJJdGlsZGVcIjpcIlxcdTAxMjhcIixcIml0aWxkZVwiOlwiXFx1MDEyOVwiLFwiSXVrY3lcIjpcIlxcdTA0MDZcIixcIml1a2N5XCI6XCJcXHUwNDU2XCIsXCJJdW1sXCI6XCJcXHhDRlwiLFwiaXVtbFwiOlwiXFx4RUZcIixcIkpjaXJjXCI6XCJcXHUwMTM0XCIsXCJqY2lyY1wiOlwiXFx1MDEzNVwiLFwiSmN5XCI6XCJcXHUwNDE5XCIsXCJqY3lcIjpcIlxcdTA0MzlcIixcIkpmclwiOlwiXFx1RDgzNVxcdUREMERcIixcImpmclwiOlwiXFx1RDgzNVxcdUREMjdcIixcImptYXRoXCI6XCJcXHUwMjM3XCIsXCJKb3BmXCI6XCJcXHVEODM1XFx1REQ0MVwiLFwiam9wZlwiOlwiXFx1RDgzNVxcdURENUJcIixcIkpzY3JcIjpcIlxcdUQ4MzVcXHVEQ0E1XCIsXCJqc2NyXCI6XCJcXHVEODM1XFx1RENCRlwiLFwiSnNlcmN5XCI6XCJcXHUwNDA4XCIsXCJqc2VyY3lcIjpcIlxcdTA0NThcIixcIkp1a2N5XCI6XCJcXHUwNDA0XCIsXCJqdWtjeVwiOlwiXFx1MDQ1NFwiLFwiS2FwcGFcIjpcIlxcdTAzOUFcIixcImthcHBhXCI6XCJcXHUwM0JBXCIsXCJrYXBwYXZcIjpcIlxcdTAzRjBcIixcIktjZWRpbFwiOlwiXFx1MDEzNlwiLFwia2NlZGlsXCI6XCJcXHUwMTM3XCIsXCJLY3lcIjpcIlxcdTA0MUFcIixcImtjeVwiOlwiXFx1MDQzQVwiLFwiS2ZyXCI6XCJcXHVEODM1XFx1REQwRVwiLFwia2ZyXCI6XCJcXHVEODM1XFx1REQyOFwiLFwia2dyZWVuXCI6XCJcXHUwMTM4XCIsXCJLSGN5XCI6XCJcXHUwNDI1XCIsXCJraGN5XCI6XCJcXHUwNDQ1XCIsXCJLSmN5XCI6XCJcXHUwNDBDXCIsXCJramN5XCI6XCJcXHUwNDVDXCIsXCJLb3BmXCI6XCJcXHVEODM1XFx1REQ0MlwiLFwia29wZlwiOlwiXFx1RDgzNVxcdURENUNcIixcIktzY3JcIjpcIlxcdUQ4MzVcXHVEQ0E2XCIsXCJrc2NyXCI6XCJcXHVEODM1XFx1RENDMFwiLFwibEFhcnJcIjpcIlxcdTIxREFcIixcIkxhY3V0ZVwiOlwiXFx1MDEzOVwiLFwibGFjdXRlXCI6XCJcXHUwMTNBXCIsXCJsYWVtcHR5dlwiOlwiXFx1MjlCNFwiLFwibGFncmFuXCI6XCJcXHUyMTEyXCIsXCJMYW1iZGFcIjpcIlxcdTAzOUJcIixcImxhbWJkYVwiOlwiXFx1MDNCQlwiLFwibGFuZ1wiOlwiXFx1MjdFOFwiLFwiTGFuZ1wiOlwiXFx1MjdFQVwiLFwibGFuZ2RcIjpcIlxcdTI5OTFcIixcImxhbmdsZVwiOlwiXFx1MjdFOFwiLFwibGFwXCI6XCJcXHUyQTg1XCIsXCJMYXBsYWNldHJmXCI6XCJcXHUyMTEyXCIsXCJsYXF1b1wiOlwiXFx4QUJcIixcImxhcnJiXCI6XCJcXHUyMUU0XCIsXCJsYXJyYmZzXCI6XCJcXHUyOTFGXCIsXCJsYXJyXCI6XCJcXHUyMTkwXCIsXCJMYXJyXCI6XCJcXHUyMTlFXCIsXCJsQXJyXCI6XCJcXHUyMUQwXCIsXCJsYXJyZnNcIjpcIlxcdTI5MURcIixcImxhcnJoa1wiOlwiXFx1MjFBOVwiLFwibGFycmxwXCI6XCJcXHUyMUFCXCIsXCJsYXJycGxcIjpcIlxcdTI5MzlcIixcImxhcnJzaW1cIjpcIlxcdTI5NzNcIixcImxhcnJ0bFwiOlwiXFx1MjFBMlwiLFwibGF0YWlsXCI6XCJcXHUyOTE5XCIsXCJsQXRhaWxcIjpcIlxcdTI5MUJcIixcImxhdFwiOlwiXFx1MkFBQlwiLFwibGF0ZVwiOlwiXFx1MkFBRFwiLFwibGF0ZXNcIjpcIlxcdTJBQURcXHVGRTAwXCIsXCJsYmFyclwiOlwiXFx1MjkwQ1wiLFwibEJhcnJcIjpcIlxcdTI5MEVcIixcImxiYnJrXCI6XCJcXHUyNzcyXCIsXCJsYnJhY2VcIjpcIntcIixcImxicmFja1wiOlwiW1wiLFwibGJya2VcIjpcIlxcdTI5OEJcIixcImxicmtzbGRcIjpcIlxcdTI5OEZcIixcImxicmtzbHVcIjpcIlxcdTI5OERcIixcIkxjYXJvblwiOlwiXFx1MDEzRFwiLFwibGNhcm9uXCI6XCJcXHUwMTNFXCIsXCJMY2VkaWxcIjpcIlxcdTAxM0JcIixcImxjZWRpbFwiOlwiXFx1MDEzQ1wiLFwibGNlaWxcIjpcIlxcdTIzMDhcIixcImxjdWJcIjpcIntcIixcIkxjeVwiOlwiXFx1MDQxQlwiLFwibGN5XCI6XCJcXHUwNDNCXCIsXCJsZGNhXCI6XCJcXHUyOTM2XCIsXCJsZHF1b1wiOlwiXFx1MjAxQ1wiLFwibGRxdW9yXCI6XCJcXHUyMDFFXCIsXCJsZHJkaGFyXCI6XCJcXHUyOTY3XCIsXCJsZHJ1c2hhclwiOlwiXFx1Mjk0QlwiLFwibGRzaFwiOlwiXFx1MjFCMlwiLFwibGVcIjpcIlxcdTIyNjRcIixcImxFXCI6XCJcXHUyMjY2XCIsXCJMZWZ0QW5nbGVCcmFja2V0XCI6XCJcXHUyN0U4XCIsXCJMZWZ0QXJyb3dCYXJcIjpcIlxcdTIxRTRcIixcImxlZnRhcnJvd1wiOlwiXFx1MjE5MFwiLFwiTGVmdEFycm93XCI6XCJcXHUyMTkwXCIsXCJMZWZ0YXJyb3dcIjpcIlxcdTIxRDBcIixcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjpcIlxcdTIxQzZcIixcImxlZnRhcnJvd3RhaWxcIjpcIlxcdTIxQTJcIixcIkxlZnRDZWlsaW5nXCI6XCJcXHUyMzA4XCIsXCJMZWZ0RG91YmxlQnJhY2tldFwiOlwiXFx1MjdFNlwiLFwiTGVmdERvd25UZWVWZWN0b3JcIjpcIlxcdTI5NjFcIixcIkxlZnREb3duVmVjdG9yQmFyXCI6XCJcXHUyOTU5XCIsXCJMZWZ0RG93blZlY3RvclwiOlwiXFx1MjFDM1wiLFwiTGVmdEZsb29yXCI6XCJcXHUyMzBBXCIsXCJsZWZ0aGFycG9vbmRvd25cIjpcIlxcdTIxQkRcIixcImxlZnRoYXJwb29udXBcIjpcIlxcdTIxQkNcIixcImxlZnRsZWZ0YXJyb3dzXCI6XCJcXHUyMUM3XCIsXCJsZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjE5NFwiLFwiTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTIxOTRcIixcIkxlZnRyaWdodGFycm93XCI6XCJcXHUyMUQ0XCIsXCJsZWZ0cmlnaHRhcnJvd3NcIjpcIlxcdTIxQzZcIixcImxlZnRyaWdodGhhcnBvb25zXCI6XCJcXHUyMUNCXCIsXCJsZWZ0cmlnaHRzcXVpZ2Fycm93XCI6XCJcXHUyMUFEXCIsXCJMZWZ0UmlnaHRWZWN0b3JcIjpcIlxcdTI5NEVcIixcIkxlZnRUZWVBcnJvd1wiOlwiXFx1MjFBNFwiLFwiTGVmdFRlZVwiOlwiXFx1MjJBM1wiLFwiTGVmdFRlZVZlY3RvclwiOlwiXFx1Mjk1QVwiLFwibGVmdHRocmVldGltZXNcIjpcIlxcdTIyQ0JcIixcIkxlZnRUcmlhbmdsZUJhclwiOlwiXFx1MjlDRlwiLFwiTGVmdFRyaWFuZ2xlXCI6XCJcXHUyMkIyXCIsXCJMZWZ0VHJpYW5nbGVFcXVhbFwiOlwiXFx1MjJCNFwiLFwiTGVmdFVwRG93blZlY3RvclwiOlwiXFx1Mjk1MVwiLFwiTGVmdFVwVGVlVmVjdG9yXCI6XCJcXHUyOTYwXCIsXCJMZWZ0VXBWZWN0b3JCYXJcIjpcIlxcdTI5NThcIixcIkxlZnRVcFZlY3RvclwiOlwiXFx1MjFCRlwiLFwiTGVmdFZlY3RvckJhclwiOlwiXFx1Mjk1MlwiLFwiTGVmdFZlY3RvclwiOlwiXFx1MjFCQ1wiLFwibEVnXCI6XCJcXHUyQThCXCIsXCJsZWdcIjpcIlxcdTIyREFcIixcImxlcVwiOlwiXFx1MjI2NFwiLFwibGVxcVwiOlwiXFx1MjI2NlwiLFwibGVxc2xhbnRcIjpcIlxcdTJBN0RcIixcImxlc2NjXCI6XCJcXHUyQUE4XCIsXCJsZXNcIjpcIlxcdTJBN0RcIixcImxlc2RvdFwiOlwiXFx1MkE3RlwiLFwibGVzZG90b1wiOlwiXFx1MkE4MVwiLFwibGVzZG90b3JcIjpcIlxcdTJBODNcIixcImxlc2dcIjpcIlxcdTIyREFcXHVGRTAwXCIsXCJsZXNnZXNcIjpcIlxcdTJBOTNcIixcImxlc3NhcHByb3hcIjpcIlxcdTJBODVcIixcImxlc3Nkb3RcIjpcIlxcdTIyRDZcIixcImxlc3NlcWd0clwiOlwiXFx1MjJEQVwiLFwibGVzc2VxcWd0clwiOlwiXFx1MkE4QlwiLFwiTGVzc0VxdWFsR3JlYXRlclwiOlwiXFx1MjJEQVwiLFwiTGVzc0Z1bGxFcXVhbFwiOlwiXFx1MjI2NlwiLFwiTGVzc0dyZWF0ZXJcIjpcIlxcdTIyNzZcIixcImxlc3NndHJcIjpcIlxcdTIyNzZcIixcIkxlc3NMZXNzXCI6XCJcXHUyQUExXCIsXCJsZXNzc2ltXCI6XCJcXHUyMjcyXCIsXCJMZXNzU2xhbnRFcXVhbFwiOlwiXFx1MkE3RFwiLFwiTGVzc1RpbGRlXCI6XCJcXHUyMjcyXCIsXCJsZmlzaHRcIjpcIlxcdTI5N0NcIixcImxmbG9vclwiOlwiXFx1MjMwQVwiLFwiTGZyXCI6XCJcXHVEODM1XFx1REQwRlwiLFwibGZyXCI6XCJcXHVEODM1XFx1REQyOVwiLFwibGdcIjpcIlxcdTIyNzZcIixcImxnRVwiOlwiXFx1MkE5MVwiLFwibEhhclwiOlwiXFx1Mjk2MlwiLFwibGhhcmRcIjpcIlxcdTIxQkRcIixcImxoYXJ1XCI6XCJcXHUyMUJDXCIsXCJsaGFydWxcIjpcIlxcdTI5NkFcIixcImxoYmxrXCI6XCJcXHUyNTg0XCIsXCJMSmN5XCI6XCJcXHUwNDA5XCIsXCJsamN5XCI6XCJcXHUwNDU5XCIsXCJsbGFyclwiOlwiXFx1MjFDN1wiLFwibGxcIjpcIlxcdTIyNkFcIixcIkxsXCI6XCJcXHUyMkQ4XCIsXCJsbGNvcm5lclwiOlwiXFx1MjMxRVwiLFwiTGxlZnRhcnJvd1wiOlwiXFx1MjFEQVwiLFwibGxoYXJkXCI6XCJcXHUyOTZCXCIsXCJsbHRyaVwiOlwiXFx1MjVGQVwiLFwiTG1pZG90XCI6XCJcXHUwMTNGXCIsXCJsbWlkb3RcIjpcIlxcdTAxNDBcIixcImxtb3VzdGFjaGVcIjpcIlxcdTIzQjBcIixcImxtb3VzdFwiOlwiXFx1MjNCMFwiLFwibG5hcFwiOlwiXFx1MkE4OVwiLFwibG5hcHByb3hcIjpcIlxcdTJBODlcIixcImxuZVwiOlwiXFx1MkE4N1wiLFwibG5FXCI6XCJcXHUyMjY4XCIsXCJsbmVxXCI6XCJcXHUyQTg3XCIsXCJsbmVxcVwiOlwiXFx1MjI2OFwiLFwibG5zaW1cIjpcIlxcdTIyRTZcIixcImxvYW5nXCI6XCJcXHUyN0VDXCIsXCJsb2FyclwiOlwiXFx1MjFGRFwiLFwibG9icmtcIjpcIlxcdTI3RTZcIixcImxvbmdsZWZ0YXJyb3dcIjpcIlxcdTI3RjVcIixcIkxvbmdMZWZ0QXJyb3dcIjpcIlxcdTI3RjVcIixcIkxvbmdsZWZ0YXJyb3dcIjpcIlxcdTI3RjhcIixcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjdGN1wiLFwiTG9uZ0xlZnRSaWdodEFycm93XCI6XCJcXHUyN0Y3XCIsXCJMb25nbGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTI3RkFcIixcImxvbmdtYXBzdG9cIjpcIlxcdTI3RkNcIixcImxvbmdyaWdodGFycm93XCI6XCJcXHUyN0Y2XCIsXCJMb25nUmlnaHRBcnJvd1wiOlwiXFx1MjdGNlwiLFwiTG9uZ3JpZ2h0YXJyb3dcIjpcIlxcdTI3RjlcIixcImxvb3BhcnJvd2xlZnRcIjpcIlxcdTIxQUJcIixcImxvb3BhcnJvd3JpZ2h0XCI6XCJcXHUyMUFDXCIsXCJsb3BhclwiOlwiXFx1Mjk4NVwiLFwiTG9wZlwiOlwiXFx1RDgzNVxcdURENDNcIixcImxvcGZcIjpcIlxcdUQ4MzVcXHVERDVEXCIsXCJsb3BsdXNcIjpcIlxcdTJBMkRcIixcImxvdGltZXNcIjpcIlxcdTJBMzRcIixcImxvd2FzdFwiOlwiXFx1MjIxN1wiLFwibG93YmFyXCI6XCJfXCIsXCJMb3dlckxlZnRBcnJvd1wiOlwiXFx1MjE5OVwiLFwiTG93ZXJSaWdodEFycm93XCI6XCJcXHUyMTk4XCIsXCJsb3pcIjpcIlxcdTI1Q0FcIixcImxvemVuZ2VcIjpcIlxcdTI1Q0FcIixcImxvemZcIjpcIlxcdTI5RUJcIixcImxwYXJcIjpcIihcIixcImxwYXJsdFwiOlwiXFx1Mjk5M1wiLFwibHJhcnJcIjpcIlxcdTIxQzZcIixcImxyY29ybmVyXCI6XCJcXHUyMzFGXCIsXCJscmhhclwiOlwiXFx1MjFDQlwiLFwibHJoYXJkXCI6XCJcXHUyOTZEXCIsXCJscm1cIjpcIlxcdTIwMEVcIixcImxydHJpXCI6XCJcXHUyMkJGXCIsXCJsc2FxdW9cIjpcIlxcdTIwMzlcIixcImxzY3JcIjpcIlxcdUQ4MzVcXHVEQ0MxXCIsXCJMc2NyXCI6XCJcXHUyMTEyXCIsXCJsc2hcIjpcIlxcdTIxQjBcIixcIkxzaFwiOlwiXFx1MjFCMFwiLFwibHNpbVwiOlwiXFx1MjI3MlwiLFwibHNpbWVcIjpcIlxcdTJBOERcIixcImxzaW1nXCI6XCJcXHUyQThGXCIsXCJsc3FiXCI6XCJbXCIsXCJsc3F1b1wiOlwiXFx1MjAxOFwiLFwibHNxdW9yXCI6XCJcXHUyMDFBXCIsXCJMc3Ryb2tcIjpcIlxcdTAxNDFcIixcImxzdHJva1wiOlwiXFx1MDE0MlwiLFwibHRjY1wiOlwiXFx1MkFBNlwiLFwibHRjaXJcIjpcIlxcdTJBNzlcIixcImx0XCI6XCI8XCIsXCJMVFwiOlwiPFwiLFwiTHRcIjpcIlxcdTIyNkFcIixcImx0ZG90XCI6XCJcXHUyMkQ2XCIsXCJsdGhyZWVcIjpcIlxcdTIyQ0JcIixcImx0aW1lc1wiOlwiXFx1MjJDOVwiLFwibHRsYXJyXCI6XCJcXHUyOTc2XCIsXCJsdHF1ZXN0XCI6XCJcXHUyQTdCXCIsXCJsdHJpXCI6XCJcXHUyNUMzXCIsXCJsdHJpZVwiOlwiXFx1MjJCNFwiLFwibHRyaWZcIjpcIlxcdTI1QzJcIixcImx0clBhclwiOlwiXFx1Mjk5NlwiLFwibHVyZHNoYXJcIjpcIlxcdTI5NEFcIixcImx1cnVoYXJcIjpcIlxcdTI5NjZcIixcImx2ZXJ0bmVxcVwiOlwiXFx1MjI2OFxcdUZFMDBcIixcImx2bkVcIjpcIlxcdTIyNjhcXHVGRTAwXCIsXCJtYWNyXCI6XCJcXHhBRlwiLFwibWFsZVwiOlwiXFx1MjY0MlwiLFwibWFsdFwiOlwiXFx1MjcyMFwiLFwibWFsdGVzZVwiOlwiXFx1MjcyMFwiLFwiTWFwXCI6XCJcXHUyOTA1XCIsXCJtYXBcIjpcIlxcdTIxQTZcIixcIm1hcHN0b1wiOlwiXFx1MjFBNlwiLFwibWFwc3RvZG93blwiOlwiXFx1MjFBN1wiLFwibWFwc3RvbGVmdFwiOlwiXFx1MjFBNFwiLFwibWFwc3RvdXBcIjpcIlxcdTIxQTVcIixcIm1hcmtlclwiOlwiXFx1MjVBRVwiLFwibWNvbW1hXCI6XCJcXHUyQTI5XCIsXCJNY3lcIjpcIlxcdTA0MUNcIixcIm1jeVwiOlwiXFx1MDQzQ1wiLFwibWRhc2hcIjpcIlxcdTIwMTRcIixcIm1ERG90XCI6XCJcXHUyMjNBXCIsXCJtZWFzdXJlZGFuZ2xlXCI6XCJcXHUyMjIxXCIsXCJNZWRpdW1TcGFjZVwiOlwiXFx1MjA1RlwiLFwiTWVsbGludHJmXCI6XCJcXHUyMTMzXCIsXCJNZnJcIjpcIlxcdUQ4MzVcXHVERDEwXCIsXCJtZnJcIjpcIlxcdUQ4MzVcXHVERDJBXCIsXCJtaG9cIjpcIlxcdTIxMjdcIixcIm1pY3JvXCI6XCJcXHhCNVwiLFwibWlkYXN0XCI6XCIqXCIsXCJtaWRjaXJcIjpcIlxcdTJBRjBcIixcIm1pZFwiOlwiXFx1MjIyM1wiLFwibWlkZG90XCI6XCJcXHhCN1wiLFwibWludXNiXCI6XCJcXHUyMjlGXCIsXCJtaW51c1wiOlwiXFx1MjIxMlwiLFwibWludXNkXCI6XCJcXHUyMjM4XCIsXCJtaW51c2R1XCI6XCJcXHUyQTJBXCIsXCJNaW51c1BsdXNcIjpcIlxcdTIyMTNcIixcIm1sY3BcIjpcIlxcdTJBREJcIixcIm1sZHJcIjpcIlxcdTIwMjZcIixcIm1ucGx1c1wiOlwiXFx1MjIxM1wiLFwibW9kZWxzXCI6XCJcXHUyMkE3XCIsXCJNb3BmXCI6XCJcXHVEODM1XFx1REQ0NFwiLFwibW9wZlwiOlwiXFx1RDgzNVxcdURENUVcIixcIm1wXCI6XCJcXHUyMjEzXCIsXCJtc2NyXCI6XCJcXHVEODM1XFx1RENDMlwiLFwiTXNjclwiOlwiXFx1MjEzM1wiLFwibXN0cG9zXCI6XCJcXHUyMjNFXCIsXCJNdVwiOlwiXFx1MDM5Q1wiLFwibXVcIjpcIlxcdTAzQkNcIixcIm11bHRpbWFwXCI6XCJcXHUyMkI4XCIsXCJtdW1hcFwiOlwiXFx1MjJCOFwiLFwibmFibGFcIjpcIlxcdTIyMDdcIixcIk5hY3V0ZVwiOlwiXFx1MDE0M1wiLFwibmFjdXRlXCI6XCJcXHUwMTQ0XCIsXCJuYW5nXCI6XCJcXHUyMjIwXFx1MjBEMlwiLFwibmFwXCI6XCJcXHUyMjQ5XCIsXCJuYXBFXCI6XCJcXHUyQTcwXFx1MDMzOFwiLFwibmFwaWRcIjpcIlxcdTIyNEJcXHUwMzM4XCIsXCJuYXBvc1wiOlwiXFx1MDE0OVwiLFwibmFwcHJveFwiOlwiXFx1MjI0OVwiLFwibmF0dXJhbFwiOlwiXFx1MjY2RVwiLFwibmF0dXJhbHNcIjpcIlxcdTIxMTVcIixcIm5hdHVyXCI6XCJcXHUyNjZFXCIsXCJuYnNwXCI6XCJcXHhBMFwiLFwibmJ1bXBcIjpcIlxcdTIyNEVcXHUwMzM4XCIsXCJuYnVtcGVcIjpcIlxcdTIyNEZcXHUwMzM4XCIsXCJuY2FwXCI6XCJcXHUyQTQzXCIsXCJOY2Fyb25cIjpcIlxcdTAxNDdcIixcIm5jYXJvblwiOlwiXFx1MDE0OFwiLFwiTmNlZGlsXCI6XCJcXHUwMTQ1XCIsXCJuY2VkaWxcIjpcIlxcdTAxNDZcIixcIm5jb25nXCI6XCJcXHUyMjQ3XCIsXCJuY29uZ2RvdFwiOlwiXFx1MkE2RFxcdTAzMzhcIixcIm5jdXBcIjpcIlxcdTJBNDJcIixcIk5jeVwiOlwiXFx1MDQxRFwiLFwibmN5XCI6XCJcXHUwNDNEXCIsXCJuZGFzaFwiOlwiXFx1MjAxM1wiLFwibmVhcmhrXCI6XCJcXHUyOTI0XCIsXCJuZWFyclwiOlwiXFx1MjE5N1wiLFwibmVBcnJcIjpcIlxcdTIxRDdcIixcIm5lYXJyb3dcIjpcIlxcdTIxOTdcIixcIm5lXCI6XCJcXHUyMjYwXCIsXCJuZWRvdFwiOlwiXFx1MjI1MFxcdTAzMzhcIixcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjpcIlxcdTIwMEJcIixcIk5lZ2F0aXZlVGhpY2tTcGFjZVwiOlwiXFx1MjAwQlwiLFwiTmVnYXRpdmVUaGluU3BhY2VcIjpcIlxcdTIwMEJcIixcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOlwiXFx1MjAwQlwiLFwibmVxdWl2XCI6XCJcXHUyMjYyXCIsXCJuZXNlYXJcIjpcIlxcdTI5MjhcIixcIm5lc2ltXCI6XCJcXHUyMjQyXFx1MDMzOFwiLFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIlxcdTIyNkJcIixcIk5lc3RlZExlc3NMZXNzXCI6XCJcXHUyMjZBXCIsXCJOZXdMaW5lXCI6XCJcXG5cIixcIm5leGlzdFwiOlwiXFx1MjIwNFwiLFwibmV4aXN0c1wiOlwiXFx1MjIwNFwiLFwiTmZyXCI6XCJcXHVEODM1XFx1REQxMVwiLFwibmZyXCI6XCJcXHVEODM1XFx1REQyQlwiLFwibmdFXCI6XCJcXHUyMjY3XFx1MDMzOFwiLFwibmdlXCI6XCJcXHUyMjcxXCIsXCJuZ2VxXCI6XCJcXHUyMjcxXCIsXCJuZ2VxcVwiOlwiXFx1MjI2N1xcdTAzMzhcIixcIm5nZXFzbGFudFwiOlwiXFx1MkE3RVxcdTAzMzhcIixcIm5nZXNcIjpcIlxcdTJBN0VcXHUwMzM4XCIsXCJuR2dcIjpcIlxcdTIyRDlcXHUwMzM4XCIsXCJuZ3NpbVwiOlwiXFx1MjI3NVwiLFwibkd0XCI6XCJcXHUyMjZCXFx1MjBEMlwiLFwibmd0XCI6XCJcXHUyMjZGXCIsXCJuZ3RyXCI6XCJcXHUyMjZGXCIsXCJuR3R2XCI6XCJcXHUyMjZCXFx1MDMzOFwiLFwibmhhcnJcIjpcIlxcdTIxQUVcIixcIm5oQXJyXCI6XCJcXHUyMUNFXCIsXCJuaHBhclwiOlwiXFx1MkFGMlwiLFwibmlcIjpcIlxcdTIyMEJcIixcIm5pc1wiOlwiXFx1MjJGQ1wiLFwibmlzZFwiOlwiXFx1MjJGQVwiLFwibml2XCI6XCJcXHUyMjBCXCIsXCJOSmN5XCI6XCJcXHUwNDBBXCIsXCJuamN5XCI6XCJcXHUwNDVBXCIsXCJubGFyclwiOlwiXFx1MjE5QVwiLFwibmxBcnJcIjpcIlxcdTIxQ0RcIixcIm5sZHJcIjpcIlxcdTIwMjVcIixcIm5sRVwiOlwiXFx1MjI2NlxcdTAzMzhcIixcIm5sZVwiOlwiXFx1MjI3MFwiLFwibmxlZnRhcnJvd1wiOlwiXFx1MjE5QVwiLFwibkxlZnRhcnJvd1wiOlwiXFx1MjFDRFwiLFwibmxlZnRyaWdodGFycm93XCI6XCJcXHUyMUFFXCIsXCJuTGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTIxQ0VcIixcIm5sZXFcIjpcIlxcdTIyNzBcIixcIm5sZXFxXCI6XCJcXHUyMjY2XFx1MDMzOFwiLFwibmxlcXNsYW50XCI6XCJcXHUyQTdEXFx1MDMzOFwiLFwibmxlc1wiOlwiXFx1MkE3RFxcdTAzMzhcIixcIm5sZXNzXCI6XCJcXHUyMjZFXCIsXCJuTGxcIjpcIlxcdTIyRDhcXHUwMzM4XCIsXCJubHNpbVwiOlwiXFx1MjI3NFwiLFwibkx0XCI6XCJcXHUyMjZBXFx1MjBEMlwiLFwibmx0XCI6XCJcXHUyMjZFXCIsXCJubHRyaVwiOlwiXFx1MjJFQVwiLFwibmx0cmllXCI6XCJcXHUyMkVDXCIsXCJuTHR2XCI6XCJcXHUyMjZBXFx1MDMzOFwiLFwibm1pZFwiOlwiXFx1MjIyNFwiLFwiTm9CcmVha1wiOlwiXFx1MjA2MFwiLFwiTm9uQnJlYWtpbmdTcGFjZVwiOlwiXFx4QTBcIixcIm5vcGZcIjpcIlxcdUQ4MzVcXHVERDVGXCIsXCJOb3BmXCI6XCJcXHUyMTE1XCIsXCJOb3RcIjpcIlxcdTJBRUNcIixcIm5vdFwiOlwiXFx4QUNcIixcIk5vdENvbmdydWVudFwiOlwiXFx1MjI2MlwiLFwiTm90Q3VwQ2FwXCI6XCJcXHUyMjZEXCIsXCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOlwiXFx1MjIyNlwiLFwiTm90RWxlbWVudFwiOlwiXFx1MjIwOVwiLFwiTm90RXF1YWxcIjpcIlxcdTIyNjBcIixcIk5vdEVxdWFsVGlsZGVcIjpcIlxcdTIyNDJcXHUwMzM4XCIsXCJOb3RFeGlzdHNcIjpcIlxcdTIyMDRcIixcIk5vdEdyZWF0ZXJcIjpcIlxcdTIyNkZcIixcIk5vdEdyZWF0ZXJFcXVhbFwiOlwiXFx1MjI3MVwiLFwiTm90R3JlYXRlckZ1bGxFcXVhbFwiOlwiXFx1MjI2N1xcdTAzMzhcIixcIk5vdEdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyMjZCXFx1MDMzOFwiLFwiTm90R3JlYXRlckxlc3NcIjpcIlxcdTIyNzlcIixcIk5vdEdyZWF0ZXJTbGFudEVxdWFsXCI6XCJcXHUyQTdFXFx1MDMzOFwiLFwiTm90R3JlYXRlclRpbGRlXCI6XCJcXHUyMjc1XCIsXCJOb3RIdW1wRG93bkh1bXBcIjpcIlxcdTIyNEVcXHUwMzM4XCIsXCJOb3RIdW1wRXF1YWxcIjpcIlxcdTIyNEZcXHUwMzM4XCIsXCJub3RpblwiOlwiXFx1MjIwOVwiLFwibm90aW5kb3RcIjpcIlxcdTIyRjVcXHUwMzM4XCIsXCJub3RpbkVcIjpcIlxcdTIyRjlcXHUwMzM4XCIsXCJub3RpbnZhXCI6XCJcXHUyMjA5XCIsXCJub3RpbnZiXCI6XCJcXHUyMkY3XCIsXCJub3RpbnZjXCI6XCJcXHUyMkY2XCIsXCJOb3RMZWZ0VHJpYW5nbGVCYXJcIjpcIlxcdTI5Q0ZcXHUwMzM4XCIsXCJOb3RMZWZ0VHJpYW5nbGVcIjpcIlxcdTIyRUFcIixcIk5vdExlZnRUcmlhbmdsZUVxdWFsXCI6XCJcXHUyMkVDXCIsXCJOb3RMZXNzXCI6XCJcXHUyMjZFXCIsXCJOb3RMZXNzRXF1YWxcIjpcIlxcdTIyNzBcIixcIk5vdExlc3NHcmVhdGVyXCI6XCJcXHUyMjc4XCIsXCJOb3RMZXNzTGVzc1wiOlwiXFx1MjI2QVxcdTAzMzhcIixcIk5vdExlc3NTbGFudEVxdWFsXCI6XCJcXHUyQTdEXFx1MDMzOFwiLFwiTm90TGVzc1RpbGRlXCI6XCJcXHUyMjc0XCIsXCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwiXFx1MkFBMlxcdTAzMzhcIixcIk5vdE5lc3RlZExlc3NMZXNzXCI6XCJcXHUyQUExXFx1MDMzOFwiLFwibm90bmlcIjpcIlxcdTIyMENcIixcIm5vdG5pdmFcIjpcIlxcdTIyMENcIixcIm5vdG5pdmJcIjpcIlxcdTIyRkVcIixcIm5vdG5pdmNcIjpcIlxcdTIyRkRcIixcIk5vdFByZWNlZGVzXCI6XCJcXHUyMjgwXCIsXCJOb3RQcmVjZWRlc0VxdWFsXCI6XCJcXHUyQUFGXFx1MDMzOFwiLFwiTm90UHJlY2VkZXNTbGFudEVxdWFsXCI6XCJcXHUyMkUwXCIsXCJOb3RSZXZlcnNlRWxlbWVudFwiOlwiXFx1MjIwQ1wiLFwiTm90UmlnaHRUcmlhbmdsZUJhclwiOlwiXFx1MjlEMFxcdTAzMzhcIixcIk5vdFJpZ2h0VHJpYW5nbGVcIjpcIlxcdTIyRUJcIixcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwiXFx1MjJFRFwiLFwiTm90U3F1YXJlU3Vic2V0XCI6XCJcXHUyMjhGXFx1MDMzOFwiLFwiTm90U3F1YXJlU3Vic2V0RXF1YWxcIjpcIlxcdTIyRTJcIixcIk5vdFNxdWFyZVN1cGVyc2V0XCI6XCJcXHUyMjkwXFx1MDMzOFwiLFwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwiXFx1MjJFM1wiLFwiTm90U3Vic2V0XCI6XCJcXHUyMjgyXFx1MjBEMlwiLFwiTm90U3Vic2V0RXF1YWxcIjpcIlxcdTIyODhcIixcIk5vdFN1Y2NlZWRzXCI6XCJcXHUyMjgxXCIsXCJOb3RTdWNjZWVkc0VxdWFsXCI6XCJcXHUyQUIwXFx1MDMzOFwiLFwiTm90U3VjY2VlZHNTbGFudEVxdWFsXCI6XCJcXHUyMkUxXCIsXCJOb3RTdWNjZWVkc1RpbGRlXCI6XCJcXHUyMjdGXFx1MDMzOFwiLFwiTm90U3VwZXJzZXRcIjpcIlxcdTIyODNcXHUyMEQyXCIsXCJOb3RTdXBlcnNldEVxdWFsXCI6XCJcXHUyMjg5XCIsXCJOb3RUaWxkZVwiOlwiXFx1MjI0MVwiLFwiTm90VGlsZGVFcXVhbFwiOlwiXFx1MjI0NFwiLFwiTm90VGlsZGVGdWxsRXF1YWxcIjpcIlxcdTIyNDdcIixcIk5vdFRpbGRlVGlsZGVcIjpcIlxcdTIyNDlcIixcIk5vdFZlcnRpY2FsQmFyXCI6XCJcXHUyMjI0XCIsXCJucGFyYWxsZWxcIjpcIlxcdTIyMjZcIixcIm5wYXJcIjpcIlxcdTIyMjZcIixcIm5wYXJzbFwiOlwiXFx1MkFGRFxcdTIwRTVcIixcIm5wYXJ0XCI6XCJcXHUyMjAyXFx1MDMzOFwiLFwibnBvbGludFwiOlwiXFx1MkExNFwiLFwibnByXCI6XCJcXHUyMjgwXCIsXCJucHJjdWVcIjpcIlxcdTIyRTBcIixcIm5wcmVjXCI6XCJcXHUyMjgwXCIsXCJucHJlY2VxXCI6XCJcXHUyQUFGXFx1MDMzOFwiLFwibnByZVwiOlwiXFx1MkFBRlxcdTAzMzhcIixcIm5yYXJyY1wiOlwiXFx1MjkzM1xcdTAzMzhcIixcIm5yYXJyXCI6XCJcXHUyMTlCXCIsXCJuckFyclwiOlwiXFx1MjFDRlwiLFwibnJhcnJ3XCI6XCJcXHUyMTlEXFx1MDMzOFwiLFwibnJpZ2h0YXJyb3dcIjpcIlxcdTIxOUJcIixcIm5SaWdodGFycm93XCI6XCJcXHUyMUNGXCIsXCJucnRyaVwiOlwiXFx1MjJFQlwiLFwibnJ0cmllXCI6XCJcXHUyMkVEXCIsXCJuc2NcIjpcIlxcdTIyODFcIixcIm5zY2N1ZVwiOlwiXFx1MjJFMVwiLFwibnNjZVwiOlwiXFx1MkFCMFxcdTAzMzhcIixcIk5zY3JcIjpcIlxcdUQ4MzVcXHVEQ0E5XCIsXCJuc2NyXCI6XCJcXHVEODM1XFx1RENDM1wiLFwibnNob3J0bWlkXCI6XCJcXHUyMjI0XCIsXCJuc2hvcnRwYXJhbGxlbFwiOlwiXFx1MjIyNlwiLFwibnNpbVwiOlwiXFx1MjI0MVwiLFwibnNpbWVcIjpcIlxcdTIyNDRcIixcIm5zaW1lcVwiOlwiXFx1MjI0NFwiLFwibnNtaWRcIjpcIlxcdTIyMjRcIixcIm5zcGFyXCI6XCJcXHUyMjI2XCIsXCJuc3FzdWJlXCI6XCJcXHUyMkUyXCIsXCJuc3FzdXBlXCI6XCJcXHUyMkUzXCIsXCJuc3ViXCI6XCJcXHUyMjg0XCIsXCJuc3ViRVwiOlwiXFx1MkFDNVxcdTAzMzhcIixcIm5zdWJlXCI6XCJcXHUyMjg4XCIsXCJuc3Vic2V0XCI6XCJcXHUyMjgyXFx1MjBEMlwiLFwibnN1YnNldGVxXCI6XCJcXHUyMjg4XCIsXCJuc3Vic2V0ZXFxXCI6XCJcXHUyQUM1XFx1MDMzOFwiLFwibnN1Y2NcIjpcIlxcdTIyODFcIixcIm5zdWNjZXFcIjpcIlxcdTJBQjBcXHUwMzM4XCIsXCJuc3VwXCI6XCJcXHUyMjg1XCIsXCJuc3VwRVwiOlwiXFx1MkFDNlxcdTAzMzhcIixcIm5zdXBlXCI6XCJcXHUyMjg5XCIsXCJuc3Vwc2V0XCI6XCJcXHUyMjgzXFx1MjBEMlwiLFwibnN1cHNldGVxXCI6XCJcXHUyMjg5XCIsXCJuc3Vwc2V0ZXFxXCI6XCJcXHUyQUM2XFx1MDMzOFwiLFwibnRnbFwiOlwiXFx1MjI3OVwiLFwiTnRpbGRlXCI6XCJcXHhEMVwiLFwibnRpbGRlXCI6XCJcXHhGMVwiLFwibnRsZ1wiOlwiXFx1MjI3OFwiLFwibnRyaWFuZ2xlbGVmdFwiOlwiXFx1MjJFQVwiLFwibnRyaWFuZ2xlbGVmdGVxXCI6XCJcXHUyMkVDXCIsXCJudHJpYW5nbGVyaWdodFwiOlwiXFx1MjJFQlwiLFwibnRyaWFuZ2xlcmlnaHRlcVwiOlwiXFx1MjJFRFwiLFwiTnVcIjpcIlxcdTAzOURcIixcIm51XCI6XCJcXHUwM0JEXCIsXCJudW1cIjpcIiNcIixcIm51bWVyb1wiOlwiXFx1MjExNlwiLFwibnVtc3BcIjpcIlxcdTIwMDdcIixcIm52YXBcIjpcIlxcdTIyNERcXHUyMEQyXCIsXCJudmRhc2hcIjpcIlxcdTIyQUNcIixcIm52RGFzaFwiOlwiXFx1MjJBRFwiLFwiblZkYXNoXCI6XCJcXHUyMkFFXCIsXCJuVkRhc2hcIjpcIlxcdTIyQUZcIixcIm52Z2VcIjpcIlxcdTIyNjVcXHUyMEQyXCIsXCJudmd0XCI6XCI+XFx1MjBEMlwiLFwibnZIYXJyXCI6XCJcXHUyOTA0XCIsXCJudmluZmluXCI6XCJcXHUyOURFXCIsXCJudmxBcnJcIjpcIlxcdTI5MDJcIixcIm52bGVcIjpcIlxcdTIyNjRcXHUyMEQyXCIsXCJudmx0XCI6XCI8XFx1MjBEMlwiLFwibnZsdHJpZVwiOlwiXFx1MjJCNFxcdTIwRDJcIixcIm52ckFyclwiOlwiXFx1MjkwM1wiLFwibnZydHJpZVwiOlwiXFx1MjJCNVxcdTIwRDJcIixcIm52c2ltXCI6XCJcXHUyMjNDXFx1MjBEMlwiLFwibndhcmhrXCI6XCJcXHUyOTIzXCIsXCJud2FyclwiOlwiXFx1MjE5NlwiLFwibndBcnJcIjpcIlxcdTIxRDZcIixcIm53YXJyb3dcIjpcIlxcdTIxOTZcIixcIm53bmVhclwiOlwiXFx1MjkyN1wiLFwiT2FjdXRlXCI6XCJcXHhEM1wiLFwib2FjdXRlXCI6XCJcXHhGM1wiLFwib2FzdFwiOlwiXFx1MjI5QlwiLFwiT2NpcmNcIjpcIlxceEQ0XCIsXCJvY2lyY1wiOlwiXFx4RjRcIixcIm9jaXJcIjpcIlxcdTIyOUFcIixcIk9jeVwiOlwiXFx1MDQxRVwiLFwib2N5XCI6XCJcXHUwNDNFXCIsXCJvZGFzaFwiOlwiXFx1MjI5RFwiLFwiT2RibGFjXCI6XCJcXHUwMTUwXCIsXCJvZGJsYWNcIjpcIlxcdTAxNTFcIixcIm9kaXZcIjpcIlxcdTJBMzhcIixcIm9kb3RcIjpcIlxcdTIyOTlcIixcIm9kc29sZFwiOlwiXFx1MjlCQ1wiLFwiT0VsaWdcIjpcIlxcdTAxNTJcIixcIm9lbGlnXCI6XCJcXHUwMTUzXCIsXCJvZmNpclwiOlwiXFx1MjlCRlwiLFwiT2ZyXCI6XCJcXHVEODM1XFx1REQxMlwiLFwib2ZyXCI6XCJcXHVEODM1XFx1REQyQ1wiLFwib2dvblwiOlwiXFx1MDJEQlwiLFwiT2dyYXZlXCI6XCJcXHhEMlwiLFwib2dyYXZlXCI6XCJcXHhGMlwiLFwib2d0XCI6XCJcXHUyOUMxXCIsXCJvaGJhclwiOlwiXFx1MjlCNVwiLFwib2htXCI6XCJcXHUwM0E5XCIsXCJvaW50XCI6XCJcXHUyMjJFXCIsXCJvbGFyclwiOlwiXFx1MjFCQVwiLFwib2xjaXJcIjpcIlxcdTI5QkVcIixcIm9sY3Jvc3NcIjpcIlxcdTI5QkJcIixcIm9saW5lXCI6XCJcXHUyMDNFXCIsXCJvbHRcIjpcIlxcdTI5QzBcIixcIk9tYWNyXCI6XCJcXHUwMTRDXCIsXCJvbWFjclwiOlwiXFx1MDE0RFwiLFwiT21lZ2FcIjpcIlxcdTAzQTlcIixcIm9tZWdhXCI6XCJcXHUwM0M5XCIsXCJPbWljcm9uXCI6XCJcXHUwMzlGXCIsXCJvbWljcm9uXCI6XCJcXHUwM0JGXCIsXCJvbWlkXCI6XCJcXHUyOUI2XCIsXCJvbWludXNcIjpcIlxcdTIyOTZcIixcIk9vcGZcIjpcIlxcdUQ4MzVcXHVERDQ2XCIsXCJvb3BmXCI6XCJcXHVEODM1XFx1REQ2MFwiLFwib3BhclwiOlwiXFx1MjlCN1wiLFwiT3BlbkN1cmx5RG91YmxlUXVvdGVcIjpcIlxcdTIwMUNcIixcIk9wZW5DdXJseVF1b3RlXCI6XCJcXHUyMDE4XCIsXCJvcGVycFwiOlwiXFx1MjlCOVwiLFwib3BsdXNcIjpcIlxcdTIyOTVcIixcIm9yYXJyXCI6XCJcXHUyMUJCXCIsXCJPclwiOlwiXFx1MkE1NFwiLFwib3JcIjpcIlxcdTIyMjhcIixcIm9yZFwiOlwiXFx1MkE1RFwiLFwib3JkZXJcIjpcIlxcdTIxMzRcIixcIm9yZGVyb2ZcIjpcIlxcdTIxMzRcIixcIm9yZGZcIjpcIlxceEFBXCIsXCJvcmRtXCI6XCJcXHhCQVwiLFwib3JpZ29mXCI6XCJcXHUyMkI2XCIsXCJvcm9yXCI6XCJcXHUyQTU2XCIsXCJvcnNsb3BlXCI6XCJcXHUyQTU3XCIsXCJvcnZcIjpcIlxcdTJBNUJcIixcIm9TXCI6XCJcXHUyNEM4XCIsXCJPc2NyXCI6XCJcXHVEODM1XFx1RENBQVwiLFwib3NjclwiOlwiXFx1MjEzNFwiLFwiT3NsYXNoXCI6XCJcXHhEOFwiLFwib3NsYXNoXCI6XCJcXHhGOFwiLFwib3NvbFwiOlwiXFx1MjI5OFwiLFwiT3RpbGRlXCI6XCJcXHhENVwiLFwib3RpbGRlXCI6XCJcXHhGNVwiLFwib3RpbWVzYXNcIjpcIlxcdTJBMzZcIixcIk90aW1lc1wiOlwiXFx1MkEzN1wiLFwib3RpbWVzXCI6XCJcXHUyMjk3XCIsXCJPdW1sXCI6XCJcXHhENlwiLFwib3VtbFwiOlwiXFx4RjZcIixcIm92YmFyXCI6XCJcXHUyMzNEXCIsXCJPdmVyQmFyXCI6XCJcXHUyMDNFXCIsXCJPdmVyQnJhY2VcIjpcIlxcdTIzREVcIixcIk92ZXJCcmFja2V0XCI6XCJcXHUyM0I0XCIsXCJPdmVyUGFyZW50aGVzaXNcIjpcIlxcdTIzRENcIixcInBhcmFcIjpcIlxceEI2XCIsXCJwYXJhbGxlbFwiOlwiXFx1MjIyNVwiLFwicGFyXCI6XCJcXHUyMjI1XCIsXCJwYXJzaW1cIjpcIlxcdTJBRjNcIixcInBhcnNsXCI6XCJcXHUyQUZEXCIsXCJwYXJ0XCI6XCJcXHUyMjAyXCIsXCJQYXJ0aWFsRFwiOlwiXFx1MjIwMlwiLFwiUGN5XCI6XCJcXHUwNDFGXCIsXCJwY3lcIjpcIlxcdTA0M0ZcIixcInBlcmNudFwiOlwiJVwiLFwicGVyaW9kXCI6XCIuXCIsXCJwZXJtaWxcIjpcIlxcdTIwMzBcIixcInBlcnBcIjpcIlxcdTIyQTVcIixcInBlcnRlbmtcIjpcIlxcdTIwMzFcIixcIlBmclwiOlwiXFx1RDgzNVxcdUREMTNcIixcInBmclwiOlwiXFx1RDgzNVxcdUREMkRcIixcIlBoaVwiOlwiXFx1MDNBNlwiLFwicGhpXCI6XCJcXHUwM0M2XCIsXCJwaGl2XCI6XCJcXHUwM0Q1XCIsXCJwaG1tYXRcIjpcIlxcdTIxMzNcIixcInBob25lXCI6XCJcXHUyNjBFXCIsXCJQaVwiOlwiXFx1MDNBMFwiLFwicGlcIjpcIlxcdTAzQzBcIixcInBpdGNoZm9ya1wiOlwiXFx1MjJENFwiLFwicGl2XCI6XCJcXHUwM0Q2XCIsXCJwbGFuY2tcIjpcIlxcdTIxMEZcIixcInBsYW5ja2hcIjpcIlxcdTIxMEVcIixcInBsYW5rdlwiOlwiXFx1MjEwRlwiLFwicGx1c2FjaXJcIjpcIlxcdTJBMjNcIixcInBsdXNiXCI6XCJcXHUyMjlFXCIsXCJwbHVzY2lyXCI6XCJcXHUyQTIyXCIsXCJwbHVzXCI6XCIrXCIsXCJwbHVzZG9cIjpcIlxcdTIyMTRcIixcInBsdXNkdVwiOlwiXFx1MkEyNVwiLFwicGx1c2VcIjpcIlxcdTJBNzJcIixcIlBsdXNNaW51c1wiOlwiXFx4QjFcIixcInBsdXNtblwiOlwiXFx4QjFcIixcInBsdXNzaW1cIjpcIlxcdTJBMjZcIixcInBsdXN0d29cIjpcIlxcdTJBMjdcIixcInBtXCI6XCJcXHhCMVwiLFwiUG9pbmNhcmVwbGFuZVwiOlwiXFx1MjEwQ1wiLFwicG9pbnRpbnRcIjpcIlxcdTJBMTVcIixcInBvcGZcIjpcIlxcdUQ4MzVcXHVERDYxXCIsXCJQb3BmXCI6XCJcXHUyMTE5XCIsXCJwb3VuZFwiOlwiXFx4QTNcIixcInByYXBcIjpcIlxcdTJBQjdcIixcIlByXCI6XCJcXHUyQUJCXCIsXCJwclwiOlwiXFx1MjI3QVwiLFwicHJjdWVcIjpcIlxcdTIyN0NcIixcInByZWNhcHByb3hcIjpcIlxcdTJBQjdcIixcInByZWNcIjpcIlxcdTIyN0FcIixcInByZWNjdXJseWVxXCI6XCJcXHUyMjdDXCIsXCJQcmVjZWRlc1wiOlwiXFx1MjI3QVwiLFwiUHJlY2VkZXNFcXVhbFwiOlwiXFx1MkFBRlwiLFwiUHJlY2VkZXNTbGFudEVxdWFsXCI6XCJcXHUyMjdDXCIsXCJQcmVjZWRlc1RpbGRlXCI6XCJcXHUyMjdFXCIsXCJwcmVjZXFcIjpcIlxcdTJBQUZcIixcInByZWNuYXBwcm94XCI6XCJcXHUyQUI5XCIsXCJwcmVjbmVxcVwiOlwiXFx1MkFCNVwiLFwicHJlY25zaW1cIjpcIlxcdTIyRThcIixcInByZVwiOlwiXFx1MkFBRlwiLFwicHJFXCI6XCJcXHUyQUIzXCIsXCJwcmVjc2ltXCI6XCJcXHUyMjdFXCIsXCJwcmltZVwiOlwiXFx1MjAzMlwiLFwiUHJpbWVcIjpcIlxcdTIwMzNcIixcInByaW1lc1wiOlwiXFx1MjExOVwiLFwicHJuYXBcIjpcIlxcdTJBQjlcIixcInBybkVcIjpcIlxcdTJBQjVcIixcInBybnNpbVwiOlwiXFx1MjJFOFwiLFwicHJvZFwiOlwiXFx1MjIwRlwiLFwiUHJvZHVjdFwiOlwiXFx1MjIwRlwiLFwicHJvZmFsYXJcIjpcIlxcdTIzMkVcIixcInByb2ZsaW5lXCI6XCJcXHUyMzEyXCIsXCJwcm9mc3VyZlwiOlwiXFx1MjMxM1wiLFwicHJvcFwiOlwiXFx1MjIxRFwiLFwiUHJvcG9ydGlvbmFsXCI6XCJcXHUyMjFEXCIsXCJQcm9wb3J0aW9uXCI6XCJcXHUyMjM3XCIsXCJwcm9wdG9cIjpcIlxcdTIyMURcIixcInByc2ltXCI6XCJcXHUyMjdFXCIsXCJwcnVyZWxcIjpcIlxcdTIyQjBcIixcIlBzY3JcIjpcIlxcdUQ4MzVcXHVEQ0FCXCIsXCJwc2NyXCI6XCJcXHVEODM1XFx1RENDNVwiLFwiUHNpXCI6XCJcXHUwM0E4XCIsXCJwc2lcIjpcIlxcdTAzQzhcIixcInB1bmNzcFwiOlwiXFx1MjAwOFwiLFwiUWZyXCI6XCJcXHVEODM1XFx1REQxNFwiLFwicWZyXCI6XCJcXHVEODM1XFx1REQyRVwiLFwicWludFwiOlwiXFx1MkEwQ1wiLFwicW9wZlwiOlwiXFx1RDgzNVxcdURENjJcIixcIlFvcGZcIjpcIlxcdTIxMUFcIixcInFwcmltZVwiOlwiXFx1MjA1N1wiLFwiUXNjclwiOlwiXFx1RDgzNVxcdURDQUNcIixcInFzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M2XCIsXCJxdWF0ZXJuaW9uc1wiOlwiXFx1MjEwRFwiLFwicXVhdGludFwiOlwiXFx1MkExNlwiLFwicXVlc3RcIjpcIj9cIixcInF1ZXN0ZXFcIjpcIlxcdTIyNUZcIixcInF1b3RcIjpcIlxcXCJcIixcIlFVT1RcIjpcIlxcXCJcIixcInJBYXJyXCI6XCJcXHUyMURCXCIsXCJyYWNlXCI6XCJcXHUyMjNEXFx1MDMzMVwiLFwiUmFjdXRlXCI6XCJcXHUwMTU0XCIsXCJyYWN1dGVcIjpcIlxcdTAxNTVcIixcInJhZGljXCI6XCJcXHUyMjFBXCIsXCJyYWVtcHR5dlwiOlwiXFx1MjlCM1wiLFwicmFuZ1wiOlwiXFx1MjdFOVwiLFwiUmFuZ1wiOlwiXFx1MjdFQlwiLFwicmFuZ2RcIjpcIlxcdTI5OTJcIixcInJhbmdlXCI6XCJcXHUyOUE1XCIsXCJyYW5nbGVcIjpcIlxcdTI3RTlcIixcInJhcXVvXCI6XCJcXHhCQlwiLFwicmFycmFwXCI6XCJcXHUyOTc1XCIsXCJyYXJyYlwiOlwiXFx1MjFFNVwiLFwicmFycmJmc1wiOlwiXFx1MjkyMFwiLFwicmFycmNcIjpcIlxcdTI5MzNcIixcInJhcnJcIjpcIlxcdTIxOTJcIixcIlJhcnJcIjpcIlxcdTIxQTBcIixcInJBcnJcIjpcIlxcdTIxRDJcIixcInJhcnJmc1wiOlwiXFx1MjkxRVwiLFwicmFycmhrXCI6XCJcXHUyMUFBXCIsXCJyYXJybHBcIjpcIlxcdTIxQUNcIixcInJhcnJwbFwiOlwiXFx1Mjk0NVwiLFwicmFycnNpbVwiOlwiXFx1Mjk3NFwiLFwiUmFycnRsXCI6XCJcXHUyOTE2XCIsXCJyYXJydGxcIjpcIlxcdTIxQTNcIixcInJhcnJ3XCI6XCJcXHUyMTlEXCIsXCJyYXRhaWxcIjpcIlxcdTI5MUFcIixcInJBdGFpbFwiOlwiXFx1MjkxQ1wiLFwicmF0aW9cIjpcIlxcdTIyMzZcIixcInJhdGlvbmFsc1wiOlwiXFx1MjExQVwiLFwicmJhcnJcIjpcIlxcdTI5MERcIixcInJCYXJyXCI6XCJcXHUyOTBGXCIsXCJSQmFyclwiOlwiXFx1MjkxMFwiLFwicmJicmtcIjpcIlxcdTI3NzNcIixcInJicmFjZVwiOlwifVwiLFwicmJyYWNrXCI6XCJdXCIsXCJyYnJrZVwiOlwiXFx1Mjk4Q1wiLFwicmJya3NsZFwiOlwiXFx1Mjk4RVwiLFwicmJya3NsdVwiOlwiXFx1Mjk5MFwiLFwiUmNhcm9uXCI6XCJcXHUwMTU4XCIsXCJyY2Fyb25cIjpcIlxcdTAxNTlcIixcIlJjZWRpbFwiOlwiXFx1MDE1NlwiLFwicmNlZGlsXCI6XCJcXHUwMTU3XCIsXCJyY2VpbFwiOlwiXFx1MjMwOVwiLFwicmN1YlwiOlwifVwiLFwiUmN5XCI6XCJcXHUwNDIwXCIsXCJyY3lcIjpcIlxcdTA0NDBcIixcInJkY2FcIjpcIlxcdTI5MzdcIixcInJkbGRoYXJcIjpcIlxcdTI5NjlcIixcInJkcXVvXCI6XCJcXHUyMDFEXCIsXCJyZHF1b3JcIjpcIlxcdTIwMURcIixcInJkc2hcIjpcIlxcdTIxQjNcIixcInJlYWxcIjpcIlxcdTIxMUNcIixcInJlYWxpbmVcIjpcIlxcdTIxMUJcIixcInJlYWxwYXJ0XCI6XCJcXHUyMTFDXCIsXCJyZWFsc1wiOlwiXFx1MjExRFwiLFwiUmVcIjpcIlxcdTIxMUNcIixcInJlY3RcIjpcIlxcdTI1QURcIixcInJlZ1wiOlwiXFx4QUVcIixcIlJFR1wiOlwiXFx4QUVcIixcIlJldmVyc2VFbGVtZW50XCI6XCJcXHUyMjBCXCIsXCJSZXZlcnNlRXF1aWxpYnJpdW1cIjpcIlxcdTIxQ0JcIixcIlJldmVyc2VVcEVxdWlsaWJyaXVtXCI6XCJcXHUyOTZGXCIsXCJyZmlzaHRcIjpcIlxcdTI5N0RcIixcInJmbG9vclwiOlwiXFx1MjMwQlwiLFwicmZyXCI6XCJcXHVEODM1XFx1REQyRlwiLFwiUmZyXCI6XCJcXHUyMTFDXCIsXCJySGFyXCI6XCJcXHUyOTY0XCIsXCJyaGFyZFwiOlwiXFx1MjFDMVwiLFwicmhhcnVcIjpcIlxcdTIxQzBcIixcInJoYXJ1bFwiOlwiXFx1Mjk2Q1wiLFwiUmhvXCI6XCJcXHUwM0ExXCIsXCJyaG9cIjpcIlxcdTAzQzFcIixcInJob3ZcIjpcIlxcdTAzRjFcIixcIlJpZ2h0QW5nbGVCcmFja2V0XCI6XCJcXHUyN0U5XCIsXCJSaWdodEFycm93QmFyXCI6XCJcXHUyMUU1XCIsXCJyaWdodGFycm93XCI6XCJcXHUyMTkyXCIsXCJSaWdodEFycm93XCI6XCJcXHUyMTkyXCIsXCJSaWdodGFycm93XCI6XCJcXHUyMUQyXCIsXCJSaWdodEFycm93TGVmdEFycm93XCI6XCJcXHUyMUM0XCIsXCJyaWdodGFycm93dGFpbFwiOlwiXFx1MjFBM1wiLFwiUmlnaHRDZWlsaW5nXCI6XCJcXHUyMzA5XCIsXCJSaWdodERvdWJsZUJyYWNrZXRcIjpcIlxcdTI3RTdcIixcIlJpZ2h0RG93blRlZVZlY3RvclwiOlwiXFx1Mjk1RFwiLFwiUmlnaHREb3duVmVjdG9yQmFyXCI6XCJcXHUyOTU1XCIsXCJSaWdodERvd25WZWN0b3JcIjpcIlxcdTIxQzJcIixcIlJpZ2h0Rmxvb3JcIjpcIlxcdTIzMEJcIixcInJpZ2h0aGFycG9vbmRvd25cIjpcIlxcdTIxQzFcIixcInJpZ2h0aGFycG9vbnVwXCI6XCJcXHUyMUMwXCIsXCJyaWdodGxlZnRhcnJvd3NcIjpcIlxcdTIxQzRcIixcInJpZ2h0bGVmdGhhcnBvb25zXCI6XCJcXHUyMUNDXCIsXCJyaWdodHJpZ2h0YXJyb3dzXCI6XCJcXHUyMUM5XCIsXCJyaWdodHNxdWlnYXJyb3dcIjpcIlxcdTIxOURcIixcIlJpZ2h0VGVlQXJyb3dcIjpcIlxcdTIxQTZcIixcIlJpZ2h0VGVlXCI6XCJcXHUyMkEyXCIsXCJSaWdodFRlZVZlY3RvclwiOlwiXFx1Mjk1QlwiLFwicmlnaHR0aHJlZXRpbWVzXCI6XCJcXHUyMkNDXCIsXCJSaWdodFRyaWFuZ2xlQmFyXCI6XCJcXHUyOUQwXCIsXCJSaWdodFRyaWFuZ2xlXCI6XCJcXHUyMkIzXCIsXCJSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyQjVcIixcIlJpZ2h0VXBEb3duVmVjdG9yXCI6XCJcXHUyOTRGXCIsXCJSaWdodFVwVGVlVmVjdG9yXCI6XCJcXHUyOTVDXCIsXCJSaWdodFVwVmVjdG9yQmFyXCI6XCJcXHUyOTU0XCIsXCJSaWdodFVwVmVjdG9yXCI6XCJcXHUyMUJFXCIsXCJSaWdodFZlY3RvckJhclwiOlwiXFx1Mjk1M1wiLFwiUmlnaHRWZWN0b3JcIjpcIlxcdTIxQzBcIixcInJpbmdcIjpcIlxcdTAyREFcIixcInJpc2luZ2RvdHNlcVwiOlwiXFx1MjI1M1wiLFwicmxhcnJcIjpcIlxcdTIxQzRcIixcInJsaGFyXCI6XCJcXHUyMUNDXCIsXCJybG1cIjpcIlxcdTIwMEZcIixcInJtb3VzdGFjaGVcIjpcIlxcdTIzQjFcIixcInJtb3VzdFwiOlwiXFx1MjNCMVwiLFwicm5taWRcIjpcIlxcdTJBRUVcIixcInJvYW5nXCI6XCJcXHUyN0VEXCIsXCJyb2FyclwiOlwiXFx1MjFGRVwiLFwicm9icmtcIjpcIlxcdTI3RTdcIixcInJvcGFyXCI6XCJcXHUyOTg2XCIsXCJyb3BmXCI6XCJcXHVEODM1XFx1REQ2M1wiLFwiUm9wZlwiOlwiXFx1MjExRFwiLFwicm9wbHVzXCI6XCJcXHUyQTJFXCIsXCJyb3RpbWVzXCI6XCJcXHUyQTM1XCIsXCJSb3VuZEltcGxpZXNcIjpcIlxcdTI5NzBcIixcInJwYXJcIjpcIilcIixcInJwYXJndFwiOlwiXFx1Mjk5NFwiLFwicnBwb2xpbnRcIjpcIlxcdTJBMTJcIixcInJyYXJyXCI6XCJcXHUyMUM5XCIsXCJScmlnaHRhcnJvd1wiOlwiXFx1MjFEQlwiLFwicnNhcXVvXCI6XCJcXHUyMDNBXCIsXCJyc2NyXCI6XCJcXHVEODM1XFx1RENDN1wiLFwiUnNjclwiOlwiXFx1MjExQlwiLFwicnNoXCI6XCJcXHUyMUIxXCIsXCJSc2hcIjpcIlxcdTIxQjFcIixcInJzcWJcIjpcIl1cIixcInJzcXVvXCI6XCJcXHUyMDE5XCIsXCJyc3F1b3JcIjpcIlxcdTIwMTlcIixcInJ0aHJlZVwiOlwiXFx1MjJDQ1wiLFwicnRpbWVzXCI6XCJcXHUyMkNBXCIsXCJydHJpXCI6XCJcXHUyNUI5XCIsXCJydHJpZVwiOlwiXFx1MjJCNVwiLFwicnRyaWZcIjpcIlxcdTI1QjhcIixcInJ0cmlsdHJpXCI6XCJcXHUyOUNFXCIsXCJSdWxlRGVsYXllZFwiOlwiXFx1MjlGNFwiLFwicnVsdWhhclwiOlwiXFx1Mjk2OFwiLFwicnhcIjpcIlxcdTIxMUVcIixcIlNhY3V0ZVwiOlwiXFx1MDE1QVwiLFwic2FjdXRlXCI6XCJcXHUwMTVCXCIsXCJzYnF1b1wiOlwiXFx1MjAxQVwiLFwic2NhcFwiOlwiXFx1MkFCOFwiLFwiU2Nhcm9uXCI6XCJcXHUwMTYwXCIsXCJzY2Fyb25cIjpcIlxcdTAxNjFcIixcIlNjXCI6XCJcXHUyQUJDXCIsXCJzY1wiOlwiXFx1MjI3QlwiLFwic2NjdWVcIjpcIlxcdTIyN0RcIixcInNjZVwiOlwiXFx1MkFCMFwiLFwic2NFXCI6XCJcXHUyQUI0XCIsXCJTY2VkaWxcIjpcIlxcdTAxNUVcIixcInNjZWRpbFwiOlwiXFx1MDE1RlwiLFwiU2NpcmNcIjpcIlxcdTAxNUNcIixcInNjaXJjXCI6XCJcXHUwMTVEXCIsXCJzY25hcFwiOlwiXFx1MkFCQVwiLFwic2NuRVwiOlwiXFx1MkFCNlwiLFwic2Nuc2ltXCI6XCJcXHUyMkU5XCIsXCJzY3BvbGludFwiOlwiXFx1MkExM1wiLFwic2NzaW1cIjpcIlxcdTIyN0ZcIixcIlNjeVwiOlwiXFx1MDQyMVwiLFwic2N5XCI6XCJcXHUwNDQxXCIsXCJzZG90YlwiOlwiXFx1MjJBMVwiLFwic2RvdFwiOlwiXFx1MjJDNVwiLFwic2RvdGVcIjpcIlxcdTJBNjZcIixcInNlYXJoa1wiOlwiXFx1MjkyNVwiLFwic2VhcnJcIjpcIlxcdTIxOThcIixcInNlQXJyXCI6XCJcXHUyMUQ4XCIsXCJzZWFycm93XCI6XCJcXHUyMTk4XCIsXCJzZWN0XCI6XCJcXHhBN1wiLFwic2VtaVwiOlwiO1wiLFwic2Vzd2FyXCI6XCJcXHUyOTI5XCIsXCJzZXRtaW51c1wiOlwiXFx1MjIxNlwiLFwic2V0bW5cIjpcIlxcdTIyMTZcIixcInNleHRcIjpcIlxcdTI3MzZcIixcIlNmclwiOlwiXFx1RDgzNVxcdUREMTZcIixcInNmclwiOlwiXFx1RDgzNVxcdUREMzBcIixcInNmcm93blwiOlwiXFx1MjMyMlwiLFwic2hhcnBcIjpcIlxcdTI2NkZcIixcIlNIQ0hjeVwiOlwiXFx1MDQyOVwiLFwic2hjaGN5XCI6XCJcXHUwNDQ5XCIsXCJTSGN5XCI6XCJcXHUwNDI4XCIsXCJzaGN5XCI6XCJcXHUwNDQ4XCIsXCJTaG9ydERvd25BcnJvd1wiOlwiXFx1MjE5M1wiLFwiU2hvcnRMZWZ0QXJyb3dcIjpcIlxcdTIxOTBcIixcInNob3J0bWlkXCI6XCJcXHUyMjIzXCIsXCJzaG9ydHBhcmFsbGVsXCI6XCJcXHUyMjI1XCIsXCJTaG9ydFJpZ2h0QXJyb3dcIjpcIlxcdTIxOTJcIixcIlNob3J0VXBBcnJvd1wiOlwiXFx1MjE5MVwiLFwic2h5XCI6XCJcXHhBRFwiLFwiU2lnbWFcIjpcIlxcdTAzQTNcIixcInNpZ21hXCI6XCJcXHUwM0MzXCIsXCJzaWdtYWZcIjpcIlxcdTAzQzJcIixcInNpZ21hdlwiOlwiXFx1MDNDMlwiLFwic2ltXCI6XCJcXHUyMjNDXCIsXCJzaW1kb3RcIjpcIlxcdTJBNkFcIixcInNpbWVcIjpcIlxcdTIyNDNcIixcInNpbWVxXCI6XCJcXHUyMjQzXCIsXCJzaW1nXCI6XCJcXHUyQTlFXCIsXCJzaW1nRVwiOlwiXFx1MkFBMFwiLFwic2ltbFwiOlwiXFx1MkE5RFwiLFwic2ltbEVcIjpcIlxcdTJBOUZcIixcInNpbW5lXCI6XCJcXHUyMjQ2XCIsXCJzaW1wbHVzXCI6XCJcXHUyQTI0XCIsXCJzaW1yYXJyXCI6XCJcXHUyOTcyXCIsXCJzbGFyclwiOlwiXFx1MjE5MFwiLFwiU21hbGxDaXJjbGVcIjpcIlxcdTIyMThcIixcInNtYWxsc2V0bWludXNcIjpcIlxcdTIyMTZcIixcInNtYXNocFwiOlwiXFx1MkEzM1wiLFwic21lcGFyc2xcIjpcIlxcdTI5RTRcIixcInNtaWRcIjpcIlxcdTIyMjNcIixcInNtaWxlXCI6XCJcXHUyMzIzXCIsXCJzbXRcIjpcIlxcdTJBQUFcIixcInNtdGVcIjpcIlxcdTJBQUNcIixcInNtdGVzXCI6XCJcXHUyQUFDXFx1RkUwMFwiLFwiU09GVGN5XCI6XCJcXHUwNDJDXCIsXCJzb2Z0Y3lcIjpcIlxcdTA0NENcIixcInNvbGJhclwiOlwiXFx1MjMzRlwiLFwic29sYlwiOlwiXFx1MjlDNFwiLFwic29sXCI6XCIvXCIsXCJTb3BmXCI6XCJcXHVEODM1XFx1REQ0QVwiLFwic29wZlwiOlwiXFx1RDgzNVxcdURENjRcIixcInNwYWRlc1wiOlwiXFx1MjY2MFwiLFwic3BhZGVzdWl0XCI6XCJcXHUyNjYwXCIsXCJzcGFyXCI6XCJcXHUyMjI1XCIsXCJzcWNhcFwiOlwiXFx1MjI5M1wiLFwic3FjYXBzXCI6XCJcXHUyMjkzXFx1RkUwMFwiLFwic3FjdXBcIjpcIlxcdTIyOTRcIixcInNxY3Vwc1wiOlwiXFx1MjI5NFxcdUZFMDBcIixcIlNxcnRcIjpcIlxcdTIyMUFcIixcInNxc3ViXCI6XCJcXHUyMjhGXCIsXCJzcXN1YmVcIjpcIlxcdTIyOTFcIixcInNxc3Vic2V0XCI6XCJcXHUyMjhGXCIsXCJzcXN1YnNldGVxXCI6XCJcXHUyMjkxXCIsXCJzcXN1cFwiOlwiXFx1MjI5MFwiLFwic3FzdXBlXCI6XCJcXHUyMjkyXCIsXCJzcXN1cHNldFwiOlwiXFx1MjI5MFwiLFwic3FzdXBzZXRlcVwiOlwiXFx1MjI5MlwiLFwic3F1YXJlXCI6XCJcXHUyNUExXCIsXCJTcXVhcmVcIjpcIlxcdTI1QTFcIixcIlNxdWFyZUludGVyc2VjdGlvblwiOlwiXFx1MjI5M1wiLFwiU3F1YXJlU3Vic2V0XCI6XCJcXHUyMjhGXCIsXCJTcXVhcmVTdWJzZXRFcXVhbFwiOlwiXFx1MjI5MVwiLFwiU3F1YXJlU3VwZXJzZXRcIjpcIlxcdTIyOTBcIixcIlNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIlxcdTIyOTJcIixcIlNxdWFyZVVuaW9uXCI6XCJcXHUyMjk0XCIsXCJzcXVhcmZcIjpcIlxcdTI1QUFcIixcInNxdVwiOlwiXFx1MjVBMVwiLFwic3F1ZlwiOlwiXFx1MjVBQVwiLFwic3JhcnJcIjpcIlxcdTIxOTJcIixcIlNzY3JcIjpcIlxcdUQ4MzVcXHVEQ0FFXCIsXCJzc2NyXCI6XCJcXHVEODM1XFx1RENDOFwiLFwic3NldG1uXCI6XCJcXHUyMjE2XCIsXCJzc21pbGVcIjpcIlxcdTIzMjNcIixcInNzdGFyZlwiOlwiXFx1MjJDNlwiLFwiU3RhclwiOlwiXFx1MjJDNlwiLFwic3RhclwiOlwiXFx1MjYwNlwiLFwic3RhcmZcIjpcIlxcdTI2MDVcIixcInN0cmFpZ2h0ZXBzaWxvblwiOlwiXFx1MDNGNVwiLFwic3RyYWlnaHRwaGlcIjpcIlxcdTAzRDVcIixcInN0cm5zXCI6XCJcXHhBRlwiLFwic3ViXCI6XCJcXHUyMjgyXCIsXCJTdWJcIjpcIlxcdTIyRDBcIixcInN1YmRvdFwiOlwiXFx1MkFCRFwiLFwic3ViRVwiOlwiXFx1MkFDNVwiLFwic3ViZVwiOlwiXFx1MjI4NlwiLFwic3ViZWRvdFwiOlwiXFx1MkFDM1wiLFwic3VibXVsdFwiOlwiXFx1MkFDMVwiLFwic3VibkVcIjpcIlxcdTJBQ0JcIixcInN1Ym5lXCI6XCJcXHUyMjhBXCIsXCJzdWJwbHVzXCI6XCJcXHUyQUJGXCIsXCJzdWJyYXJyXCI6XCJcXHUyOTc5XCIsXCJzdWJzZXRcIjpcIlxcdTIyODJcIixcIlN1YnNldFwiOlwiXFx1MjJEMFwiLFwic3Vic2V0ZXFcIjpcIlxcdTIyODZcIixcInN1YnNldGVxcVwiOlwiXFx1MkFDNVwiLFwiU3Vic2V0RXF1YWxcIjpcIlxcdTIyODZcIixcInN1YnNldG5lcVwiOlwiXFx1MjI4QVwiLFwic3Vic2V0bmVxcVwiOlwiXFx1MkFDQlwiLFwic3Vic2ltXCI6XCJcXHUyQUM3XCIsXCJzdWJzdWJcIjpcIlxcdTJBRDVcIixcInN1YnN1cFwiOlwiXFx1MkFEM1wiLFwic3VjY2FwcHJveFwiOlwiXFx1MkFCOFwiLFwic3VjY1wiOlwiXFx1MjI3QlwiLFwic3VjY2N1cmx5ZXFcIjpcIlxcdTIyN0RcIixcIlN1Y2NlZWRzXCI6XCJcXHUyMjdCXCIsXCJTdWNjZWVkc0VxdWFsXCI6XCJcXHUyQUIwXCIsXCJTdWNjZWVkc1NsYW50RXF1YWxcIjpcIlxcdTIyN0RcIixcIlN1Y2NlZWRzVGlsZGVcIjpcIlxcdTIyN0ZcIixcInN1Y2NlcVwiOlwiXFx1MkFCMFwiLFwic3VjY25hcHByb3hcIjpcIlxcdTJBQkFcIixcInN1Y2NuZXFxXCI6XCJcXHUyQUI2XCIsXCJzdWNjbnNpbVwiOlwiXFx1MjJFOVwiLFwic3VjY3NpbVwiOlwiXFx1MjI3RlwiLFwiU3VjaFRoYXRcIjpcIlxcdTIyMEJcIixcInN1bVwiOlwiXFx1MjIxMVwiLFwiU3VtXCI6XCJcXHUyMjExXCIsXCJzdW5nXCI6XCJcXHUyNjZBXCIsXCJzdXAxXCI6XCJcXHhCOVwiLFwic3VwMlwiOlwiXFx4QjJcIixcInN1cDNcIjpcIlxceEIzXCIsXCJzdXBcIjpcIlxcdTIyODNcIixcIlN1cFwiOlwiXFx1MjJEMVwiLFwic3VwZG90XCI6XCJcXHUyQUJFXCIsXCJzdXBkc3ViXCI6XCJcXHUyQUQ4XCIsXCJzdXBFXCI6XCJcXHUyQUM2XCIsXCJzdXBlXCI6XCJcXHUyMjg3XCIsXCJzdXBlZG90XCI6XCJcXHUyQUM0XCIsXCJTdXBlcnNldFwiOlwiXFx1MjI4M1wiLFwiU3VwZXJzZXRFcXVhbFwiOlwiXFx1MjI4N1wiLFwic3VwaHNvbFwiOlwiXFx1MjdDOVwiLFwic3VwaHN1YlwiOlwiXFx1MkFEN1wiLFwic3VwbGFyclwiOlwiXFx1Mjk3QlwiLFwic3VwbXVsdFwiOlwiXFx1MkFDMlwiLFwic3VwbkVcIjpcIlxcdTJBQ0NcIixcInN1cG5lXCI6XCJcXHUyMjhCXCIsXCJzdXBwbHVzXCI6XCJcXHUyQUMwXCIsXCJzdXBzZXRcIjpcIlxcdTIyODNcIixcIlN1cHNldFwiOlwiXFx1MjJEMVwiLFwic3Vwc2V0ZXFcIjpcIlxcdTIyODdcIixcInN1cHNldGVxcVwiOlwiXFx1MkFDNlwiLFwic3Vwc2V0bmVxXCI6XCJcXHUyMjhCXCIsXCJzdXBzZXRuZXFxXCI6XCJcXHUyQUNDXCIsXCJzdXBzaW1cIjpcIlxcdTJBQzhcIixcInN1cHN1YlwiOlwiXFx1MkFENFwiLFwic3Vwc3VwXCI6XCJcXHUyQUQ2XCIsXCJzd2FyaGtcIjpcIlxcdTI5MjZcIixcInN3YXJyXCI6XCJcXHUyMTk5XCIsXCJzd0FyclwiOlwiXFx1MjFEOVwiLFwic3dhcnJvd1wiOlwiXFx1MjE5OVwiLFwic3dud2FyXCI6XCJcXHUyOTJBXCIsXCJzemxpZ1wiOlwiXFx4REZcIixcIlRhYlwiOlwiXFx0XCIsXCJ0YXJnZXRcIjpcIlxcdTIzMTZcIixcIlRhdVwiOlwiXFx1MDNBNFwiLFwidGF1XCI6XCJcXHUwM0M0XCIsXCJ0YnJrXCI6XCJcXHUyM0I0XCIsXCJUY2Fyb25cIjpcIlxcdTAxNjRcIixcInRjYXJvblwiOlwiXFx1MDE2NVwiLFwiVGNlZGlsXCI6XCJcXHUwMTYyXCIsXCJ0Y2VkaWxcIjpcIlxcdTAxNjNcIixcIlRjeVwiOlwiXFx1MDQyMlwiLFwidGN5XCI6XCJcXHUwNDQyXCIsXCJ0ZG90XCI6XCJcXHUyMERCXCIsXCJ0ZWxyZWNcIjpcIlxcdTIzMTVcIixcIlRmclwiOlwiXFx1RDgzNVxcdUREMTdcIixcInRmclwiOlwiXFx1RDgzNVxcdUREMzFcIixcInRoZXJlNFwiOlwiXFx1MjIzNFwiLFwidGhlcmVmb3JlXCI6XCJcXHUyMjM0XCIsXCJUaGVyZWZvcmVcIjpcIlxcdTIyMzRcIixcIlRoZXRhXCI6XCJcXHUwMzk4XCIsXCJ0aGV0YVwiOlwiXFx1MDNCOFwiLFwidGhldGFzeW1cIjpcIlxcdTAzRDFcIixcInRoZXRhdlwiOlwiXFx1MDNEMVwiLFwidGhpY2thcHByb3hcIjpcIlxcdTIyNDhcIixcInRoaWNrc2ltXCI6XCJcXHUyMjNDXCIsXCJUaGlja1NwYWNlXCI6XCJcXHUyMDVGXFx1MjAwQVwiLFwiVGhpblNwYWNlXCI6XCJcXHUyMDA5XCIsXCJ0aGluc3BcIjpcIlxcdTIwMDlcIixcInRoa2FwXCI6XCJcXHUyMjQ4XCIsXCJ0aGtzaW1cIjpcIlxcdTIyM0NcIixcIlRIT1JOXCI6XCJcXHhERVwiLFwidGhvcm5cIjpcIlxceEZFXCIsXCJ0aWxkZVwiOlwiXFx1MDJEQ1wiLFwiVGlsZGVcIjpcIlxcdTIyM0NcIixcIlRpbGRlRXF1YWxcIjpcIlxcdTIyNDNcIixcIlRpbGRlRnVsbEVxdWFsXCI6XCJcXHUyMjQ1XCIsXCJUaWxkZVRpbGRlXCI6XCJcXHUyMjQ4XCIsXCJ0aW1lc2JhclwiOlwiXFx1MkEzMVwiLFwidGltZXNiXCI6XCJcXHUyMkEwXCIsXCJ0aW1lc1wiOlwiXFx4RDdcIixcInRpbWVzZFwiOlwiXFx1MkEzMFwiLFwidGludFwiOlwiXFx1MjIyRFwiLFwidG9lYVwiOlwiXFx1MjkyOFwiLFwidG9wYm90XCI6XCJcXHUyMzM2XCIsXCJ0b3BjaXJcIjpcIlxcdTJBRjFcIixcInRvcFwiOlwiXFx1MjJBNFwiLFwiVG9wZlwiOlwiXFx1RDgzNVxcdURENEJcIixcInRvcGZcIjpcIlxcdUQ4MzVcXHVERDY1XCIsXCJ0b3Bmb3JrXCI6XCJcXHUyQURBXCIsXCJ0b3NhXCI6XCJcXHUyOTI5XCIsXCJ0cHJpbWVcIjpcIlxcdTIwMzRcIixcInRyYWRlXCI6XCJcXHUyMTIyXCIsXCJUUkFERVwiOlwiXFx1MjEyMlwiLFwidHJpYW5nbGVcIjpcIlxcdTI1QjVcIixcInRyaWFuZ2xlZG93blwiOlwiXFx1MjVCRlwiLFwidHJpYW5nbGVsZWZ0XCI6XCJcXHUyNUMzXCIsXCJ0cmlhbmdsZWxlZnRlcVwiOlwiXFx1MjJCNFwiLFwidHJpYW5nbGVxXCI6XCJcXHUyMjVDXCIsXCJ0cmlhbmdsZXJpZ2h0XCI6XCJcXHUyNUI5XCIsXCJ0cmlhbmdsZXJpZ2h0ZXFcIjpcIlxcdTIyQjVcIixcInRyaWRvdFwiOlwiXFx1MjVFQ1wiLFwidHJpZVwiOlwiXFx1MjI1Q1wiLFwidHJpbWludXNcIjpcIlxcdTJBM0FcIixcIlRyaXBsZURvdFwiOlwiXFx1MjBEQlwiLFwidHJpcGx1c1wiOlwiXFx1MkEzOVwiLFwidHJpc2JcIjpcIlxcdTI5Q0RcIixcInRyaXRpbWVcIjpcIlxcdTJBM0JcIixcInRycGV6aXVtXCI6XCJcXHUyM0UyXCIsXCJUc2NyXCI6XCJcXHVEODM1XFx1RENBRlwiLFwidHNjclwiOlwiXFx1RDgzNVxcdURDQzlcIixcIlRTY3lcIjpcIlxcdTA0MjZcIixcInRzY3lcIjpcIlxcdTA0NDZcIixcIlRTSGN5XCI6XCJcXHUwNDBCXCIsXCJ0c2hjeVwiOlwiXFx1MDQ1QlwiLFwiVHN0cm9rXCI6XCJcXHUwMTY2XCIsXCJ0c3Ryb2tcIjpcIlxcdTAxNjdcIixcInR3aXh0XCI6XCJcXHUyMjZDXCIsXCJ0d29oZWFkbGVmdGFycm93XCI6XCJcXHUyMTlFXCIsXCJ0d29oZWFkcmlnaHRhcnJvd1wiOlwiXFx1MjFBMFwiLFwiVWFjdXRlXCI6XCJcXHhEQVwiLFwidWFjdXRlXCI6XCJcXHhGQVwiLFwidWFyclwiOlwiXFx1MjE5MVwiLFwiVWFyclwiOlwiXFx1MjE5RlwiLFwidUFyclwiOlwiXFx1MjFEMVwiLFwiVWFycm9jaXJcIjpcIlxcdTI5NDlcIixcIlVicmN5XCI6XCJcXHUwNDBFXCIsXCJ1YnJjeVwiOlwiXFx1MDQ1RVwiLFwiVWJyZXZlXCI6XCJcXHUwMTZDXCIsXCJ1YnJldmVcIjpcIlxcdTAxNkRcIixcIlVjaXJjXCI6XCJcXHhEQlwiLFwidWNpcmNcIjpcIlxceEZCXCIsXCJVY3lcIjpcIlxcdTA0MjNcIixcInVjeVwiOlwiXFx1MDQ0M1wiLFwidWRhcnJcIjpcIlxcdTIxQzVcIixcIlVkYmxhY1wiOlwiXFx1MDE3MFwiLFwidWRibGFjXCI6XCJcXHUwMTcxXCIsXCJ1ZGhhclwiOlwiXFx1Mjk2RVwiLFwidWZpc2h0XCI6XCJcXHUyOTdFXCIsXCJVZnJcIjpcIlxcdUQ4MzVcXHVERDE4XCIsXCJ1ZnJcIjpcIlxcdUQ4MzVcXHVERDMyXCIsXCJVZ3JhdmVcIjpcIlxceEQ5XCIsXCJ1Z3JhdmVcIjpcIlxceEY5XCIsXCJ1SGFyXCI6XCJcXHUyOTYzXCIsXCJ1aGFybFwiOlwiXFx1MjFCRlwiLFwidWhhcnJcIjpcIlxcdTIxQkVcIixcInVoYmxrXCI6XCJcXHUyNTgwXCIsXCJ1bGNvcm5cIjpcIlxcdTIzMUNcIixcInVsY29ybmVyXCI6XCJcXHUyMzFDXCIsXCJ1bGNyb3BcIjpcIlxcdTIzMEZcIixcInVsdHJpXCI6XCJcXHUyNUY4XCIsXCJVbWFjclwiOlwiXFx1MDE2QVwiLFwidW1hY3JcIjpcIlxcdTAxNkJcIixcInVtbFwiOlwiXFx4QThcIixcIlVuZGVyQmFyXCI6XCJfXCIsXCJVbmRlckJyYWNlXCI6XCJcXHUyM0RGXCIsXCJVbmRlckJyYWNrZXRcIjpcIlxcdTIzQjVcIixcIlVuZGVyUGFyZW50aGVzaXNcIjpcIlxcdTIzRERcIixcIlVuaW9uXCI6XCJcXHUyMkMzXCIsXCJVbmlvblBsdXNcIjpcIlxcdTIyOEVcIixcIlVvZ29uXCI6XCJcXHUwMTcyXCIsXCJ1b2dvblwiOlwiXFx1MDE3M1wiLFwiVW9wZlwiOlwiXFx1RDgzNVxcdURENENcIixcInVvcGZcIjpcIlxcdUQ4MzVcXHVERDY2XCIsXCJVcEFycm93QmFyXCI6XCJcXHUyOTEyXCIsXCJ1cGFycm93XCI6XCJcXHUyMTkxXCIsXCJVcEFycm93XCI6XCJcXHUyMTkxXCIsXCJVcGFycm93XCI6XCJcXHUyMUQxXCIsXCJVcEFycm93RG93bkFycm93XCI6XCJcXHUyMUM1XCIsXCJ1cGRvd25hcnJvd1wiOlwiXFx1MjE5NVwiLFwiVXBEb3duQXJyb3dcIjpcIlxcdTIxOTVcIixcIlVwZG93bmFycm93XCI6XCJcXHUyMUQ1XCIsXCJVcEVxdWlsaWJyaXVtXCI6XCJcXHUyOTZFXCIsXCJ1cGhhcnBvb25sZWZ0XCI6XCJcXHUyMUJGXCIsXCJ1cGhhcnBvb25yaWdodFwiOlwiXFx1MjFCRVwiLFwidXBsdXNcIjpcIlxcdTIyOEVcIixcIlVwcGVyTGVmdEFycm93XCI6XCJcXHUyMTk2XCIsXCJVcHBlclJpZ2h0QXJyb3dcIjpcIlxcdTIxOTdcIixcInVwc2lcIjpcIlxcdTAzQzVcIixcIlVwc2lcIjpcIlxcdTAzRDJcIixcInVwc2loXCI6XCJcXHUwM0QyXCIsXCJVcHNpbG9uXCI6XCJcXHUwM0E1XCIsXCJ1cHNpbG9uXCI6XCJcXHUwM0M1XCIsXCJVcFRlZUFycm93XCI6XCJcXHUyMUE1XCIsXCJVcFRlZVwiOlwiXFx1MjJBNVwiLFwidXB1cGFycm93c1wiOlwiXFx1MjFDOFwiLFwidXJjb3JuXCI6XCJcXHUyMzFEXCIsXCJ1cmNvcm5lclwiOlwiXFx1MjMxRFwiLFwidXJjcm9wXCI6XCJcXHUyMzBFXCIsXCJVcmluZ1wiOlwiXFx1MDE2RVwiLFwidXJpbmdcIjpcIlxcdTAxNkZcIixcInVydHJpXCI6XCJcXHUyNUY5XCIsXCJVc2NyXCI6XCJcXHVEODM1XFx1RENCMFwiLFwidXNjclwiOlwiXFx1RDgzNVxcdURDQ0FcIixcInV0ZG90XCI6XCJcXHUyMkYwXCIsXCJVdGlsZGVcIjpcIlxcdTAxNjhcIixcInV0aWxkZVwiOlwiXFx1MDE2OVwiLFwidXRyaVwiOlwiXFx1MjVCNVwiLFwidXRyaWZcIjpcIlxcdTI1QjRcIixcInV1YXJyXCI6XCJcXHUyMUM4XCIsXCJVdW1sXCI6XCJcXHhEQ1wiLFwidXVtbFwiOlwiXFx4RkNcIixcInV3YW5nbGVcIjpcIlxcdTI5QTdcIixcInZhbmdydFwiOlwiXFx1Mjk5Q1wiLFwidmFyZXBzaWxvblwiOlwiXFx1MDNGNVwiLFwidmFya2FwcGFcIjpcIlxcdTAzRjBcIixcInZhcm5vdGhpbmdcIjpcIlxcdTIyMDVcIixcInZhcnBoaVwiOlwiXFx1MDNENVwiLFwidmFycGlcIjpcIlxcdTAzRDZcIixcInZhcnByb3B0b1wiOlwiXFx1MjIxRFwiLFwidmFyclwiOlwiXFx1MjE5NVwiLFwidkFyclwiOlwiXFx1MjFENVwiLFwidmFycmhvXCI6XCJcXHUwM0YxXCIsXCJ2YXJzaWdtYVwiOlwiXFx1MDNDMlwiLFwidmFyc3Vic2V0bmVxXCI6XCJcXHUyMjhBXFx1RkUwMFwiLFwidmFyc3Vic2V0bmVxcVwiOlwiXFx1MkFDQlxcdUZFMDBcIixcInZhcnN1cHNldG5lcVwiOlwiXFx1MjI4QlxcdUZFMDBcIixcInZhcnN1cHNldG5lcXFcIjpcIlxcdTJBQ0NcXHVGRTAwXCIsXCJ2YXJ0aGV0YVwiOlwiXFx1MDNEMVwiLFwidmFydHJpYW5nbGVsZWZ0XCI6XCJcXHUyMkIyXCIsXCJ2YXJ0cmlhbmdsZXJpZ2h0XCI6XCJcXHUyMkIzXCIsXCJ2QmFyXCI6XCJcXHUyQUU4XCIsXCJWYmFyXCI6XCJcXHUyQUVCXCIsXCJ2QmFydlwiOlwiXFx1MkFFOVwiLFwiVmN5XCI6XCJcXHUwNDEyXCIsXCJ2Y3lcIjpcIlxcdTA0MzJcIixcInZkYXNoXCI6XCJcXHUyMkEyXCIsXCJ2RGFzaFwiOlwiXFx1MjJBOFwiLFwiVmRhc2hcIjpcIlxcdTIyQTlcIixcIlZEYXNoXCI6XCJcXHUyMkFCXCIsXCJWZGFzaGxcIjpcIlxcdTJBRTZcIixcInZlZWJhclwiOlwiXFx1MjJCQlwiLFwidmVlXCI6XCJcXHUyMjI4XCIsXCJWZWVcIjpcIlxcdTIyQzFcIixcInZlZWVxXCI6XCJcXHUyMjVBXCIsXCJ2ZWxsaXBcIjpcIlxcdTIyRUVcIixcInZlcmJhclwiOlwifFwiLFwiVmVyYmFyXCI6XCJcXHUyMDE2XCIsXCJ2ZXJ0XCI6XCJ8XCIsXCJWZXJ0XCI6XCJcXHUyMDE2XCIsXCJWZXJ0aWNhbEJhclwiOlwiXFx1MjIyM1wiLFwiVmVydGljYWxMaW5lXCI6XCJ8XCIsXCJWZXJ0aWNhbFNlcGFyYXRvclwiOlwiXFx1Mjc1OFwiLFwiVmVydGljYWxUaWxkZVwiOlwiXFx1MjI0MFwiLFwiVmVyeVRoaW5TcGFjZVwiOlwiXFx1MjAwQVwiLFwiVmZyXCI6XCJcXHVEODM1XFx1REQxOVwiLFwidmZyXCI6XCJcXHVEODM1XFx1REQzM1wiLFwidmx0cmlcIjpcIlxcdTIyQjJcIixcInZuc3ViXCI6XCJcXHUyMjgyXFx1MjBEMlwiLFwidm5zdXBcIjpcIlxcdTIyODNcXHUyMEQyXCIsXCJWb3BmXCI6XCJcXHVEODM1XFx1REQ0RFwiLFwidm9wZlwiOlwiXFx1RDgzNVxcdURENjdcIixcInZwcm9wXCI6XCJcXHUyMjFEXCIsXCJ2cnRyaVwiOlwiXFx1MjJCM1wiLFwiVnNjclwiOlwiXFx1RDgzNVxcdURDQjFcIixcInZzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NCXCIsXCJ2c3VibkVcIjpcIlxcdTJBQ0JcXHVGRTAwXCIsXCJ2c3VibmVcIjpcIlxcdTIyOEFcXHVGRTAwXCIsXCJ2c3VwbkVcIjpcIlxcdTJBQ0NcXHVGRTAwXCIsXCJ2c3VwbmVcIjpcIlxcdTIyOEJcXHVGRTAwXCIsXCJWdmRhc2hcIjpcIlxcdTIyQUFcIixcInZ6aWd6YWdcIjpcIlxcdTI5OUFcIixcIldjaXJjXCI6XCJcXHUwMTc0XCIsXCJ3Y2lyY1wiOlwiXFx1MDE3NVwiLFwid2VkYmFyXCI6XCJcXHUyQTVGXCIsXCJ3ZWRnZVwiOlwiXFx1MjIyN1wiLFwiV2VkZ2VcIjpcIlxcdTIyQzBcIixcIndlZGdlcVwiOlwiXFx1MjI1OVwiLFwid2VpZXJwXCI6XCJcXHUyMTE4XCIsXCJXZnJcIjpcIlxcdUQ4MzVcXHVERDFBXCIsXCJ3ZnJcIjpcIlxcdUQ4MzVcXHVERDM0XCIsXCJXb3BmXCI6XCJcXHVEODM1XFx1REQ0RVwiLFwid29wZlwiOlwiXFx1RDgzNVxcdURENjhcIixcIndwXCI6XCJcXHUyMTE4XCIsXCJ3clwiOlwiXFx1MjI0MFwiLFwid3JlYXRoXCI6XCJcXHUyMjQwXCIsXCJXc2NyXCI6XCJcXHVEODM1XFx1RENCMlwiLFwid3NjclwiOlwiXFx1RDgzNVxcdURDQ0NcIixcInhjYXBcIjpcIlxcdTIyQzJcIixcInhjaXJjXCI6XCJcXHUyNUVGXCIsXCJ4Y3VwXCI6XCJcXHUyMkMzXCIsXCJ4ZHRyaVwiOlwiXFx1MjVCRFwiLFwiWGZyXCI6XCJcXHVEODM1XFx1REQxQlwiLFwieGZyXCI6XCJcXHVEODM1XFx1REQzNVwiLFwieGhhcnJcIjpcIlxcdTI3RjdcIixcInhoQXJyXCI6XCJcXHUyN0ZBXCIsXCJYaVwiOlwiXFx1MDM5RVwiLFwieGlcIjpcIlxcdTAzQkVcIixcInhsYXJyXCI6XCJcXHUyN0Y1XCIsXCJ4bEFyclwiOlwiXFx1MjdGOFwiLFwieG1hcFwiOlwiXFx1MjdGQ1wiLFwieG5pc1wiOlwiXFx1MjJGQlwiLFwieG9kb3RcIjpcIlxcdTJBMDBcIixcIlhvcGZcIjpcIlxcdUQ4MzVcXHVERDRGXCIsXCJ4b3BmXCI6XCJcXHVEODM1XFx1REQ2OVwiLFwieG9wbHVzXCI6XCJcXHUyQTAxXCIsXCJ4b3RpbWVcIjpcIlxcdTJBMDJcIixcInhyYXJyXCI6XCJcXHUyN0Y2XCIsXCJ4ckFyclwiOlwiXFx1MjdGOVwiLFwiWHNjclwiOlwiXFx1RDgzNVxcdURDQjNcIixcInhzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NEXCIsXCJ4c3FjdXBcIjpcIlxcdTJBMDZcIixcInh1cGx1c1wiOlwiXFx1MkEwNFwiLFwieHV0cmlcIjpcIlxcdTI1QjNcIixcInh2ZWVcIjpcIlxcdTIyQzFcIixcInh3ZWRnZVwiOlwiXFx1MjJDMFwiLFwiWWFjdXRlXCI6XCJcXHhERFwiLFwieWFjdXRlXCI6XCJcXHhGRFwiLFwiWUFjeVwiOlwiXFx1MDQyRlwiLFwieWFjeVwiOlwiXFx1MDQ0RlwiLFwiWWNpcmNcIjpcIlxcdTAxNzZcIixcInljaXJjXCI6XCJcXHUwMTc3XCIsXCJZY3lcIjpcIlxcdTA0MkJcIixcInljeVwiOlwiXFx1MDQ0QlwiLFwieWVuXCI6XCJcXHhBNVwiLFwiWWZyXCI6XCJcXHVEODM1XFx1REQxQ1wiLFwieWZyXCI6XCJcXHVEODM1XFx1REQzNlwiLFwiWUljeVwiOlwiXFx1MDQwN1wiLFwieWljeVwiOlwiXFx1MDQ1N1wiLFwiWW9wZlwiOlwiXFx1RDgzNVxcdURENTBcIixcInlvcGZcIjpcIlxcdUQ4MzVcXHVERDZBXCIsXCJZc2NyXCI6XCJcXHVEODM1XFx1RENCNFwiLFwieXNjclwiOlwiXFx1RDgzNVxcdURDQ0VcIixcIllVY3lcIjpcIlxcdTA0MkVcIixcInl1Y3lcIjpcIlxcdTA0NEVcIixcInl1bWxcIjpcIlxceEZGXCIsXCJZdW1sXCI6XCJcXHUwMTc4XCIsXCJaYWN1dGVcIjpcIlxcdTAxNzlcIixcInphY3V0ZVwiOlwiXFx1MDE3QVwiLFwiWmNhcm9uXCI6XCJcXHUwMTdEXCIsXCJ6Y2Fyb25cIjpcIlxcdTAxN0VcIixcIlpjeVwiOlwiXFx1MDQxN1wiLFwiemN5XCI6XCJcXHUwNDM3XCIsXCJaZG90XCI6XCJcXHUwMTdCXCIsXCJ6ZG90XCI6XCJcXHUwMTdDXCIsXCJ6ZWV0cmZcIjpcIlxcdTIxMjhcIixcIlplcm9XaWR0aFNwYWNlXCI6XCJcXHUyMDBCXCIsXCJaZXRhXCI6XCJcXHUwMzk2XCIsXCJ6ZXRhXCI6XCJcXHUwM0I2XCIsXCJ6ZnJcIjpcIlxcdUQ4MzVcXHVERDM3XCIsXCJaZnJcIjpcIlxcdTIxMjhcIixcIlpIY3lcIjpcIlxcdTA0MTZcIixcInpoY3lcIjpcIlxcdTA0MzZcIixcInppZ3JhcnJcIjpcIlxcdTIxRERcIixcInpvcGZcIjpcIlxcdUQ4MzVcXHVERDZCXCIsXCJab3BmXCI6XCJcXHUyMTI0XCIsXCJac2NyXCI6XCJcXHVEODM1XFx1RENCNVwiLFwienNjclwiOlwiXFx1RDgzNVxcdURDQ0ZcIixcInp3alwiOlwiXFx1MjAwRFwiLFwiendualwiOlwiXFx1MjAwQ1wifTt9LHt9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9e1wiQWFjdXRlXCI6XCJcXHhDMVwiLFwiYWFjdXRlXCI6XCJcXHhFMVwiLFwiQWNpcmNcIjpcIlxceEMyXCIsXCJhY2lyY1wiOlwiXFx4RTJcIixcImFjdXRlXCI6XCJcXHhCNFwiLFwiQUVsaWdcIjpcIlxceEM2XCIsXCJhZWxpZ1wiOlwiXFx4RTZcIixcIkFncmF2ZVwiOlwiXFx4QzBcIixcImFncmF2ZVwiOlwiXFx4RTBcIixcImFtcFwiOlwiJlwiLFwiQU1QXCI6XCImXCIsXCJBcmluZ1wiOlwiXFx4QzVcIixcImFyaW5nXCI6XCJcXHhFNVwiLFwiQXRpbGRlXCI6XCJcXHhDM1wiLFwiYXRpbGRlXCI6XCJcXHhFM1wiLFwiQXVtbFwiOlwiXFx4QzRcIixcImF1bWxcIjpcIlxceEU0XCIsXCJicnZiYXJcIjpcIlxceEE2XCIsXCJDY2VkaWxcIjpcIlxceEM3XCIsXCJjY2VkaWxcIjpcIlxceEU3XCIsXCJjZWRpbFwiOlwiXFx4QjhcIixcImNlbnRcIjpcIlxceEEyXCIsXCJjb3B5XCI6XCJcXHhBOVwiLFwiQ09QWVwiOlwiXFx4QTlcIixcImN1cnJlblwiOlwiXFx4QTRcIixcImRlZ1wiOlwiXFx4QjBcIixcImRpdmlkZVwiOlwiXFx4RjdcIixcIkVhY3V0ZVwiOlwiXFx4QzlcIixcImVhY3V0ZVwiOlwiXFx4RTlcIixcIkVjaXJjXCI6XCJcXHhDQVwiLFwiZWNpcmNcIjpcIlxceEVBXCIsXCJFZ3JhdmVcIjpcIlxceEM4XCIsXCJlZ3JhdmVcIjpcIlxceEU4XCIsXCJFVEhcIjpcIlxceEQwXCIsXCJldGhcIjpcIlxceEYwXCIsXCJFdW1sXCI6XCJcXHhDQlwiLFwiZXVtbFwiOlwiXFx4RUJcIixcImZyYWMxMlwiOlwiXFx4QkRcIixcImZyYWMxNFwiOlwiXFx4QkNcIixcImZyYWMzNFwiOlwiXFx4QkVcIixcImd0XCI6XCI+XCIsXCJHVFwiOlwiPlwiLFwiSWFjdXRlXCI6XCJcXHhDRFwiLFwiaWFjdXRlXCI6XCJcXHhFRFwiLFwiSWNpcmNcIjpcIlxceENFXCIsXCJpY2lyY1wiOlwiXFx4RUVcIixcImlleGNsXCI6XCJcXHhBMVwiLFwiSWdyYXZlXCI6XCJcXHhDQ1wiLFwiaWdyYXZlXCI6XCJcXHhFQ1wiLFwiaXF1ZXN0XCI6XCJcXHhCRlwiLFwiSXVtbFwiOlwiXFx4Q0ZcIixcIml1bWxcIjpcIlxceEVGXCIsXCJsYXF1b1wiOlwiXFx4QUJcIixcImx0XCI6XCI8XCIsXCJMVFwiOlwiPFwiLFwibWFjclwiOlwiXFx4QUZcIixcIm1pY3JvXCI6XCJcXHhCNVwiLFwibWlkZG90XCI6XCJcXHhCN1wiLFwibmJzcFwiOlwiXFx4QTBcIixcIm5vdFwiOlwiXFx4QUNcIixcIk50aWxkZVwiOlwiXFx4RDFcIixcIm50aWxkZVwiOlwiXFx4RjFcIixcIk9hY3V0ZVwiOlwiXFx4RDNcIixcIm9hY3V0ZVwiOlwiXFx4RjNcIixcIk9jaXJjXCI6XCJcXHhENFwiLFwib2NpcmNcIjpcIlxceEY0XCIsXCJPZ3JhdmVcIjpcIlxceEQyXCIsXCJvZ3JhdmVcIjpcIlxceEYyXCIsXCJvcmRmXCI6XCJcXHhBQVwiLFwib3JkbVwiOlwiXFx4QkFcIixcIk9zbGFzaFwiOlwiXFx4RDhcIixcIm9zbGFzaFwiOlwiXFx4RjhcIixcIk90aWxkZVwiOlwiXFx4RDVcIixcIm90aWxkZVwiOlwiXFx4RjVcIixcIk91bWxcIjpcIlxceEQ2XCIsXCJvdW1sXCI6XCJcXHhGNlwiLFwicGFyYVwiOlwiXFx4QjZcIixcInBsdXNtblwiOlwiXFx4QjFcIixcInBvdW5kXCI6XCJcXHhBM1wiLFwicXVvdFwiOlwiXFxcIlwiLFwiUVVPVFwiOlwiXFxcIlwiLFwicmFxdW9cIjpcIlxceEJCXCIsXCJyZWdcIjpcIlxceEFFXCIsXCJSRUdcIjpcIlxceEFFXCIsXCJzZWN0XCI6XCJcXHhBN1wiLFwic2h5XCI6XCJcXHhBRFwiLFwic3VwMVwiOlwiXFx4QjlcIixcInN1cDJcIjpcIlxceEIyXCIsXCJzdXAzXCI6XCJcXHhCM1wiLFwic3psaWdcIjpcIlxceERGXCIsXCJUSE9STlwiOlwiXFx4REVcIixcInRob3JuXCI6XCJcXHhGRVwiLFwidGltZXNcIjpcIlxceEQ3XCIsXCJVYWN1dGVcIjpcIlxceERBXCIsXCJ1YWN1dGVcIjpcIlxceEZBXCIsXCJVY2lyY1wiOlwiXFx4REJcIixcInVjaXJjXCI6XCJcXHhGQlwiLFwiVWdyYXZlXCI6XCJcXHhEOVwiLFwidWdyYXZlXCI6XCJcXHhGOVwiLFwidW1sXCI6XCJcXHhBOFwiLFwiVXVtbFwiOlwiXFx4RENcIixcInV1bWxcIjpcIlxceEZDXCIsXCJZYWN1dGVcIjpcIlxceEREXCIsXCJ5YWN1dGVcIjpcIlxceEZEXCIsXCJ5ZW5cIjpcIlxceEE1XCIsXCJ5dW1sXCI6XCJcXHhGRlwifTt9LHt9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9e1wiYW1wXCI6XCImXCIsXCJhcG9zXCI6XCInXCIsXCJndFwiOlwiPlwiLFwibHRcIjpcIjxcIixcInF1b3RcIjpcIlxcXCJcIn07fSx7fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxudmFyIG9iamVjdENyZWF0ZT1PYmplY3QuY3JlYXRlfHxvYmplY3RDcmVhdGVQb2x5ZmlsbDt2YXIgb2JqZWN0S2V5cz1PYmplY3Qua2V5c3x8b2JqZWN0S2V5c1BvbHlmaWxsO3ZhciBiaW5kPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kfHxmdW5jdGlvbkJpbmRQb2x5ZmlsbDtmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKXtpZighdGhpcy5fZXZlbnRzfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsJ19ldmVudHMnKSl7dGhpcy5fZXZlbnRzPW9iamVjdENyZWF0ZShudWxsKTt0aGlzLl9ldmVudHNDb3VudD0wO310aGlzLl9tYXhMaXN0ZW5lcnM9dGhpcy5fbWF4TGlzdGVuZXJzfHx1bmRlZmluZWQ7fW1vZHVsZS5leHBvcnRzPUV2ZW50RW1pdHRlcjsvLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXI9RXZlbnRFbWl0dGVyO0V2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cz11bmRlZmluZWQ7RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXVuZGVmaW5lZDsvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycz0xMDt2YXIgaGFzRGVmaW5lUHJvcGVydHk7dHJ5e3ZhciBvPXt9O2lmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlPYmplY3QuZGVmaW5lUHJvcGVydHkobywneCcse3ZhbHVlOjB9KTtoYXNEZWZpbmVQcm9wZXJ0eT1vLng9PT0wO31jYXRjaChlcnIpe2hhc0RlZmluZVByb3BlcnR5PWZhbHNlO31pZihoYXNEZWZpbmVQcm9wZXJ0eSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwnZGVmYXVsdE1heExpc3RlbmVycycse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7fSxzZXQ6ZnVuY3Rpb24gc2V0KGFyZyl7Ly8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3Jcbi8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG5pZih0eXBlb2YgYXJnIT09J251bWJlcid8fGFyZzwwfHxhcmchPT1hcmcpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO2RlZmF1bHRNYXhMaXN0ZW5lcnM9YXJnO319KTt9ZWxzZXtFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycz1kZWZhdWx0TWF4TGlzdGVuZXJzO30vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnM9ZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pe2lmKHR5cGVvZiBuIT09J251bWJlcid8fG48MHx8aXNOYU4obikpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO3RoaXMuX21heExpc3RlbmVycz1uO3JldHVybiB0aGlzO307ZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KXtpZih0aGF0Ll9tYXhMaXN0ZW5lcnM9PT11bmRlZmluZWQpcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO3JldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7fUV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpe3JldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO307Ly8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsaXNGbixzZWxmKXtpZihpc0ZuKWhhbmRsZXIuY2FsbChzZWxmKTtlbHNle3ZhciBsZW49aGFuZGxlci5sZW5ndGg7dmFyIGxpc3RlbmVycz1hcnJheUNsb25lKGhhbmRsZXIsbGVuKTtmb3IodmFyIGk9MDtpPGxlbjsrK2kpe2xpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO319fWZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlcixpc0ZuLHNlbGYsYXJnMSl7aWYoaXNGbiloYW5kbGVyLmNhbGwoc2VsZixhcmcxKTtlbHNle3ZhciBsZW49aGFuZGxlci5sZW5ndGg7dmFyIGxpc3RlbmVycz1hcnJheUNsb25lKGhhbmRsZXIsbGVuKTtmb3IodmFyIGk9MDtpPGxlbjsrK2kpe2xpc3RlbmVyc1tpXS5jYWxsKHNlbGYsYXJnMSk7fX19ZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLGlzRm4sc2VsZixhcmcxLGFyZzIpe2lmKGlzRm4paGFuZGxlci5jYWxsKHNlbGYsYXJnMSxhcmcyKTtlbHNle3ZhciBsZW49aGFuZGxlci5sZW5ndGg7dmFyIGxpc3RlbmVycz1hcnJheUNsb25lKGhhbmRsZXIsbGVuKTtmb3IodmFyIGk9MDtpPGxlbjsrK2kpe2xpc3RlbmVyc1tpXS5jYWxsKHNlbGYsYXJnMSxhcmcyKTt9fX1mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlcixpc0ZuLHNlbGYsYXJnMSxhcmcyLGFyZzMpe2lmKGlzRm4paGFuZGxlci5jYWxsKHNlbGYsYXJnMSxhcmcyLGFyZzMpO2Vsc2V7dmFyIGxlbj1oYW5kbGVyLmxlbmd0aDt2YXIgbGlzdGVuZXJzPWFycmF5Q2xvbmUoaGFuZGxlcixsZW4pO2Zvcih2YXIgaT0wO2k8bGVuOysraSl7bGlzdGVuZXJzW2ldLmNhbGwoc2VsZixhcmcxLGFyZzIsYXJnMyk7fX19ZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlcixpc0ZuLHNlbGYsYXJncyl7aWYoaXNGbiloYW5kbGVyLmFwcGx5KHNlbGYsYXJncyk7ZWxzZXt2YXIgbGVuPWhhbmRsZXIubGVuZ3RoO3ZhciBsaXN0ZW5lcnM9YXJyYXlDbG9uZShoYW5kbGVyLGxlbik7Zm9yKHZhciBpPTA7aTxsZW47KytpKXtsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZixhcmdzKTt9fX1FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24gZW1pdCh0eXBlKXt2YXIgZXIsaGFuZGxlcixsZW4sYXJncyxpLGV2ZW50czt2YXIgZG9FcnJvcj10eXBlPT09J2Vycm9yJztldmVudHM9dGhpcy5fZXZlbnRzO2lmKGV2ZW50cylkb0Vycm9yPWRvRXJyb3ImJmV2ZW50cy5lcnJvcj09bnVsbDtlbHNlIGlmKCFkb0Vycm9yKXJldHVybiBmYWxzZTsvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG5pZihkb0Vycm9yKXtpZihhcmd1bWVudHMubGVuZ3RoPjEpZXI9YXJndW1lbnRzWzFdO2lmKGVyIGluc3RhbmNlb2YgRXJyb3Ipe3Rocm93IGVyOy8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG59ZWxzZXsvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG52YXIgZXJyPW5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcrZXIrJyknKTtlcnIuY29udGV4dD1lcjt0aHJvdyBlcnI7fXJldHVybiBmYWxzZTt9aGFuZGxlcj1ldmVudHNbdHlwZV07aWYoIWhhbmRsZXIpcmV0dXJuIGZhbHNlO3ZhciBpc0ZuPXR5cGVvZiBoYW5kbGVyPT09J2Z1bmN0aW9uJztsZW49YXJndW1lbnRzLmxlbmd0aDtzd2l0Y2gobGVuKXsvLyBmYXN0IGNhc2VzXG5jYXNlIDE6ZW1pdE5vbmUoaGFuZGxlcixpc0ZuLHRoaXMpO2JyZWFrO2Nhc2UgMjplbWl0T25lKGhhbmRsZXIsaXNGbix0aGlzLGFyZ3VtZW50c1sxXSk7YnJlYWs7Y2FzZSAzOmVtaXRUd28oaGFuZGxlcixpc0ZuLHRoaXMsYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSk7YnJlYWs7Y2FzZSA0OmVtaXRUaHJlZShoYW5kbGVyLGlzRm4sdGhpcyxhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdLGFyZ3VtZW50c1szXSk7YnJlYWs7Ly8gc2xvd2VyXG5kZWZhdWx0OmFyZ3M9bmV3IEFycmF5KGxlbi0xKTtmb3IoaT0xO2k8bGVuO2krKyl7YXJnc1tpLTFdPWFyZ3VtZW50c1tpXTt9ZW1pdE1hbnkoaGFuZGxlcixpc0ZuLHRoaXMsYXJncyk7fXJldHVybiB0cnVlO307ZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCx0eXBlLGxpc3RlbmVyLHByZXBlbmQpe3ZhciBtO3ZhciBldmVudHM7dmFyIGV4aXN0aW5nO2lmKHR5cGVvZiBsaXN0ZW5lciE9PSdmdW5jdGlvbicpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO2V2ZW50cz10YXJnZXQuX2V2ZW50cztpZighZXZlbnRzKXtldmVudHM9dGFyZ2V0Ll9ldmVudHM9b2JqZWN0Q3JlYXRlKG51bGwpO3RhcmdldC5fZXZlbnRzQ291bnQ9MDt9ZWxzZXsvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuaWYoZXZlbnRzLm5ld0xpc3RlbmVyKXt0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLHR5cGUsbGlzdGVuZXIubGlzdGVuZXI/bGlzdGVuZXIubGlzdGVuZXI6bGlzdGVuZXIpOy8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbi8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbmV2ZW50cz10YXJnZXQuX2V2ZW50czt9ZXhpc3Rpbmc9ZXZlbnRzW3R5cGVdO31pZighZXhpc3Rpbmcpey8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuZXhpc3Rpbmc9ZXZlbnRzW3R5cGVdPWxpc3RlbmVyOysrdGFyZ2V0Ll9ldmVudHNDb3VudDt9ZWxzZXtpZih0eXBlb2YgZXhpc3Rpbmc9PT0nZnVuY3Rpb24nKXsvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbmV4aXN0aW5nPWV2ZW50c1t0eXBlXT1wcmVwZW5kP1tsaXN0ZW5lcixleGlzdGluZ106W2V4aXN0aW5nLGxpc3RlbmVyXTt9ZWxzZXsvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG5pZihwcmVwZW5kKXtleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTt9ZWxzZXtleGlzdGluZy5wdXNoKGxpc3RlbmVyKTt9fS8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG5pZighZXhpc3Rpbmcud2FybmVkKXttPSRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtpZihtJiZtPjAmJmV4aXN0aW5nLmxlbmd0aD5tKXtleGlzdGluZy53YXJuZWQ9dHJ1ZTt2YXIgdz1uZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJytleGlzdGluZy5sZW5ndGgrJyBcIicrU3RyaW5nKHR5cGUpKydcIiBsaXN0ZW5lcnMgJysnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcrJ2luY3JlYXNlIGxpbWl0LicpO3cubmFtZT0nTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJzt3LmVtaXR0ZXI9dGFyZ2V0O3cudHlwZT10eXBlO3cuY291bnQ9ZXhpc3RpbmcubGVuZ3RoO2lmKCh0eXBlb2YgY29uc29sZT09PVwidW5kZWZpbmVkXCI/XCJ1bmRlZmluZWRcIjpfdHlwZW9mKGNvbnNvbGUpKT09PSdvYmplY3QnJiZjb25zb2xlLndhcm4pe2NvbnNvbGUud2FybignJXM6ICVzJyx3Lm5hbWUsdy5tZXNzYWdlKTt9fX19cmV0dXJuIHRhcmdldDt9RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1mdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLGxpc3RlbmVyKXtyZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsdHlwZSxsaXN0ZW5lcixmYWxzZSk7fTtFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uPUV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXI9ZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsbGlzdGVuZXIpe3JldHVybiBfYWRkTGlzdGVuZXIodGhpcyx0eXBlLGxpc3RlbmVyLHRydWUpO307ZnVuY3Rpb24gb25jZVdyYXBwZXIoKXtpZighdGhpcy5maXJlZCl7dGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLHRoaXMud3JhcEZuKTt0aGlzLmZpcmVkPXRydWU7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtjYXNlIDE6cmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCxhcmd1bWVudHNbMF0pO2Nhc2UgMjpyZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pO2Nhc2UgMzpyZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKTtkZWZhdWx0OnZhciBhcmdzPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtmb3IodmFyIGk9MDtpPGFyZ3MubGVuZ3RoOysraSl7YXJnc1tpXT1hcmd1bWVudHNbaV07fXRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsYXJncyk7fX19ZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCx0eXBlLGxpc3RlbmVyKXt2YXIgc3RhdGU9e2ZpcmVkOmZhbHNlLHdyYXBGbjp1bmRlZmluZWQsdGFyZ2V0OnRhcmdldCx0eXBlOnR5cGUsbGlzdGVuZXI6bGlzdGVuZXJ9O3ZhciB3cmFwcGVkPWJpbmQuY2FsbChvbmNlV3JhcHBlcixzdGF0ZSk7d3JhcHBlZC5saXN0ZW5lcj1saXN0ZW5lcjtzdGF0ZS53cmFwRm49d3JhcHBlZDtyZXR1cm4gd3JhcHBlZDt9RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlPWZ1bmN0aW9uIG9uY2UodHlwZSxsaXN0ZW5lcil7aWYodHlwZW9mIGxpc3RlbmVyIT09J2Z1bmN0aW9uJyl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7dGhpcy5vbih0eXBlLF9vbmNlV3JhcCh0aGlzLHR5cGUsbGlzdGVuZXIpKTtyZXR1cm4gdGhpczt9O0V2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lcj1mdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsbGlzdGVuZXIpe2lmKHR5cGVvZiBsaXN0ZW5lciE9PSdmdW5jdGlvbicpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO3RoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsX29uY2VXcmFwKHRoaXMsdHlwZSxsaXN0ZW5lcikpO3JldHVybiB0aGlzO307Ly8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSxsaXN0ZW5lcil7dmFyIGxpc3QsZXZlbnRzLHBvc2l0aW9uLGksb3JpZ2luYWxMaXN0ZW5lcjtpZih0eXBlb2YgbGlzdGVuZXIhPT0nZnVuY3Rpb24nKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtldmVudHM9dGhpcy5fZXZlbnRzO2lmKCFldmVudHMpcmV0dXJuIHRoaXM7bGlzdD1ldmVudHNbdHlwZV07aWYoIWxpc3QpcmV0dXJuIHRoaXM7aWYobGlzdD09PWxpc3RlbmVyfHxsaXN0Lmxpc3RlbmVyPT09bGlzdGVuZXIpe2lmKC0tdGhpcy5fZXZlbnRzQ291bnQ9PT0wKXRoaXMuX2V2ZW50cz1vYmplY3RDcmVhdGUobnVsbCk7ZWxzZXtkZWxldGUgZXZlbnRzW3R5cGVdO2lmKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcil0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJyx0eXBlLGxpc3QubGlzdGVuZXJ8fGxpc3RlbmVyKTt9fWVsc2UgaWYodHlwZW9mIGxpc3QhPT0nZnVuY3Rpb24nKXtwb3NpdGlvbj0tMTtmb3IoaT1saXN0Lmxlbmd0aC0xO2k+PTA7aS0tKXtpZihsaXN0W2ldPT09bGlzdGVuZXJ8fGxpc3RbaV0ubGlzdGVuZXI9PT1saXN0ZW5lcil7b3JpZ2luYWxMaXN0ZW5lcj1saXN0W2ldLmxpc3RlbmVyO3Bvc2l0aW9uPWk7YnJlYWs7fX1pZihwb3NpdGlvbjwwKXJldHVybiB0aGlzO2lmKHBvc2l0aW9uPT09MClsaXN0LnNoaWZ0KCk7ZWxzZSBzcGxpY2VPbmUobGlzdCxwb3NpdGlvbik7aWYobGlzdC5sZW5ndGg9PT0xKWV2ZW50c1t0eXBlXT1saXN0WzBdO2lmKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcil0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJyx0eXBlLG9yaWdpbmFsTGlzdGVuZXJ8fGxpc3RlbmVyKTt9cmV0dXJuIHRoaXM7fTtFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSl7dmFyIGxpc3RlbmVycyxldmVudHMsaTtldmVudHM9dGhpcy5fZXZlbnRzO2lmKCFldmVudHMpcmV0dXJuIHRoaXM7Ly8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuaWYoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcil7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApe3RoaXMuX2V2ZW50cz1vYmplY3RDcmVhdGUobnVsbCk7dGhpcy5fZXZlbnRzQ291bnQ9MDt9ZWxzZSBpZihldmVudHNbdHlwZV0pe2lmKC0tdGhpcy5fZXZlbnRzQ291bnQ9PT0wKXRoaXMuX2V2ZW50cz1vYmplY3RDcmVhdGUobnVsbCk7ZWxzZSBkZWxldGUgZXZlbnRzW3R5cGVdO31yZXR1cm4gdGhpczt9Ly8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG5pZihhcmd1bWVudHMubGVuZ3RoPT09MCl7dmFyIGtleXM9b2JqZWN0S2V5cyhldmVudHMpO3ZhciBrZXk7Zm9yKGk9MDtpPGtleXMubGVuZ3RoOysraSl7a2V5PWtleXNbaV07aWYoa2V5PT09J3JlbW92ZUxpc3RlbmVyJyljb250aW51ZTt0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO310aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTt0aGlzLl9ldmVudHM9b2JqZWN0Q3JlYXRlKG51bGwpO3RoaXMuX2V2ZW50c0NvdW50PTA7cmV0dXJuIHRoaXM7fWxpc3RlbmVycz1ldmVudHNbdHlwZV07aWYodHlwZW9mIGxpc3RlbmVycz09PSdmdW5jdGlvbicpe3RoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSxsaXN0ZW5lcnMpO31lbHNlIGlmKGxpc3RlbmVycyl7Ly8gTElGTyBvcmRlclxuZm9yKGk9bGlzdGVuZXJzLmxlbmd0aC0xO2k+PTA7aS0tKXt0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsbGlzdGVuZXJzW2ldKTt9fXJldHVybiB0aGlzO307ZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsdHlwZSx1bndyYXApe3ZhciBldmVudHM9dGFyZ2V0Ll9ldmVudHM7aWYoIWV2ZW50cylyZXR1cm5bXTt2YXIgZXZsaXN0ZW5lcj1ldmVudHNbdHlwZV07aWYoIWV2bGlzdGVuZXIpcmV0dXJuW107aWYodHlwZW9mIGV2bGlzdGVuZXI9PT0nZnVuY3Rpb24nKXJldHVybiB1bndyYXA/W2V2bGlzdGVuZXIubGlzdGVuZXJ8fGV2bGlzdGVuZXJdOltldmxpc3RlbmVyXTtyZXR1cm4gdW53cmFwP3Vud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKTphcnJheUNsb25lKGV2bGlzdGVuZXIsZXZsaXN0ZW5lci5sZW5ndGgpO31FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbiBsaXN0ZW5lcnModHlwZSl7cmV0dXJuIF9saXN0ZW5lcnModGhpcyx0eXBlLHRydWUpO307RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnM9ZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpe3JldHVybiBfbGlzdGVuZXJzKHRoaXMsdHlwZSxmYWxzZSk7fTtFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudD1mdW5jdGlvbihlbWl0dGVyLHR5cGUpe2lmKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQ9PT0nZnVuY3Rpb24nKXtyZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO31lbHNle3JldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlcix0eXBlKTt9fTtFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQ9bGlzdGVuZXJDb3VudDtmdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpe3ZhciBldmVudHM9dGhpcy5fZXZlbnRzO2lmKGV2ZW50cyl7dmFyIGV2bGlzdGVuZXI9ZXZlbnRzW3R5cGVdO2lmKHR5cGVvZiBldmxpc3RlbmVyPT09J2Z1bmN0aW9uJyl7cmV0dXJuIDE7fWVsc2UgaWYoZXZsaXN0ZW5lcil7cmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO319cmV0dXJuIDA7fUV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcz1mdW5jdGlvbiBldmVudE5hbWVzKCl7cmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50PjA/UmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cyk6W107fTsvLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCxpbmRleCl7Zm9yKHZhciBpPWluZGV4LGs9aSsxLG49bGlzdC5sZW5ndGg7azxuO2krPTEsays9MSl7bGlzdFtpXT1saXN0W2tdO31saXN0LnBvcCgpO31mdW5jdGlvbiBhcnJheUNsb25lKGFycixuKXt2YXIgY29weT1uZXcgQXJyYXkobik7Zm9yKHZhciBpPTA7aTxuOysraSl7Y29weVtpXT1hcnJbaV07fXJldHVybiBjb3B5O31mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKXt2YXIgcmV0PW5ldyBBcnJheShhcnIubGVuZ3RoKTtmb3IodmFyIGk9MDtpPHJldC5sZW5ndGg7KytpKXtyZXRbaV09YXJyW2ldLmxpc3RlbmVyfHxhcnJbaV07fXJldHVybiByZXQ7fWZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKXt2YXIgRj1mdW5jdGlvbiBGKCl7fTtGLnByb3RvdHlwZT1wcm90bztyZXR1cm4gbmV3IEYoKTt9ZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iail7dmFyIGtleXM9W107Zm9yKHZhciBrIGluIG9iail7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaixrKSl7a2V5cy5wdXNoKGspO319cmV0dXJuIGs7fWZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpe3ZhciBmbj10aGlzO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBmbi5hcHBseShjb250ZXh0LGFyZ3VtZW50cyk7fTt9fSx7fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBfX2V4dGVuZHM9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIF9leHRlbmRTdGF0aWNzMj1mdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsYil7X2V4dGVuZFN0YXRpY3MyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihkLGIpe2QuX19wcm90b19fPWI7fXx8ZnVuY3Rpb24oZCxiKXtmb3IodmFyIHAgaW4gYil7aWYoYi5oYXNPd25Qcm9wZXJ0eShwKSlkW3BdPWJbcF07fX07cmV0dXJuIF9leHRlbmRTdGF0aWNzMihkLGIpO307cmV0dXJuIGZ1bmN0aW9uKGQsYil7X2V4dGVuZFN0YXRpY3MyKGQsYik7ZnVuY3Rpb24gX18oKXt0aGlzLmNvbnN0cnVjdG9yPWQ7fWQucHJvdG90eXBlPWI9PT1udWxsP09iamVjdC5jcmVhdGUoYik6KF9fLnByb3RvdHlwZT1iLnByb3RvdHlwZSxuZXcgX18oKSk7fTt9KCk7dmFyIF9faW1wb3J0RGVmYXVsdD10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24obW9kKXtyZXR1cm4gbW9kJiZtb2QuX19lc01vZHVsZT9tb2Q6e1wiZGVmYXVsdFwiOm1vZH07fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciBNdWx0aXBsZXhIYW5kbGVyXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL011bHRpcGxleEhhbmRsZXJcIikpO3ZhciBDb2xsZWN0aW5nSGFuZGxlcj0vKiogQGNsYXNzICovZnVuY3Rpb24oX3N1cGVyKXtfX2V4dGVuZHMoQ29sbGVjdGluZ0hhbmRsZXIsX3N1cGVyKTtmdW5jdGlvbiBDb2xsZWN0aW5nSGFuZGxlcihjYnMpe2lmKGNicz09PXZvaWQgMCl7Y2JzPXt9O312YXIgX3RoaXM9X3N1cGVyLmNhbGwodGhpcyxmdW5jdGlvbihuYW1lKXt2YXIgX2E7dmFyIGFyZ3M9W107Zm9yKHZhciBfaT0xO19pPGFyZ3VtZW50cy5sZW5ndGg7X2krKyl7YXJnc1tfaS0xXT1hcmd1bWVudHNbX2ldO31fdGhpcy5ldmVudHMucHVzaChbbmFtZV0uY29uY2F0KGFyZ3MpKTsvLyBAdHMtaWdub3JlXG5pZihfdGhpcy5fY2JzW25hbWVdKShfYT1fdGhpcy5fY2JzKVtuYW1lXS5hcHBseShfYSxhcmdzKTt9KXx8dGhpcztfdGhpcy5fY2JzPWNicztfdGhpcy5ldmVudHM9W107cmV0dXJuIF90aGlzO31Db2xsZWN0aW5nSGFuZGxlci5wcm90b3R5cGUub25yZXNldD1mdW5jdGlvbigpe3RoaXMuZXZlbnRzPVtdO2lmKHRoaXMuX2Nicy5vbnJlc2V0KXRoaXMuX2Nicy5vbnJlc2V0KCk7fTtDb2xsZWN0aW5nSGFuZGxlci5wcm90b3R5cGUucmVzdGFydD1mdW5jdGlvbigpe3ZhciBfYTtpZih0aGlzLl9jYnMub25yZXNldCl0aGlzLl9jYnMub25yZXNldCgpO2Zvcih2YXIgaT0wO2k8dGhpcy5ldmVudHMubGVuZ3RoO2krKyl7dmFyIF9iPXRoaXMuZXZlbnRzW2ldLG5hbWVfMT1fYlswXSxhcmdzPV9iLnNsaWNlKDEpO2lmKCF0aGlzLl9jYnNbbmFtZV8xXSl7Y29udGludWU7fS8vIEB0cy1pZ25vcmVcbihfYT10aGlzLl9jYnMpW25hbWVfMV0uYXBwbHkoX2EsYXJncyk7fX07cmV0dXJuIENvbGxlY3RpbmdIYW5kbGVyO30oTXVsdGlwbGV4SGFuZGxlcl8xW1wiZGVmYXVsdFwiXSk7ZXhwb3J0cy5Db2xsZWN0aW5nSGFuZGxlcj1Db2xsZWN0aW5nSGFuZGxlcjt9LHtcIi4vTXVsdGlwbGV4SGFuZGxlclwiOjI4fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBfX2V4dGVuZHM9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIF9leHRlbmRTdGF0aWNzMz1mdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsYil7X2V4dGVuZFN0YXRpY3MzPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihkLGIpe2QuX19wcm90b19fPWI7fXx8ZnVuY3Rpb24oZCxiKXtmb3IodmFyIHAgaW4gYil7aWYoYi5oYXNPd25Qcm9wZXJ0eShwKSlkW3BdPWJbcF07fX07cmV0dXJuIF9leHRlbmRTdGF0aWNzMyhkLGIpO307cmV0dXJuIGZ1bmN0aW9uKGQsYil7X2V4dGVuZFN0YXRpY3MzKGQsYik7ZnVuY3Rpb24gX18oKXt0aGlzLmNvbnN0cnVjdG9yPWQ7fWQucHJvdG90eXBlPWI9PT1udWxsP09iamVjdC5jcmVhdGUoYik6KF9fLnByb3RvdHlwZT1iLnByb3RvdHlwZSxuZXcgX18oKSk7fTt9KCk7dmFyIF9faW1wb3J0RGVmYXVsdD10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24obW9kKXtyZXR1cm4gbW9kJiZtb2QuX19lc01vZHVsZT9tb2Q6e1wiZGVmYXVsdFwiOm1vZH07fTt2YXIgX19pbXBvcnRTdGFyPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihtb2Qpe2lmKG1vZCYmbW9kLl9fZXNNb2R1bGUpcmV0dXJuIG1vZDt2YXIgcmVzdWx0PXt9O2lmKG1vZCE9bnVsbClmb3IodmFyIGsgaW4gbW9kKXtpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsaykpcmVzdWx0W2tdPW1vZFtrXTt9cmVzdWx0W1wiZGVmYXVsdFwiXT1tb2Q7cmV0dXJuIHJlc3VsdDt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIGRvbWhhbmRsZXJfMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRvbWhhbmRsZXJcIikpO3ZhciBEb21VdGlscz1fX2ltcG9ydFN0YXIocmVxdWlyZShcImRvbXV0aWxzXCIpKTt2YXIgUGFyc2VyXzE9cmVxdWlyZShcIi4vUGFyc2VyXCIpOy8vVE9ETzogQ29uc3VtZSBkYXRhIGFzIGl0IGlzIGNvbWluZyBpblxudmFyIEZlZWRIYW5kbGVyPS8qKiBAY2xhc3MgKi9mdW5jdGlvbihfc3VwZXIpe19fZXh0ZW5kcyhGZWVkSGFuZGxlcixfc3VwZXIpOy8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9mdW5jdGlvbiBGZWVkSGFuZGxlcihjYWxsYmFjayxvcHRpb25zKXt2YXIgX3RoaXM9dGhpcztpZihfdHlwZW9mKGNhbGxiYWNrKT09PVwib2JqZWN0XCImJmNhbGxiYWNrIT09bnVsbCl7Y2FsbGJhY2s9dW5kZWZpbmVkO29wdGlvbnM9Y2FsbGJhY2s7fV90aGlzPV9zdXBlci5jYWxsKHRoaXMsY2FsbGJhY2ssb3B0aW9ucyl8fHRoaXM7cmV0dXJuIF90aGlzO31GZWVkSGFuZGxlci5wcm90b3R5cGUub25lbmQ9ZnVuY3Rpb24oKXt2YXIgZmVlZD17fTt2YXIgZmVlZFJvb3Q9Z2V0T25lRWxlbWVudChpc1ZhbGlkRmVlZCx0aGlzLmRvbSk7aWYoZmVlZFJvb3Qpe2lmKGZlZWRSb290Lm5hbWU9PT1cImZlZWRcIil7dmFyIGNoaWxkcz1mZWVkUm9vdC5jaGlsZHJlbjtmZWVkLnR5cGU9XCJhdG9tXCI7YWRkQ29uZGl0aW9uYWxseShmZWVkLFwiaWRcIixcImlkXCIsY2hpbGRzKTthZGRDb25kaXRpb25hbGx5KGZlZWQsXCJ0aXRsZVwiLFwidGl0bGVcIixjaGlsZHMpO3ZhciBocmVmPWdldEF0dHJpYnV0ZShcImhyZWZcIixnZXRPbmVFbGVtZW50KFwibGlua1wiLGNoaWxkcykpO2lmKGhyZWYpe2ZlZWQubGluaz1ocmVmO31hZGRDb25kaXRpb25hbGx5KGZlZWQsXCJkZXNjcmlwdGlvblwiLFwic3VidGl0bGVcIixjaGlsZHMpO3ZhciB1cGRhdGVkPWZldGNoKFwidXBkYXRlZFwiLGNoaWxkcyk7aWYodXBkYXRlZCl7ZmVlZC51cGRhdGVkPW5ldyBEYXRlKHVwZGF0ZWQpO31hZGRDb25kaXRpb25hbGx5KGZlZWQsXCJhdXRob3JcIixcImVtYWlsXCIsY2hpbGRzLHRydWUpO2ZlZWQuaXRlbXM9Z2V0RWxlbWVudHMoXCJlbnRyeVwiLGNoaWxkcykubWFwKGZ1bmN0aW9uKGl0ZW0pe3ZhciBlbnRyeT17fTt2YXIgY2hpbGRyZW49aXRlbS5jaGlsZHJlbjthZGRDb25kaXRpb25hbGx5KGVudHJ5LFwiaWRcIixcImlkXCIsY2hpbGRyZW4pO2FkZENvbmRpdGlvbmFsbHkoZW50cnksXCJ0aXRsZVwiLFwidGl0bGVcIixjaGlsZHJlbik7dmFyIGhyZWY9Z2V0QXR0cmlidXRlKFwiaHJlZlwiLGdldE9uZUVsZW1lbnQoXCJsaW5rXCIsY2hpbGRyZW4pKTtpZihocmVmKXtlbnRyeS5saW5rPWhyZWY7fXZhciBkZXNjcmlwdGlvbj1mZXRjaChcInN1bW1hcnlcIixjaGlsZHJlbil8fGZldGNoKFwiY29udGVudFwiLGNoaWxkcmVuKTtpZihkZXNjcmlwdGlvbil7ZW50cnkuZGVzY3JpcHRpb249ZGVzY3JpcHRpb247fXZhciBwdWJEYXRlPWZldGNoKFwidXBkYXRlZFwiLGNoaWxkcmVuKTtpZihwdWJEYXRlKXtlbnRyeS5wdWJEYXRlPW5ldyBEYXRlKHB1YkRhdGUpO31yZXR1cm4gZW50cnk7fSk7fWVsc2V7dmFyIGNoaWxkcz1nZXRPbmVFbGVtZW50KFwiY2hhbm5lbFwiLGZlZWRSb290LmNoaWxkcmVuKS5jaGlsZHJlbjtmZWVkLnR5cGU9ZmVlZFJvb3QubmFtZS5zdWJzdHIoMCwzKTtmZWVkLmlkPVwiXCI7YWRkQ29uZGl0aW9uYWxseShmZWVkLFwidGl0bGVcIixcInRpdGxlXCIsY2hpbGRzKTthZGRDb25kaXRpb25hbGx5KGZlZWQsXCJsaW5rXCIsXCJsaW5rXCIsY2hpbGRzKTthZGRDb25kaXRpb25hbGx5KGZlZWQsXCJkZXNjcmlwdGlvblwiLFwiZGVzY3JpcHRpb25cIixjaGlsZHMpO3ZhciB1cGRhdGVkPWZldGNoKFwibGFzdEJ1aWxkRGF0ZVwiLGNoaWxkcyk7aWYodXBkYXRlZCl7ZmVlZC51cGRhdGVkPW5ldyBEYXRlKHVwZGF0ZWQpO31hZGRDb25kaXRpb25hbGx5KGZlZWQsXCJhdXRob3JcIixcIm1hbmFnaW5nRWRpdG9yXCIsY2hpbGRzLHRydWUpO2ZlZWQuaXRlbXM9Z2V0RWxlbWVudHMoXCJpdGVtXCIsZmVlZFJvb3QuY2hpbGRyZW4pLm1hcChmdW5jdGlvbihpdGVtKXt2YXIgZW50cnk9e307dmFyIGNoaWxkcmVuPWl0ZW0uY2hpbGRyZW47YWRkQ29uZGl0aW9uYWxseShlbnRyeSxcImlkXCIsXCJndWlkXCIsY2hpbGRyZW4pO2FkZENvbmRpdGlvbmFsbHkoZW50cnksXCJ0aXRsZVwiLFwidGl0bGVcIixjaGlsZHJlbik7YWRkQ29uZGl0aW9uYWxseShlbnRyeSxcImxpbmtcIixcImxpbmtcIixjaGlsZHJlbik7YWRkQ29uZGl0aW9uYWxseShlbnRyeSxcImRlc2NyaXB0aW9uXCIsXCJkZXNjcmlwdGlvblwiLGNoaWxkcmVuKTt2YXIgcHViRGF0ZT1mZXRjaChcInB1YkRhdGVcIixjaGlsZHJlbik7aWYocHViRGF0ZSllbnRyeS5wdWJEYXRlPW5ldyBEYXRlKHB1YkRhdGUpO3JldHVybiBlbnRyeTt9KTt9fXRoaXMuZmVlZD1mZWVkO3RoaXMuaGFuZGxlQ2FsbGJhY2soZmVlZFJvb3Q/bnVsbDpFcnJvcihcImNvdWxkbid0IGZpbmQgcm9vdCBvZiBmZWVkXCIpKTt9O3JldHVybiBGZWVkSGFuZGxlcjt9KGRvbWhhbmRsZXJfMVtcImRlZmF1bHRcIl0pO2V4cG9ydHMuRmVlZEhhbmRsZXI9RmVlZEhhbmRsZXI7ZnVuY3Rpb24gZ2V0RWxlbWVudHMod2hhdCx3aGVyZSl7cmV0dXJuIERvbVV0aWxzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHdoYXQsd2hlcmUsdHJ1ZSk7fWZ1bmN0aW9uIGdldE9uZUVsZW1lbnQod2hhdCx3aGVyZSl7cmV0dXJuIERvbVV0aWxzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHdoYXQsd2hlcmUsdHJ1ZSwxKVswXTt9ZnVuY3Rpb24gZmV0Y2god2hhdCx3aGVyZSxyZWN1cnNlKXtpZihyZWN1cnNlPT09dm9pZCAwKXtyZWN1cnNlPWZhbHNlO31yZXR1cm4gRG9tVXRpbHMuZ2V0VGV4dChEb21VdGlscy5nZXRFbGVtZW50c0J5VGFnTmFtZSh3aGF0LHdoZXJlLHJlY3Vyc2UsMSkpLnRyaW0oKTt9ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5hbWUsZWxlbSl7aWYoIWVsZW0pe3JldHVybiBudWxsO312YXIgYXR0cmlicz1lbGVtLmF0dHJpYnM7cmV0dXJuIGF0dHJpYnNbbmFtZV07fWZ1bmN0aW9uIGFkZENvbmRpdGlvbmFsbHkob2JqLHByb3Asd2hhdCx3aGVyZSxyZWN1cnNlKXtpZihyZWN1cnNlPT09dm9pZCAwKXtyZWN1cnNlPWZhbHNlO312YXIgdG1wPWZldGNoKHdoYXQsd2hlcmUscmVjdXJzZSk7Ly8gQHRzLWlnbm9yZVxuaWYodG1wKW9ialtwcm9wXT10bXA7fWZ1bmN0aW9uIGlzVmFsaWRGZWVkKHZhbHVlKXtyZXR1cm4gdmFsdWU9PT1cInJzc1wifHx2YWx1ZT09PVwiZmVlZFwifHx2YWx1ZT09PVwicmRmOlJERlwiO312YXIgZGVmYXVsdE9wdGlvbnM9e3htbE1vZGU6dHJ1ZX07LyoqXG4gKiBQYXJzZSBhIGZlZWQuXG4gKlxuICogQHBhcmFtIGZlZWQgVGhlIGZlZWQgdGhhdCBzaG91bGQgYmUgcGFyc2VkLCBhcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsbHksIG9wdGlvbnMgZm9yIHBhcnNpbmcuIFdoZW4gdXNpbmcgdGhpcyBvcHRpb24sIHlvdSBwcm9iYWJseSB3YW50IHRvIHNldCBgeG1sTW9kZWAgdG8gYHRydWVgLlxuICovZnVuY3Rpb24gcGFyc2VGZWVkKGZlZWQsb3B0aW9ucyl7aWYob3B0aW9ucz09PXZvaWQgMCl7b3B0aW9ucz1kZWZhdWx0T3B0aW9uczt9dmFyIGhhbmRsZXI9bmV3IEZlZWRIYW5kbGVyKG9wdGlvbnMpO25ldyBQYXJzZXJfMS5QYXJzZXIoaGFuZGxlcixvcHRpb25zKS5lbmQoZmVlZCk7cmV0dXJuIGhhbmRsZXIuZmVlZDt9ZXhwb3J0cy5wYXJzZUZlZWQ9cGFyc2VGZWVkO30se1wiLi9QYXJzZXJcIjoyOSxcImRvbWhhbmRsZXJcIjo3LFwiZG9tdXRpbHNcIjoxMH1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pOy8qKlxuICogQ2FsbHMgYSBzcGVjaWZpYyBoYW5kbGVyIGZ1bmN0aW9uIGZvciBhbGwgZXZlbnRzIHRoYXQgYXJlIGVuY291bnRlcmVkLlxuICpcbiAqIEBwYXJhbSBmdW5jIOKAlCBUaGUgZnVuY3Rpb24gdG8gbXVsdGlwbGV4IGFsbCBldmVudHMgdG8uXG4gKi92YXIgTXVsdGlwbGV4SGFuZGxlcj0vKiogQGNsYXNzICovZnVuY3Rpb24oKXtmdW5jdGlvbiBNdWx0aXBsZXhIYW5kbGVyKGZ1bmMpe3RoaXMuX2Z1bmM9ZnVuYzt9LyogRm9ybWF0OiBldmVudG5hbWU6IG51bWJlciBvZiBhcmd1bWVudHMgKi9NdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmF0dHJpYnV0ZT1mdW5jdGlvbihuYW1lLHZhbHVlKXt0aGlzLl9mdW5jKFwib25hdHRyaWJ1dGVcIixuYW1lLHZhbHVlKTt9O011bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9uY2RhdGFzdGFydD1mdW5jdGlvbigpe3RoaXMuX2Z1bmMoXCJvbmNkYXRhc3RhcnRcIik7fTtNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmNkYXRhZW5kPWZ1bmN0aW9uKCl7dGhpcy5fZnVuYyhcIm9uY2RhdGFlbmRcIik7fTtNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbnRleHQ9ZnVuY3Rpb24odGV4dCl7dGhpcy5fZnVuYyhcIm9udGV4dFwiLHRleHQpO307TXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb249ZnVuY3Rpb24obmFtZSx2YWx1ZSl7dGhpcy5fZnVuYyhcIm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uXCIsbmFtZSx2YWx1ZSk7fTtNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmNvbW1lbnQ9ZnVuY3Rpb24oY29tbWVudCl7dGhpcy5fZnVuYyhcIm9uY29tbWVudFwiLGNvbW1lbnQpO307TXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25jb21tZW50ZW5kPWZ1bmN0aW9uKCl7dGhpcy5fZnVuYyhcIm9uY29tbWVudGVuZFwiKTt9O011bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9uY2xvc2V0YWc9ZnVuY3Rpb24obmFtZSl7dGhpcy5fZnVuYyhcIm9uY2xvc2V0YWdcIixuYW1lKTt9O011bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9ub3BlbnRhZz1mdW5jdGlvbihuYW1lLGF0dHJpYnMpe3RoaXMuX2Z1bmMoXCJvbm9wZW50YWdcIixuYW1lLGF0dHJpYnMpO307TXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25vcGVudGFnbmFtZT1mdW5jdGlvbihuYW1lKXt0aGlzLl9mdW5jKFwib25vcGVudGFnbmFtZVwiLG5hbWUpO307TXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25lcnJvcj1mdW5jdGlvbihlcnJvcil7dGhpcy5fZnVuYyhcIm9uZXJyb3JcIixlcnJvcik7fTtNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmVuZD1mdW5jdGlvbigpe3RoaXMuX2Z1bmMoXCJvbmVuZFwiKTt9O011bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9ucGFyc2VyaW5pdD1mdW5jdGlvbihwYXJzZXIpe3RoaXMuX2Z1bmMoXCJvbnBhcnNlcmluaXRcIixwYXJzZXIpO307TXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25yZXNldD1mdW5jdGlvbigpe3RoaXMuX2Z1bmMoXCJvbnJlc2V0XCIpO307cmV0dXJuIE11bHRpcGxleEhhbmRsZXI7fSgpO2V4cG9ydHNbXCJkZWZhdWx0XCJdPU11bHRpcGxleEhhbmRsZXI7fSx7fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBfX2V4dGVuZHM9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIF9leHRlbmRTdGF0aWNzND1mdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsYil7X2V4dGVuZFN0YXRpY3M0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihkLGIpe2QuX19wcm90b19fPWI7fXx8ZnVuY3Rpb24oZCxiKXtmb3IodmFyIHAgaW4gYil7aWYoYi5oYXNPd25Qcm9wZXJ0eShwKSlkW3BdPWJbcF07fX07cmV0dXJuIF9leHRlbmRTdGF0aWNzNChkLGIpO307cmV0dXJuIGZ1bmN0aW9uKGQsYil7X2V4dGVuZFN0YXRpY3M0KGQsYik7ZnVuY3Rpb24gX18oKXt0aGlzLmNvbnN0cnVjdG9yPWQ7fWQucHJvdG90eXBlPWI9PT1udWxsP09iamVjdC5jcmVhdGUoYik6KF9fLnByb3RvdHlwZT1iLnByb3RvdHlwZSxuZXcgX18oKSk7fTt9KCk7dmFyIF9faW1wb3J0RGVmYXVsdD10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24obW9kKXtyZXR1cm4gbW9kJiZtb2QuX19lc01vZHVsZT9tb2Q6e1wiZGVmYXVsdFwiOm1vZH07fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciBUb2tlbml6ZXJfMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vVG9rZW5pemVyXCIpKTt2YXIgZXZlbnRzXzE9cmVxdWlyZShcImV2ZW50c1wiKTt2YXIgZm9ybVRhZ3M9bmV3IFNldChbXCJpbnB1dFwiLFwib3B0aW9uXCIsXCJvcHRncm91cFwiLFwic2VsZWN0XCIsXCJidXR0b25cIixcImRhdGFsaXN0XCIsXCJ0ZXh0YXJlYVwiXSk7dmFyIHBUYWc9bmV3IFNldChbXCJwXCJdKTt2YXIgb3BlbkltcGxpZXNDbG9zZT17dHI6bmV3IFNldChbXCJ0clwiLFwidGhcIixcInRkXCJdKSx0aDpuZXcgU2V0KFtcInRoXCJdKSx0ZDpuZXcgU2V0KFtcInRoZWFkXCIsXCJ0aFwiLFwidGRcIl0pLGJvZHk6bmV3IFNldChbXCJoZWFkXCIsXCJsaW5rXCIsXCJzY3JpcHRcIl0pLGxpOm5ldyBTZXQoW1wibGlcIl0pLHA6cFRhZyxoMTpwVGFnLGgyOnBUYWcsaDM6cFRhZyxoNDpwVGFnLGg1OnBUYWcsaDY6cFRhZyxzZWxlY3Q6Zm9ybVRhZ3MsaW5wdXQ6Zm9ybVRhZ3Msb3V0cHV0OmZvcm1UYWdzLGJ1dHRvbjpmb3JtVGFncyxkYXRhbGlzdDpmb3JtVGFncyx0ZXh0YXJlYTpmb3JtVGFncyxvcHRpb246bmV3IFNldChbXCJvcHRpb25cIl0pLG9wdGdyb3VwOm5ldyBTZXQoW1wib3B0Z3JvdXBcIixcIm9wdGlvblwiXSksZGQ6bmV3IFNldChbXCJkdFwiLFwiZGRcIl0pLGR0Om5ldyBTZXQoW1wiZHRcIixcImRkXCJdKSxhZGRyZXNzOnBUYWcsYXJ0aWNsZTpwVGFnLGFzaWRlOnBUYWcsYmxvY2txdW90ZTpwVGFnLGRldGFpbHM6cFRhZyxkaXY6cFRhZyxkbDpwVGFnLGZpZWxkc2V0OnBUYWcsZmlnY2FwdGlvbjpwVGFnLGZpZ3VyZTpwVGFnLGZvb3RlcjpwVGFnLGZvcm06cFRhZyxoZWFkZXI6cFRhZyxocjpwVGFnLG1haW46cFRhZyxuYXY6cFRhZyxvbDpwVGFnLHByZTpwVGFnLHNlY3Rpb246cFRhZyx0YWJsZTpwVGFnLHVsOnBUYWcscnQ6bmV3IFNldChbXCJydFwiLFwicnBcIl0pLHJwOm5ldyBTZXQoW1wicnRcIixcInJwXCJdKSx0Ym9keTpuZXcgU2V0KFtcInRoZWFkXCIsXCJ0Ym9keVwiXSksdGZvb3Q6bmV3IFNldChbXCJ0aGVhZFwiLFwidGJvZHlcIl0pfTt2YXIgdm9pZEVsZW1lbnRzPW5ldyBTZXQoW1wiYXJlYVwiLFwiYmFzZVwiLFwiYmFzZWZvbnRcIixcImJyXCIsXCJjb2xcIixcImNvbW1hbmRcIixcImVtYmVkXCIsXCJmcmFtZVwiLFwiaHJcIixcImltZ1wiLFwiaW5wdXRcIixcImlzaW5kZXhcIixcImtleWdlblwiLFwibGlua1wiLFwibWV0YVwiLFwicGFyYW1cIixcInNvdXJjZVwiLFwidHJhY2tcIixcIndiclwiXSk7dmFyIGZvcmVpZ25Db250ZXh0RWxlbWVudHM9bmV3IFNldChbXCJtYXRoXCIsXCJzdmdcIl0pO3ZhciBodG1sSW50ZWdyYXRpb25FbGVtZW50cz1uZXcgU2V0KFtcIm1pXCIsXCJtb1wiLFwibW5cIixcIm1zXCIsXCJtdGV4dFwiLFwiYW5ub3RhdGlvbi14bWxcIixcImZvcmVpZ25PYmplY3RcIixcImRlc2NcIixcInRpdGxlXCJdKTt2YXIgcmVOYW1lRW5kPS9cXHN8XFwvLzt2YXIgUGFyc2VyPS8qKiBAY2xhc3MgKi9mdW5jdGlvbihfc3VwZXIpe19fZXh0ZW5kcyhQYXJzZXIsX3N1cGVyKTtmdW5jdGlvbiBQYXJzZXIoY2JzLG9wdGlvbnMpe3ZhciBfdGhpcz1fc3VwZXIuY2FsbCh0aGlzKXx8dGhpcztfdGhpcy5fdGFnbmFtZT1cIlwiO190aGlzLl9hdHRyaWJuYW1lPVwiXCI7X3RoaXMuX2F0dHJpYnZhbHVlPVwiXCI7X3RoaXMuX2F0dHJpYnM9bnVsbDtfdGhpcy5fc3RhY2s9W107X3RoaXMuX2ZvcmVpZ25Db250ZXh0PVtdO190aGlzLnN0YXJ0SW5kZXg9MDtfdGhpcy5lbmRJbmRleD1udWxsOy8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5fdGhpcy5wYXJzZUNodW5rPVBhcnNlci5wcm90b3R5cGUud3JpdGU7X3RoaXMuZG9uZT1QYXJzZXIucHJvdG90eXBlLmVuZDtfdGhpcy5fb3B0aW9ucz1vcHRpb25zfHx7fTtfdGhpcy5fY2JzPWNic3x8e307X3RoaXMuX3RhZ25hbWU9XCJcIjtfdGhpcy5fYXR0cmlibmFtZT1cIlwiO190aGlzLl9hdHRyaWJ2YWx1ZT1cIlwiO190aGlzLl9hdHRyaWJzPW51bGw7X3RoaXMuX3N0YWNrPVtdO190aGlzLl9mb3JlaWduQ29udGV4dD1bXTtfdGhpcy5zdGFydEluZGV4PTA7X3RoaXMuZW5kSW5kZXg9bnVsbDtfdGhpcy5fbG93ZXJDYXNlVGFnTmFtZXM9XCJsb3dlckNhc2VUYWdzXCJpbiBfdGhpcy5fb3B0aW9ucz8hIV90aGlzLl9vcHRpb25zLmxvd2VyQ2FzZVRhZ3M6IV90aGlzLl9vcHRpb25zLnhtbE1vZGU7X3RoaXMuX2xvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzPVwibG93ZXJDYXNlQXR0cmlidXRlTmFtZXNcImluIF90aGlzLl9vcHRpb25zPyEhX3RoaXMuX29wdGlvbnMubG93ZXJDYXNlQXR0cmlidXRlTmFtZXM6IV90aGlzLl9vcHRpb25zLnhtbE1vZGU7X3RoaXMuX3Rva2VuaXplcj1uZXcoX3RoaXMuX29wdGlvbnMuVG9rZW5pemVyfHxUb2tlbml6ZXJfMVtcImRlZmF1bHRcIl0pKF90aGlzLl9vcHRpb25zLF90aGlzKTtpZihfdGhpcy5fY2JzLm9ucGFyc2VyaW5pdClfdGhpcy5fY2JzLm9ucGFyc2VyaW5pdChfdGhpcyk7cmV0dXJuIF90aGlzO31QYXJzZXIucHJvdG90eXBlLl91cGRhdGVQb3NpdGlvbj1mdW5jdGlvbihpbml0aWFsT2Zmc2V0KXtpZih0aGlzLmVuZEluZGV4PT09bnVsbCl7aWYodGhpcy5fdG9rZW5pemVyLl9zZWN0aW9uU3RhcnQ8PWluaXRpYWxPZmZzZXQpe3RoaXMuc3RhcnRJbmRleD0wO31lbHNle3RoaXMuc3RhcnRJbmRleD10aGlzLl90b2tlbml6ZXIuX3NlY3Rpb25TdGFydC1pbml0aWFsT2Zmc2V0O319ZWxzZSB0aGlzLnN0YXJ0SW5kZXg9dGhpcy5lbmRJbmRleCsxO3RoaXMuZW5kSW5kZXg9dGhpcy5fdG9rZW5pemVyLmdldEFic29sdXRlSW5kZXgoKTt9Oy8vVG9rZW5pemVyIGV2ZW50IGhhbmRsZXJzXG5QYXJzZXIucHJvdG90eXBlLm9udGV4dD1mdW5jdGlvbihkYXRhKXt0aGlzLl91cGRhdGVQb3NpdGlvbigxKTsvLyBAdHMtaWdub3JlXG50aGlzLmVuZEluZGV4LS07aWYodGhpcy5fY2JzLm9udGV4dCl0aGlzLl9jYnMub250ZXh0KGRhdGEpO307UGFyc2VyLnByb3RvdHlwZS5vbm9wZW50YWduYW1lPWZ1bmN0aW9uKG5hbWUpe2lmKHRoaXMuX2xvd2VyQ2FzZVRhZ05hbWVzKXtuYW1lPW5hbWUudG9Mb3dlckNhc2UoKTt9dGhpcy5fdGFnbmFtZT1uYW1lO2lmKCF0aGlzLl9vcHRpb25zLnhtbE1vZGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcGVuSW1wbGllc0Nsb3NlLG5hbWUpKXtmb3IodmFyIGVsPXZvaWQgMDsvLyBAdHMtaWdub3JlXG5vcGVuSW1wbGllc0Nsb3NlW25hbWVdLmhhcyhlbD10aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGgtMV0pO3RoaXMub25jbG9zZXRhZyhlbCkpezt9fWlmKHRoaXMuX29wdGlvbnMueG1sTW9kZXx8IXZvaWRFbGVtZW50cy5oYXMobmFtZSkpe3RoaXMuX3N0YWNrLnB1c2gobmFtZSk7aWYoZm9yZWlnbkNvbnRleHRFbGVtZW50cy5oYXMobmFtZSkpe3RoaXMuX2ZvcmVpZ25Db250ZXh0LnB1c2godHJ1ZSk7fWVsc2UgaWYoaHRtbEludGVncmF0aW9uRWxlbWVudHMuaGFzKG5hbWUpKXt0aGlzLl9mb3JlaWduQ29udGV4dC5wdXNoKGZhbHNlKTt9fWlmKHRoaXMuX2Nicy5vbm9wZW50YWduYW1lKXRoaXMuX2Nicy5vbm9wZW50YWduYW1lKG5hbWUpO2lmKHRoaXMuX2Nicy5vbm9wZW50YWcpdGhpcy5fYXR0cmlicz17fTt9O1BhcnNlci5wcm90b3R5cGUub25vcGVudGFnZW5kPWZ1bmN0aW9uKCl7dGhpcy5fdXBkYXRlUG9zaXRpb24oMSk7aWYodGhpcy5fYXR0cmlicyl7aWYodGhpcy5fY2JzLm9ub3BlbnRhZyl7dGhpcy5fY2JzLm9ub3BlbnRhZyh0aGlzLl90YWduYW1lLHRoaXMuX2F0dHJpYnMpO310aGlzLl9hdHRyaWJzPW51bGw7fWlmKCF0aGlzLl9vcHRpb25zLnhtbE1vZGUmJnRoaXMuX2Nicy5vbmNsb3NldGFnJiZ2b2lkRWxlbWVudHMuaGFzKHRoaXMuX3RhZ25hbWUpKXt0aGlzLl9jYnMub25jbG9zZXRhZyh0aGlzLl90YWduYW1lKTt9dGhpcy5fdGFnbmFtZT1cIlwiO307UGFyc2VyLnByb3RvdHlwZS5vbmNsb3NldGFnPWZ1bmN0aW9uKG5hbWUpe3RoaXMuX3VwZGF0ZVBvc2l0aW9uKDEpO2lmKHRoaXMuX2xvd2VyQ2FzZVRhZ05hbWVzKXtuYW1lPW5hbWUudG9Mb3dlckNhc2UoKTt9aWYoZm9yZWlnbkNvbnRleHRFbGVtZW50cy5oYXMobmFtZSl8fGh0bWxJbnRlZ3JhdGlvbkVsZW1lbnRzLmhhcyhuYW1lKSl7dGhpcy5fZm9yZWlnbkNvbnRleHQucG9wKCk7fWlmKHRoaXMuX3N0YWNrLmxlbmd0aCYmKHRoaXMuX29wdGlvbnMueG1sTW9kZXx8IXZvaWRFbGVtZW50cy5oYXMobmFtZSkpKXt2YXIgcG9zPXRoaXMuX3N0YWNrLmxhc3RJbmRleE9mKG5hbWUpO2lmKHBvcyE9PS0xKXtpZih0aGlzLl9jYnMub25jbG9zZXRhZyl7cG9zPXRoaXMuX3N0YWNrLmxlbmd0aC1wb3M7Ly8gQHRzLWlnbm9yZVxud2hpbGUocG9zLS0pe3RoaXMuX2Nicy5vbmNsb3NldGFnKHRoaXMuX3N0YWNrLnBvcCgpKTt9fWVsc2UgdGhpcy5fc3RhY2subGVuZ3RoPXBvczt9ZWxzZSBpZihuYW1lPT09XCJwXCImJiF0aGlzLl9vcHRpb25zLnhtbE1vZGUpe3RoaXMub25vcGVudGFnbmFtZShuYW1lKTt0aGlzLl9jbG9zZUN1cnJlbnRUYWcoKTt9fWVsc2UgaWYoIXRoaXMuX29wdGlvbnMueG1sTW9kZSYmKG5hbWU9PT1cImJyXCJ8fG5hbWU9PT1cInBcIikpe3RoaXMub25vcGVudGFnbmFtZShuYW1lKTt0aGlzLl9jbG9zZUN1cnJlbnRUYWcoKTt9fTtQYXJzZXIucHJvdG90eXBlLm9uc2VsZmNsb3Npbmd0YWc9ZnVuY3Rpb24oKXtpZih0aGlzLl9vcHRpb25zLnhtbE1vZGV8fHRoaXMuX29wdGlvbnMucmVjb2duaXplU2VsZkNsb3Npbmd8fHRoaXMuX2ZvcmVpZ25Db250ZXh0W3RoaXMuX2ZvcmVpZ25Db250ZXh0Lmxlbmd0aC0xXSl7dGhpcy5fY2xvc2VDdXJyZW50VGFnKCk7fWVsc2V7dGhpcy5vbm9wZW50YWdlbmQoKTt9fTtQYXJzZXIucHJvdG90eXBlLl9jbG9zZUN1cnJlbnRUYWc9ZnVuY3Rpb24oKXt2YXIgbmFtZT10aGlzLl90YWduYW1lO3RoaXMub25vcGVudGFnZW5kKCk7Ly9zZWxmLWNsb3NpbmcgdGFncyB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4vLyhjaGVhcGVyIGNoZWNrIHRoYW4gaW4gb25jbG9zZXRhZylcbmlmKHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrLmxlbmd0aC0xXT09PW5hbWUpe2lmKHRoaXMuX2Nicy5vbmNsb3NldGFnKXt0aGlzLl9jYnMub25jbG9zZXRhZyhuYW1lKTt9dGhpcy5fc3RhY2sucG9wKCk7fX07UGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYm5hbWU9ZnVuY3Rpb24obmFtZSl7aWYodGhpcy5fbG93ZXJDYXNlQXR0cmlidXRlTmFtZXMpe25hbWU9bmFtZS50b0xvd2VyQ2FzZSgpO310aGlzLl9hdHRyaWJuYW1lPW5hbWU7fTtQYXJzZXIucHJvdG90eXBlLm9uYXR0cmliZGF0YT1mdW5jdGlvbih2YWx1ZSl7dGhpcy5fYXR0cmlidmFsdWUrPXZhbHVlO307UGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYmVuZD1mdW5jdGlvbigpe2lmKHRoaXMuX2Nicy5vbmF0dHJpYnV0ZSl0aGlzLl9jYnMub25hdHRyaWJ1dGUodGhpcy5fYXR0cmlibmFtZSx0aGlzLl9hdHRyaWJ2YWx1ZSk7aWYodGhpcy5fYXR0cmlicyYmIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9hdHRyaWJzLHRoaXMuX2F0dHJpYm5hbWUpKXt0aGlzLl9hdHRyaWJzW3RoaXMuX2F0dHJpYm5hbWVdPXRoaXMuX2F0dHJpYnZhbHVlO310aGlzLl9hdHRyaWJuYW1lPVwiXCI7dGhpcy5fYXR0cmlidmFsdWU9XCJcIjt9O1BhcnNlci5wcm90b3R5cGUuX2dldEluc3RydWN0aW9uTmFtZT1mdW5jdGlvbih2YWx1ZSl7dmFyIGlkeD12YWx1ZS5zZWFyY2gocmVOYW1lRW5kKTt2YXIgbmFtZT1pZHg8MD92YWx1ZTp2YWx1ZS5zdWJzdHIoMCxpZHgpO2lmKHRoaXMuX2xvd2VyQ2FzZVRhZ05hbWVzKXtuYW1lPW5hbWUudG9Mb3dlckNhc2UoKTt9cmV0dXJuIG5hbWU7fTtQYXJzZXIucHJvdG90eXBlLm9uZGVjbGFyYXRpb249ZnVuY3Rpb24odmFsdWUpe2lmKHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbil7dmFyIG5hbWVfMT10aGlzLl9nZXRJbnN0cnVjdGlvbk5hbWUodmFsdWUpO3RoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihcIiFcIituYW1lXzEsXCIhXCIrdmFsdWUpO319O1BhcnNlci5wcm90b3R5cGUub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb249ZnVuY3Rpb24odmFsdWUpe2lmKHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbil7dmFyIG5hbWVfMj10aGlzLl9nZXRJbnN0cnVjdGlvbk5hbWUodmFsdWUpO3RoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihcIj9cIituYW1lXzIsXCI/XCIrdmFsdWUpO319O1BhcnNlci5wcm90b3R5cGUub25jb21tZW50PWZ1bmN0aW9uKHZhbHVlKXt0aGlzLl91cGRhdGVQb3NpdGlvbig0KTtpZih0aGlzLl9jYnMub25jb21tZW50KXRoaXMuX2Nicy5vbmNvbW1lbnQodmFsdWUpO2lmKHRoaXMuX2Nicy5vbmNvbW1lbnRlbmQpdGhpcy5fY2JzLm9uY29tbWVudGVuZCgpO307UGFyc2VyLnByb3RvdHlwZS5vbmNkYXRhPWZ1bmN0aW9uKHZhbHVlKXt0aGlzLl91cGRhdGVQb3NpdGlvbigxKTtpZih0aGlzLl9vcHRpb25zLnhtbE1vZGV8fHRoaXMuX29wdGlvbnMucmVjb2duaXplQ0RBVEEpe2lmKHRoaXMuX2Nicy5vbmNkYXRhc3RhcnQpdGhpcy5fY2JzLm9uY2RhdGFzdGFydCgpO2lmKHRoaXMuX2Nicy5vbnRleHQpdGhpcy5fY2JzLm9udGV4dCh2YWx1ZSk7aWYodGhpcy5fY2JzLm9uY2RhdGFlbmQpdGhpcy5fY2JzLm9uY2RhdGFlbmQoKTt9ZWxzZXt0aGlzLm9uY29tbWVudChcIltDREFUQVtcIit2YWx1ZStcIl1dXCIpO319O1BhcnNlci5wcm90b3R5cGUub25lcnJvcj1mdW5jdGlvbihlcnIpe2lmKHRoaXMuX2Nicy5vbmVycm9yKXRoaXMuX2Nicy5vbmVycm9yKGVycik7fTtQYXJzZXIucHJvdG90eXBlLm9uZW5kPWZ1bmN0aW9uKCl7aWYodGhpcy5fY2JzLm9uY2xvc2V0YWcpe2Zvcih2YXIgaT10aGlzLl9zdGFjay5sZW5ndGg7aT4wO3RoaXMuX2Nicy5vbmNsb3NldGFnKHRoaXMuX3N0YWNrWy0taV0pKXs7fX1pZih0aGlzLl9jYnMub25lbmQpdGhpcy5fY2JzLm9uZW5kKCk7fTsvL1Jlc2V0cyB0aGUgcGFyc2VyIHRvIGEgYmxhbmsgc3RhdGUsIHJlYWR5IHRvIHBhcnNlIGEgbmV3IEhUTUwgZG9jdW1lbnRcblBhcnNlci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXtpZih0aGlzLl9jYnMub25yZXNldCl0aGlzLl9jYnMub25yZXNldCgpO3RoaXMuX3Rva2VuaXplci5yZXNldCgpO3RoaXMuX3RhZ25hbWU9XCJcIjt0aGlzLl9hdHRyaWJuYW1lPVwiXCI7dGhpcy5fYXR0cmlicz1udWxsO3RoaXMuX3N0YWNrPVtdO2lmKHRoaXMuX2Nicy5vbnBhcnNlcmluaXQpdGhpcy5fY2JzLm9ucGFyc2VyaW5pdCh0aGlzKTt9Oy8vUGFyc2VzIGEgY29tcGxldGUgSFRNTCBkb2N1bWVudCBhbmQgcHVzaGVzIGl0IHRvIHRoZSBoYW5kbGVyXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcGxldGU9ZnVuY3Rpb24oZGF0YSl7dGhpcy5yZXNldCgpO3RoaXMuZW5kKGRhdGEpO307UGFyc2VyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihjaHVuayl7dGhpcy5fdG9rZW5pemVyLndyaXRlKGNodW5rKTt9O1BhcnNlci5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKGNodW5rKXt0aGlzLl90b2tlbml6ZXIuZW5kKGNodW5rKTt9O1BhcnNlci5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24oKXt0aGlzLl90b2tlbml6ZXIucGF1c2UoKTt9O1BhcnNlci5wcm90b3R5cGUucmVzdW1lPWZ1bmN0aW9uKCl7dGhpcy5fdG9rZW5pemVyLnJlc3VtZSgpO307cmV0dXJuIFBhcnNlcjt9KGV2ZW50c18xLkV2ZW50RW1pdHRlcik7ZXhwb3J0cy5QYXJzZXI9UGFyc2VyO30se1wiLi9Ub2tlbml6ZXJcIjozMCxcImV2ZW50c1wiOjI1fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOntcImRlZmF1bHRcIjptb2R9O307T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgZGVjb2RlX2NvZGVwb2ludF8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZW50aXRpZXMvbGliL2RlY29kZV9jb2RlcG9pbnRcIikpO3ZhciBlbnRpdGllc19qc29uXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uXCIpKTt2YXIgbGVnYWN5X2pzb25fMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVudGl0aWVzL2xpYi9tYXBzL2xlZ2FjeS5qc29uXCIpKTt2YXIgeG1sX2pzb25fMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVudGl0aWVzL2xpYi9tYXBzL3htbC5qc29uXCIpKTtmdW5jdGlvbiB3aGl0ZXNwYWNlKGMpe3JldHVybiBjPT09XCIgXCJ8fGM9PT1cIlxcblwifHxjPT09XCJcXHRcInx8Yz09PVwiXFxmXCJ8fGM9PT1cIlxcclwiO31mdW5jdGlvbiBpZkVsc2VTdGF0ZSh1cHBlcixTVUNDRVNTLEZBSUxVUkUpe3ZhciBsb3dlcj11cHBlci50b0xvd2VyQ2FzZSgpO2lmKHVwcGVyPT09bG93ZXIpe3JldHVybiBmdW5jdGlvbih0LGMpe2lmKGM9PT1sb3dlcil7dC5fc3RhdGU9U1VDQ0VTUzt9ZWxzZXt0Ll9zdGF0ZT1GQUlMVVJFO3QuX2luZGV4LS07fX07fWVsc2V7cmV0dXJuIGZ1bmN0aW9uKHQsYyl7aWYoYz09PWxvd2VyfHxjPT09dXBwZXIpe3QuX3N0YXRlPVNVQ0NFU1M7fWVsc2V7dC5fc3RhdGU9RkFJTFVSRTt0Ll9pbmRleC0tO319O319ZnVuY3Rpb24gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcih1cHBlcixORVhUX1NUQVRFKXt2YXIgbG93ZXI9dXBwZXIudG9Mb3dlckNhc2UoKTtyZXR1cm4gZnVuY3Rpb24odCxjKXtpZihjPT09bG93ZXJ8fGM9PT11cHBlcil7dC5fc3RhdGU9TkVYVF9TVEFURTt9ZWxzZXt0Ll9zdGF0ZT0zLyogSW5UYWdOYW1lICovO3QuX2luZGV4LS07Ly9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxufX07fXZhciBzdGF0ZUJlZm9yZUNkYXRhMT1pZkVsc2VTdGF0ZShcIkNcIiwyMy8qIEJlZm9yZUNkYXRhMiAqLywxNi8qIEluRGVjbGFyYXRpb24gKi8pO3ZhciBzdGF0ZUJlZm9yZUNkYXRhMj1pZkVsc2VTdGF0ZShcIkRcIiwyNC8qIEJlZm9yZUNkYXRhMyAqLywxNi8qIEluRGVjbGFyYXRpb24gKi8pO3ZhciBzdGF0ZUJlZm9yZUNkYXRhMz1pZkVsc2VTdGF0ZShcIkFcIiwyNS8qIEJlZm9yZUNkYXRhNCAqLywxNi8qIEluRGVjbGFyYXRpb24gKi8pO3ZhciBzdGF0ZUJlZm9yZUNkYXRhND1pZkVsc2VTdGF0ZShcIlRcIiwyNi8qIEJlZm9yZUNkYXRhNSAqLywxNi8qIEluRGVjbGFyYXRpb24gKi8pO3ZhciBzdGF0ZUJlZm9yZUNkYXRhNT1pZkVsc2VTdGF0ZShcIkFcIiwyNy8qIEJlZm9yZUNkYXRhNiAqLywxNi8qIEluRGVjbGFyYXRpb24gKi8pO3ZhciBzdGF0ZUJlZm9yZVNjcmlwdDE9Y29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlJcIiwzNC8qIEJlZm9yZVNjcmlwdDIgKi8pO3ZhciBzdGF0ZUJlZm9yZVNjcmlwdDI9Y29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIklcIiwzNS8qIEJlZm9yZVNjcmlwdDMgKi8pO3ZhciBzdGF0ZUJlZm9yZVNjcmlwdDM9Y29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlBcIiwzNi8qIEJlZm9yZVNjcmlwdDQgKi8pO3ZhciBzdGF0ZUJlZm9yZVNjcmlwdDQ9Y29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlRcIiwzNy8qIEJlZm9yZVNjcmlwdDUgKi8pO3ZhciBzdGF0ZUFmdGVyU2NyaXB0MT1pZkVsc2VTdGF0ZShcIlJcIiwzOS8qIEFmdGVyU2NyaXB0MiAqLywxLyogVGV4dCAqLyk7dmFyIHN0YXRlQWZ0ZXJTY3JpcHQyPWlmRWxzZVN0YXRlKFwiSVwiLDQwLyogQWZ0ZXJTY3JpcHQzICovLDEvKiBUZXh0ICovKTt2YXIgc3RhdGVBZnRlclNjcmlwdDM9aWZFbHNlU3RhdGUoXCJQXCIsNDEvKiBBZnRlclNjcmlwdDQgKi8sMS8qIFRleHQgKi8pO3ZhciBzdGF0ZUFmdGVyU2NyaXB0ND1pZkVsc2VTdGF0ZShcIlRcIiw0Mi8qIEFmdGVyU2NyaXB0NSAqLywxLyogVGV4dCAqLyk7dmFyIHN0YXRlQmVmb3JlU3R5bGUxPWNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJZXCIsNDQvKiBCZWZvcmVTdHlsZTIgKi8pO3ZhciBzdGF0ZUJlZm9yZVN0eWxlMj1jb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiTFwiLDQ1LyogQmVmb3JlU3R5bGUzICovKTt2YXIgc3RhdGVCZWZvcmVTdHlsZTM9Y29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIkVcIiw0Ni8qIEJlZm9yZVN0eWxlNCAqLyk7dmFyIHN0YXRlQWZ0ZXJTdHlsZTE9aWZFbHNlU3RhdGUoXCJZXCIsNDgvKiBBZnRlclN0eWxlMiAqLywxLyogVGV4dCAqLyk7dmFyIHN0YXRlQWZ0ZXJTdHlsZTI9aWZFbHNlU3RhdGUoXCJMXCIsNDkvKiBBZnRlclN0eWxlMyAqLywxLyogVGV4dCAqLyk7dmFyIHN0YXRlQWZ0ZXJTdHlsZTM9aWZFbHNlU3RhdGUoXCJFXCIsNTAvKiBBZnRlclN0eWxlNCAqLywxLyogVGV4dCAqLyk7dmFyIHN0YXRlQmVmb3JlRW50aXR5PWlmRWxzZVN0YXRlKFwiI1wiLDUyLyogQmVmb3JlTnVtZXJpY0VudGl0eSAqLyw1My8qIEluTmFtZWRFbnRpdHkgKi8pO3ZhciBzdGF0ZUJlZm9yZU51bWVyaWNFbnRpdHk9aWZFbHNlU3RhdGUoXCJYXCIsNTUvKiBJbkhleEVudGl0eSAqLyw1NC8qIEluTnVtZXJpY0VudGl0eSAqLyk7dmFyIFRva2VuaXplcj0vKiogQGNsYXNzICovZnVuY3Rpb24oKXtmdW5jdGlvbiBUb2tlbml6ZXIob3B0aW9ucyxjYnMpey8qKiBUaGUgY3VycmVudCBzdGF0ZSB0aGUgdG9rZW5pemVyIGlzIGluLiAqL3RoaXMuX3N0YXRlPTEvKiBUZXh0ICovOy8qKiBUaGUgcmVhZCBidWZmZXIuICovdGhpcy5fYnVmZmVyPVwiXCI7LyoqIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY3Rpb24gdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC4gKi90aGlzLl9zZWN0aW9uU3RhcnQ9MDsvKiogVGhlIGluZGV4IHdpdGhpbiB0aGUgYnVmZmVyIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBsb29raW5nIGF0LiAqL3RoaXMuX2luZGV4PTA7LyoqXG4gICAgICAgICAqIERhdGEgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYnVmZmVyIG9jY2FzaW9uYWxseS5cbiAgICAgICAgICogYF9idWZmZXJPZmZzZXRgIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHJlbW92ZWQsIHRvIG1ha2Ugc3VyZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBhY2N1cmF0ZS5cbiAgICAgICAgICovdGhpcy5fYnVmZmVyT2Zmc2V0PTA7LyoqIFNvbWUgYmVoYXZpb3IsIGVnLiB3aGVuIGRlY29kaW5nIGVudGl0aWVzLCBpcyBkb25lIHdoaWxlIHdlIGFyZSBpbiBhbm90aGVyIHN0YXRlLiBUaGlzIGtlZXBzIHRyYWNrIG9mIHRoZSBvdGhlciBzdGF0ZSB0eXBlLiAqL3RoaXMuX2Jhc2VTdGF0ZT0xLyogVGV4dCAqLzsvKiogRm9yIHNwZWNpYWwgcGFyc2luZyBiZWhhdmlvciBpbnNpZGUgb2Ygc2NyaXB0IGFuZCBzdHlsZSB0YWdzLiAqL3RoaXMuX3NwZWNpYWw9MS8qIE5vbmUgKi87LyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0b2tlbml6ZXIgaGFzIGJlZW4gcGF1c2VkLiAqL3RoaXMuX3J1bm5pbmc9dHJ1ZTsvKiogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRva2VuaXplciBoYXMgZmluaXNoZWQgcnVubmluZyAvIGAuZW5kYCBoYXMgYmVlbiBjYWxsZWQuICovdGhpcy5fZW5kZWQ9ZmFsc2U7dGhpcy5fY2JzPWNiczt0aGlzLl94bWxNb2RlPSEhKG9wdGlvbnMmJm9wdGlvbnMueG1sTW9kZSk7dGhpcy5fZGVjb2RlRW50aXRpZXM9ISEob3B0aW9ucyYmb3B0aW9ucy5kZWNvZGVFbnRpdGllcyk7fVRva2VuaXplci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9idWZmZXI9XCJcIjt0aGlzLl9zZWN0aW9uU3RhcnQ9MDt0aGlzLl9pbmRleD0wO3RoaXMuX2J1ZmZlck9mZnNldD0wO3RoaXMuX2Jhc2VTdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9zcGVjaWFsPTEvKiBOb25lICovO3RoaXMuX3J1bm5pbmc9dHJ1ZTt0aGlzLl9lbmRlZD1mYWxzZTt9O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlVGV4dD1mdW5jdGlvbihjKXtpZihjPT09XCI8XCIpe2lmKHRoaXMuX2luZGV4PnRoaXMuX3NlY3Rpb25TdGFydCl7dGhpcy5fY2JzLm9udGV4dCh0aGlzLl9nZXRTZWN0aW9uKCkpO310aGlzLl9zdGF0ZT0yLyogQmVmb3JlVGFnTmFtZSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7fWVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMmJnRoaXMuX3NwZWNpYWw9PT0xLyogTm9uZSAqLyYmYz09PVwiJlwiKXtpZih0aGlzLl9pbmRleD50aGlzLl9zZWN0aW9uU3RhcnQpe3RoaXMuX2Nicy5vbnRleHQodGhpcy5fZ2V0U2VjdGlvbigpKTt9dGhpcy5fYmFzZVN0YXRlPTEvKiBUZXh0ICovO3RoaXMuX3N0YXRlPTUxLyogQmVmb3JlRW50aXR5ICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleDt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVRhZ05hbWU9ZnVuY3Rpb24oYyl7aWYoYz09PVwiL1wiKXt0aGlzLl9zdGF0ZT01LyogQmVmb3JlQ2xvc2luZ1RhZ05hbWUgKi87fWVsc2UgaWYoYz09PVwiPFwiKXt0aGlzLl9jYnMub250ZXh0KHRoaXMuX2dldFNlY3Rpb24oKSk7dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4O31lbHNlIGlmKGM9PT1cIj5cInx8dGhpcy5fc3BlY2lhbCE9PTEvKiBOb25lICovfHx3aGl0ZXNwYWNlKGMpKXt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt9ZWxzZSBpZihjPT09XCIhXCIpe3RoaXMuX3N0YXRlPTE1LyogQmVmb3JlRGVjbGFyYXRpb24gKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fWVsc2UgaWYoYz09PVwiP1wiKXt0aGlzLl9zdGF0ZT0xNy8qIEluUHJvY2Vzc2luZ0luc3RydWN0aW9uICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleCsxO31lbHNle3RoaXMuX3N0YXRlPSF0aGlzLl94bWxNb2RlJiYoYz09PVwic1wifHxjPT09XCJTXCIpPzMxLyogQmVmb3JlU3BlY2lhbCAqLzozLyogSW5UYWdOYW1lICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleDt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluVGFnTmFtZT1mdW5jdGlvbihjKXtpZihjPT09XCIvXCJ8fGM9PT1cIj5cInx8d2hpdGVzcGFjZShjKSl7dGhpcy5fZW1pdFRva2VuKFwib25vcGVudGFnbmFtZVwiKTt0aGlzLl9zdGF0ZT04LyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLzt0aGlzLl9pbmRleC0tO319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQ2xvc2luZ1RhZ05hbWU9ZnVuY3Rpb24oYyl7aWYod2hpdGVzcGFjZShjKSl7Ly8gaWdub3JlXG59ZWxzZSBpZihjPT09XCI+XCIpe3RoaXMuX3N0YXRlPTEvKiBUZXh0ICovO31lbHNlIGlmKHRoaXMuX3NwZWNpYWwhPT0xLyogTm9uZSAqLyl7aWYoYz09PVwic1wifHxjPT09XCJTXCIpe3RoaXMuX3N0YXRlPTMyLyogQmVmb3JlU3BlY2lhbEVuZCAqLzt9ZWxzZXt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9pbmRleC0tO319ZWxzZXt0aGlzLl9zdGF0ZT02LyogSW5DbG9zaW5nVGFnTmFtZSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkNsb3NpbmdUYWdOYW1lPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIj5cInx8d2hpdGVzcGFjZShjKSl7dGhpcy5fZW1pdFRva2VuKFwib25jbG9zZXRhZ1wiKTt0aGlzLl9zdGF0ZT03LyogQWZ0ZXJDbG9zaW5nVGFnTmFtZSAqLzt0aGlzLl9pbmRleC0tO319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDbG9zaW5nVGFnTmFtZT1mdW5jdGlvbihjKXsvL3NraXAgZXZlcnl0aGluZyB1bnRpbCBcIj5cIlxuaWYoYz09PVwiPlwiKXt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWU9ZnVuY3Rpb24oYyl7aWYoYz09PVwiPlwiKXt0aGlzLl9jYnMub25vcGVudGFnZW5kKCk7dGhpcy5fc3RhdGU9MS8qIFRleHQgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fWVsc2UgaWYoYz09PVwiL1wiKXt0aGlzLl9zdGF0ZT00LyogSW5TZWxmQ2xvc2luZ1RhZyAqLzt9ZWxzZSBpZighd2hpdGVzcGFjZShjKSl7dGhpcy5fc3RhdGU9OS8qIEluQXR0cmlidXRlTmFtZSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJblNlbGZDbG9zaW5nVGFnPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIj5cIil7dGhpcy5fY2JzLm9uc2VsZmNsb3Npbmd0YWcoKTt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9ZWxzZSBpZighd2hpdGVzcGFjZShjKSl7dGhpcy5fc3RhdGU9OC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87dGhpcy5faW5kZXgtLTt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQXR0cmlidXRlTmFtZT1mdW5jdGlvbihjKXtpZihjPT09XCI9XCJ8fGM9PT1cIi9cInx8Yz09PVwiPlwifHx3aGl0ZXNwYWNlKGMpKXt0aGlzLl9jYnMub25hdHRyaWJuYW1lKHRoaXMuX2dldFNlY3Rpb24oKSk7dGhpcy5fc2VjdGlvblN0YXJ0PS0xO3RoaXMuX3N0YXRlPTEwLyogQWZ0ZXJBdHRyaWJ1dGVOYW1lICovO3RoaXMuX2luZGV4LS07fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckF0dHJpYnV0ZU5hbWU9ZnVuY3Rpb24oYyl7aWYoYz09PVwiPVwiKXt0aGlzLl9zdGF0ZT0xMS8qIEJlZm9yZUF0dHJpYnV0ZVZhbHVlICovO31lbHNlIGlmKGM9PT1cIi9cInx8Yz09PVwiPlwiKXt0aGlzLl9jYnMub25hdHRyaWJlbmQoKTt0aGlzLl9zdGF0ZT04LyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLzt0aGlzLl9pbmRleC0tO31lbHNlIGlmKCF3aGl0ZXNwYWNlKGMpKXt0aGlzLl9jYnMub25hdHRyaWJlbmQoKTt0aGlzLl9zdGF0ZT05LyogSW5BdHRyaWJ1dGVOYW1lICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleDt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUF0dHJpYnV0ZVZhbHVlPWZ1bmN0aW9uKGMpe2lmKGM9PT0nXCInKXt0aGlzLl9zdGF0ZT0xMi8qIEluQXR0cmlidXRlVmFsdWVEcSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9ZWxzZSBpZihjPT09XCInXCIpe3RoaXMuX3N0YXRlPTEzLyogSW5BdHRyaWJ1dGVWYWx1ZVNxICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleCsxO31lbHNlIGlmKCF3aGl0ZXNwYWNlKGMpKXt0aGlzLl9zdGF0ZT0xNC8qIEluQXR0cmlidXRlVmFsdWVOcSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7dGhpcy5faW5kZXgtLTsvL3JlY29uc3VtZSB0b2tlblxufX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzPWZ1bmN0aW9uKGMpe2lmKGM9PT0nXCInKXt0aGlzLl9lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7dGhpcy5fY2JzLm9uYXR0cmliZW5kKCk7dGhpcy5fc3RhdGU9OC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87fWVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMmJmM9PT1cIiZcIil7dGhpcy5fZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO3RoaXMuX2Jhc2VTdGF0ZT10aGlzLl9zdGF0ZTt0aGlzLl9zdGF0ZT01MS8qIEJlZm9yZUVudGl0eSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVzPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIidcIil7dGhpcy5fZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO3RoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO3RoaXMuX3N0YXRlPTgvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovO31lbHNlIGlmKHRoaXMuX2RlY29kZUVudGl0aWVzJiZjPT09XCImXCIpe3RoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTt0aGlzLl9iYXNlU3RhdGU9dGhpcy5fc3RhdGU7dGhpcy5fc3RhdGU9NTEvKiBCZWZvcmVFbnRpdHkgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4O319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzPWZ1bmN0aW9uKGMpe2lmKHdoaXRlc3BhY2UoYyl8fGM9PT1cIj5cIil7dGhpcy5fZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO3RoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO3RoaXMuX3N0YXRlPTgvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovO3RoaXMuX2luZGV4LS07fWVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMmJmM9PT1cIiZcIil7dGhpcy5fZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO3RoaXMuX2Jhc2VTdGF0ZT10aGlzLl9zdGF0ZTt0aGlzLl9zdGF0ZT01MS8qIEJlZm9yZUVudGl0eSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVEZWNsYXJhdGlvbj1mdW5jdGlvbihjKXt0aGlzLl9zdGF0ZT1jPT09XCJbXCI/MjIvKiBCZWZvcmVDZGF0YTEgKi86Yz09PVwiLVwiPzE4LyogQmVmb3JlQ29tbWVudCAqLzoxNi8qIEluRGVjbGFyYXRpb24gKi87fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluRGVjbGFyYXRpb249ZnVuY3Rpb24oYyl7aWYoYz09PVwiPlwiKXt0aGlzLl9jYnMub25kZWNsYXJhdGlvbih0aGlzLl9nZXRTZWN0aW9uKCkpO3RoaXMuX3N0YXRlPTEvKiBUZXh0ICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleCsxO319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb249ZnVuY3Rpb24oYyl7aWYoYz09PVwiPlwiKXt0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24odGhpcy5fZ2V0U2VjdGlvbigpKTt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNvbW1lbnQ9ZnVuY3Rpb24oYyl7aWYoYz09PVwiLVwiKXt0aGlzLl9zdGF0ZT0xOS8qIEluQ29tbWVudCAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9ZWxzZXt0aGlzLl9zdGF0ZT0xNi8qIEluRGVjbGFyYXRpb24gKi87fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkNvbW1lbnQ9ZnVuY3Rpb24oYyl7aWYoYz09PVwiLVwiKXRoaXMuX3N0YXRlPTIwLyogQWZ0ZXJDb21tZW50MSAqLzt9O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDb21tZW50MT1mdW5jdGlvbihjKXtpZihjPT09XCItXCIpe3RoaXMuX3N0YXRlPTIxLyogQWZ0ZXJDb21tZW50MiAqLzt9ZWxzZXt0aGlzLl9zdGF0ZT0xOS8qIEluQ29tbWVudCAqLzt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ29tbWVudDI9ZnVuY3Rpb24oYyl7aWYoYz09PVwiPlwiKXsvL3JlbW92ZSAyIHRyYWlsaW5nIGNoYXJzXG50aGlzLl9jYnMub25jb21tZW50KHRoaXMuX2J1ZmZlci5zdWJzdHJpbmcodGhpcy5fc2VjdGlvblN0YXJ0LHRoaXMuX2luZGV4LTIpKTt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9ZWxzZSBpZihjIT09XCItXCIpe3RoaXMuX3N0YXRlPTE5LyogSW5Db21tZW50ICovO30vLyBlbHNlOiBzdGF5IGluIEFGVEVSX0NPTU1FTlRfMiAoYC0tLT5gKVxufTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNkYXRhNj1mdW5jdGlvbihjKXtpZihjPT09XCJbXCIpe3RoaXMuX3N0YXRlPTI4LyogSW5DZGF0YSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9ZWxzZXt0aGlzLl9zdGF0ZT0xNi8qIEluRGVjbGFyYXRpb24gKi87dGhpcy5faW5kZXgtLTt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQ2RhdGE9ZnVuY3Rpb24oYyl7aWYoYz09PVwiXVwiKXRoaXMuX3N0YXRlPTI5LyogQWZ0ZXJDZGF0YTEgKi87fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ2RhdGExPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIl1cIil0aGlzLl9zdGF0ZT0zMC8qIEFmdGVyQ2RhdGEyICovO2Vsc2UgdGhpcy5fc3RhdGU9MjgvKiBJbkNkYXRhICovO307VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNkYXRhMj1mdW5jdGlvbihjKXtpZihjPT09XCI+XCIpey8vcmVtb3ZlIDIgdHJhaWxpbmcgY2hhcnNcbnRoaXMuX2Nicy5vbmNkYXRhKHRoaXMuX2J1ZmZlci5zdWJzdHJpbmcodGhpcy5fc2VjdGlvblN0YXJ0LHRoaXMuX2luZGV4LTIpKTt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9ZWxzZSBpZihjIT09XCJdXCIpe3RoaXMuX3N0YXRlPTI4LyogSW5DZGF0YSAqLzt9Ly9lbHNlOiBzdGF5IGluIEFGVEVSX0NEQVRBXzIgKGBdXV0+YClcbn07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTcGVjaWFsPWZ1bmN0aW9uKGMpe2lmKGM9PT1cImNcInx8Yz09PVwiQ1wiKXt0aGlzLl9zdGF0ZT0zMy8qIEJlZm9yZVNjcmlwdDEgKi87fWVsc2UgaWYoYz09PVwidFwifHxjPT09XCJUXCIpe3RoaXMuX3N0YXRlPTQzLyogQmVmb3JlU3R5bGUxICovO31lbHNle3RoaXMuX3N0YXRlPTMvKiBJblRhZ05hbWUgKi87dGhpcy5faW5kZXgtLTsvL2NvbnN1bWUgdGhlIHRva2VuIGFnYWluXG59fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVNwZWNpYWxFbmQ9ZnVuY3Rpb24oYyl7aWYodGhpcy5fc3BlY2lhbD09PTIvKiBTY3JpcHQgKi8mJihjPT09XCJjXCJ8fGM9PT1cIkNcIikpe3RoaXMuX3N0YXRlPTM4LyogQWZ0ZXJTY3JpcHQxICovO31lbHNlIGlmKHRoaXMuX3NwZWNpYWw9PT0zLyogU3R5bGUgKi8mJihjPT09XCJ0XCJ8fGM9PT1cIlRcIikpe3RoaXMuX3N0YXRlPTQ3LyogQWZ0ZXJTdHlsZTEgKi87fWVsc2UgdGhpcy5fc3RhdGU9MS8qIFRleHQgKi87fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVNjcmlwdDU9ZnVuY3Rpb24oYyl7aWYoYz09PVwiL1wifHxjPT09XCI+XCJ8fHdoaXRlc3BhY2UoYykpe3RoaXMuX3NwZWNpYWw9Mi8qIFNjcmlwdCAqLzt9dGhpcy5fc3RhdGU9My8qIEluVGFnTmFtZSAqLzt0aGlzLl9pbmRleC0tOy8vY29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cbn07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclNjcmlwdDU9ZnVuY3Rpb24oYyl7aWYoYz09PVwiPlwifHx3aGl0ZXNwYWNlKGMpKXt0aGlzLl9zcGVjaWFsPTEvKiBOb25lICovO3RoaXMuX3N0YXRlPTYvKiBJbkNsb3NpbmdUYWdOYW1lICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleC02O3RoaXMuX2luZGV4LS07Ly9yZWNvbnN1bWUgdGhlIHRva2VuXG59ZWxzZSB0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt9O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU3R5bGU0PWZ1bmN0aW9uKGMpe2lmKGM9PT1cIi9cInx8Yz09PVwiPlwifHx3aGl0ZXNwYWNlKGMpKXt0aGlzLl9zcGVjaWFsPTMvKiBTdHlsZSAqLzt9dGhpcy5fc3RhdGU9My8qIEluVGFnTmFtZSAqLzt0aGlzLl9pbmRleC0tOy8vY29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cbn07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclN0eWxlND1mdW5jdGlvbihjKXtpZihjPT09XCI+XCJ8fHdoaXRlc3BhY2UoYykpe3RoaXMuX3NwZWNpYWw9MS8qIE5vbmUgKi87dGhpcy5fc3RhdGU9Ni8qIEluQ2xvc2luZ1RhZ05hbWUgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4LTU7dGhpcy5faW5kZXgtLTsvL3JlY29uc3VtZSB0aGUgdG9rZW5cbn1lbHNlIHRoaXMuX3N0YXRlPTEvKiBUZXh0ICovO307Ly9mb3IgZW50aXRpZXMgdGVybWluYXRlZCB3aXRoIGEgc2VtaWNvbG9uXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9wYXJzZU5hbWVkRW50aXR5U3RyaWN0PWZ1bmN0aW9uKCl7Ly9vZmZzZXQgPSAxXG5pZih0aGlzLl9zZWN0aW9uU3RhcnQrMTx0aGlzLl9pbmRleCl7dmFyIGVudGl0eT10aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCsxLHRoaXMuX2luZGV4KSxtYXA9dGhpcy5feG1sTW9kZT94bWxfanNvbl8xW1wiZGVmYXVsdFwiXTplbnRpdGllc19qc29uXzFbXCJkZWZhdWx0XCJdO2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsZW50aXR5KSl7Ly8gQHRzLWlnbm9yZVxudGhpcy5fZW1pdFBhcnRpYWwobWFwW2VudGl0eV0pO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleCsxO319fTsvL3BhcnNlcyBsZWdhY3kgZW50aXRpZXMgKHdpdGhvdXQgdHJhaWxpbmcgc2VtaWNvbG9uKVxuVG9rZW5pemVyLnByb3RvdHlwZS5fcGFyc2VMZWdhY3lFbnRpdHk9ZnVuY3Rpb24oKXt2YXIgc3RhcnQ9dGhpcy5fc2VjdGlvblN0YXJ0KzE7dmFyIGxpbWl0PXRoaXMuX2luZGV4LXN0YXJ0O2lmKGxpbWl0PjYpbGltaXQ9NjsvLyBUaGUgbWF4IGxlbmd0aCBvZiBsZWdhY3kgZW50aXRpZXMgaXMgNlxud2hpbGUobGltaXQ+PTIpey8vIFRoZSBtaW4gbGVuZ3RoIG9mIGxlZ2FjeSBlbnRpdGllcyBpcyAyXG52YXIgZW50aXR5PXRoaXMuX2J1ZmZlci5zdWJzdHIoc3RhcnQsbGltaXQpO2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsZWdhY3lfanNvbl8xW1wiZGVmYXVsdFwiXSxlbnRpdHkpKXsvLyBAdHMtaWdub3JlXG50aGlzLl9lbWl0UGFydGlhbChsZWdhY3lfanNvbl8xW1wiZGVmYXVsdFwiXVtlbnRpdHldKTt0aGlzLl9zZWN0aW9uU3RhcnQrPWxpbWl0KzE7cmV0dXJuO31lbHNle2xpbWl0LS07fX19O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5OYW1lZEVudGl0eT1mdW5jdGlvbihjKXtpZihjPT09XCI7XCIpe3RoaXMuX3BhcnNlTmFtZWRFbnRpdHlTdHJpY3QoKTtpZih0aGlzLl9zZWN0aW9uU3RhcnQrMTx0aGlzLl9pbmRleCYmIXRoaXMuX3htbE1vZGUpe3RoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7fXRoaXMuX3N0YXRlPXRoaXMuX2Jhc2VTdGF0ZTt9ZWxzZSBpZigoYzxcImFcInx8Yz5cInpcIikmJihjPFwiQVwifHxjPlwiWlwiKSYmKGM8XCIwXCJ8fGM+XCI5XCIpKXtpZih0aGlzLl94bWxNb2RlfHx0aGlzLl9zZWN0aW9uU3RhcnQrMT09PXRoaXMuX2luZGV4KXsvLyBpZ25vcmVcbn1lbHNlIGlmKHRoaXMuX2Jhc2VTdGF0ZSE9PTEvKiBUZXh0ICovKXtpZihjIT09XCI9XCIpe3RoaXMuX3BhcnNlTmFtZWRFbnRpdHlTdHJpY3QoKTt9fWVsc2V7dGhpcy5fcGFyc2VMZWdhY3lFbnRpdHkoKTt9dGhpcy5fc3RhdGU9dGhpcy5fYmFzZVN0YXRlO3RoaXMuX2luZGV4LS07fX07VG9rZW5pemVyLnByb3RvdHlwZS5fZGVjb2RlTnVtZXJpY0VudGl0eT1mdW5jdGlvbihvZmZzZXQsYmFzZSl7dmFyIHNlY3Rpb25TdGFydD10aGlzLl9zZWN0aW9uU3RhcnQrb2Zmc2V0O2lmKHNlY3Rpb25TdGFydCE9PXRoaXMuX2luZGV4KXsvL3BhcnNlIGVudGl0eVxudmFyIGVudGl0eT10aGlzLl9idWZmZXIuc3Vic3RyaW5nKHNlY3Rpb25TdGFydCx0aGlzLl9pbmRleCk7dmFyIHBhcnNlZD1wYXJzZUludChlbnRpdHksYmFzZSk7dGhpcy5fZW1pdFBhcnRpYWwoZGVjb2RlX2NvZGVwb2ludF8xW1wiZGVmYXVsdFwiXShwYXJzZWQpKTt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7fWVsc2V7dGhpcy5fc2VjdGlvblN0YXJ0LS07fXRoaXMuX3N0YXRlPXRoaXMuX2Jhc2VTdGF0ZTt9O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5OdW1lcmljRW50aXR5PWZ1bmN0aW9uKGMpe2lmKGM9PT1cIjtcIil7dGhpcy5fZGVjb2RlTnVtZXJpY0VudGl0eSgyLDEwKTt0aGlzLl9zZWN0aW9uU3RhcnQrKzt9ZWxzZSBpZihjPFwiMFwifHxjPlwiOVwiKXtpZighdGhpcy5feG1sTW9kZSl7dGhpcy5fZGVjb2RlTnVtZXJpY0VudGl0eSgyLDEwKTt9ZWxzZXt0aGlzLl9zdGF0ZT10aGlzLl9iYXNlU3RhdGU7fXRoaXMuX2luZGV4LS07fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkhleEVudGl0eT1mdW5jdGlvbihjKXtpZihjPT09XCI7XCIpe3RoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMywxNik7dGhpcy5fc2VjdGlvblN0YXJ0Kys7fWVsc2UgaWYoKGM8XCJhXCJ8fGM+XCJmXCIpJiYoYzxcIkFcInx8Yz5cIkZcIikmJihjPFwiMFwifHxjPlwiOVwiKSl7aWYoIXRoaXMuX3htbE1vZGUpe3RoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMywxNik7fWVsc2V7dGhpcy5fc3RhdGU9dGhpcy5fYmFzZVN0YXRlO310aGlzLl9pbmRleC0tO319O1Rva2VuaXplci5wcm90b3R5cGUuX2NsZWFudXA9ZnVuY3Rpb24oKXtpZih0aGlzLl9zZWN0aW9uU3RhcnQ8MCl7dGhpcy5fYnVmZmVyPVwiXCI7dGhpcy5fYnVmZmVyT2Zmc2V0Kz10aGlzLl9pbmRleDt0aGlzLl9pbmRleD0wO31lbHNlIGlmKHRoaXMuX3J1bm5pbmcpe2lmKHRoaXMuX3N0YXRlPT09MS8qIFRleHQgKi8pe2lmKHRoaXMuX3NlY3Rpb25TdGFydCE9PXRoaXMuX2luZGV4KXt0aGlzLl9jYnMub250ZXh0KHRoaXMuX2J1ZmZlci5zdWJzdHIodGhpcy5fc2VjdGlvblN0YXJ0KSk7fXRoaXMuX2J1ZmZlcj1cIlwiO3RoaXMuX2J1ZmZlck9mZnNldCs9dGhpcy5faW5kZXg7dGhpcy5faW5kZXg9MDt9ZWxzZSBpZih0aGlzLl9zZWN0aW9uU3RhcnQ9PT10aGlzLl9pbmRleCl7Ly90aGUgc2VjdGlvbiBqdXN0IHN0YXJ0ZWRcbnRoaXMuX2J1ZmZlcj1cIlwiO3RoaXMuX2J1ZmZlck9mZnNldCs9dGhpcy5faW5kZXg7dGhpcy5faW5kZXg9MDt9ZWxzZXsvL3JlbW92ZSBldmVyeXRoaW5nIHVubmVjZXNzYXJ5XG50aGlzLl9idWZmZXI9dGhpcy5fYnVmZmVyLnN1YnN0cih0aGlzLl9zZWN0aW9uU3RhcnQpO3RoaXMuX2luZGV4LT10aGlzLl9zZWN0aW9uU3RhcnQ7dGhpcy5fYnVmZmVyT2Zmc2V0Kz10aGlzLl9zZWN0aW9uU3RhcnQ7fXRoaXMuX3NlY3Rpb25TdGFydD0wO319Oy8vVE9ETyBtYWtlIGV2ZW50cyBjb25kaXRpb25hbFxuVG9rZW5pemVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihjaHVuayl7aWYodGhpcy5fZW5kZWQpdGhpcy5fY2JzLm9uZXJyb3IoRXJyb3IoXCIud3JpdGUoKSBhZnRlciBkb25lIVwiKSk7dGhpcy5fYnVmZmVyKz1jaHVuazt0aGlzLl9wYXJzZSgpO307Ly8gSXRlcmF0ZXMgdGhyb3VnaCB0aGUgYnVmZmVyLCBjYWxsaW5nIHRoZSBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuLy8gU3RhdGVzIHRoYXQgYXJlIG1vcmUgbGlrZWx5IHRvIGJlIGhpdCBhcmUgaGlnaGVyIHVwLCBhcyBhIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LlxuVG9rZW5pemVyLnByb3RvdHlwZS5fcGFyc2U9ZnVuY3Rpb24oKXt3aGlsZSh0aGlzLl9pbmRleDx0aGlzLl9idWZmZXIubGVuZ3RoJiZ0aGlzLl9ydW5uaW5nKXt2YXIgYz10aGlzLl9idWZmZXIuY2hhckF0KHRoaXMuX2luZGV4KTtpZih0aGlzLl9zdGF0ZT09PTEvKiBUZXh0ICovKXt0aGlzLl9zdGF0ZVRleHQoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xMi8qIEluQXR0cmlidXRlVmFsdWVEcSAqLyl7dGhpcy5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09OS8qIEluQXR0cmlidXRlTmFtZSAqLyl7dGhpcy5fc3RhdGVJbkF0dHJpYnV0ZU5hbWUoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xOS8qIEluQ29tbWVudCAqLyl7dGhpcy5fc3RhdGVJbkNvbW1lbnQoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT04LyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLyl7dGhpcy5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09My8qIEluVGFnTmFtZSAqLyl7dGhpcy5fc3RhdGVJblRhZ05hbWUoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT02LyogSW5DbG9zaW5nVGFnTmFtZSAqLyl7dGhpcy5fc3RhdGVJbkNsb3NpbmdUYWdOYW1lKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09Mi8qIEJlZm9yZVRhZ05hbWUgKi8pe3RoaXMuX3N0YXRlQmVmb3JlVGFnTmFtZShjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTEwLyogQWZ0ZXJBdHRyaWJ1dGVOYW1lICovKXt0aGlzLl9zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZShjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTEzLyogSW5BdHRyaWJ1dGVWYWx1ZVNxICovKXt0aGlzLl9zdGF0ZUluQXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZXMoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xMS8qIEJlZm9yZUF0dHJpYnV0ZVZhbHVlICovKXt0aGlzLl9zdGF0ZUJlZm9yZUF0dHJpYnV0ZVZhbHVlKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NS8qIEJlZm9yZUNsb3NpbmdUYWdOYW1lICovKXt0aGlzLl9zdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09Ny8qIEFmdGVyQ2xvc2luZ1RhZ05hbWUgKi8pe3RoaXMuX3N0YXRlQWZ0ZXJDbG9zaW5nVGFnTmFtZShjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTMxLyogQmVmb3JlU3BlY2lhbCAqLyl7dGhpcy5fc3RhdGVCZWZvcmVTcGVjaWFsKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MjAvKiBBZnRlckNvbW1lbnQxICovKXt0aGlzLl9zdGF0ZUFmdGVyQ29tbWVudDEoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xNC8qIEluQXR0cmlidXRlVmFsdWVOcSAqLyl7dGhpcy5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlTm9RdW90ZXMoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT00LyogSW5TZWxmQ2xvc2luZ1RhZyAqLyl7dGhpcy5fc3RhdGVJblNlbGZDbG9zaW5nVGFnKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MTYvKiBJbkRlY2xhcmF0aW9uICovKXt0aGlzLl9zdGF0ZUluRGVjbGFyYXRpb24oYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xNS8qIEJlZm9yZURlY2xhcmF0aW9uICovKXt0aGlzLl9zdGF0ZUJlZm9yZURlY2xhcmF0aW9uKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MjEvKiBBZnRlckNvbW1lbnQyICovKXt0aGlzLl9zdGF0ZUFmdGVyQ29tbWVudDIoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xOC8qIEJlZm9yZUNvbW1lbnQgKi8pe3RoaXMuX3N0YXRlQmVmb3JlQ29tbWVudChjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTMyLyogQmVmb3JlU3BlY2lhbEVuZCAqLyl7dGhpcy5fc3RhdGVCZWZvcmVTcGVjaWFsRW5kKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MzgvKiBBZnRlclNjcmlwdDEgKi8pe3N0YXRlQWZ0ZXJTY3JpcHQxKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0zOS8qIEFmdGVyU2NyaXB0MiAqLyl7c3RhdGVBZnRlclNjcmlwdDIodGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTQwLyogQWZ0ZXJTY3JpcHQzICovKXtzdGF0ZUFmdGVyU2NyaXB0Myh0aGlzLGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MzMvKiBCZWZvcmVTY3JpcHQxICovKXtzdGF0ZUJlZm9yZVNjcmlwdDEodGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTM0LyogQmVmb3JlU2NyaXB0MiAqLyl7c3RhdGVCZWZvcmVTY3JpcHQyKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0zNS8qIEJlZm9yZVNjcmlwdDMgKi8pe3N0YXRlQmVmb3JlU2NyaXB0Myh0aGlzLGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MzYvKiBCZWZvcmVTY3JpcHQ0ICovKXtzdGF0ZUJlZm9yZVNjcmlwdDQodGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTM3LyogQmVmb3JlU2NyaXB0NSAqLyl7dGhpcy5fc3RhdGVCZWZvcmVTY3JpcHQ1KGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NDEvKiBBZnRlclNjcmlwdDQgKi8pe3N0YXRlQWZ0ZXJTY3JpcHQ0KHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT00Mi8qIEFmdGVyU2NyaXB0NSAqLyl7dGhpcy5fc3RhdGVBZnRlclNjcmlwdDUoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT00My8qIEJlZm9yZVN0eWxlMSAqLyl7c3RhdGVCZWZvcmVTdHlsZTEodGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTI4LyogSW5DZGF0YSAqLyl7dGhpcy5fc3RhdGVJbkNkYXRhKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NDQvKiBCZWZvcmVTdHlsZTIgKi8pe3N0YXRlQmVmb3JlU3R5bGUyKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT00NS8qIEJlZm9yZVN0eWxlMyAqLyl7c3RhdGVCZWZvcmVTdHlsZTModGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTQ2LyogQmVmb3JlU3R5bGU0ICovKXt0aGlzLl9zdGF0ZUJlZm9yZVN0eWxlNChjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTQ3LyogQWZ0ZXJTdHlsZTEgKi8pe3N0YXRlQWZ0ZXJTdHlsZTEodGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTQ4LyogQWZ0ZXJTdHlsZTIgKi8pe3N0YXRlQWZ0ZXJTdHlsZTIodGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTQ5LyogQWZ0ZXJTdHlsZTMgKi8pe3N0YXRlQWZ0ZXJTdHlsZTModGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTUwLyogQWZ0ZXJTdHlsZTQgKi8pe3RoaXMuX3N0YXRlQWZ0ZXJTdHlsZTQoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xNy8qIEluUHJvY2Vzc2luZ0luc3RydWN0aW9uICovKXt0aGlzLl9zdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NTMvKiBJbk5hbWVkRW50aXR5ICovKXt0aGlzLl9zdGF0ZUluTmFtZWRFbnRpdHkoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0yMi8qIEJlZm9yZUNkYXRhMSAqLyl7c3RhdGVCZWZvcmVDZGF0YTEodGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTUxLyogQmVmb3JlRW50aXR5ICovKXtzdGF0ZUJlZm9yZUVudGl0eSh0aGlzLGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MjMvKiBCZWZvcmVDZGF0YTIgKi8pe3N0YXRlQmVmb3JlQ2RhdGEyKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0yNC8qIEJlZm9yZUNkYXRhMyAqLyl7c3RhdGVCZWZvcmVDZGF0YTModGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTI5LyogQWZ0ZXJDZGF0YTEgKi8pe3RoaXMuX3N0YXRlQWZ0ZXJDZGF0YTEoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0zMC8qIEFmdGVyQ2RhdGEyICovKXt0aGlzLl9zdGF0ZUFmdGVyQ2RhdGEyKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MjUvKiBCZWZvcmVDZGF0YTQgKi8pe3N0YXRlQmVmb3JlQ2RhdGE0KHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0yNi8qIEJlZm9yZUNkYXRhNSAqLyl7c3RhdGVCZWZvcmVDZGF0YTUodGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTI3LyogQmVmb3JlQ2RhdGE2ICovKXt0aGlzLl9zdGF0ZUJlZm9yZUNkYXRhNihjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTU1LyogSW5IZXhFbnRpdHkgKi8pe3RoaXMuX3N0YXRlSW5IZXhFbnRpdHkoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT01NC8qIEluTnVtZXJpY0VudGl0eSAqLyl7dGhpcy5fc3RhdGVJbk51bWVyaWNFbnRpdHkoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT01Mi8qIEJlZm9yZU51bWVyaWNFbnRpdHkgKi8pe3N0YXRlQmVmb3JlTnVtZXJpY0VudGl0eSh0aGlzLGMpO31lbHNle3RoaXMuX2Nicy5vbmVycm9yKEVycm9yKFwidW5rbm93biBfc3RhdGVcIiksdGhpcy5fc3RhdGUpO310aGlzLl9pbmRleCsrO310aGlzLl9jbGVhbnVwKCk7fTtUb2tlbml6ZXIucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKCl7dGhpcy5fcnVubmluZz1mYWxzZTt9O1Rva2VuaXplci5wcm90b3R5cGUucmVzdW1lPWZ1bmN0aW9uKCl7dGhpcy5fcnVubmluZz10cnVlO2lmKHRoaXMuX2luZGV4PHRoaXMuX2J1ZmZlci5sZW5ndGgpe3RoaXMuX3BhcnNlKCk7fWlmKHRoaXMuX2VuZGVkKXt0aGlzLl9maW5pc2goKTt9fTtUb2tlbml6ZXIucHJvdG90eXBlLmVuZD1mdW5jdGlvbihjaHVuayl7aWYodGhpcy5fZW5kZWQpdGhpcy5fY2JzLm9uZXJyb3IoRXJyb3IoXCIuZW5kKCkgYWZ0ZXIgZG9uZSFcIikpO2lmKGNodW5rKXRoaXMud3JpdGUoY2h1bmspO3RoaXMuX2VuZGVkPXRydWU7aWYodGhpcy5fcnVubmluZyl0aGlzLl9maW5pc2goKTt9O1Rva2VuaXplci5wcm90b3R5cGUuX2ZpbmlzaD1mdW5jdGlvbigpey8vaWYgdGhlcmUgaXMgcmVtYWluaW5nIGRhdGEsIGVtaXQgaXQgaW4gYSByZWFzb25hYmxlIHdheVxuaWYodGhpcy5fc2VjdGlvblN0YXJ0PHRoaXMuX2luZGV4KXt0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTt9dGhpcy5fY2JzLm9uZW5kKCk7fTtUb2tlbml6ZXIucHJvdG90eXBlLl9oYW5kbGVUcmFpbGluZ0RhdGE9ZnVuY3Rpb24oKXt2YXIgZGF0YT10aGlzLl9idWZmZXIuc3Vic3RyKHRoaXMuX3NlY3Rpb25TdGFydCk7aWYodGhpcy5fc3RhdGU9PT0yOC8qIEluQ2RhdGEgKi98fHRoaXMuX3N0YXRlPT09MjkvKiBBZnRlckNkYXRhMSAqL3x8dGhpcy5fc3RhdGU9PT0zMC8qIEFmdGVyQ2RhdGEyICovKXt0aGlzLl9jYnMub25jZGF0YShkYXRhKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTE5LyogSW5Db21tZW50ICovfHx0aGlzLl9zdGF0ZT09PTIwLyogQWZ0ZXJDb21tZW50MSAqL3x8dGhpcy5fc3RhdGU9PT0yMS8qIEFmdGVyQ29tbWVudDIgKi8pe3RoaXMuX2Nicy5vbmNvbW1lbnQoZGF0YSk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT01My8qIEluTmFtZWRFbnRpdHkgKi8mJiF0aGlzLl94bWxNb2RlKXt0aGlzLl9wYXJzZUxlZ2FjeUVudGl0eSgpO2lmKHRoaXMuX3NlY3Rpb25TdGFydDx0aGlzLl9pbmRleCl7dGhpcy5fc3RhdGU9dGhpcy5fYmFzZVN0YXRlO3RoaXMuX2hhbmRsZVRyYWlsaW5nRGF0YSgpO319ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTU0LyogSW5OdW1lcmljRW50aXR5ICovJiYhdGhpcy5feG1sTW9kZSl7dGhpcy5fZGVjb2RlTnVtZXJpY0VudGl0eSgyLDEwKTtpZih0aGlzLl9zZWN0aW9uU3RhcnQ8dGhpcy5faW5kZXgpe3RoaXMuX3N0YXRlPXRoaXMuX2Jhc2VTdGF0ZTt0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTt9fWVsc2UgaWYodGhpcy5fc3RhdGU9PT01NS8qIEluSGV4RW50aXR5ICovJiYhdGhpcy5feG1sTW9kZSl7dGhpcy5fZGVjb2RlTnVtZXJpY0VudGl0eSgzLDE2KTtpZih0aGlzLl9zZWN0aW9uU3RhcnQ8dGhpcy5faW5kZXgpe3RoaXMuX3N0YXRlPXRoaXMuX2Jhc2VTdGF0ZTt0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTt9fWVsc2UgaWYodGhpcy5fc3RhdGUhPT0zLyogSW5UYWdOYW1lICovJiZ0aGlzLl9zdGF0ZSE9PTgvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovJiZ0aGlzLl9zdGF0ZSE9PTExLyogQmVmb3JlQXR0cmlidXRlVmFsdWUgKi8mJnRoaXMuX3N0YXRlIT09MTAvKiBBZnRlckF0dHJpYnV0ZU5hbWUgKi8mJnRoaXMuX3N0YXRlIT09OS8qIEluQXR0cmlidXRlTmFtZSAqLyYmdGhpcy5fc3RhdGUhPT0xMy8qIEluQXR0cmlidXRlVmFsdWVTcSAqLyYmdGhpcy5fc3RhdGUhPT0xMi8qIEluQXR0cmlidXRlVmFsdWVEcSAqLyYmdGhpcy5fc3RhdGUhPT0xNC8qIEluQXR0cmlidXRlVmFsdWVOcSAqLyYmdGhpcy5fc3RhdGUhPT02LyogSW5DbG9zaW5nVGFnTmFtZSAqLyl7dGhpcy5fY2JzLm9udGV4dChkYXRhKTt9Ly9lbHNlLCBpZ25vcmUgcmVtYWluaW5nIGRhdGFcbi8vVE9ETyBhZGQgYSB3YXkgdG8gcmVtb3ZlIGN1cnJlbnQgdGFnXG59O1Rva2VuaXplci5wcm90b3R5cGUuZ2V0QWJzb2x1dGVJbmRleD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9idWZmZXJPZmZzZXQrdGhpcy5faW5kZXg7fTtUb2tlbml6ZXIucHJvdG90eXBlLl9nZXRTZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1ZmZlci5zdWJzdHJpbmcodGhpcy5fc2VjdGlvblN0YXJ0LHRoaXMuX2luZGV4KTt9O1Rva2VuaXplci5wcm90b3R5cGUuX2VtaXRUb2tlbj1mdW5jdGlvbihuYW1lKXt0aGlzLl9jYnNbbmFtZV0odGhpcy5fZ2V0U2VjdGlvbigpKTt0aGlzLl9zZWN0aW9uU3RhcnQ9LTE7fTtUb2tlbml6ZXIucHJvdG90eXBlLl9lbWl0UGFydGlhbD1mdW5jdGlvbih2YWx1ZSl7aWYodGhpcy5fYmFzZVN0YXRlIT09MS8qIFRleHQgKi8pe3RoaXMuX2Nicy5vbmF0dHJpYmRhdGEodmFsdWUpOy8vVE9ETyBpbXBsZW1lbnQgdGhlIG5ldyBldmVudFxufWVsc2V7dGhpcy5fY2JzLm9udGV4dCh2YWx1ZSk7fX07cmV0dXJuIFRva2VuaXplcjt9KCk7ZXhwb3J0c1tcImRlZmF1bHRcIl09VG9rZW5pemVyO30se1wiZW50aXRpZXMvbGliL2RlY29kZV9jb2RlcG9pbnRcIjoxOCxcImVudGl0aWVzL2xpYi9tYXBzL2VudGl0aWVzLmpzb25cIjoyMixcImVudGl0aWVzL2xpYi9tYXBzL2xlZ2FjeS5qc29uXCI6MjMsXCJlbnRpdGllcy9saWIvbWFwcy94bWwuanNvblwiOjI0fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9fZXhwb3J0KG0pe2Zvcih2YXIgcCBpbiBtKXtpZighZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSlleHBvcnRzW3BdPW1bcF07fX12YXIgX19pbXBvcnRTdGFyPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihtb2Qpe2lmKG1vZCYmbW9kLl9fZXNNb2R1bGUpcmV0dXJuIG1vZDt2YXIgcmVzdWx0PXt9O2lmKG1vZCE9bnVsbClmb3IodmFyIGsgaW4gbW9kKXtpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsaykpcmVzdWx0W2tdPW1vZFtrXTt9cmVzdWx0W1wiZGVmYXVsdFwiXT1tb2Q7cmV0dXJuIHJlc3VsdDt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIFBhcnNlcl8xPXJlcXVpcmUoXCIuL1BhcnNlclwiKTtleHBvcnRzLlBhcnNlcj1QYXJzZXJfMS5QYXJzZXI7dmFyIGRvbWhhbmRsZXJfMT1yZXF1aXJlKFwiZG9taGFuZGxlclwiKTtleHBvcnRzLkRvbUhhbmRsZXI9ZG9taGFuZGxlcl8xLkRvbUhhbmRsZXI7ZXhwb3J0cy5EZWZhdWx0SGFuZGxlcj1kb21oYW5kbGVyXzEuRG9tSGFuZGxlcjsvLyBIZWxwZXIgbWV0aG9kc1xuLyoqXG4gKiBQYXJzZXMgZGF0YSwgcmV0dXJucyB0aGUgcmVzdWx0aW5nIERPTS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0aGF0IHNob3VsZCBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciB0aGUgcGFyc2VyIGFuZCBET00gYnVpbGRlci5cbiAqL2Z1bmN0aW9uIHBhcnNlRE9NKGRhdGEsb3B0aW9ucyl7dmFyIGhhbmRsZXI9bmV3IGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyKHZvaWQgMCxvcHRpb25zKTtuZXcgUGFyc2VyXzEuUGFyc2VyKGhhbmRsZXIsb3B0aW9ucykuZW5kKGRhdGEpO3JldHVybiBoYW5kbGVyLmRvbTt9ZXhwb3J0cy5wYXJzZURPTT1wYXJzZURPTTsvKipcbiAqIENyZWF0ZXMgYSBwYXJzZXIgaW5zdGFuY2UsIHdpdGggYW4gYXR0YWNoZWQgRE9NIGhhbmRsZXIuXG4gKlxuICogQHBhcmFtIGNiIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIHBhcnNpbmcgaGFzIGJlZW4gY29tcGxldGVkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGJ1aWxkZXIuXG4gKiBAcGFyYW0gZWxlbWVudENiIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSBhIHRhZyBoYXMgYmVlbiBjb21wbGV0ZWQgaW5zaWRlIG9mIHRoZSBET00uXG4gKi9mdW5jdGlvbiBjcmVhdGVEb21TdHJlYW0oY2Isb3B0aW9ucyxlbGVtZW50Q2Ipe3ZhciBoYW5kbGVyPW5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcihjYixvcHRpb25zLGVsZW1lbnRDYik7cmV0dXJuIG5ldyBQYXJzZXJfMS5QYXJzZXIoaGFuZGxlcixvcHRpb25zKTt9ZXhwb3J0cy5jcmVhdGVEb21TdHJlYW09Y3JlYXRlRG9tU3RyZWFtO3ZhciBUb2tlbml6ZXJfMT1yZXF1aXJlKFwiLi9Ub2tlbml6ZXJcIik7ZXhwb3J0cy5Ub2tlbml6ZXI9VG9rZW5pemVyXzFbXCJkZWZhdWx0XCJdO3ZhciBFbGVtZW50VHlwZT1fX2ltcG9ydFN0YXIocmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpKTtleHBvcnRzLkVsZW1lbnRUeXBlPUVsZW1lbnRUeXBlOy8qKlxuICogTGlzdCBvZiBhbGwgZXZlbnRzIHRoYXQgdGhlIHBhcnNlciBlbWl0cy5cbiAqXG4gKiBGb3JtYXQ6IGV2ZW50bmFtZTogbnVtYmVyIG9mIGFyZ3VtZW50cy5cbiAqL2V4cG9ydHMuRVZFTlRTPXthdHRyaWJ1dGU6MixjZGF0YXN0YXJ0OjAsY2RhdGFlbmQ6MCx0ZXh0OjEscHJvY2Vzc2luZ2luc3RydWN0aW9uOjIsY29tbWVudDoxLGNvbW1lbnRlbmQ6MCxjbG9zZXRhZzoxLG9wZW50YWc6MixvcGVudGFnbmFtZToxLGVycm9yOjEsZW5kOjB9Oy8qXG4gICAgQWxsIG9mIHRoZSBmb2xsb3dpbmcgZXhwb3J0cyBleGlzdCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuXG4gICAgVGhleSBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZCBldmVudHVhbGx5LlxuKi9fX2V4cG9ydChyZXF1aXJlKFwiLi9GZWVkSGFuZGxlclwiKSk7X19leHBvcnQocmVxdWlyZShcIi4vV3JpdGFibGVTdHJlYW1cIikpO19fZXhwb3J0KHJlcXVpcmUoXCIuL0NvbGxlY3RpbmdIYW5kbGVyXCIpKTt2YXIgRG9tVXRpbHM9X19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkb211dGlsc1wiKSk7ZXhwb3J0cy5Eb21VdGlscz1Eb21VdGlsczt2YXIgRmVlZEhhbmRsZXJfMT1yZXF1aXJlKFwiLi9GZWVkSGFuZGxlclwiKTtleHBvcnRzLlJzc0hhbmRsZXI9RmVlZEhhbmRsZXJfMS5GZWVkSGFuZGxlcjt9LHtcIi4vQ29sbGVjdGluZ0hhbmRsZXJcIjoyNixcIi4vRmVlZEhhbmRsZXJcIjoyNyxcIi4vUGFyc2VyXCI6MjksXCIuL1Rva2VuaXplclwiOjMwLFwiLi9Xcml0YWJsZVN0cmVhbVwiOjIsXCJkb21lbGVtZW50dHlwZVwiOjYsXCJkb21oYW5kbGVyXCI6NyxcImRvbXV0aWxzXCI6MTB9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7ZXhwb3J0cy5yZWFkPWZ1bmN0aW9uKGJ1ZmZlcixvZmZzZXQsaXNMRSxtTGVuLG5CeXRlcyl7dmFyIGUsbTt2YXIgZUxlbj1uQnl0ZXMqOC1tTGVuLTE7dmFyIGVNYXg9KDE8PGVMZW4pLTE7dmFyIGVCaWFzPWVNYXg+PjE7dmFyIG5CaXRzPS03O3ZhciBpPWlzTEU/bkJ5dGVzLTE6MDt2YXIgZD1pc0xFPy0xOjE7dmFyIHM9YnVmZmVyW29mZnNldCtpXTtpKz1kO2U9cyYoMTw8LW5CaXRzKS0xO3M+Pj0tbkJpdHM7bkJpdHMrPWVMZW47Zm9yKDtuQml0cz4wO2U9ZSoyNTYrYnVmZmVyW29mZnNldCtpXSxpKz1kLG5CaXRzLT04KXt9bT1lJigxPDwtbkJpdHMpLTE7ZT4+PS1uQml0cztuQml0cys9bUxlbjtmb3IoO25CaXRzPjA7bT1tKjI1NitidWZmZXJbb2Zmc2V0K2ldLGkrPWQsbkJpdHMtPTgpe31pZihlPT09MCl7ZT0xLWVCaWFzO31lbHNlIGlmKGU9PT1lTWF4KXtyZXR1cm4gbT9OYU46KHM/LTE6MSkqSW5maW5pdHk7fWVsc2V7bT1tK01hdGgucG93KDIsbUxlbik7ZT1lLWVCaWFzO31yZXR1cm4ocz8tMToxKSptKk1hdGgucG93KDIsZS1tTGVuKTt9O2V4cG9ydHMud3JpdGU9ZnVuY3Rpb24oYnVmZmVyLHZhbHVlLG9mZnNldCxpc0xFLG1MZW4sbkJ5dGVzKXt2YXIgZSxtLGM7dmFyIGVMZW49bkJ5dGVzKjgtbUxlbi0xO3ZhciBlTWF4PSgxPDxlTGVuKS0xO3ZhciBlQmlhcz1lTWF4Pj4xO3ZhciBydD1tTGVuPT09MjM/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowO3ZhciBpPWlzTEU/MDpuQnl0ZXMtMTt2YXIgZD1pc0xFPzE6LTE7dmFyIHM9dmFsdWU8MHx8dmFsdWU9PT0wJiYxL3ZhbHVlPDA/MTowO3ZhbHVlPU1hdGguYWJzKHZhbHVlKTtpZihpc05hTih2YWx1ZSl8fHZhbHVlPT09SW5maW5pdHkpe209aXNOYU4odmFsdWUpPzE6MDtlPWVNYXg7fWVsc2V7ZT1NYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKS9NYXRoLkxOMik7aWYodmFsdWUqKGM9TWF0aC5wb3coMiwtZSkpPDEpe2UtLTtjKj0yO31pZihlK2VCaWFzPj0xKXt2YWx1ZSs9cnQvYzt9ZWxzZXt2YWx1ZSs9cnQqTWF0aC5wb3coMiwxLWVCaWFzKTt9aWYodmFsdWUqYz49Mil7ZSsrO2MvPTI7fWlmKGUrZUJpYXM+PWVNYXgpe209MDtlPWVNYXg7fWVsc2UgaWYoZStlQmlhcz49MSl7bT0odmFsdWUqYy0xKSpNYXRoLnBvdygyLG1MZW4pO2U9ZStlQmlhczt9ZWxzZXttPXZhbHVlKk1hdGgucG93KDIsZUJpYXMtMSkqTWF0aC5wb3coMixtTGVuKTtlPTA7fX1mb3IoO21MZW4+PTg7YnVmZmVyW29mZnNldCtpXT1tJjB4ZmYsaSs9ZCxtLz0yNTYsbUxlbi09OCl7fWU9ZTw8bUxlbnxtO2VMZW4rPW1MZW47Zm9yKDtlTGVuPjA7YnVmZmVyW29mZnNldCtpXT1lJjB4ZmYsaSs9ZCxlLz0yNTYsZUxlbi09OCl7fWJ1ZmZlcltvZmZzZXQraS1kXXw9cyoxMjg7fTt9LHt9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGdldE5hdGl2ZT1yZXF1aXJlKCcuL19nZXROYXRpdmUnKSxyb290PXJlcXVpcmUoJy4vX3Jvb3QnKTsvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovdmFyIERhdGFWaWV3PWdldE5hdGl2ZShyb290LCdEYXRhVmlldycpO21vZHVsZS5leHBvcnRzPURhdGFWaWV3O30se1wiLi9fZ2V0TmF0aXZlXCI6OTMsXCIuL19yb290XCI6MTMwfV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBoYXNoQ2xlYXI9cmVxdWlyZSgnLi9faGFzaENsZWFyJyksaGFzaERlbGV0ZT1yZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksaGFzaEdldD1yZXF1aXJlKCcuL19oYXNoR2V0JyksaGFzaEhhcz1yZXF1aXJlKCcuL19oYXNoSGFzJyksaGFzaFNldD1yZXF1aXJlKCcuL19oYXNoU2V0Jyk7LyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9mdW5jdGlvbiBIYXNoKGVudHJpZXMpe3ZhciBpbmRleD0tMSxsZW5ndGg9ZW50cmllcz09bnVsbD8wOmVudHJpZXMubGVuZ3RoO3RoaXMuY2xlYXIoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIGVudHJ5PWVudHJpZXNbaW5kZXhdO3RoaXMuc2V0KGVudHJ5WzBdLGVudHJ5WzFdKTt9fS8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyPWhhc2hDbGVhcjtIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ109aGFzaERlbGV0ZTtIYXNoLnByb3RvdHlwZS5nZXQ9aGFzaEdldDtIYXNoLnByb3RvdHlwZS5oYXM9aGFzaEhhcztIYXNoLnByb3RvdHlwZS5zZXQ9aGFzaFNldDttb2R1bGUuZXhwb3J0cz1IYXNoO30se1wiLi9faGFzaENsZWFyXCI6MTAwLFwiLi9faGFzaERlbGV0ZVwiOjEwMSxcIi4vX2hhc2hHZXRcIjoxMDIsXCIuL19oYXNoSGFzXCI6MTAzLFwiLi9faGFzaFNldFwiOjEwNH1dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgbGlzdENhY2hlQ2xlYXI9cmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxsaXN0Q2FjaGVEZWxldGU9cmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksbGlzdENhY2hlR2V0PXJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLGxpc3RDYWNoZUhhcz1yZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxsaXN0Q2FjaGVTZXQ9cmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7LyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpe3ZhciBpbmRleD0tMSxsZW5ndGg9ZW50cmllcz09bnVsbD8wOmVudHJpZXMubGVuZ3RoO3RoaXMuY2xlYXIoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIGVudHJ5PWVudHJpZXNbaW5kZXhdO3RoaXMuc2V0KGVudHJ5WzBdLGVudHJ5WzFdKTt9fS8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhcj1saXN0Q2FjaGVDbGVhcjtMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXT1saXN0Q2FjaGVEZWxldGU7TGlzdENhY2hlLnByb3RvdHlwZS5nZXQ9bGlzdENhY2hlR2V0O0xpc3RDYWNoZS5wcm90b3R5cGUuaGFzPWxpc3RDYWNoZUhhcztMaXN0Q2FjaGUucHJvdG90eXBlLnNldD1saXN0Q2FjaGVTZXQ7bW9kdWxlLmV4cG9ydHM9TGlzdENhY2hlO30se1wiLi9fbGlzdENhY2hlQ2xlYXJcIjoxMTMsXCIuL19saXN0Q2FjaGVEZWxldGVcIjoxMTQsXCIuL19saXN0Q2FjaGVHZXRcIjoxMTUsXCIuL19saXN0Q2FjaGVIYXNcIjoxMTYsXCIuL19saXN0Q2FjaGVTZXRcIjoxMTd9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGdldE5hdGl2ZT1yZXF1aXJlKCcuL19nZXROYXRpdmUnKSxyb290PXJlcXVpcmUoJy4vX3Jvb3QnKTsvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovdmFyIE1hcD1nZXROYXRpdmUocm9vdCwnTWFwJyk7bW9kdWxlLmV4cG9ydHM9TWFwO30se1wiLi9fZ2V0TmF0aXZlXCI6OTMsXCIuL19yb290XCI6MTMwfV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBtYXBDYWNoZUNsZWFyPXJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxtYXBDYWNoZURlbGV0ZT1yZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLG1hcENhY2hlR2V0PXJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksbWFwQ2FjaGVIYXM9cmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxtYXBDYWNoZVNldD1yZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpOy8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcyl7dmFyIGluZGV4PS0xLGxlbmd0aD1lbnRyaWVzPT1udWxsPzA6ZW50cmllcy5sZW5ndGg7dGhpcy5jbGVhcigpO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgZW50cnk9ZW50cmllc1tpbmRleF07dGhpcy5zZXQoZW50cnlbMF0sZW50cnlbMV0pO319Ly8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhcj1tYXBDYWNoZUNsZWFyO01hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ109bWFwQ2FjaGVEZWxldGU7TWFwQ2FjaGUucHJvdG90eXBlLmdldD1tYXBDYWNoZUdldDtNYXBDYWNoZS5wcm90b3R5cGUuaGFzPW1hcENhY2hlSGFzO01hcENhY2hlLnByb3RvdHlwZS5zZXQ9bWFwQ2FjaGVTZXQ7bW9kdWxlLmV4cG9ydHM9TWFwQ2FjaGU7fSx7XCIuL19tYXBDYWNoZUNsZWFyXCI6MTE4LFwiLi9fbWFwQ2FjaGVEZWxldGVcIjoxMTksXCIuL19tYXBDYWNoZUdldFwiOjEyMCxcIi4vX21hcENhY2hlSGFzXCI6MTIxLFwiLi9fbWFwQ2FjaGVTZXRcIjoxMjJ9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGdldE5hdGl2ZT1yZXF1aXJlKCcuL19nZXROYXRpdmUnKSxyb290PXJlcXVpcmUoJy4vX3Jvb3QnKTsvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovdmFyIFByb21pc2U9Z2V0TmF0aXZlKHJvb3QsJ1Byb21pc2UnKTttb2R1bGUuZXhwb3J0cz1Qcm9taXNlO30se1wiLi9fZ2V0TmF0aXZlXCI6OTMsXCIuL19yb290XCI6MTMwfV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBnZXROYXRpdmU9cmVxdWlyZSgnLi9fZ2V0TmF0aXZlJykscm9vdD1yZXF1aXJlKCcuL19yb290Jyk7LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL3ZhciBTZXQ9Z2V0TmF0aXZlKHJvb3QsJ1NldCcpO21vZHVsZS5leHBvcnRzPVNldDt9LHtcIi4vX2dldE5hdGl2ZVwiOjkzLFwiLi9fcm9vdFwiOjEzMH1dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgTGlzdENhY2hlPXJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLHN0YWNrQ2xlYXI9cmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLHN0YWNrRGVsZXRlPXJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksc3RhY2tHZXQ9cmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxzdGFja0hhcz1yZXF1aXJlKCcuL19zdGFja0hhcycpLHN0YWNrU2V0PXJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7LyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL2Z1bmN0aW9uIFN0YWNrKGVudHJpZXMpe3ZhciBkYXRhPXRoaXMuX19kYXRhX189bmV3IExpc3RDYWNoZShlbnRyaWVzKTt0aGlzLnNpemU9ZGF0YS5zaXplO30vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyPXN0YWNrQ2xlYXI7U3RhY2sucHJvdG90eXBlWydkZWxldGUnXT1zdGFja0RlbGV0ZTtTdGFjay5wcm90b3R5cGUuZ2V0PXN0YWNrR2V0O1N0YWNrLnByb3RvdHlwZS5oYXM9c3RhY2tIYXM7U3RhY2sucHJvdG90eXBlLnNldD1zdGFja1NldDttb2R1bGUuZXhwb3J0cz1TdGFjazt9LHtcIi4vX0xpc3RDYWNoZVwiOjM1LFwiLi9fc3RhY2tDbGVhclwiOjEzNCxcIi4vX3N0YWNrRGVsZXRlXCI6MTM1LFwiLi9fc3RhY2tHZXRcIjoxMzYsXCIuL19zdGFja0hhc1wiOjEzNyxcIi4vX3N0YWNrU2V0XCI6MTM4fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciByb290PXJlcXVpcmUoJy4vX3Jvb3QnKTsvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi92YXIgX1N5bWJvbD1yb290LlN5bWJvbDttb2R1bGUuZXhwb3J0cz1fU3ltYm9sO30se1wiLi9fcm9vdFwiOjEzMH1dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgcm9vdD1yZXF1aXJlKCcuL19yb290Jyk7LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovdmFyIFVpbnQ4QXJyYXk9cm9vdC5VaW50OEFycmF5O21vZHVsZS5leHBvcnRzPVVpbnQ4QXJyYXk7fSx7XCIuL19yb290XCI6MTMwfV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBnZXROYXRpdmU9cmVxdWlyZSgnLi9fZ2V0TmF0aXZlJykscm9vdD1yZXF1aXJlKCcuL19yb290Jyk7LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL3ZhciBXZWFrTWFwPWdldE5hdGl2ZShyb290LCdXZWFrTWFwJyk7bW9kdWxlLmV4cG9ydHM9V2Vha01hcDt9LHtcIi4vX2dldE5hdGl2ZVwiOjkzLFwiLi9fcm9vdFwiOjEzMH1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovZnVuY3Rpb24gYXBwbHkoZnVuYyx0aGlzQXJnLGFyZ3Mpe3N3aXRjaChhcmdzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7Y2FzZSAxOnJldHVybiBmdW5jLmNhbGwodGhpc0FyZyxhcmdzWzBdKTtjYXNlIDI6cmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLGFyZ3NbMF0sYXJnc1sxXSk7Y2FzZSAzOnJldHVybiBmdW5jLmNhbGwodGhpc0FyZyxhcmdzWzBdLGFyZ3NbMV0sYXJnc1syXSk7fXJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsYXJncyk7fW1vZHVsZS5leHBvcnRzPWFwcGx5O30se31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL2Z1bmN0aW9uIGFycmF5RWFjaChhcnJheSxpdGVyYXRlZSl7dmFyIGluZGV4PS0xLGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDt3aGlsZSgrK2luZGV4PGxlbmd0aCl7aWYoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLGluZGV4LGFycmF5KT09PWZhbHNlKXticmVhazt9fXJldHVybiBhcnJheTt9bW9kdWxlLmV4cG9ydHM9YXJyYXlFYWNoO30se31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL2Z1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LHByZWRpY2F0ZSl7dmFyIGluZGV4PS0xLGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aCxyZXNJbmRleD0wLHJlc3VsdD1bXTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIHZhbHVlPWFycmF5W2luZGV4XTtpZihwcmVkaWNhdGUodmFsdWUsaW5kZXgsYXJyYXkpKXtyZXN1bHRbcmVzSW5kZXgrK109dmFsdWU7fX1yZXR1cm4gcmVzdWx0O31tb2R1bGUuZXhwb3J0cz1hcnJheUZpbHRlcjt9LHt9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2VUaW1lcz1yZXF1aXJlKCcuL19iYXNlVGltZXMnKSxpc0FyZ3VtZW50cz1yZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksaXNBcnJheT1yZXF1aXJlKCcuL2lzQXJyYXknKSxpc0J1ZmZlcj1yZXF1aXJlKCcuL2lzQnVmZmVyJyksaXNJbmRleD1yZXF1aXJlKCcuL19pc0luZGV4JyksaXNUeXBlZEFycmF5PXJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL3ZhciBoYXNPd25Qcm9wZXJ0eT1vYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsvKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSxpbmhlcml0ZWQpe3ZhciBpc0Fycj1pc0FycmF5KHZhbHVlKSxpc0FyZz0haXNBcnImJmlzQXJndW1lbnRzKHZhbHVlKSxpc0J1ZmY9IWlzQXJyJiYhaXNBcmcmJmlzQnVmZmVyKHZhbHVlKSxpc1R5cGU9IWlzQXJyJiYhaXNBcmcmJiFpc0J1ZmYmJmlzVHlwZWRBcnJheSh2YWx1ZSksc2tpcEluZGV4ZXM9aXNBcnJ8fGlzQXJnfHxpc0J1ZmZ8fGlzVHlwZSxyZXN1bHQ9c2tpcEluZGV4ZXM/YmFzZVRpbWVzKHZhbHVlLmxlbmd0aCxTdHJpbmcpOltdLGxlbmd0aD1yZXN1bHQubGVuZ3RoO2Zvcih2YXIga2V5IGluIHZhbHVlKXtpZigoaW5oZXJpdGVkfHxoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLGtleSkpJiYhKHNraXBJbmRleGVzJiYoLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxua2V5PT0nbGVuZ3RoJ3x8Ly8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG5pc0J1ZmYmJihrZXk9PSdvZmZzZXQnfHxrZXk9PSdwYXJlbnQnKXx8Ly8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuaXNUeXBlJiYoa2V5PT0nYnVmZmVyJ3x8a2V5PT0nYnl0ZUxlbmd0aCd8fGtleT09J2J5dGVPZmZzZXQnKXx8Ly8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuaXNJbmRleChrZXksbGVuZ3RoKSkpKXtyZXN1bHQucHVzaChrZXkpO319cmV0dXJuIHJlc3VsdDt9bW9kdWxlLmV4cG9ydHM9YXJyYXlMaWtlS2V5czt9LHtcIi4vX2Jhc2VUaW1lc1wiOjcyLFwiLi9faXNJbmRleFwiOjEwOCxcIi4vaXNBcmd1bWVudHNcIjoxNDUsXCIuL2lzQXJyYXlcIjoxNDYsXCIuL2lzQnVmZmVyXCI6MTQ5LFwiLi9pc1R5cGVkQXJyYXlcIjoxNTl9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9mdW5jdGlvbiBhcnJheU1hcChhcnJheSxpdGVyYXRlZSl7dmFyIGluZGV4PS0xLGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aCxyZXN1bHQ9QXJyYXkobGVuZ3RoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7cmVzdWx0W2luZGV4XT1pdGVyYXRlZShhcnJheVtpbmRleF0saW5kZXgsYXJyYXkpO31yZXR1cm4gcmVzdWx0O31tb2R1bGUuZXhwb3J0cz1hcnJheU1hcDt9LHt9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksdmFsdWVzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPXZhbHVlcy5sZW5ndGgsb2Zmc2V0PWFycmF5Lmxlbmd0aDt3aGlsZSgrK2luZGV4PGxlbmd0aCl7YXJyYXlbb2Zmc2V0K2luZGV4XT12YWx1ZXNbaW5kZXhdO31yZXR1cm4gYXJyYXk7fW1vZHVsZS5leHBvcnRzPWFycmF5UHVzaDt9LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2VBc3NpZ25WYWx1ZT1yZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxlcT1yZXF1aXJlKCcuL2VxJyk7LyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCxrZXksdmFsdWUpe2lmKHZhbHVlIT09dW5kZWZpbmVkJiYhZXEob2JqZWN0W2tleV0sdmFsdWUpfHx2YWx1ZT09PXVuZGVmaW5lZCYmIShrZXkgaW4gb2JqZWN0KSl7YmFzZUFzc2lnblZhbHVlKG9iamVjdCxrZXksdmFsdWUpO319bW9kdWxlLmV4cG9ydHM9YXNzaWduTWVyZ2VWYWx1ZTt9LHtcIi4vX2Jhc2VBc3NpZ25WYWx1ZVwiOjU1LFwiLi9lcVwiOjE0Mn1dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYmFzZUFzc2lnblZhbHVlPXJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLGVxPXJlcXVpcmUoJy4vZXEnKTsvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovdmFyIG9iamVjdFByb3RvPU9iamVjdC5wcm90b3R5cGU7LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovdmFyIGhhc093blByb3BlcnR5PW9iamVjdFByb3RvLmhhc093blByb3BlcnR5Oy8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LGtleSx2YWx1ZSl7dmFyIG9ialZhbHVlPW9iamVjdFtrZXldO2lmKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3Qsa2V5KSYmZXEob2JqVmFsdWUsdmFsdWUpKXx8dmFsdWU9PT11bmRlZmluZWQmJiEoa2V5IGluIG9iamVjdCkpe2Jhc2VBc3NpZ25WYWx1ZShvYmplY3Qsa2V5LHZhbHVlKTt9fW1vZHVsZS5leHBvcnRzPWFzc2lnblZhbHVlO30se1wiLi9fYmFzZUFzc2lnblZhbHVlXCI6NTUsXCIuL2VxXCI6MTQyfV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBlcT1yZXF1aXJlKCcuL2VxJyk7LyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL2Z1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSxrZXkpe3ZhciBsZW5ndGg9YXJyYXkubGVuZ3RoO3doaWxlKGxlbmd0aC0tKXtpZihlcShhcnJheVtsZW5ndGhdWzBdLGtleSkpe3JldHVybiBsZW5ndGg7fX1yZXR1cm4tMTt9bW9kdWxlLmV4cG9ydHM9YXNzb2NJbmRleE9mO30se1wiLi9lcVwiOjE0Mn1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgY29weU9iamVjdD1yZXF1aXJlKCcuL19jb3B5T2JqZWN0Jyksa2V5cz1yZXF1aXJlKCcuL2tleXMnKTsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL2Z1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LHNvdXJjZSl7cmV0dXJuIG9iamVjdCYmY29weU9iamVjdChzb3VyY2Usa2V5cyhzb3VyY2UpLG9iamVjdCk7fW1vZHVsZS5leHBvcnRzPWJhc2VBc3NpZ247fSx7XCIuL19jb3B5T2JqZWN0XCI6ODIsXCIuL2tleXNcIjoxNjB9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGNvcHlPYmplY3Q9cmVxdWlyZSgnLi9fY29weU9iamVjdCcpLGtleXNJbj1yZXF1aXJlKCcuL2tleXNJbicpOy8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LHNvdXJjZSl7cmV0dXJuIG9iamVjdCYmY29weU9iamVjdChzb3VyY2Usa2V5c0luKHNvdXJjZSksb2JqZWN0KTt9bW9kdWxlLmV4cG9ydHM9YmFzZUFzc2lnbkluO30se1wiLi9fY29weU9iamVjdFwiOjgyLFwiLi9rZXlzSW5cIjoxNjF9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGRlZmluZVByb3BlcnR5PXJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LGtleSx2YWx1ZSl7aWYoa2V5PT0nX19wcm90b19fJyYmZGVmaW5lUHJvcGVydHkpe2RlZmluZVByb3BlcnR5KG9iamVjdCxrZXkseydjb25maWd1cmFibGUnOnRydWUsJ2VudW1lcmFibGUnOnRydWUsJ3ZhbHVlJzp2YWx1ZSwnd3JpdGFibGUnOnRydWV9KTt9ZWxzZXtvYmplY3Rba2V5XT12YWx1ZTt9fW1vZHVsZS5leHBvcnRzPWJhc2VBc3NpZ25WYWx1ZTt9LHtcIi4vX2RlZmluZVByb3BlcnR5XCI6ODh9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIFN0YWNrPXJlcXVpcmUoJy4vX1N0YWNrJyksYXJyYXlFYWNoPXJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLGFzc2lnblZhbHVlPXJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksYmFzZUFzc2lnbj1yZXF1aXJlKCcuL19iYXNlQXNzaWduJyksYmFzZUFzc2lnbkluPXJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLGNsb25lQnVmZmVyPXJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksY29weUFycmF5PXJlcXVpcmUoJy4vX2NvcHlBcnJheScpLGNvcHlTeW1ib2xzPXJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksY29weVN5bWJvbHNJbj1yZXF1aXJlKCcuL19jb3B5U3ltYm9sc0luJyksZ2V0QWxsS2V5cz1yZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksZ2V0QWxsS2V5c0luPXJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLGdldFRhZz1yZXF1aXJlKCcuL19nZXRUYWcnKSxpbml0Q2xvbmVBcnJheT1yZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLGluaXRDbG9uZUJ5VGFnPXJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksaW5pdENsb25lT2JqZWN0PXJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLGlzQXJyYXk9cmVxdWlyZSgnLi9pc0FycmF5JyksaXNCdWZmZXI9cmVxdWlyZSgnLi9pc0J1ZmZlcicpLGlzTWFwPXJlcXVpcmUoJy4vaXNNYXAnKSxpc09iamVjdD1yZXF1aXJlKCcuL2lzT2JqZWN0JyksaXNTZXQ9cmVxdWlyZSgnLi9pc1NldCcpLGtleXM9cmVxdWlyZSgnLi9rZXlzJyk7LyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi92YXIgQ0xPTkVfREVFUF9GTEFHPTEsQ0xPTkVfRkxBVF9GTEFHPTIsQ0xPTkVfU1lNQk9MU19GTEFHPTQ7LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL3ZhciBhcmdzVGFnPSdbb2JqZWN0IEFyZ3VtZW50c10nLGFycmF5VGFnPSdbb2JqZWN0IEFycmF5XScsYm9vbFRhZz0nW29iamVjdCBCb29sZWFuXScsZGF0ZVRhZz0nW29iamVjdCBEYXRlXScsZXJyb3JUYWc9J1tvYmplY3QgRXJyb3JdJyxmdW5jVGFnPSdbb2JqZWN0IEZ1bmN0aW9uXScsZ2VuVGFnPSdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsbWFwVGFnPSdbb2JqZWN0IE1hcF0nLG51bWJlclRhZz0nW29iamVjdCBOdW1iZXJdJyxvYmplY3RUYWc9J1tvYmplY3QgT2JqZWN0XScscmVnZXhwVGFnPSdbb2JqZWN0IFJlZ0V4cF0nLHNldFRhZz0nW29iamVjdCBTZXRdJyxzdHJpbmdUYWc9J1tvYmplY3QgU3RyaW5nXScsc3ltYm9sVGFnPSdbb2JqZWN0IFN5bWJvbF0nLHdlYWtNYXBUYWc9J1tvYmplY3QgV2Vha01hcF0nO3ZhciBhcnJheUJ1ZmZlclRhZz0nW29iamVjdCBBcnJheUJ1ZmZlcl0nLGRhdGFWaWV3VGFnPSdbb2JqZWN0IERhdGFWaWV3XScsZmxvYXQzMlRhZz0nW29iamVjdCBGbG9hdDMyQXJyYXldJyxmbG9hdDY0VGFnPSdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLGludDhUYWc9J1tvYmplY3QgSW50OEFycmF5XScsaW50MTZUYWc9J1tvYmplY3QgSW50MTZBcnJheV0nLGludDMyVGFnPSdbb2JqZWN0IEludDMyQXJyYXldJyx1aW50OFRhZz0nW29iamVjdCBVaW50OEFycmF5XScsdWludDhDbGFtcGVkVGFnPSdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsdWludDE2VGFnPSdbb2JqZWN0IFVpbnQxNkFycmF5XScsdWludDMyVGFnPSdbb2JqZWN0IFVpbnQzMkFycmF5XSc7LyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi92YXIgY2xvbmVhYmxlVGFncz17fTtjbG9uZWFibGVUYWdzW2FyZ3NUYWddPWNsb25lYWJsZVRhZ3NbYXJyYXlUYWddPWNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddPWNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddPWNsb25lYWJsZVRhZ3NbYm9vbFRhZ109Y2xvbmVhYmxlVGFnc1tkYXRlVGFnXT1jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddPWNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ109Y2xvbmVhYmxlVGFnc1tpbnQ4VGFnXT1jbG9uZWFibGVUYWdzW2ludDE2VGFnXT1jbG9uZWFibGVUYWdzW2ludDMyVGFnXT1jbG9uZWFibGVUYWdzW21hcFRhZ109Y2xvbmVhYmxlVGFnc1tudW1iZXJUYWddPWNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXT1jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ109Y2xvbmVhYmxlVGFnc1tzZXRUYWddPWNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXT1jbG9uZWFibGVUYWdzW3N5bWJvbFRhZ109Y2xvbmVhYmxlVGFnc1t1aW50OFRhZ109Y2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddPWNsb25lYWJsZVRhZ3NbdWludDE2VGFnXT1jbG9uZWFibGVUYWdzW3VpbnQzMlRhZ109dHJ1ZTtjbG9uZWFibGVUYWdzW2Vycm9yVGFnXT1jbG9uZWFibGVUYWdzW2Z1bmNUYWddPWNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ109ZmFsc2U7LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLGJpdG1hc2ssY3VzdG9taXplcixrZXksb2JqZWN0LHN0YWNrKXt2YXIgcmVzdWx0LGlzRGVlcD1iaXRtYXNrJkNMT05FX0RFRVBfRkxBRyxpc0ZsYXQ9Yml0bWFzayZDTE9ORV9GTEFUX0ZMQUcsaXNGdWxsPWJpdG1hc2smQ0xPTkVfU1lNQk9MU19GTEFHO2lmKGN1c3RvbWl6ZXIpe3Jlc3VsdD1vYmplY3Q/Y3VzdG9taXplcih2YWx1ZSxrZXksb2JqZWN0LHN0YWNrKTpjdXN0b21pemVyKHZhbHVlKTt9aWYocmVzdWx0IT09dW5kZWZpbmVkKXtyZXR1cm4gcmVzdWx0O31pZighaXNPYmplY3QodmFsdWUpKXtyZXR1cm4gdmFsdWU7fXZhciBpc0Fycj1pc0FycmF5KHZhbHVlKTtpZihpc0Fycil7cmVzdWx0PWluaXRDbG9uZUFycmF5KHZhbHVlKTtpZighaXNEZWVwKXtyZXR1cm4gY29weUFycmF5KHZhbHVlLHJlc3VsdCk7fX1lbHNle3ZhciB0YWc9Z2V0VGFnKHZhbHVlKSxpc0Z1bmM9dGFnPT1mdW5jVGFnfHx0YWc9PWdlblRhZztpZihpc0J1ZmZlcih2YWx1ZSkpe3JldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSxpc0RlZXApO31pZih0YWc9PW9iamVjdFRhZ3x8dGFnPT1hcmdzVGFnfHxpc0Z1bmMmJiFvYmplY3Qpe3Jlc3VsdD1pc0ZsYXR8fGlzRnVuYz97fTppbml0Q2xvbmVPYmplY3QodmFsdWUpO2lmKCFpc0RlZXApe3JldHVybiBpc0ZsYXQ/Y29weVN5bWJvbHNJbih2YWx1ZSxiYXNlQXNzaWduSW4ocmVzdWx0LHZhbHVlKSk6Y29weVN5bWJvbHModmFsdWUsYmFzZUFzc2lnbihyZXN1bHQsdmFsdWUpKTt9fWVsc2V7aWYoIWNsb25lYWJsZVRhZ3NbdGFnXSl7cmV0dXJuIG9iamVjdD92YWx1ZTp7fTt9cmVzdWx0PWluaXRDbG9uZUJ5VGFnKHZhbHVlLHRhZyxpc0RlZXApO319Ly8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbnN0YWNrfHwoc3RhY2s9bmV3IFN0YWNrKCkpO3ZhciBzdGFja2VkPXN0YWNrLmdldCh2YWx1ZSk7aWYoc3RhY2tlZCl7cmV0dXJuIHN0YWNrZWQ7fXN0YWNrLnNldCh2YWx1ZSxyZXN1bHQpO2lmKGlzU2V0KHZhbHVlKSl7dmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSl7cmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsYml0bWFzayxjdXN0b21pemVyLHN1YlZhbHVlLHZhbHVlLHN0YWNrKSk7fSk7fWVsc2UgaWYoaXNNYXAodmFsdWUpKXt2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLGtleSl7cmVzdWx0LnNldChrZXksYmFzZUNsb25lKHN1YlZhbHVlLGJpdG1hc2ssY3VzdG9taXplcixrZXksdmFsdWUsc3RhY2spKTt9KTt9dmFyIGtleXNGdW5jPWlzRnVsbD9pc0ZsYXQ/Z2V0QWxsS2V5c0luOmdldEFsbEtleXM6aXNGbGF0P2tleXNJbjprZXlzO3ZhciBwcm9wcz1pc0Fycj91bmRlZmluZWQ6a2V5c0Z1bmModmFsdWUpO2FycmF5RWFjaChwcm9wc3x8dmFsdWUsZnVuY3Rpb24oc3ViVmFsdWUsa2V5KXtpZihwcm9wcyl7a2V5PXN1YlZhbHVlO3N1YlZhbHVlPXZhbHVlW2tleV07fS8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5hc3NpZ25WYWx1ZShyZXN1bHQsa2V5LGJhc2VDbG9uZShzdWJWYWx1ZSxiaXRtYXNrLGN1c3RvbWl6ZXIsa2V5LHZhbHVlLHN0YWNrKSk7fSk7cmV0dXJuIHJlc3VsdDt9bW9kdWxlLmV4cG9ydHM9YmFzZUNsb25lO30se1wiLi9fU3RhY2tcIjo0MCxcIi4vX2FycmF5RWFjaFwiOjQ1LFwiLi9fYXNzaWduVmFsdWVcIjo1MSxcIi4vX2Jhc2VBc3NpZ25cIjo1MyxcIi4vX2Jhc2VBc3NpZ25JblwiOjU0LFwiLi9fY2xvbmVCdWZmZXJcIjo3NixcIi4vX2NvcHlBcnJheVwiOjgxLFwiLi9fY29weVN5bWJvbHNcIjo4MyxcIi4vX2NvcHlTeW1ib2xzSW5cIjo4NCxcIi4vX2dldEFsbEtleXNcIjo5MCxcIi4vX2dldEFsbEtleXNJblwiOjkxLFwiLi9fZ2V0VGFnXCI6OTgsXCIuL19pbml0Q2xvbmVBcnJheVwiOjEwNSxcIi4vX2luaXRDbG9uZUJ5VGFnXCI6MTA2LFwiLi9faW5pdENsb25lT2JqZWN0XCI6MTA3LFwiLi9pc0FycmF5XCI6MTQ2LFwiLi9pc0J1ZmZlclwiOjE0OSxcIi4vaXNNYXBcIjoxNTIsXCIuL2lzT2JqZWN0XCI6MTUzLFwiLi9pc1NldFwiOjE1NixcIi4va2V5c1wiOjE2MH1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgaXNPYmplY3Q9cmVxdWlyZSgnLi9pc09iamVjdCcpOy8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RDcmVhdGU9T2JqZWN0LmNyZWF0ZTsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovdmFyIGJhc2VDcmVhdGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBvYmplY3QoKXt9cmV0dXJuIGZ1bmN0aW9uKHByb3RvKXtpZighaXNPYmplY3QocHJvdG8pKXtyZXR1cm57fTt9aWYob2JqZWN0Q3JlYXRlKXtyZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTt9b2JqZWN0LnByb3RvdHlwZT1wcm90bzt2YXIgcmVzdWx0PW5ldyBvYmplY3QoKTtvYmplY3QucHJvdG90eXBlPXVuZGVmaW5lZDtyZXR1cm4gcmVzdWx0O307fSgpO21vZHVsZS5leHBvcnRzPWJhc2VDcmVhdGU7fSx7XCIuL2lzT2JqZWN0XCI6MTUzfV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBjcmVhdGVCYXNlRm9yPXJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL3ZhciBiYXNlRm9yPWNyZWF0ZUJhc2VGb3IoKTttb2R1bGUuZXhwb3J0cz1iYXNlRm9yO30se1wiLi9fY3JlYXRlQmFzZUZvclwiOjg3fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBhcnJheVB1c2g9cmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksaXNBcnJheT1yZXF1aXJlKCcuL2lzQXJyYXknKTsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3Qsa2V5c0Z1bmMsc3ltYm9sc0Z1bmMpe3ZhciByZXN1bHQ9a2V5c0Z1bmMob2JqZWN0KTtyZXR1cm4gaXNBcnJheShvYmplY3QpP3Jlc3VsdDphcnJheVB1c2gocmVzdWx0LHN5bWJvbHNGdW5jKG9iamVjdCkpO31tb2R1bGUuZXhwb3J0cz1iYXNlR2V0QWxsS2V5czt9LHtcIi4vX2FycmF5UHVzaFwiOjQ5LFwiLi9pc0FycmF5XCI6MTQ2fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBfU3ltYm9sMj1yZXF1aXJlKCcuL19TeW1ib2wnKSxnZXRSYXdUYWc9cmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksb2JqZWN0VG9TdHJpbmc9cmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTsvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovdmFyIG51bGxUYWc9J1tvYmplY3QgTnVsbF0nLHVuZGVmaW5lZFRhZz0nW29iamVjdCBVbmRlZmluZWRdJzsvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi92YXIgc3ltVG9TdHJpbmdUYWc9X1N5bWJvbDI/X1N5bWJvbDIudG9TdHJpbmdUYWc6dW5kZWZpbmVkOy8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSl7aWYodmFsdWU9PW51bGwpe3JldHVybiB2YWx1ZT09PXVuZGVmaW5lZD91bmRlZmluZWRUYWc6bnVsbFRhZzt9cmV0dXJuIHN5bVRvU3RyaW5nVGFnJiZzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpP2dldFJhd1RhZyh2YWx1ZSk6b2JqZWN0VG9TdHJpbmcodmFsdWUpO31tb2R1bGUuZXhwb3J0cz1iYXNlR2V0VGFnO30se1wiLi9fU3ltYm9sXCI6NDEsXCIuL19nZXRSYXdUYWdcIjo5NSxcIi4vX29iamVjdFRvU3RyaW5nXCI6MTI3fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBiYXNlR2V0VGFnPXJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxpc09iamVjdExpa2U9cmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTsvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovdmFyIGFyZ3NUYWc9J1tvYmplY3QgQXJndW1lbnRzXSc7LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKXtyZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSYmYmFzZUdldFRhZyh2YWx1ZSk9PWFyZ3NUYWc7fW1vZHVsZS5leHBvcnRzPWJhc2VJc0FyZ3VtZW50czt9LHtcIi4vX2Jhc2VHZXRUYWdcIjo2MCxcIi4vaXNPYmplY3RMaWtlXCI6MTU0fV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBnZXRUYWc9cmVxdWlyZSgnLi9fZ2V0VGFnJyksaXNPYmplY3RMaWtlPXJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL3ZhciBtYXBUYWc9J1tvYmplY3QgTWFwXSc7LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmdldFRhZyh2YWx1ZSk9PW1hcFRhZzt9bW9kdWxlLmV4cG9ydHM9YmFzZUlzTWFwO30se1wiLi9fZ2V0VGFnXCI6OTgsXCIuL2lzT2JqZWN0TGlrZVwiOjE1NH1dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgaXNGdW5jdGlvbj1yZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxpc01hc2tlZD1yZXF1aXJlKCcuL19pc01hc2tlZCcpLGlzT2JqZWN0PXJlcXVpcmUoJy4vaXNPYmplY3QnKSx0b1NvdXJjZT1yZXF1aXJlKCcuL190b1NvdXJjZScpOy8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi92YXIgcmVSZWdFeHBDaGFyPS9bXFxcXF4kLiorPygpW1xcXXt9fF0vZzsvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovdmFyIHJlSXNIb3N0Q3Rvcj0vXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvOy8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi92YXIgZnVuY1Byb3RvPUZ1bmN0aW9uLnByb3RvdHlwZSxvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi92YXIgZnVuY1RvU3RyaW5nPWZ1bmNQcm90by50b1N0cmluZzsvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi92YXIgaGFzT3duUHJvcGVydHk9b2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7LyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi92YXIgcmVJc05hdGl2ZT1SZWdFeHAoJ14nK2Z1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwnXFxcXCQmJykucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywnJDEuKj8nKSsnJCcpOy8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSl7aWYoIWlzT2JqZWN0KHZhbHVlKXx8aXNNYXNrZWQodmFsdWUpKXtyZXR1cm4gZmFsc2U7fXZhciBwYXR0ZXJuPWlzRnVuY3Rpb24odmFsdWUpP3JlSXNOYXRpdmU6cmVJc0hvc3RDdG9yO3JldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTt9bW9kdWxlLmV4cG9ydHM9YmFzZUlzTmF0aXZlO30se1wiLi9faXNNYXNrZWRcIjoxMTEsXCIuL190b1NvdXJjZVwiOjEzOSxcIi4vaXNGdW5jdGlvblwiOjE1MCxcIi4vaXNPYmplY3RcIjoxNTN9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGdldFRhZz1yZXF1aXJlKCcuL19nZXRUYWcnKSxpc09iamVjdExpa2U9cmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTsvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovdmFyIHNldFRhZz0nW29iamVjdCBTZXRdJzsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKXtyZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSYmZ2V0VGFnKHZhbHVlKT09c2V0VGFnO31tb2R1bGUuZXhwb3J0cz1iYXNlSXNTZXQ7fSx7XCIuL19nZXRUYWdcIjo5OCxcIi4vaXNPYmplY3RMaWtlXCI6MTU0fV0sNjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBiYXNlR2V0VGFnPXJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxpc0xlbmd0aD1yZXF1aXJlKCcuL2lzTGVuZ3RoJyksaXNPYmplY3RMaWtlPXJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL3ZhciBhcmdzVGFnPSdbb2JqZWN0IEFyZ3VtZW50c10nLGFycmF5VGFnPSdbb2JqZWN0IEFycmF5XScsYm9vbFRhZz0nW29iamVjdCBCb29sZWFuXScsZGF0ZVRhZz0nW29iamVjdCBEYXRlXScsZXJyb3JUYWc9J1tvYmplY3QgRXJyb3JdJyxmdW5jVGFnPSdbb2JqZWN0IEZ1bmN0aW9uXScsbWFwVGFnPSdbb2JqZWN0IE1hcF0nLG51bWJlclRhZz0nW29iamVjdCBOdW1iZXJdJyxvYmplY3RUYWc9J1tvYmplY3QgT2JqZWN0XScscmVnZXhwVGFnPSdbb2JqZWN0IFJlZ0V4cF0nLHNldFRhZz0nW29iamVjdCBTZXRdJyxzdHJpbmdUYWc9J1tvYmplY3QgU3RyaW5nXScsd2Vha01hcFRhZz0nW29iamVjdCBXZWFrTWFwXSc7dmFyIGFycmF5QnVmZmVyVGFnPSdbb2JqZWN0IEFycmF5QnVmZmVyXScsZGF0YVZpZXdUYWc9J1tvYmplY3QgRGF0YVZpZXddJyxmbG9hdDMyVGFnPSdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLGZsb2F0NjRUYWc9J1tvYmplY3QgRmxvYXQ2NEFycmF5XScsaW50OFRhZz0nW29iamVjdCBJbnQ4QXJyYXldJyxpbnQxNlRhZz0nW29iamVjdCBJbnQxNkFycmF5XScsaW50MzJUYWc9J1tvYmplY3QgSW50MzJBcnJheV0nLHVpbnQ4VGFnPSdbb2JqZWN0IFVpbnQ4QXJyYXldJyx1aW50OENsYW1wZWRUYWc9J1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyx1aW50MTZUYWc9J1tvYmplY3QgVWludDE2QXJyYXldJyx1aW50MzJUYWc9J1tvYmplY3QgVWludDMyQXJyYXldJzsvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovdmFyIHR5cGVkQXJyYXlUYWdzPXt9O3R5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddPXR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddPXR5cGVkQXJyYXlUYWdzW2ludDhUYWddPXR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXT10eXBlZEFycmF5VGFnc1tpbnQzMlRhZ109dHlwZWRBcnJheVRhZ3NbdWludDhUYWddPXR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ109dHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXT10eXBlZEFycmF5VGFnc1t1aW50MzJUYWddPXRydWU7dHlwZWRBcnJheVRhZ3NbYXJnc1RhZ109dHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddPXR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXT10eXBlZEFycmF5VGFnc1tib29sVGFnXT10eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ109dHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ109dHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddPXR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddPXR5cGVkQXJyYXlUYWdzW21hcFRhZ109dHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXT10eXBlZEFycmF5VGFnc1tvYmplY3RUYWddPXR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ109dHlwZWRBcnJheVRhZ3Nbc2V0VGFnXT10eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddPXR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddPWZhbHNlOy8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKXtyZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSYmaXNMZW5ndGgodmFsdWUubGVuZ3RoKSYmISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07fW1vZHVsZS5leHBvcnRzPWJhc2VJc1R5cGVkQXJyYXk7fSx7XCIuL19iYXNlR2V0VGFnXCI6NjAsXCIuL2lzTGVuZ3RoXCI6MTUxLFwiLi9pc09iamVjdExpa2VcIjoxNTR9XSw2NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGlzUHJvdG90eXBlPXJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksbmF0aXZlS2V5cz1yZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL3ZhciBoYXNPd25Qcm9wZXJ0eT1vYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL2Z1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCl7aWYoIWlzUHJvdG90eXBlKG9iamVjdCkpe3JldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7fXZhciByZXN1bHQ9W107Zm9yKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpe2lmKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LGtleSkmJmtleSE9J2NvbnN0cnVjdG9yJyl7cmVzdWx0LnB1c2goa2V5KTt9fXJldHVybiByZXN1bHQ7fW1vZHVsZS5leHBvcnRzPWJhc2VLZXlzO30se1wiLi9faXNQcm90b3R5cGVcIjoxMTIsXCIuL19uYXRpdmVLZXlzXCI6MTI0fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBpc09iamVjdD1yZXF1aXJlKCcuL2lzT2JqZWN0JyksaXNQcm90b3R5cGU9cmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxuYXRpdmVLZXlzSW49cmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL3ZhciBoYXNPd25Qcm9wZXJ0eT1vYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3Qpe2lmKCFpc09iamVjdChvYmplY3QpKXtyZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7fXZhciBpc1Byb3RvPWlzUHJvdG90eXBlKG9iamVjdCkscmVzdWx0PVtdO2Zvcih2YXIga2V5IGluIG9iamVjdCl7aWYoIShrZXk9PSdjb25zdHJ1Y3RvcicmJihpc1Byb3RvfHwhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3Qsa2V5KSkpKXtyZXN1bHQucHVzaChrZXkpO319cmV0dXJuIHJlc3VsdDt9bW9kdWxlLmV4cG9ydHM9YmFzZUtleXNJbjt9LHtcIi4vX2lzUHJvdG90eXBlXCI6MTEyLFwiLi9fbmF0aXZlS2V5c0luXCI6MTI1LFwiLi9pc09iamVjdFwiOjE1M31dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgU3RhY2s9cmVxdWlyZSgnLi9fU3RhY2snKSxhc3NpZ25NZXJnZVZhbHVlPXJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxiYXNlRm9yPXJlcXVpcmUoJy4vX2Jhc2VGb3InKSxiYXNlTWVyZ2VEZWVwPXJlcXVpcmUoJy4vX2Jhc2VNZXJnZURlZXAnKSxpc09iamVjdD1yZXF1aXJlKCcuL2lzT2JqZWN0Jyksa2V5c0luPXJlcXVpcmUoJy4va2V5c0luJyksc2FmZUdldD1yZXF1aXJlKCcuL19zYWZlR2V0Jyk7LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL2Z1bmN0aW9uIGJhc2VNZXJnZShvYmplY3Qsc291cmNlLHNyY0luZGV4LGN1c3RvbWl6ZXIsc3RhY2spe2lmKG9iamVjdD09PXNvdXJjZSl7cmV0dXJuO31iYXNlRm9yKHNvdXJjZSxmdW5jdGlvbihzcmNWYWx1ZSxrZXkpe3N0YWNrfHwoc3RhY2s9bmV3IFN0YWNrKCkpO2lmKGlzT2JqZWN0KHNyY1ZhbHVlKSl7YmFzZU1lcmdlRGVlcChvYmplY3Qsc291cmNlLGtleSxzcmNJbmRleCxiYXNlTWVyZ2UsY3VzdG9taXplcixzdGFjayk7fWVsc2V7dmFyIG5ld1ZhbHVlPWN1c3RvbWl6ZXI/Y3VzdG9taXplcihzYWZlR2V0KG9iamVjdCxrZXkpLHNyY1ZhbHVlLGtleSsnJyxvYmplY3Qsc291cmNlLHN0YWNrKTp1bmRlZmluZWQ7aWYobmV3VmFsdWU9PT11bmRlZmluZWQpe25ld1ZhbHVlPXNyY1ZhbHVlO31hc3NpZ25NZXJnZVZhbHVlKG9iamVjdCxrZXksbmV3VmFsdWUpO319LGtleXNJbik7fW1vZHVsZS5leHBvcnRzPWJhc2VNZXJnZTt9LHtcIi4vX1N0YWNrXCI6NDAsXCIuL19hc3NpZ25NZXJnZVZhbHVlXCI6NTAsXCIuL19iYXNlRm9yXCI6NTgsXCIuL19iYXNlTWVyZ2VEZWVwXCI6NjksXCIuL19zYWZlR2V0XCI6MTMxLFwiLi9pc09iamVjdFwiOjE1MyxcIi4va2V5c0luXCI6MTYxfV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBhc3NpZ25NZXJnZVZhbHVlPXJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxjbG9uZUJ1ZmZlcj1yZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLGNsb25lVHlwZWRBcnJheT1yZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxjb3B5QXJyYXk9cmVxdWlyZSgnLi9fY29weUFycmF5JyksaW5pdENsb25lT2JqZWN0PXJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLGlzQXJndW1lbnRzPXJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxpc0FycmF5PXJlcXVpcmUoJy4vaXNBcnJheScpLGlzQXJyYXlMaWtlT2JqZWN0PXJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxpc0J1ZmZlcj1yZXF1aXJlKCcuL2lzQnVmZmVyJyksaXNGdW5jdGlvbj1yZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxpc09iamVjdD1yZXF1aXJlKCcuL2lzT2JqZWN0JyksaXNQbGFpbk9iamVjdD1yZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxpc1R5cGVkQXJyYXk9cmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxzYWZlR2V0PXJlcXVpcmUoJy4vX3NhZmVHZXQnKSx0b1BsYWluT2JqZWN0PXJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpOy8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL2Z1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LHNvdXJjZSxrZXksc3JjSW5kZXgsbWVyZ2VGdW5jLGN1c3RvbWl6ZXIsc3RhY2spe3ZhciBvYmpWYWx1ZT1zYWZlR2V0KG9iamVjdCxrZXkpLHNyY1ZhbHVlPXNhZmVHZXQoc291cmNlLGtleSksc3RhY2tlZD1zdGFjay5nZXQoc3JjVmFsdWUpO2lmKHN0YWNrZWQpe2Fzc2lnbk1lcmdlVmFsdWUob2JqZWN0LGtleSxzdGFja2VkKTtyZXR1cm47fXZhciBuZXdWYWx1ZT1jdXN0b21pemVyP2N1c3RvbWl6ZXIob2JqVmFsdWUsc3JjVmFsdWUsa2V5KycnLG9iamVjdCxzb3VyY2Usc3RhY2spOnVuZGVmaW5lZDt2YXIgaXNDb21tb249bmV3VmFsdWU9PT11bmRlZmluZWQ7aWYoaXNDb21tb24pe3ZhciBpc0Fycj1pc0FycmF5KHNyY1ZhbHVlKSxpc0J1ZmY9IWlzQXJyJiZpc0J1ZmZlcihzcmNWYWx1ZSksaXNUeXBlZD0haXNBcnImJiFpc0J1ZmYmJmlzVHlwZWRBcnJheShzcmNWYWx1ZSk7bmV3VmFsdWU9c3JjVmFsdWU7aWYoaXNBcnJ8fGlzQnVmZnx8aXNUeXBlZCl7aWYoaXNBcnJheShvYmpWYWx1ZSkpe25ld1ZhbHVlPW9ialZhbHVlO31lbHNlIGlmKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSl7bmV3VmFsdWU9Y29weUFycmF5KG9ialZhbHVlKTt9ZWxzZSBpZihpc0J1ZmYpe2lzQ29tbW9uPWZhbHNlO25ld1ZhbHVlPWNsb25lQnVmZmVyKHNyY1ZhbHVlLHRydWUpO31lbHNlIGlmKGlzVHlwZWQpe2lzQ29tbW9uPWZhbHNlO25ld1ZhbHVlPWNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSx0cnVlKTt9ZWxzZXtuZXdWYWx1ZT1bXTt9fWVsc2UgaWYoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSl8fGlzQXJndW1lbnRzKHNyY1ZhbHVlKSl7bmV3VmFsdWU9b2JqVmFsdWU7aWYoaXNBcmd1bWVudHMob2JqVmFsdWUpKXtuZXdWYWx1ZT10b1BsYWluT2JqZWN0KG9ialZhbHVlKTt9ZWxzZSBpZighaXNPYmplY3Qob2JqVmFsdWUpfHxpc0Z1bmN0aW9uKG9ialZhbHVlKSl7bmV3VmFsdWU9aW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTt9fWVsc2V7aXNDb21tb249ZmFsc2U7fX1pZihpc0NvbW1vbil7Ly8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5zdGFjay5zZXQoc3JjVmFsdWUsbmV3VmFsdWUpO21lcmdlRnVuYyhuZXdWYWx1ZSxzcmNWYWx1ZSxzcmNJbmRleCxjdXN0b21pemVyLHN0YWNrKTtzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO31hc3NpZ25NZXJnZVZhbHVlKG9iamVjdCxrZXksbmV3VmFsdWUpO31tb2R1bGUuZXhwb3J0cz1iYXNlTWVyZ2VEZWVwO30se1wiLi9fYXNzaWduTWVyZ2VWYWx1ZVwiOjUwLFwiLi9fY2xvbmVCdWZmZXJcIjo3NixcIi4vX2Nsb25lVHlwZWRBcnJheVwiOjgwLFwiLi9fY29weUFycmF5XCI6ODEsXCIuL19pbml0Q2xvbmVPYmplY3RcIjoxMDcsXCIuL19zYWZlR2V0XCI6MTMxLFwiLi9pc0FyZ3VtZW50c1wiOjE0NSxcIi4vaXNBcnJheVwiOjE0NixcIi4vaXNBcnJheUxpa2VPYmplY3RcIjoxNDgsXCIuL2lzQnVmZmVyXCI6MTQ5LFwiLi9pc0Z1bmN0aW9uXCI6MTUwLFwiLi9pc09iamVjdFwiOjE1MyxcIi4vaXNQbGFpbk9iamVjdFwiOjE1NSxcIi4vaXNUeXBlZEFycmF5XCI6MTU5LFwiLi90b1BsYWluT2JqZWN0XCI6MTY1fV0sNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBpZGVudGl0eT1yZXF1aXJlKCcuL2lkZW50aXR5Jyksb3ZlclJlc3Q9cmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxzZXRUb1N0cmluZz1yZXF1aXJlKCcuL19zZXRUb1N0cmluZycpOy8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9mdW5jdGlvbiBiYXNlUmVzdChmdW5jLHN0YXJ0KXtyZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYyxzdGFydCxpZGVudGl0eSksZnVuYysnJyk7fW1vZHVsZS5leHBvcnRzPWJhc2VSZXN0O30se1wiLi9fb3ZlclJlc3RcIjoxMjksXCIuL19zZXRUb1N0cmluZ1wiOjEzMixcIi4vaWRlbnRpdHlcIjoxNDR9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGNvbnN0YW50PXJlcXVpcmUoJy4vY29uc3RhbnQnKSxkZWZpbmVQcm9wZXJ0eT1yZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLGlkZW50aXR5PXJlcXVpcmUoJy4vaWRlbnRpdHknKTsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi92YXIgYmFzZVNldFRvU3RyaW5nPSFkZWZpbmVQcm9wZXJ0eT9pZGVudGl0eTpmdW5jdGlvbihmdW5jLHN0cmluZyl7cmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsJ3RvU3RyaW5nJyx7J2NvbmZpZ3VyYWJsZSc6dHJ1ZSwnZW51bWVyYWJsZSc6ZmFsc2UsJ3ZhbHVlJzpjb25zdGFudChzdHJpbmcpLCd3cml0YWJsZSc6dHJ1ZX0pO307bW9kdWxlLmV4cG9ydHM9YmFzZVNldFRvU3RyaW5nO30se1wiLi9fZGVmaW5lUHJvcGVydHlcIjo4OCxcIi4vY29uc3RhbnRcIjoxNDEsXCIuL2lkZW50aXR5XCI6MTQ0fV0sNzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovZnVuY3Rpb24gYmFzZVRpbWVzKG4saXRlcmF0ZWUpe3ZhciBpbmRleD0tMSxyZXN1bHQ9QXJyYXkobik7d2hpbGUoKytpbmRleDxuKXtyZXN1bHRbaW5kZXhdPWl0ZXJhdGVlKGluZGV4KTt9cmV0dXJuIHJlc3VsdDt9bW9kdWxlLmV4cG9ydHM9YmFzZVRpbWVzO30se31dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgX1N5bWJvbDM9cmVxdWlyZSgnLi9fU3ltYm9sJyksYXJyYXlNYXA9cmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxpc0FycmF5PXJlcXVpcmUoJy4vaXNBcnJheScpLGlzU3ltYm9sPXJlcXVpcmUoJy4vaXNTeW1ib2wnKTsvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi92YXIgSU5GSU5JVFk9MS8wOy8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL3ZhciBzeW1ib2xQcm90bz1fU3ltYm9sMz9fU3ltYm9sMy5wcm90b3R5cGU6dW5kZWZpbmVkLHN5bWJvbFRvU3RyaW5nPXN5bWJvbFByb3RvP3N5bWJvbFByb3RvLnRvU3RyaW5nOnVuZGVmaW5lZDsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpey8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG5pZih0eXBlb2YgdmFsdWU9PSdzdHJpbmcnKXtyZXR1cm4gdmFsdWU7fWlmKGlzQXJyYXkodmFsdWUpKXsvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxucmV0dXJuIGFycmF5TWFwKHZhbHVlLGJhc2VUb1N0cmluZykrJyc7fWlmKGlzU3ltYm9sKHZhbHVlKSl7cmV0dXJuIHN5bWJvbFRvU3RyaW5nP3N5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpOicnO312YXIgcmVzdWx0PXZhbHVlKycnO3JldHVybiByZXN1bHQ9PScwJyYmMS92YWx1ZT09LUlORklOSVRZPyctMCc6cmVzdWx0O31tb2R1bGUuZXhwb3J0cz1iYXNlVG9TdHJpbmc7fSx7XCIuL19TeW1ib2xcIjo0MSxcIi4vX2FycmF5TWFwXCI6NDgsXCIuL2lzQXJyYXlcIjoxNDYsXCIuL2lzU3ltYm9sXCI6MTU4fV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYyl7cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKXtyZXR1cm4gZnVuYyh2YWx1ZSk7fTt9bW9kdWxlLmV4cG9ydHM9YmFzZVVuYXJ5O30se31dLDc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgVWludDhBcnJheT1yZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7LyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL2Z1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpe3ZhciByZXN1bHQ9bmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO25ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7cmV0dXJuIHJlc3VsdDt9bW9kdWxlLmV4cG9ydHM9Y2xvbmVBcnJheUJ1ZmZlcjt9LHtcIi4vX1VpbnQ4QXJyYXlcIjo0Mn1dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgcm9vdD1yZXF1aXJlKCcuL19yb290Jyk7LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi92YXIgZnJlZUV4cG9ydHM9X3R5cGVvZihleHBvcnRzKT09J29iamVjdCcmJmV4cG9ydHMmJiFleHBvcnRzLm5vZGVUeXBlJiZleHBvcnRzOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi92YXIgZnJlZU1vZHVsZT1mcmVlRXhwb3J0cyYmX3R5cGVvZihtb2R1bGUpPT0nb2JqZWN0JyYmbW9kdWxlJiYhbW9kdWxlLm5vZGVUeXBlJiZtb2R1bGU7LyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi92YXIgbW9kdWxlRXhwb3J0cz1mcmVlTW9kdWxlJiZmcmVlTW9kdWxlLmV4cG9ydHM9PT1mcmVlRXhwb3J0czsvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi92YXIgQnVmZmVyPW1vZHVsZUV4cG9ydHM/cm9vdC5CdWZmZXI6dW5kZWZpbmVkLGFsbG9jVW5zYWZlPUJ1ZmZlcj9CdWZmZXIuYWxsb2NVbnNhZmU6dW5kZWZpbmVkOy8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsaXNEZWVwKXtpZihpc0RlZXApe3JldHVybiBidWZmZXIuc2xpY2UoKTt9dmFyIGxlbmd0aD1idWZmZXIubGVuZ3RoLHJlc3VsdD1hbGxvY1Vuc2FmZT9hbGxvY1Vuc2FmZShsZW5ndGgpOm5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtidWZmZXIuY29weShyZXN1bHQpO3JldHVybiByZXN1bHQ7fW1vZHVsZS5leHBvcnRzPWNsb25lQnVmZmVyO30se1wiLi9fcm9vdFwiOjEzMH1dLDc3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgY2xvbmVBcnJheUJ1ZmZlcj1yZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7LyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL2Z1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsaXNEZWVwKXt2YXIgYnVmZmVyPWlzRGVlcD9jbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcik6ZGF0YVZpZXcuYnVmZmVyO3JldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLGRhdGFWaWV3LmJ5dGVPZmZzZXQsZGF0YVZpZXcuYnl0ZUxlbmd0aCk7fW1vZHVsZS5leHBvcnRzPWNsb25lRGF0YVZpZXc7fSx7XCIuL19jbG9uZUFycmF5QnVmZmVyXCI6NzV9XSw3ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovdmFyIHJlRmxhZ3M9L1xcdyokLzsvKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL2Z1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCl7dmFyIHJlc3VsdD1uZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UscmVGbGFncy5leGVjKHJlZ2V4cCkpO3Jlc3VsdC5sYXN0SW5kZXg9cmVnZXhwLmxhc3RJbmRleDtyZXR1cm4gcmVzdWx0O31tb2R1bGUuZXhwb3J0cz1jbG9uZVJlZ0V4cDt9LHt9XSw3OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIF9TeW1ib2w0PXJlcXVpcmUoJy4vX1N5bWJvbCcpOy8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL3ZhciBzeW1ib2xQcm90bz1fU3ltYm9sND9fU3ltYm9sNC5wcm90b3R5cGU6dW5kZWZpbmVkLHN5bWJvbFZhbHVlT2Y9c3ltYm9sUHJvdG8/c3ltYm9sUHJvdG8udmFsdWVPZjp1bmRlZmluZWQ7LyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKXtyZXR1cm4gc3ltYm9sVmFsdWVPZj9PYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpOnt9O31tb2R1bGUuZXhwb3J0cz1jbG9uZVN5bWJvbDt9LHtcIi4vX1N5bWJvbFwiOjQxfV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBjbG9uZUFycmF5QnVmZmVyPXJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTsvKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSxpc0RlZXApe3ZhciBidWZmZXI9aXNEZWVwP2Nsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpOnR5cGVkQXJyYXkuYnVmZmVyO3JldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsdHlwZWRBcnJheS5ieXRlT2Zmc2V0LHR5cGVkQXJyYXkubGVuZ3RoKTt9bW9kdWxlLmV4cG9ydHM9Y2xvbmVUeXBlZEFycmF5O30se1wiLi9fY2xvbmVBcnJheUJ1ZmZlclwiOjc1fV0sODE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL2Z1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsYXJyYXkpe3ZhciBpbmRleD0tMSxsZW5ndGg9c291cmNlLmxlbmd0aDthcnJheXx8KGFycmF5PUFycmF5KGxlbmd0aCkpO3doaWxlKCsraW5kZXg8bGVuZ3RoKXthcnJheVtpbmRleF09c291cmNlW2luZGV4XTt9cmV0dXJuIGFycmF5O31tb2R1bGUuZXhwb3J0cz1jb3B5QXJyYXk7fSx7fV0sODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBhc3NpZ25WYWx1ZT1yZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLGJhc2VBc3NpZ25WYWx1ZT1yZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTsvKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UscHJvcHMsb2JqZWN0LGN1c3RvbWl6ZXIpe3ZhciBpc05ldz0hb2JqZWN0O29iamVjdHx8KG9iamVjdD17fSk7dmFyIGluZGV4PS0xLGxlbmd0aD1wcm9wcy5sZW5ndGg7d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciBrZXk9cHJvcHNbaW5kZXhdO3ZhciBuZXdWYWx1ZT1jdXN0b21pemVyP2N1c3RvbWl6ZXIob2JqZWN0W2tleV0sc291cmNlW2tleV0sa2V5LG9iamVjdCxzb3VyY2UpOnVuZGVmaW5lZDtpZihuZXdWYWx1ZT09PXVuZGVmaW5lZCl7bmV3VmFsdWU9c291cmNlW2tleV07fWlmKGlzTmV3KXtiYXNlQXNzaWduVmFsdWUob2JqZWN0LGtleSxuZXdWYWx1ZSk7fWVsc2V7YXNzaWduVmFsdWUob2JqZWN0LGtleSxuZXdWYWx1ZSk7fX1yZXR1cm4gb2JqZWN0O31tb2R1bGUuZXhwb3J0cz1jb3B5T2JqZWN0O30se1wiLi9fYXNzaWduVmFsdWVcIjo1MSxcIi4vX2Jhc2VBc3NpZ25WYWx1ZVwiOjU1fV0sODM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBjb3B5T2JqZWN0PXJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxnZXRTeW1ib2xzPXJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTsvKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL2Z1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSxvYmplY3Qpe3JldHVybiBjb3B5T2JqZWN0KHNvdXJjZSxnZXRTeW1ib2xzKHNvdXJjZSksb2JqZWN0KTt9bW9kdWxlLmV4cG9ydHM9Y29weVN5bWJvbHM7fSx7XCIuL19jb3B5T2JqZWN0XCI6ODIsXCIuL19nZXRTeW1ib2xzXCI6OTZ9XSw4NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGNvcHlPYmplY3Q9cmVxdWlyZSgnLi9fY29weU9iamVjdCcpLGdldFN5bWJvbHNJbj1yZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTsvKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2Usb2JqZWN0KXtyZXR1cm4gY29weU9iamVjdChzb3VyY2UsZ2V0U3ltYm9sc0luKHNvdXJjZSksb2JqZWN0KTt9bW9kdWxlLmV4cG9ydHM9Y29weVN5bWJvbHNJbjt9LHtcIi4vX2NvcHlPYmplY3RcIjo4MixcIi4vX2dldFN5bWJvbHNJblwiOjk3fV0sODU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciByb290PXJlcXVpcmUoJy4vX3Jvb3QnKTsvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovdmFyIGNvcmVKc0RhdGE9cm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107bW9kdWxlLmV4cG9ydHM9Y29yZUpzRGF0YTt9LHtcIi4vX3Jvb3RcIjoxMzB9XSw4NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2VSZXN0PXJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksaXNJdGVyYXRlZUNhbGw9cmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTsvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcil7cmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCxzb3VyY2VzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPXNvdXJjZXMubGVuZ3RoLGN1c3RvbWl6ZXI9bGVuZ3RoPjE/c291cmNlc1tsZW5ndGgtMV06dW5kZWZpbmVkLGd1YXJkPWxlbmd0aD4yP3NvdXJjZXNbMl06dW5kZWZpbmVkO2N1c3RvbWl6ZXI9YXNzaWduZXIubGVuZ3RoPjMmJnR5cGVvZiBjdXN0b21pemVyPT0nZnVuY3Rpb24nPyhsZW5ndGgtLSxjdXN0b21pemVyKTp1bmRlZmluZWQ7aWYoZ3VhcmQmJmlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sc291cmNlc1sxXSxndWFyZCkpe2N1c3RvbWl6ZXI9bGVuZ3RoPDM/dW5kZWZpbmVkOmN1c3RvbWl6ZXI7bGVuZ3RoPTE7fW9iamVjdD1PYmplY3Qob2JqZWN0KTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIHNvdXJjZT1zb3VyY2VzW2luZGV4XTtpZihzb3VyY2Upe2Fzc2lnbmVyKG9iamVjdCxzb3VyY2UsaW5kZXgsY3VzdG9taXplcik7fX1yZXR1cm4gb2JqZWN0O30pO31tb2R1bGUuZXhwb3J0cz1jcmVhdGVBc3NpZ25lcjt9LHtcIi4vX2Jhc2VSZXN0XCI6NzAsXCIuL19pc0l0ZXJhdGVlQ2FsbFwiOjEwOX1dLDg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCl7cmV0dXJuIGZ1bmN0aW9uKG9iamVjdCxpdGVyYXRlZSxrZXlzRnVuYyl7dmFyIGluZGV4PS0xLGl0ZXJhYmxlPU9iamVjdChvYmplY3QpLHByb3BzPWtleXNGdW5jKG9iamVjdCksbGVuZ3RoPXByb3BzLmxlbmd0aDt3aGlsZShsZW5ndGgtLSl7dmFyIGtleT1wcm9wc1tmcm9tUmlnaHQ/bGVuZ3RoOisraW5kZXhdO2lmKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sa2V5LGl0ZXJhYmxlKT09PWZhbHNlKXticmVhazt9fXJldHVybiBvYmplY3Q7fTt9bW9kdWxlLmV4cG9ydHM9Y3JlYXRlQmFzZUZvcjt9LHt9XSw4ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGdldE5hdGl2ZT1yZXF1aXJlKCcuL19nZXROYXRpdmUnKTt2YXIgZGVmaW5lUHJvcGVydHk9ZnVuY3Rpb24oKXt0cnl7dmFyIGZ1bmM9Z2V0TmF0aXZlKE9iamVjdCwnZGVmaW5lUHJvcGVydHknKTtmdW5jKHt9LCcnLHt9KTtyZXR1cm4gZnVuYzt9Y2F0Y2goZSl7fX0oKTttb2R1bGUuZXhwb3J0cz1kZWZpbmVQcm9wZXJ0eTt9LHtcIi4vX2dldE5hdGl2ZVwiOjkzfV0sODk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpey8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovdmFyIGZyZWVHbG9iYWw9X3R5cGVvZihnbG9iYWwpPT0nb2JqZWN0JyYmZ2xvYmFsJiZnbG9iYWwuT2JqZWN0PT09T2JqZWN0JiZnbG9iYWw7bW9kdWxlLmV4cG9ydHM9ZnJlZUdsb2JhbDt9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCI/Z2xvYmFsOnR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSk7fSx7fV0sOTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBiYXNlR2V0QWxsS2V5cz1yZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLGdldFN5bWJvbHM9cmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLGtleXM9cmVxdWlyZSgnLi9rZXlzJyk7LyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3Qpe3JldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3Qsa2V5cyxnZXRTeW1ib2xzKTt9bW9kdWxlLmV4cG9ydHM9Z2V0QWxsS2V5czt9LHtcIi4vX2Jhc2VHZXRBbGxLZXlzXCI6NTksXCIuL19nZXRTeW1ib2xzXCI6OTYsXCIuL2tleXNcIjoxNjB9XSw5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2VHZXRBbGxLZXlzPXJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksZ2V0U3ltYm9sc0luPXJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLGtleXNJbj1yZXF1aXJlKCcuL2tleXNJbicpOy8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL2Z1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3Qpe3JldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3Qsa2V5c0luLGdldFN5bWJvbHNJbik7fW1vZHVsZS5leHBvcnRzPWdldEFsbEtleXNJbjt9LHtcIi4vX2Jhc2VHZXRBbGxLZXlzXCI6NTksXCIuL19nZXRTeW1ib2xzSW5cIjo5NyxcIi4va2V5c0luXCI6MTYxfV0sOTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBpc0tleWFibGU9cmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7LyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL2Z1bmN0aW9uIGdldE1hcERhdGEobWFwLGtleSl7dmFyIGRhdGE9bWFwLl9fZGF0YV9fO3JldHVybiBpc0tleWFibGUoa2V5KT9kYXRhW3R5cGVvZiBrZXk9PSdzdHJpbmcnPydzdHJpbmcnOidoYXNoJ106ZGF0YS5tYXA7fW1vZHVsZS5leHBvcnRzPWdldE1hcERhdGE7fSx7XCIuL19pc0tleWFibGVcIjoxMTB9XSw5MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2VJc05hdGl2ZT1yZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxnZXRWYWx1ZT1yZXF1aXJlKCcuL19nZXRWYWx1ZScpOy8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LGtleSl7dmFyIHZhbHVlPWdldFZhbHVlKG9iamVjdCxrZXkpO3JldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpP3ZhbHVlOnVuZGVmaW5lZDt9bW9kdWxlLmV4cG9ydHM9Z2V0TmF0aXZlO30se1wiLi9fYmFzZUlzTmF0aXZlXCI6NjMsXCIuL19nZXRWYWx1ZVwiOjk5fV0sOTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBvdmVyQXJnPXJlcXVpcmUoJy4vX292ZXJBcmcnKTsvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi92YXIgZ2V0UHJvdG90eXBlPW92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLE9iamVjdCk7bW9kdWxlLmV4cG9ydHM9Z2V0UHJvdG90eXBlO30se1wiLi9fb3ZlckFyZ1wiOjEyOH1dLDk1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgX1N5bWJvbDU9cmVxdWlyZSgnLi9fU3ltYm9sJyk7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL3ZhciBoYXNPd25Qcm9wZXJ0eT1vYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsvKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nPW9iamVjdFByb3RvLnRvU3RyaW5nOy8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL3ZhciBzeW1Ub1N0cmluZ1RhZz1fU3ltYm9sNT9fU3ltYm9sNS50b1N0cmluZ1RhZzp1bmRlZmluZWQ7LyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKXt2YXIgaXNPd249aGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSxzeW1Ub1N0cmluZ1RhZyksdGFnPXZhbHVlW3N5bVRvU3RyaW5nVGFnXTt0cnl7dmFsdWVbc3ltVG9TdHJpbmdUYWddPXVuZGVmaW5lZDt2YXIgdW5tYXNrZWQ9dHJ1ZTt9Y2F0Y2goZSl7fXZhciByZXN1bHQ9bmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7aWYodW5tYXNrZWQpe2lmKGlzT3duKXt2YWx1ZVtzeW1Ub1N0cmluZ1RhZ109dGFnO31lbHNle2RlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107fX1yZXR1cm4gcmVzdWx0O31tb2R1bGUuZXhwb3J0cz1nZXRSYXdUYWc7fSx7XCIuL19TeW1ib2xcIjo0MX1dLDk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYXJyYXlGaWx0ZXI9cmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxzdHViQXJyYXk9cmVxdWlyZSgnLi9zdHViQXJyYXknKTsvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovdmFyIG9iamVjdFByb3RvPU9iamVjdC5wcm90b3R5cGU7LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlPW9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlOy8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi92YXIgbmF0aXZlR2V0U3ltYm9scz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOy8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovdmFyIGdldFN5bWJvbHM9IW5hdGl2ZUdldFN5bWJvbHM/c3R1YkFycmF5OmZ1bmN0aW9uKG9iamVjdCl7aWYob2JqZWN0PT1udWxsKXtyZXR1cm5bXTt9b2JqZWN0PU9iamVjdChvYmplY3QpO3JldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksZnVuY3Rpb24oc3ltYm9sKXtyZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3Qsc3ltYm9sKTt9KTt9O21vZHVsZS5leHBvcnRzPWdldFN5bWJvbHM7fSx7XCIuL19hcnJheUZpbHRlclwiOjQ2LFwiLi9zdHViQXJyYXlcIjoxNjN9XSw5NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGFycmF5UHVzaD1yZXF1aXJlKCcuL19hcnJheVB1c2gnKSxnZXRQcm90b3R5cGU9cmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksZ2V0U3ltYm9scz1yZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksc3R1YkFycmF5PXJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL3ZhciBuYXRpdmVHZXRTeW1ib2xzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7LyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL3ZhciBnZXRTeW1ib2xzSW49IW5hdGl2ZUdldFN5bWJvbHM/c3R1YkFycmF5OmZ1bmN0aW9uKG9iamVjdCl7dmFyIHJlc3VsdD1bXTt3aGlsZShvYmplY3Qpe2FycmF5UHVzaChyZXN1bHQsZ2V0U3ltYm9scyhvYmplY3QpKTtvYmplY3Q9Z2V0UHJvdG90eXBlKG9iamVjdCk7fXJldHVybiByZXN1bHQ7fTttb2R1bGUuZXhwb3J0cz1nZXRTeW1ib2xzSW47fSx7XCIuL19hcnJheVB1c2hcIjo0OSxcIi4vX2dldFByb3RvdHlwZVwiOjk0LFwiLi9fZ2V0U3ltYm9sc1wiOjk2LFwiLi9zdHViQXJyYXlcIjoxNjN9XSw5ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIERhdGFWaWV3PXJlcXVpcmUoJy4vX0RhdGFWaWV3JyksTWFwPXJlcXVpcmUoJy4vX01hcCcpLFByb21pc2U9cmVxdWlyZSgnLi9fUHJvbWlzZScpLFNldD1yZXF1aXJlKCcuL19TZXQnKSxXZWFrTWFwPXJlcXVpcmUoJy4vX1dlYWtNYXAnKSxiYXNlR2V0VGFnPXJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSx0b1NvdXJjZT1yZXF1aXJlKCcuL190b1NvdXJjZScpOy8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi92YXIgbWFwVGFnPSdbb2JqZWN0IE1hcF0nLG9iamVjdFRhZz0nW29iamVjdCBPYmplY3RdJyxwcm9taXNlVGFnPSdbb2JqZWN0IFByb21pc2VdJyxzZXRUYWc9J1tvYmplY3QgU2V0XScsd2Vha01hcFRhZz0nW29iamVjdCBXZWFrTWFwXSc7dmFyIGRhdGFWaWV3VGFnPSdbb2JqZWN0IERhdGFWaWV3XSc7LyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi92YXIgZGF0YVZpZXdDdG9yU3RyaW5nPXRvU291cmNlKERhdGFWaWV3KSxtYXBDdG9yU3RyaW5nPXRvU291cmNlKE1hcCkscHJvbWlzZUN0b3JTdHJpbmc9dG9Tb3VyY2UoUHJvbWlzZSksc2V0Q3RvclN0cmluZz10b1NvdXJjZShTZXQpLHdlYWtNYXBDdG9yU3RyaW5nPXRvU291cmNlKFdlYWtNYXApOy8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi92YXIgZ2V0VGFnPWJhc2VHZXRUYWc7Ly8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYoRGF0YVZpZXcmJmdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkhPWRhdGFWaWV3VGFnfHxNYXAmJmdldFRhZyhuZXcgTWFwKCkpIT1tYXBUYWd8fFByb21pc2UmJmdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkhPXByb21pc2VUYWd8fFNldCYmZ2V0VGFnKG5ldyBTZXQoKSkhPXNldFRhZ3x8V2Vha01hcCYmZ2V0VGFnKG5ldyBXZWFrTWFwKCkpIT13ZWFrTWFwVGFnKXtnZXRUYWc9ZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKXt2YXIgcmVzdWx0PWJhc2VHZXRUYWcodmFsdWUpLEN0b3I9cmVzdWx0PT1vYmplY3RUYWc/dmFsdWUuY29uc3RydWN0b3I6dW5kZWZpbmVkLGN0b3JTdHJpbmc9Q3Rvcj90b1NvdXJjZShDdG9yKTonJztpZihjdG9yU3RyaW5nKXtzd2l0Y2goY3RvclN0cmluZyl7Y2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6cmV0dXJuIGRhdGFWaWV3VGFnO2Nhc2UgbWFwQ3RvclN0cmluZzpyZXR1cm4gbWFwVGFnO2Nhc2UgcHJvbWlzZUN0b3JTdHJpbmc6cmV0dXJuIHByb21pc2VUYWc7Y2FzZSBzZXRDdG9yU3RyaW5nOnJldHVybiBzZXRUYWc7Y2FzZSB3ZWFrTWFwQ3RvclN0cmluZzpyZXR1cm4gd2Vha01hcFRhZzt9fXJldHVybiByZXN1bHQ7fTt9bW9kdWxlLmV4cG9ydHM9Z2V0VGFnO30se1wiLi9fRGF0YVZpZXdcIjozMyxcIi4vX01hcFwiOjM2LFwiLi9fUHJvbWlzZVwiOjM4LFwiLi9fU2V0XCI6MzksXCIuL19XZWFrTWFwXCI6NDMsXCIuL19iYXNlR2V0VGFnXCI6NjAsXCIuL190b1NvdXJjZVwiOjEzOX1dLDk5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LGtleSl7cmV0dXJuIG9iamVjdD09bnVsbD91bmRlZmluZWQ6b2JqZWN0W2tleV07fW1vZHVsZS5leHBvcnRzPWdldFZhbHVlO30se31dLDEwMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIG5hdGl2ZUNyZWF0ZT1yZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTsvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovZnVuY3Rpb24gaGFzaENsZWFyKCl7dGhpcy5fX2RhdGFfXz1uYXRpdmVDcmVhdGU/bmF0aXZlQ3JlYXRlKG51bGwpOnt9O3RoaXMuc2l6ZT0wO31tb2R1bGUuZXhwb3J0cz1oYXNoQ2xlYXI7fSx7XCIuL19uYXRpdmVDcmVhdGVcIjoxMjN9XSwxMDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpe3ZhciByZXN1bHQ9dGhpcy5oYXMoa2V5KSYmZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTt0aGlzLnNpemUtPXJlc3VsdD8xOjA7cmV0dXJuIHJlc3VsdDt9bW9kdWxlLmV4cG9ydHM9aGFzaERlbGV0ZTt9LHt9XSwxMDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBuYXRpdmVDcmVhdGU9cmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7LyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL3ZhciBIQVNIX1VOREVGSU5FRD0nX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL3ZhciBoYXNPd25Qcm9wZXJ0eT1vYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsvKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL2Z1bmN0aW9uIGhhc2hHZXQoa2V5KXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fO2lmKG5hdGl2ZUNyZWF0ZSl7dmFyIHJlc3VsdD1kYXRhW2tleV07cmV0dXJuIHJlc3VsdD09PUhBU0hfVU5ERUZJTkVEP3VuZGVmaW5lZDpyZXN1bHQ7fXJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsa2V5KT9kYXRhW2tleV06dW5kZWZpbmVkO31tb2R1bGUuZXhwb3J0cz1oYXNoR2V0O30se1wiLi9fbmF0aXZlQ3JlYXRlXCI6MTIzfV0sMTAzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgbmF0aXZlQ3JlYXRlPXJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpOy8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi92YXIgb2JqZWN0UHJvdG89T2JqZWN0LnByb3RvdHlwZTsvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi92YXIgaGFzT3duUHJvcGVydHk9b2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7LyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaGFzaEhhcyhrZXkpe3ZhciBkYXRhPXRoaXMuX19kYXRhX187cmV0dXJuIG5hdGl2ZUNyZWF0ZT9kYXRhW2tleV0hPT11bmRlZmluZWQ6aGFzT3duUHJvcGVydHkuY2FsbChkYXRhLGtleSk7fW1vZHVsZS5leHBvcnRzPWhhc2hIYXM7fSx7XCIuL19uYXRpdmVDcmVhdGVcIjoxMjN9XSwxMDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBuYXRpdmVDcmVhdGU9cmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7LyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL3ZhciBIQVNIX1VOREVGSU5FRD0nX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7LyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL2Z1bmN0aW9uIGhhc2hTZXQoa2V5LHZhbHVlKXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fO3RoaXMuc2l6ZSs9dGhpcy5oYXMoa2V5KT8wOjE7ZGF0YVtrZXldPW5hdGl2ZUNyZWF0ZSYmdmFsdWU9PT11bmRlZmluZWQ/SEFTSF9VTkRFRklORUQ6dmFsdWU7cmV0dXJuIHRoaXM7fW1vZHVsZS5leHBvcnRzPWhhc2hTZXQ7fSx7XCIuL19uYXRpdmVDcmVhdGVcIjoxMjN9XSwxMDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi92YXIgb2JqZWN0UHJvdG89T2JqZWN0LnByb3RvdHlwZTsvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi92YXIgaGFzT3duUHJvcGVydHk9b2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7LyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL2Z1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aCxyZXN1bHQ9bmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7Ly8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbmlmKGxlbmd0aCYmdHlwZW9mIGFycmF5WzBdPT0nc3RyaW5nJyYmaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwnaW5kZXgnKSl7cmVzdWx0LmluZGV4PWFycmF5LmluZGV4O3Jlc3VsdC5pbnB1dD1hcnJheS5pbnB1dDt9cmV0dXJuIHJlc3VsdDt9bW9kdWxlLmV4cG9ydHM9aW5pdENsb25lQXJyYXk7fSx7fV0sMTA2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgY2xvbmVBcnJheUJ1ZmZlcj1yZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksY2xvbmVEYXRhVmlldz1yZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksY2xvbmVSZWdFeHA9cmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxjbG9uZVN5bWJvbD1yZXF1aXJlKCcuL19jbG9uZVN5bWJvbCcpLGNsb25lVHlwZWRBcnJheT1yZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTsvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovdmFyIGJvb2xUYWc9J1tvYmplY3QgQm9vbGVhbl0nLGRhdGVUYWc9J1tvYmplY3QgRGF0ZV0nLG1hcFRhZz0nW29iamVjdCBNYXBdJyxudW1iZXJUYWc9J1tvYmplY3QgTnVtYmVyXScscmVnZXhwVGFnPSdbb2JqZWN0IFJlZ0V4cF0nLHNldFRhZz0nW29iamVjdCBTZXRdJyxzdHJpbmdUYWc9J1tvYmplY3QgU3RyaW5nXScsc3ltYm9sVGFnPSdbb2JqZWN0IFN5bWJvbF0nO3ZhciBhcnJheUJ1ZmZlclRhZz0nW29iamVjdCBBcnJheUJ1ZmZlcl0nLGRhdGFWaWV3VGFnPSdbb2JqZWN0IERhdGFWaWV3XScsZmxvYXQzMlRhZz0nW29iamVjdCBGbG9hdDMyQXJyYXldJyxmbG9hdDY0VGFnPSdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLGludDhUYWc9J1tvYmplY3QgSW50OEFycmF5XScsaW50MTZUYWc9J1tvYmplY3QgSW50MTZBcnJheV0nLGludDMyVGFnPSdbb2JqZWN0IEludDMyQXJyYXldJyx1aW50OFRhZz0nW29iamVjdCBVaW50OEFycmF5XScsdWludDhDbGFtcGVkVGFnPSdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsdWludDE2VGFnPSdbb2JqZWN0IFVpbnQxNkFycmF5XScsdWludDMyVGFnPSdbb2JqZWN0IFVpbnQzMkFycmF5XSc7LyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL2Z1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCx0YWcsaXNEZWVwKXt2YXIgQ3Rvcj1vYmplY3QuY29uc3RydWN0b3I7c3dpdGNoKHRhZyl7Y2FzZSBhcnJheUJ1ZmZlclRhZzpyZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO2Nhc2UgYm9vbFRhZzpjYXNlIGRhdGVUYWc6cmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO2Nhc2UgZGF0YVZpZXdUYWc6cmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LGlzRGVlcCk7Y2FzZSBmbG9hdDMyVGFnOmNhc2UgZmxvYXQ2NFRhZzpjYXNlIGludDhUYWc6Y2FzZSBpbnQxNlRhZzpjYXNlIGludDMyVGFnOmNhc2UgdWludDhUYWc6Y2FzZSB1aW50OENsYW1wZWRUYWc6Y2FzZSB1aW50MTZUYWc6Y2FzZSB1aW50MzJUYWc6cmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsaXNEZWVwKTtjYXNlIG1hcFRhZzpyZXR1cm4gbmV3IEN0b3IoKTtjYXNlIG51bWJlclRhZzpjYXNlIHN0cmluZ1RhZzpyZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtjYXNlIHJlZ2V4cFRhZzpyZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtjYXNlIHNldFRhZzpyZXR1cm4gbmV3IEN0b3IoKTtjYXNlIHN5bWJvbFRhZzpyZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTt9fW1vZHVsZS5leHBvcnRzPWluaXRDbG9uZUJ5VGFnO30se1wiLi9fY2xvbmVBcnJheUJ1ZmZlclwiOjc1LFwiLi9fY2xvbmVEYXRhVmlld1wiOjc3LFwiLi9fY2xvbmVSZWdFeHBcIjo3OCxcIi4vX2Nsb25lU3ltYm9sXCI6NzksXCIuL19jbG9uZVR5cGVkQXJyYXlcIjo4MH1dLDEwNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2VDcmVhdGU9cmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLGdldFByb3RvdHlwZT1yZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxpc1Byb3RvdHlwZT1yZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpOy8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL2Z1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3Qpe3JldHVybiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yPT0nZnVuY3Rpb24nJiYhaXNQcm90b3R5cGUob2JqZWN0KT9iYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKTp7fTt9bW9kdWxlLmV4cG9ydHM9aW5pdENsb25lT2JqZWN0O30se1wiLi9fYmFzZUNyZWF0ZVwiOjU3LFwiLi9fZ2V0UHJvdG90eXBlXCI6OTQsXCIuL19pc1Byb3RvdHlwZVwiOjExMn1dLDEwODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovdmFyIE1BWF9TQUZFX0lOVEVHRVI9OTAwNzE5OTI1NDc0MDk5MTsvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovdmFyIHJlSXNVaW50PS9eKD86MHxbMS05XVxcZCopJC87LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSxsZW5ndGgpe3ZhciB0eXBlPV90eXBlb2YodmFsdWUpO2xlbmd0aD1sZW5ndGg9PW51bGw/TUFYX1NBRkVfSU5URUdFUjpsZW5ndGg7cmV0dXJuISFsZW5ndGgmJih0eXBlPT0nbnVtYmVyJ3x8dHlwZSE9J3N5bWJvbCcmJnJlSXNVaW50LnRlc3QodmFsdWUpKSYmdmFsdWU+LTEmJnZhbHVlJTE9PTAmJnZhbHVlPGxlbmd0aDt9bW9kdWxlLmV4cG9ydHM9aXNJbmRleDt9LHt9XSwxMDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBlcT1yZXF1aXJlKCcuL2VxJyksaXNBcnJheUxpa2U9cmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLGlzSW5kZXg9cmVxdWlyZSgnLi9faXNJbmRleCcpLGlzT2JqZWN0PXJlcXVpcmUoJy4vaXNPYmplY3QnKTsvKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsaW5kZXgsb2JqZWN0KXtpZighaXNPYmplY3Qob2JqZWN0KSl7cmV0dXJuIGZhbHNlO312YXIgdHlwZT1fdHlwZW9mKGluZGV4KTtpZih0eXBlPT0nbnVtYmVyJz9pc0FycmF5TGlrZShvYmplY3QpJiZpc0luZGV4KGluZGV4LG9iamVjdC5sZW5ndGgpOnR5cGU9PSdzdHJpbmcnJiZpbmRleCBpbiBvYmplY3Qpe3JldHVybiBlcShvYmplY3RbaW5kZXhdLHZhbHVlKTt9cmV0dXJuIGZhbHNlO31tb2R1bGUuZXhwb3J0cz1pc0l0ZXJhdGVlQ2FsbDt9LHtcIi4vX2lzSW5kZXhcIjoxMDgsXCIuL2VxXCI6MTQyLFwiLi9pc0FycmF5TGlrZVwiOjE0NyxcIi4vaXNPYmplY3RcIjoxNTN9XSwxMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKXt2YXIgdHlwZT1fdHlwZW9mKHZhbHVlKTtyZXR1cm4gdHlwZT09J3N0cmluZyd8fHR5cGU9PSdudW1iZXInfHx0eXBlPT0nc3ltYm9sJ3x8dHlwZT09J2Jvb2xlYW4nP3ZhbHVlIT09J19fcHJvdG9fXyc6dmFsdWU9PT1udWxsO31tb2R1bGUuZXhwb3J0cz1pc0tleWFibGU7fSx7fV0sMTExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgY29yZUpzRGF0YT1yZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7LyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi92YXIgbWFza1NyY0tleT1mdW5jdGlvbigpe3ZhciB1aWQ9L1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhJiZjb3JlSnNEYXRhLmtleXMmJmNvcmVKc0RhdGEua2V5cy5JRV9QUk9UT3x8JycpO3JldHVybiB1aWQ/J1N5bWJvbChzcmMpXzEuJyt1aWQ6Jyc7fSgpOy8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGlzTWFza2VkKGZ1bmMpe3JldHVybiEhbWFza1NyY0tleSYmbWFza1NyY0tleSBpbiBmdW5jO31tb2R1bGUuZXhwb3J0cz1pc01hc2tlZDt9LHtcIi4vX2NvcmVKc0RhdGFcIjo4NX1dLDExMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpe3ZhciBDdG9yPXZhbHVlJiZ2YWx1ZS5jb25zdHJ1Y3Rvcixwcm90bz10eXBlb2YgQ3Rvcj09J2Z1bmN0aW9uJyYmQ3Rvci5wcm90b3R5cGV8fG9iamVjdFByb3RvO3JldHVybiB2YWx1ZT09PXByb3RvO31tb2R1bGUuZXhwb3J0cz1pc1Byb3RvdHlwZTt9LHt9XSwxMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL2Z1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCl7dGhpcy5fX2RhdGFfXz1bXTt0aGlzLnNpemU9MDt9bW9kdWxlLmV4cG9ydHM9bGlzdENhY2hlQ2xlYXI7fSx7fV0sMTE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYXNzb2NJbmRleE9mPXJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpOy8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi92YXIgYXJyYXlQcm90bz1BcnJheS5wcm90b3R5cGU7LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovdmFyIHNwbGljZT1hcnJheVByb3RvLnNwbGljZTsvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSl7dmFyIGRhdGE9dGhpcy5fX2RhdGFfXyxpbmRleD1hc3NvY0luZGV4T2YoZGF0YSxrZXkpO2lmKGluZGV4PDApe3JldHVybiBmYWxzZTt9dmFyIGxhc3RJbmRleD1kYXRhLmxlbmd0aC0xO2lmKGluZGV4PT1sYXN0SW5kZXgpe2RhdGEucG9wKCk7fWVsc2V7c3BsaWNlLmNhbGwoZGF0YSxpbmRleCwxKTt9LS10aGlzLnNpemU7cmV0dXJuIHRydWU7fW1vZHVsZS5leHBvcnRzPWxpc3RDYWNoZURlbGV0ZTt9LHtcIi4vX2Fzc29jSW5kZXhPZlwiOjUyfV0sMTE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYXNzb2NJbmRleE9mPXJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpOy8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fLGluZGV4PWFzc29jSW5kZXhPZihkYXRhLGtleSk7cmV0dXJuIGluZGV4PDA/dW5kZWZpbmVkOmRhdGFbaW5kZXhdWzFdO31tb2R1bGUuZXhwb3J0cz1saXN0Q2FjaGVHZXQ7fSx7XCIuL19hc3NvY0luZGV4T2ZcIjo1Mn1dLDExNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGFzc29jSW5kZXhPZj1yZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTsvKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpe3JldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXyxrZXkpPi0xO31tb2R1bGUuZXhwb3J0cz1saXN0Q2FjaGVIYXM7fSx7XCIuL19hc3NvY0luZGV4T2ZcIjo1Mn1dLDExNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGFzc29jSW5kZXhPZj1yZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTsvKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LHZhbHVlKXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fLGluZGV4PWFzc29jSW5kZXhPZihkYXRhLGtleSk7aWYoaW5kZXg8MCl7Kyt0aGlzLnNpemU7ZGF0YS5wdXNoKFtrZXksdmFsdWVdKTt9ZWxzZXtkYXRhW2luZGV4XVsxXT12YWx1ZTt9cmV0dXJuIHRoaXM7fW1vZHVsZS5leHBvcnRzPWxpc3RDYWNoZVNldDt9LHtcIi4vX2Fzc29jSW5kZXhPZlwiOjUyfV0sMTE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgSGFzaD1yZXF1aXJlKCcuL19IYXNoJyksTGlzdENhY2hlPXJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLE1hcD1yZXF1aXJlKCcuL19NYXAnKTsvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpe3RoaXMuc2l6ZT0wO3RoaXMuX19kYXRhX189eydoYXNoJzpuZXcgSGFzaCgpLCdtYXAnOm5ldyhNYXB8fExpc3RDYWNoZSkoKSwnc3RyaW5nJzpuZXcgSGFzaCgpfTt9bW9kdWxlLmV4cG9ydHM9bWFwQ2FjaGVDbGVhcjt9LHtcIi4vX0hhc2hcIjozNCxcIi4vX0xpc3RDYWNoZVwiOjM1LFwiLi9fTWFwXCI6MzZ9XSwxMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBnZXRNYXBEYXRhPXJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTsvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSl7dmFyIHJlc3VsdD1nZXRNYXBEYXRhKHRoaXMsa2V5KVsnZGVsZXRlJ10oa2V5KTt0aGlzLnNpemUtPXJlc3VsdD8xOjA7cmV0dXJuIHJlc3VsdDt9bW9kdWxlLmV4cG9ydHM9bWFwQ2FjaGVEZWxldGU7fSx7XCIuL19nZXRNYXBEYXRhXCI6OTJ9XSwxMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBnZXRNYXBEYXRhPXJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTsvKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL2Z1bmN0aW9uIG1hcENhY2hlR2V0KGtleSl7cmV0dXJuIGdldE1hcERhdGEodGhpcyxrZXkpLmdldChrZXkpO31tb2R1bGUuZXhwb3J0cz1tYXBDYWNoZUdldDt9LHtcIi4vX2dldE1hcERhdGFcIjo5Mn1dLDEyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGdldE1hcERhdGE9cmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpOy8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIG1hcENhY2hlSGFzKGtleSl7cmV0dXJuIGdldE1hcERhdGEodGhpcyxrZXkpLmhhcyhrZXkpO31tb2R1bGUuZXhwb3J0cz1tYXBDYWNoZUhhczt9LHtcIi4vX2dldE1hcERhdGFcIjo5Mn1dLDEyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGdldE1hcERhdGE9cmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpOy8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL2Z1bmN0aW9uIG1hcENhY2hlU2V0KGtleSx2YWx1ZSl7dmFyIGRhdGE9Z2V0TWFwRGF0YSh0aGlzLGtleSksc2l6ZT1kYXRhLnNpemU7ZGF0YS5zZXQoa2V5LHZhbHVlKTt0aGlzLnNpemUrPWRhdGEuc2l6ZT09c2l6ZT8wOjE7cmV0dXJuIHRoaXM7fW1vZHVsZS5leHBvcnRzPW1hcENhY2hlU2V0O30se1wiLi9fZ2V0TWFwRGF0YVwiOjkyfV0sMTIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgZ2V0TmF0aXZlPXJlcXVpcmUoJy4vX2dldE5hdGl2ZScpOy8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi92YXIgbmF0aXZlQ3JlYXRlPWdldE5hdGl2ZShPYmplY3QsJ2NyZWF0ZScpO21vZHVsZS5leHBvcnRzPW5hdGl2ZUNyZWF0ZTt9LHtcIi4vX2dldE5hdGl2ZVwiOjkzfV0sMTI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgb3ZlckFyZz1yZXF1aXJlKCcuL19vdmVyQXJnJyk7LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL3ZhciBuYXRpdmVLZXlzPW92ZXJBcmcoT2JqZWN0LmtleXMsT2JqZWN0KTttb2R1bGUuZXhwb3J0cz1uYXRpdmVLZXlzO30se1wiLi9fb3ZlckFyZ1wiOjEyOH1dLDEyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KXt2YXIgcmVzdWx0PVtdO2lmKG9iamVjdCE9bnVsbCl7Zm9yKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpe3Jlc3VsdC5wdXNoKGtleSk7fX1yZXR1cm4gcmVzdWx0O31tb2R1bGUuZXhwb3J0cz1uYXRpdmVLZXlzSW47fSx7fV0sMTI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgZnJlZUdsb2JhbD1yZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi92YXIgZnJlZUV4cG9ydHM9X3R5cGVvZihleHBvcnRzKT09J29iamVjdCcmJmV4cG9ydHMmJiFleHBvcnRzLm5vZGVUeXBlJiZleHBvcnRzOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi92YXIgZnJlZU1vZHVsZT1mcmVlRXhwb3J0cyYmX3R5cGVvZihtb2R1bGUpPT0nb2JqZWN0JyYmbW9kdWxlJiYhbW9kdWxlLm5vZGVUeXBlJiZtb2R1bGU7LyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi92YXIgbW9kdWxlRXhwb3J0cz1mcmVlTW9kdWxlJiZmcmVlTW9kdWxlLmV4cG9ydHM9PT1mcmVlRXhwb3J0czsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi92YXIgZnJlZVByb2Nlc3M9bW9kdWxlRXhwb3J0cyYmZnJlZUdsb2JhbC5wcm9jZXNzOy8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL3ZhciBub2RlVXRpbD1mdW5jdGlvbigpe3RyeXsvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbnZhciB0eXBlcz1mcmVlTW9kdWxlJiZmcmVlTW9kdWxlLnJlcXVpcmUmJmZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO2lmKHR5cGVzKXtyZXR1cm4gdHlwZXM7fS8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG5yZXR1cm4gZnJlZVByb2Nlc3MmJmZyZWVQcm9jZXNzLmJpbmRpbmcmJmZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTt9Y2F0Y2goZSl7fX0oKTttb2R1bGUuZXhwb3J0cz1ub2RlVXRpbDt9LHtcIi4vX2ZyZWVHbG9iYWxcIjo4OX1dLDEyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi92YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmc9b2JqZWN0UHJvdG8udG9TdHJpbmc7LyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSl7cmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO31tb2R1bGUuZXhwb3J0cz1vYmplY3RUb1N0cmluZzt9LHt9XSwxMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovZnVuY3Rpb24gb3ZlckFyZyhmdW5jLHRyYW5zZm9ybSl7cmV0dXJuIGZ1bmN0aW9uKGFyZyl7cmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO307fW1vZHVsZS5leHBvcnRzPW92ZXJBcmc7fSx7fV0sMTI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYXBwbHk9cmVxdWlyZSgnLi9fYXBwbHknKTsvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovdmFyIG5hdGl2ZU1heD1NYXRoLm1heDsvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9mdW5jdGlvbiBvdmVyUmVzdChmdW5jLHN0YXJ0LHRyYW5zZm9ybSl7c3RhcnQ9bmF0aXZlTWF4KHN0YXJ0PT09dW5kZWZpbmVkP2Z1bmMubGVuZ3RoLTE6c3RhcnQsMCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGFyZ3M9YXJndW1lbnRzLGluZGV4PS0xLGxlbmd0aD1uYXRpdmVNYXgoYXJncy5sZW5ndGgtc3RhcnQsMCksYXJyYXk9QXJyYXkobGVuZ3RoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7YXJyYXlbaW5kZXhdPWFyZ3Nbc3RhcnQraW5kZXhdO31pbmRleD0tMTt2YXIgb3RoZXJBcmdzPUFycmF5KHN0YXJ0KzEpO3doaWxlKCsraW5kZXg8c3RhcnQpe290aGVyQXJnc1tpbmRleF09YXJnc1tpbmRleF07fW90aGVyQXJnc1tzdGFydF09dHJhbnNmb3JtKGFycmF5KTtyZXR1cm4gYXBwbHkoZnVuYyx0aGlzLG90aGVyQXJncyk7fTt9bW9kdWxlLmV4cG9ydHM9b3ZlclJlc3Q7fSx7XCIuL19hcHBseVwiOjQ0fV0sMTMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgZnJlZUdsb2JhbD1yZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi92YXIgZnJlZVNlbGY9KHR5cGVvZiBzZWxmPT09XCJ1bmRlZmluZWRcIj9cInVuZGVmaW5lZFwiOl90eXBlb2Yoc2VsZikpPT0nb2JqZWN0JyYmc2VsZiYmc2VsZi5PYmplY3Q9PT1PYmplY3QmJnNlbGY7LyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovdmFyIHJvb3Q9ZnJlZUdsb2JhbHx8ZnJlZVNlbGZ8fEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7bW9kdWxlLmV4cG9ydHM9cm9vdDt9LHtcIi4vX2ZyZWVHbG9iYWxcIjo4OX1dLDEzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL2Z1bmN0aW9uIHNhZmVHZXQob2JqZWN0LGtleSl7aWYoa2V5PT09J2NvbnN0cnVjdG9yJyYmdHlwZW9mIG9iamVjdFtrZXldPT09J2Z1bmN0aW9uJyl7cmV0dXJuO31pZihrZXk9PSdfX3Byb3RvX18nKXtyZXR1cm47fXJldHVybiBvYmplY3Rba2V5XTt9bW9kdWxlLmV4cG9ydHM9c2FmZUdldDt9LHt9XSwxMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBiYXNlU2V0VG9TdHJpbmc9cmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksc2hvcnRPdXQ9cmVxdWlyZSgnLi9fc2hvcnRPdXQnKTsvKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovdmFyIHNldFRvU3RyaW5nPXNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7bW9kdWxlLmV4cG9ydHM9c2V0VG9TdHJpbmc7fSx7XCIuL19iYXNlU2V0VG9TdHJpbmdcIjo3MSxcIi4vX3Nob3J0T3V0XCI6MTMzfV0sMTMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovdmFyIEhPVF9DT1VOVD04MDAsSE9UX1NQQU49MTY7LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL3ZhciBuYXRpdmVOb3c9RGF0ZS5ub3c7LyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL2Z1bmN0aW9uIHNob3J0T3V0KGZ1bmMpe3ZhciBjb3VudD0wLGxhc3RDYWxsZWQ9MDtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgc3RhbXA9bmF0aXZlTm93KCkscmVtYWluaW5nPUhPVF9TUEFOLShzdGFtcC1sYXN0Q2FsbGVkKTtsYXN0Q2FsbGVkPXN0YW1wO2lmKHJlbWFpbmluZz4wKXtpZigrK2NvdW50Pj1IT1RfQ09VTlQpe3JldHVybiBhcmd1bWVudHNbMF07fX1lbHNle2NvdW50PTA7fXJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCxhcmd1bWVudHMpO307fW1vZHVsZS5leHBvcnRzPXNob3J0T3V0O30se31dLDEzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIExpc3RDYWNoZT1yZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTsvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9mdW5jdGlvbiBzdGFja0NsZWFyKCl7dGhpcy5fX2RhdGFfXz1uZXcgTGlzdENhY2hlKCk7dGhpcy5zaXplPTA7fW1vZHVsZS5leHBvcnRzPXN0YWNrQ2xlYXI7fSx7XCIuL19MaXN0Q2FjaGVcIjozNX1dLDEzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSl7dmFyIGRhdGE9dGhpcy5fX2RhdGFfXyxyZXN1bHQ9ZGF0YVsnZGVsZXRlJ10oa2V5KTt0aGlzLnNpemU9ZGF0YS5zaXplO3JldHVybiByZXN1bHQ7fW1vZHVsZS5leHBvcnRzPXN0YWNrRGVsZXRlO30se31dLDEzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL2Z1bmN0aW9uIHN0YWNrR2V0KGtleSl7cmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7fW1vZHVsZS5leHBvcnRzPXN0YWNrR2V0O30se31dLDEzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBzdGFja0hhcyhrZXkpe3JldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO31tb2R1bGUuZXhwb3J0cz1zdGFja0hhczt9LHt9XSwxMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBMaXN0Q2FjaGU9cmVxdWlyZSgnLi9fTGlzdENhY2hlJyksTWFwPXJlcXVpcmUoJy4vX01hcCcpLE1hcENhY2hlPXJlcXVpcmUoJy4vX01hcENhY2hlJyk7LyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovdmFyIExBUkdFX0FSUkFZX1NJWkU9MjAwOy8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9mdW5jdGlvbiBzdGFja1NldChrZXksdmFsdWUpe3ZhciBkYXRhPXRoaXMuX19kYXRhX187aWYoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSl7dmFyIHBhaXJzPWRhdGEuX19kYXRhX187aWYoIU1hcHx8cGFpcnMubGVuZ3RoPExBUkdFX0FSUkFZX1NJWkUtMSl7cGFpcnMucHVzaChba2V5LHZhbHVlXSk7dGhpcy5zaXplPSsrZGF0YS5zaXplO3JldHVybiB0aGlzO31kYXRhPXRoaXMuX19kYXRhX189bmV3IE1hcENhY2hlKHBhaXJzKTt9ZGF0YS5zZXQoa2V5LHZhbHVlKTt0aGlzLnNpemU9ZGF0YS5zaXplO3JldHVybiB0aGlzO31tb2R1bGUuZXhwb3J0cz1zdGFja1NldDt9LHtcIi4vX0xpc3RDYWNoZVwiOjM1LFwiLi9fTWFwXCI6MzYsXCIuL19NYXBDYWNoZVwiOjM3fV0sMTM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovdmFyIGZ1bmNQcm90bz1GdW5jdGlvbi5wcm90b3R5cGU7LyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL3ZhciBmdW5jVG9TdHJpbmc9ZnVuY1Byb3RvLnRvU3RyaW5nOy8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYyl7aWYoZnVuYyE9bnVsbCl7dHJ5e3JldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTt9Y2F0Y2goZSl7fXRyeXtyZXR1cm4gZnVuYysnJzt9Y2F0Y2goZSl7fX1yZXR1cm4nJzt9bW9kdWxlLmV4cG9ydHM9dG9Tb3VyY2U7fSx7fV0sMTQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYmFzZUNsb25lPXJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpOy8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovdmFyIENMT05FX0RFRVBfRkxBRz0xLENMT05FX1NZTUJPTFNfRkxBRz00Oy8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpe3JldHVybiBiYXNlQ2xvbmUodmFsdWUsQ0xPTkVfREVFUF9GTEFHfENMT05FX1NZTUJPTFNfRkxBRyk7fW1vZHVsZS5leHBvcnRzPWNsb25lRGVlcDt9LHtcIi4vX2Jhc2VDbG9uZVwiOjU2fV0sMTQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL2Z1bmN0aW9uIGNvbnN0YW50KHZhbHVlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdmFsdWU7fTt9bW9kdWxlLmV4cG9ydHM9Y29uc3RhbnQ7fSx7fV0sMTQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9mdW5jdGlvbiBlcSh2YWx1ZSxvdGhlcil7cmV0dXJuIHZhbHVlPT09b3RoZXJ8fHZhbHVlIT09dmFsdWUmJm90aGVyIT09b3RoZXI7fW1vZHVsZS5leHBvcnRzPWVxO30se31dLDE0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIHRvU3RyaW5nPXJlcXVpcmUoJy4vdG9TdHJpbmcnKTsvKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovdmFyIHJlUmVnRXhwQ2hhcj0vW1xcXFxeJC4qKz8oKVtcXF17fXxdL2cscmVIYXNSZWdFeHBDaGFyPVJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTsvKipcbiAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAqL2Z1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpe3N0cmluZz10b1N0cmluZyhzdHJpbmcpO3JldHVybiBzdHJpbmcmJnJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZyk/c3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCdcXFxcJCYnKTpzdHJpbmc7fW1vZHVsZS5leHBvcnRzPWVzY2FwZVJlZ0V4cDt9LHtcIi4vdG9TdHJpbmdcIjoxNjZ9XSwxNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpe3JldHVybiB2YWx1ZTt9bW9kdWxlLmV4cG9ydHM9aWRlbnRpdHk7fSx7fV0sMTQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYmFzZUlzQXJndW1lbnRzPXJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLGlzT2JqZWN0TGlrZT1yZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpOy8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi92YXIgb2JqZWN0UHJvdG89T2JqZWN0LnByb3RvdHlwZTsvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi92YXIgaGFzT3duUHJvcGVydHk9b2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlPW9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlOy8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi92YXIgaXNBcmd1bWVudHM9YmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50czt9KCkpP2Jhc2VJc0FyZ3VtZW50czpmdW5jdGlvbih2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsJ2NhbGxlZScpJiYhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwnY2FsbGVlJyk7fTttb2R1bGUuZXhwb3J0cz1pc0FyZ3VtZW50czt9LHtcIi4vX2Jhc2VJc0FyZ3VtZW50c1wiOjYxLFwiLi9pc09iamVjdExpa2VcIjoxNTR9XSwxNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL3ZhciBpc0FycmF5PUFycmF5LmlzQXJyYXk7bW9kdWxlLmV4cG9ydHM9aXNBcnJheTt9LHt9XSwxNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBpc0Z1bmN0aW9uPXJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLGlzTGVuZ3RoPXJlcXVpcmUoJy4vaXNMZW5ndGgnKTsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpe3JldHVybiB2YWx1ZSE9bnVsbCYmaXNMZW5ndGgodmFsdWUubGVuZ3RoKSYmIWlzRnVuY3Rpb24odmFsdWUpO31tb2R1bGUuZXhwb3J0cz1pc0FycmF5TGlrZTt9LHtcIi4vaXNGdW5jdGlvblwiOjE1MCxcIi4vaXNMZW5ndGhcIjoxNTF9XSwxNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBpc0FycmF5TGlrZT1yZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksaXNPYmplY3RMaWtlPXJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7LyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKXtyZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSYmaXNBcnJheUxpa2UodmFsdWUpO31tb2R1bGUuZXhwb3J0cz1pc0FycmF5TGlrZU9iamVjdDt9LHtcIi4vaXNBcnJheUxpa2VcIjoxNDcsXCIuL2lzT2JqZWN0TGlrZVwiOjE1NH1dLDE0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIHJvb3Q9cmVxdWlyZSgnLi9fcm9vdCcpLHN0dWJGYWxzZT1yZXF1aXJlKCcuL3N0dWJGYWxzZScpOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovdmFyIGZyZWVFeHBvcnRzPV90eXBlb2YoZXhwb3J0cyk9PSdvYmplY3QnJiZleHBvcnRzJiYhZXhwb3J0cy5ub2RlVHlwZSYmZXhwb3J0czsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovdmFyIGZyZWVNb2R1bGU9ZnJlZUV4cG9ydHMmJl90eXBlb2YobW9kdWxlKT09J29iamVjdCcmJm1vZHVsZSYmIW1vZHVsZS5ub2RlVHlwZSYmbW9kdWxlOy8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovdmFyIG1vZHVsZUV4cG9ydHM9ZnJlZU1vZHVsZSYmZnJlZU1vZHVsZS5leHBvcnRzPT09ZnJlZUV4cG9ydHM7LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovdmFyIEJ1ZmZlcj1tb2R1bGVFeHBvcnRzP3Jvb3QuQnVmZmVyOnVuZGVmaW5lZDsvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovdmFyIG5hdGl2ZUlzQnVmZmVyPUJ1ZmZlcj9CdWZmZXIuaXNCdWZmZXI6dW5kZWZpbmVkOy8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi92YXIgaXNCdWZmZXI9bmF0aXZlSXNCdWZmZXJ8fHN0dWJGYWxzZTttb2R1bGUuZXhwb3J0cz1pc0J1ZmZlcjt9LHtcIi4vX3Jvb3RcIjoxMzAsXCIuL3N0dWJGYWxzZVwiOjE2NH1dLDE1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2VHZXRUYWc9cmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLGlzT2JqZWN0PXJlcXVpcmUoJy4vaXNPYmplY3QnKTsvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovdmFyIGFzeW5jVGFnPSdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxmdW5jVGFnPSdbb2JqZWN0IEZ1bmN0aW9uXScsZ2VuVGFnPSdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScscHJveHlUYWc9J1tvYmplY3QgUHJveHldJzsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpe2lmKCFpc09iamVjdCh2YWx1ZSkpe3JldHVybiBmYWxzZTt9Ly8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4vLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbnZhciB0YWc9YmFzZUdldFRhZyh2YWx1ZSk7cmV0dXJuIHRhZz09ZnVuY1RhZ3x8dGFnPT1nZW5UYWd8fHRhZz09YXN5bmNUYWd8fHRhZz09cHJveHlUYWc7fW1vZHVsZS5leHBvcnRzPWlzRnVuY3Rpb247fSx7XCIuL19iYXNlR2V0VGFnXCI6NjAsXCIuL2lzT2JqZWN0XCI6MTUzfV0sMTUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi92YXIgTUFYX1NBRkVfSU5URUdFUj05MDA3MTk5MjU0NzQwOTkxOy8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWU9PSdudW1iZXInJiZ2YWx1ZT4tMSYmdmFsdWUlMT09MCYmdmFsdWU8PU1BWF9TQUZFX0lOVEVHRVI7fW1vZHVsZS5leHBvcnRzPWlzTGVuZ3RoO30se31dLDE1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2VJc01hcD1yZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxiYXNlVW5hcnk9cmVxdWlyZSgnLi9fYmFzZVVuYXJ5Jyksbm9kZVV0aWw9cmVxdWlyZSgnLi9fbm9kZVV0aWwnKTsvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL3ZhciBub2RlSXNNYXA9bm9kZVV0aWwmJm5vZGVVdGlsLmlzTWFwOy8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL3ZhciBpc01hcD1ub2RlSXNNYXA/YmFzZVVuYXJ5KG5vZGVJc01hcCk6YmFzZUlzTWFwO21vZHVsZS5leHBvcnRzPWlzTWFwO30se1wiLi9fYmFzZUlzTWFwXCI6NjIsXCIuL19iYXNlVW5hcnlcIjo3NCxcIi4vX25vZGVVdGlsXCI6MTI2fV0sMTUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpe3ZhciB0eXBlPV90eXBlb2YodmFsdWUpO3JldHVybiB2YWx1ZSE9bnVsbCYmKHR5cGU9PSdvYmplY3QnfHx0eXBlPT0nZnVuY3Rpb24nKTt9bW9kdWxlLmV4cG9ydHM9aXNPYmplY3Q7fSx7fV0sMTU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSl7cmV0dXJuIHZhbHVlIT1udWxsJiZfdHlwZW9mKHZhbHVlKT09J29iamVjdCc7fW1vZHVsZS5leHBvcnRzPWlzT2JqZWN0TGlrZTt9LHt9XSwxNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBiYXNlR2V0VGFnPXJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxnZXRQcm90b3R5cGU9cmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksaXNPYmplY3RMaWtlPXJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RUYWc9J1tvYmplY3QgT2JqZWN0XSc7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBmdW5jUHJvdG89RnVuY3Rpb24ucHJvdG90eXBlLG9iamVjdFByb3RvPU9iamVjdC5wcm90b3R5cGU7LyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL3ZhciBmdW5jVG9TdHJpbmc9ZnVuY1Byb3RvLnRvU3RyaW5nOy8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL3ZhciBoYXNPd25Qcm9wZXJ0eT1vYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovdmFyIG9iamVjdEN0b3JTdHJpbmc9ZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSl7aWYoIWlzT2JqZWN0TGlrZSh2YWx1ZSl8fGJhc2VHZXRUYWcodmFsdWUpIT1vYmplY3RUYWcpe3JldHVybiBmYWxzZTt9dmFyIHByb3RvPWdldFByb3RvdHlwZSh2YWx1ZSk7aWYocHJvdG89PT1udWxsKXtyZXR1cm4gdHJ1ZTt9dmFyIEN0b3I9aGFzT3duUHJvcGVydHkuY2FsbChwcm90bywnY29uc3RydWN0b3InKSYmcHJvdG8uY29uc3RydWN0b3I7cmV0dXJuIHR5cGVvZiBDdG9yPT0nZnVuY3Rpb24nJiZDdG9yIGluc3RhbmNlb2YgQ3RvciYmZnVuY1RvU3RyaW5nLmNhbGwoQ3Rvcik9PW9iamVjdEN0b3JTdHJpbmc7fW1vZHVsZS5leHBvcnRzPWlzUGxhaW5PYmplY3Q7fSx7XCIuL19iYXNlR2V0VGFnXCI6NjAsXCIuL19nZXRQcm90b3R5cGVcIjo5NCxcIi4vaXNPYmplY3RMaWtlXCI6MTU0fV0sMTU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYmFzZUlzU2V0PXJlcXVpcmUoJy4vX2Jhc2VJc1NldCcpLGJhc2VVbmFyeT1yZXF1aXJlKCcuL19iYXNlVW5hcnknKSxub2RlVXRpbD1yZXF1aXJlKCcuL19ub2RlVXRpbCcpOy8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovdmFyIG5vZGVJc1NldD1ub2RlVXRpbCYmbm9kZVV0aWwuaXNTZXQ7LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovdmFyIGlzU2V0PW5vZGVJc1NldD9iYXNlVW5hcnkobm9kZUlzU2V0KTpiYXNlSXNTZXQ7bW9kdWxlLmV4cG9ydHM9aXNTZXQ7fSx7XCIuL19iYXNlSXNTZXRcIjo2NCxcIi4vX2Jhc2VVbmFyeVwiOjc0LFwiLi9fbm9kZVV0aWxcIjoxMjZ9XSwxNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBiYXNlR2V0VGFnPXJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxpc0FycmF5PXJlcXVpcmUoJy4vaXNBcnJheScpLGlzT2JqZWN0TGlrZT1yZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpOy8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi92YXIgc3RyaW5nVGFnPSdbb2JqZWN0IFN0cmluZ10nOy8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSl7cmV0dXJuIHR5cGVvZiB2YWx1ZT09J3N0cmluZyd8fCFpc0FycmF5KHZhbHVlKSYmaXNPYmplY3RMaWtlKHZhbHVlKSYmYmFzZUdldFRhZyh2YWx1ZSk9PXN0cmluZ1RhZzt9bW9kdWxlLmV4cG9ydHM9aXNTdHJpbmc7fSx7XCIuL19iYXNlR2V0VGFnXCI6NjAsXCIuL2lzQXJyYXlcIjoxNDYsXCIuL2lzT2JqZWN0TGlrZVwiOjE1NH1dLDE1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2VHZXRUYWc9cmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLGlzT2JqZWN0TGlrZT1yZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpOy8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi92YXIgc3ltYm9sVGFnPSdbb2JqZWN0IFN5bWJvbF0nOy8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKXtyZXR1cm4gX3R5cGVvZih2YWx1ZSk9PSdzeW1ib2wnfHxpc09iamVjdExpa2UodmFsdWUpJiZiYXNlR2V0VGFnKHZhbHVlKT09c3ltYm9sVGFnO31tb2R1bGUuZXhwb3J0cz1pc1N5bWJvbDt9LHtcIi4vX2Jhc2VHZXRUYWdcIjo2MCxcIi4vaXNPYmplY3RMaWtlXCI6MTU0fV0sMTU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYmFzZUlzVHlwZWRBcnJheT1yZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksYmFzZVVuYXJ5PXJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLG5vZGVVdGlsPXJlcXVpcmUoJy4vX25vZGVVdGlsJyk7LyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi92YXIgbm9kZUlzVHlwZWRBcnJheT1ub2RlVXRpbCYmbm9kZVV0aWwuaXNUeXBlZEFycmF5Oy8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi92YXIgaXNUeXBlZEFycmF5PW5vZGVJc1R5cGVkQXJyYXk/YmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpOmJhc2VJc1R5cGVkQXJyYXk7bW9kdWxlLmV4cG9ydHM9aXNUeXBlZEFycmF5O30se1wiLi9fYmFzZUlzVHlwZWRBcnJheVwiOjY1LFwiLi9fYmFzZVVuYXJ5XCI6NzQsXCIuL19ub2RlVXRpbFwiOjEyNn1dLDE2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIGFycmF5TGlrZUtleXM9cmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLGJhc2VLZXlzPXJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksaXNBcnJheUxpa2U9cmVxdWlyZSgnLi9pc0FycmF5TGlrZScpOy8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL2Z1bmN0aW9uIGtleXMob2JqZWN0KXtyZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KT9hcnJheUxpa2VLZXlzKG9iamVjdCk6YmFzZUtleXMob2JqZWN0KTt9bW9kdWxlLmV4cG9ydHM9a2V5czt9LHtcIi4vX2FycmF5TGlrZUtleXNcIjo0NyxcIi4vX2Jhc2VLZXlzXCI6NjYsXCIuL2lzQXJyYXlMaWtlXCI6MTQ3fV0sMTYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYXJyYXlMaWtlS2V5cz1yZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksYmFzZUtleXNJbj1yZXF1aXJlKCcuL19iYXNlS2V5c0luJyksaXNBcnJheUxpa2U9cmVxdWlyZSgnLi9pc0FycmF5TGlrZScpOy8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovZnVuY3Rpb24ga2V5c0luKG9iamVjdCl7cmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCk/YXJyYXlMaWtlS2V5cyhvYmplY3QsdHJ1ZSk6YmFzZUtleXNJbihvYmplY3QpO31tb2R1bGUuZXhwb3J0cz1rZXlzSW47fSx7XCIuL19hcnJheUxpa2VLZXlzXCI6NDcsXCIuL19iYXNlS2V5c0luXCI6NjcsXCIuL2lzQXJyYXlMaWtlXCI6MTQ3fV0sMTYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgYmFzZU1lcmdlPXJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLGNyZWF0ZUFzc2lnbmVyPXJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyk7LyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gKlxuICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gKi92YXIgbWVyZ2VXaXRoPWNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCxzb3VyY2Usc3JjSW5kZXgsY3VzdG9taXplcil7YmFzZU1lcmdlKG9iamVjdCxzb3VyY2Usc3JjSW5kZXgsY3VzdG9taXplcik7fSk7bW9kdWxlLmV4cG9ydHM9bWVyZ2VXaXRoO30se1wiLi9fYmFzZU1lcmdlXCI6NjgsXCIuL19jcmVhdGVBc3NpZ25lclwiOjg2fV0sMTYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9mdW5jdGlvbiBzdHViQXJyYXkoKXtyZXR1cm5bXTt9bW9kdWxlLmV4cG9ydHM9c3R1YkFycmF5O30se31dLDE2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9mdW5jdGlvbiBzdHViRmFsc2UoKXtyZXR1cm4gZmFsc2U7fW1vZHVsZS5leHBvcnRzPXN0dWJGYWxzZTt9LHt9XSwxNjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBjb3B5T2JqZWN0PXJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxrZXlzSW49cmVxdWlyZSgnLi9rZXlzSW4nKTsvKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL2Z1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpe3JldHVybiBjb3B5T2JqZWN0KHZhbHVlLGtleXNJbih2YWx1ZSkpO31tb2R1bGUuZXhwb3J0cz10b1BsYWluT2JqZWN0O30se1wiLi9fY29weU9iamVjdFwiOjgyLFwiLi9rZXlzSW5cIjoxNjF9XSwxNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBiYXNlVG9TdHJpbmc9cmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7LyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSl7cmV0dXJuIHZhbHVlPT1udWxsPycnOmJhc2VUb1N0cmluZyh2YWx1ZSk7fW1vZHVsZS5leHBvcnRzPXRvU3RyaW5nO30se1wiLi9fYmFzZVRvU3RyaW5nXCI6NzN9XSwxNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihwcm9jZXNzKXsvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsYWxsb3dBYm92ZVJvb3Qpey8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG52YXIgdXA9MDtmb3IodmFyIGk9cGFydHMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBsYXN0PXBhcnRzW2ldO2lmKGxhc3Q9PT0nLicpe3BhcnRzLnNwbGljZShpLDEpO31lbHNlIGlmKGxhc3Q9PT0nLi4nKXtwYXJ0cy5zcGxpY2UoaSwxKTt1cCsrO31lbHNlIGlmKHVwKXtwYXJ0cy5zcGxpY2UoaSwxKTt1cC0tO319Ly8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuaWYoYWxsb3dBYm92ZVJvb3Qpe2Zvcig7dXAtLTt1cCl7cGFydHMudW5zaGlmdCgnLi4nKTt9fXJldHVybiBwYXJ0czt9Ly8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlPWZ1bmN0aW9uKCl7dmFyIHJlc29sdmVkUGF0aD0nJyxyZXNvbHZlZEFic29sdXRlPWZhbHNlO2Zvcih2YXIgaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFyZXNvbHZlZEFic29sdXRlO2ktLSl7dmFyIHBhdGg9aT49MD9hcmd1bWVudHNbaV06cHJvY2Vzcy5jd2QoKTsvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbmlmKHR5cGVvZiBwYXRoIT09J3N0cmluZycpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7fWVsc2UgaWYoIXBhdGgpe2NvbnRpbnVlO31yZXNvbHZlZFBhdGg9cGF0aCsnLycrcmVzb2x2ZWRQYXRoO3Jlc29sdmVkQWJzb2x1dGU9cGF0aC5jaGFyQXQoMCk9PT0nLyc7fS8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbi8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuLy8gTm9ybWFsaXplIHRoZSBwYXRoXG5yZXNvbHZlZFBhdGg9bm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLGZ1bmN0aW9uKHApe3JldHVybiEhcDt9KSwhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO3JldHVybihyZXNvbHZlZEFic29sdXRlPycvJzonJykrcmVzb2x2ZWRQYXRofHwnLic7fTsvLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemU9ZnVuY3Rpb24ocGF0aCl7dmFyIGlzQWJzb2x1dGU9ZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLHRyYWlsaW5nU2xhc2g9c3Vic3RyKHBhdGgsLTEpPT09Jy8nOy8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxucGF0aD1ub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLGZ1bmN0aW9uKHApe3JldHVybiEhcDt9KSwhaXNBYnNvbHV0ZSkuam9pbignLycpO2lmKCFwYXRoJiYhaXNBYnNvbHV0ZSl7cGF0aD0nLic7fWlmKHBhdGgmJnRyYWlsaW5nU2xhc2gpe3BhdGgrPScvJzt9cmV0dXJuKGlzQWJzb2x1dGU/Jy8nOicnKStwYXRoO307Ly8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlPWZ1bmN0aW9uKHBhdGgpe3JldHVybiBwYXRoLmNoYXJBdCgwKT09PScvJzt9Oy8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbj1mdW5jdGlvbigpe3ZhciBwYXRocz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocyxmdW5jdGlvbihwLGluZGV4KXtpZih0eXBlb2YgcCE9PSdzdHJpbmcnKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO31yZXR1cm4gcDt9KS5qb2luKCcvJykpO307Ly8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmU9ZnVuY3Rpb24oZnJvbSx0byl7ZnJvbT1leHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO3RvPWV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO2Z1bmN0aW9uIHRyaW0oYXJyKXt2YXIgc3RhcnQ9MDtmb3IoO3N0YXJ0PGFyci5sZW5ndGg7c3RhcnQrKyl7aWYoYXJyW3N0YXJ0XSE9PScnKWJyZWFrO312YXIgZW5kPWFyci5sZW5ndGgtMTtmb3IoO2VuZD49MDtlbmQtLSl7aWYoYXJyW2VuZF0hPT0nJylicmVhazt9aWYoc3RhcnQ+ZW5kKXJldHVybltdO3JldHVybiBhcnIuc2xpY2Uoc3RhcnQsZW5kLXN0YXJ0KzEpO312YXIgZnJvbVBhcnRzPXRyaW0oZnJvbS5zcGxpdCgnLycpKTt2YXIgdG9QYXJ0cz10cmltKHRvLnNwbGl0KCcvJykpO3ZhciBsZW5ndGg9TWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCx0b1BhcnRzLmxlbmd0aCk7dmFyIHNhbWVQYXJ0c0xlbmd0aD1sZW5ndGg7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXtpZihmcm9tUGFydHNbaV0hPT10b1BhcnRzW2ldKXtzYW1lUGFydHNMZW5ndGg9aTticmVhazt9fXZhciBvdXRwdXRQYXJ0cz1bXTtmb3IodmFyIGk9c2FtZVBhcnRzTGVuZ3RoO2k8ZnJvbVBhcnRzLmxlbmd0aDtpKyspe291dHB1dFBhcnRzLnB1c2goJy4uJyk7fW91dHB1dFBhcnRzPW91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO3JldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7fTtleHBvcnRzLnNlcD0nLyc7ZXhwb3J0cy5kZWxpbWl0ZXI9JzonO2V4cG9ydHMuZGlybmFtZT1mdW5jdGlvbihwYXRoKXtpZih0eXBlb2YgcGF0aCE9PSdzdHJpbmcnKXBhdGg9cGF0aCsnJztpZihwYXRoLmxlbmd0aD09PTApcmV0dXJuJy4nO3ZhciBjb2RlPXBhdGguY2hhckNvZGVBdCgwKTt2YXIgaGFzUm9vdD1jb2RlPT09NDcvKi8qLzt2YXIgZW5kPS0xO3ZhciBtYXRjaGVkU2xhc2g9dHJ1ZTtmb3IodmFyIGk9cGF0aC5sZW5ndGgtMTtpPj0xOy0taSl7Y29kZT1wYXRoLmNoYXJDb2RlQXQoaSk7aWYoY29kZT09PTQ3LyovKi8pe2lmKCFtYXRjaGVkU2xhc2gpe2VuZD1pO2JyZWFrO319ZWxzZXsvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxubWF0Y2hlZFNsYXNoPWZhbHNlO319aWYoZW5kPT09LTEpcmV0dXJuIGhhc1Jvb3Q/Jy8nOicuJztpZihoYXNSb290JiZlbmQ9PT0xKXsvLyByZXR1cm4gJy8vJztcbi8vIEJhY2t3YXJkcy1jb21wYXQgZml4OlxucmV0dXJuJy8nO31yZXR1cm4gcGF0aC5zbGljZSgwLGVuZCk7fTtmdW5jdGlvbiBiYXNlbmFtZShwYXRoKXtpZih0eXBlb2YgcGF0aCE9PSdzdHJpbmcnKXBhdGg9cGF0aCsnJzt2YXIgc3RhcnQ9MDt2YXIgZW5kPS0xO3ZhciBtYXRjaGVkU2xhc2g9dHJ1ZTt2YXIgaTtmb3IoaT1wYXRoLmxlbmd0aC0xO2k+PTA7LS1pKXtpZihwYXRoLmNoYXJDb2RlQXQoaSk9PT00Ny8qLyovKXsvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG5pZighbWF0Y2hlZFNsYXNoKXtzdGFydD1pKzE7YnJlYWs7fX1lbHNlIGlmKGVuZD09PS0xKXsvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4vLyBwYXRoIGNvbXBvbmVudFxubWF0Y2hlZFNsYXNoPWZhbHNlO2VuZD1pKzE7fX1pZihlbmQ9PT0tMSlyZXR1cm4nJztyZXR1cm4gcGF0aC5zbGljZShzdGFydCxlbmQpO30vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWU9ZnVuY3Rpb24ocGF0aCxleHQpe3ZhciBmPWJhc2VuYW1lKHBhdGgpO2lmKGV4dCYmZi5zdWJzdHIoLTEqZXh0Lmxlbmd0aCk9PT1leHQpe2Y9Zi5zdWJzdHIoMCxmLmxlbmd0aC1leHQubGVuZ3RoKTt9cmV0dXJuIGY7fTtleHBvcnRzLmV4dG5hbWU9ZnVuY3Rpb24ocGF0aCl7aWYodHlwZW9mIHBhdGghPT0nc3RyaW5nJylwYXRoPXBhdGgrJyc7dmFyIHN0YXJ0RG90PS0xO3ZhciBzdGFydFBhcnQ9MDt2YXIgZW5kPS0xO3ZhciBtYXRjaGVkU2xhc2g9dHJ1ZTsvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4vLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxudmFyIHByZURvdFN0YXRlPTA7Zm9yKHZhciBpPXBhdGgubGVuZ3RoLTE7aT49MDstLWkpe3ZhciBjb2RlPXBhdGguY2hhckNvZGVBdChpKTtpZihjb2RlPT09NDcvKi8qLyl7Ly8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbi8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuaWYoIW1hdGNoZWRTbGFzaCl7c3RhcnRQYXJ0PWkrMTticmVhazt9Y29udGludWU7fWlmKGVuZD09PS0xKXsvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4vLyBleHRlbnNpb25cbm1hdGNoZWRTbGFzaD1mYWxzZTtlbmQ9aSsxO31pZihjb2RlPT09NDYvKi4qLyl7Ly8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG5pZihzdGFydERvdD09PS0xKXN0YXJ0RG90PWk7ZWxzZSBpZihwcmVEb3RTdGF0ZSE9PTEpcHJlRG90U3RhdGU9MTt9ZWxzZSBpZihzdGFydERvdCE9PS0xKXsvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbnByZURvdFN0YXRlPS0xO319aWYoc3RhcnREb3Q9PT0tMXx8ZW5kPT09LTF8fC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG5wcmVEb3RTdGF0ZT09PTB8fC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbnByZURvdFN0YXRlPT09MSYmc3RhcnREb3Q9PT1lbmQtMSYmc3RhcnREb3Q9PT1zdGFydFBhcnQrMSl7cmV0dXJuJyc7fXJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LGVuZCk7fTtmdW5jdGlvbiBmaWx0ZXIoeHMsZil7aWYoeHMuZmlsdGVyKXJldHVybiB4cy5maWx0ZXIoZik7dmFyIHJlcz1bXTtmb3IodmFyIGk9MDtpPHhzLmxlbmd0aDtpKyspe2lmKGYoeHNbaV0saSx4cykpcmVzLnB1c2goeHNbaV0pO31yZXR1cm4gcmVzO30vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyPSdhYicuc3Vic3RyKC0xKT09PSdiJz9mdW5jdGlvbihzdHIsc3RhcnQsbGVuKXtyZXR1cm4gc3RyLnN1YnN0cihzdGFydCxsZW4pO306ZnVuY3Rpb24oc3RyLHN0YXJ0LGxlbil7aWYoc3RhcnQ8MClzdGFydD1zdHIubGVuZ3RoK3N0YXJ0O3JldHVybiBzdHIuc3Vic3RyKHN0YXJ0LGxlbik7fTt9KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSk7fSx7XCJfcHJvY2Vzc1wiOjE5Mn1dLDE2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfY29udGFpbmVyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udGFpbmVyXCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O31mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcyxzdXBlckNsYXNzKXtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7c3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yPXN1YkNsYXNzO3N1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzO30vKipcbiAqIFJlcHJlc2VudHMgYW4gYXQtcnVsZS5cbiAqXG4gKiBJZiBpdOKAmXMgZm9sbG93ZWQgaW4gdGhlIENTUyBieSBhIHt9IGJsb2NrLCB0aGlzIG5vZGUgd2lsbCBoYXZlXG4gKiBhIG5vZGVzIHByb3BlcnR5IHJlcHJlc2VudGluZyBpdHMgY2hpbGRyZW4uXG4gKlxuICogQGV4dGVuZHMgQ29udGFpbmVyXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdAY2hhcnNldCBcIlVURi04XCI7IEBtZWRpYSBwcmludCB7fScpXG4gKlxuICogY29uc3QgY2hhcnNldCA9IHJvb3QuZmlyc3RcbiAqIGNoYXJzZXQudHlwZSAgLy89PiAnYXRydWxlJ1xuICogY2hhcnNldC5ub2RlcyAvLz0+IHVuZGVmaW5lZFxuICpcbiAqIGNvbnN0IG1lZGlhID0gcm9vdC5sYXN0XG4gKiBtZWRpYS5ub2RlcyAgIC8vPT4gW11cbiAqL3ZhciBBdFJ1bGU9LyojX19QVVJFX18qL2Z1bmN0aW9uKF9Db250YWluZXIpe19pbmhlcml0c0xvb3NlKEF0UnVsZSxfQ29udGFpbmVyKTtmdW5jdGlvbiBBdFJ1bGUoZGVmYXVsdHMpe3ZhciBfdGhpcztfdGhpcz1fQ29udGFpbmVyLmNhbGwodGhpcyxkZWZhdWx0cyl8fHRoaXM7X3RoaXMudHlwZT0nYXRydWxlJztyZXR1cm4gX3RoaXM7fXZhciBfcHJvdG89QXRSdWxlLnByb3RvdHlwZTtfcHJvdG8uYXBwZW5kPWZ1bmN0aW9uIGFwcGVuZCgpe3ZhciBfQ29udGFpbmVyJHByb3RvdHlwZSQ7aWYoIXRoaXMubm9kZXMpdGhpcy5ub2Rlcz1bXTtmb3IodmFyIF9sZW49YXJndW1lbnRzLmxlbmd0aCxjaGlsZHJlbj1uZXcgQXJyYXkoX2xlbiksX2tleT0wO19rZXk8X2xlbjtfa2V5Kyspe2NoaWxkcmVuW19rZXldPWFyZ3VtZW50c1tfa2V5XTt9cmV0dXJuKF9Db250YWluZXIkcHJvdG90eXBlJD1fQ29udGFpbmVyLnByb3RvdHlwZS5hcHBlbmQpLmNhbGwuYXBwbHkoX0NvbnRhaW5lciRwcm90b3R5cGUkLFt0aGlzXS5jb25jYXQoY2hpbGRyZW4pKTt9O19wcm90by5wcmVwZW5kPWZ1bmN0aW9uIHByZXBlbmQoKXt2YXIgX0NvbnRhaW5lciRwcm90b3R5cGUkMjtpZighdGhpcy5ub2Rlcyl0aGlzLm5vZGVzPVtdO2Zvcih2YXIgX2xlbjI9YXJndW1lbnRzLmxlbmd0aCxjaGlsZHJlbj1uZXcgQXJyYXkoX2xlbjIpLF9rZXkyPTA7X2tleTI8X2xlbjI7X2tleTIrKyl7Y2hpbGRyZW5bX2tleTJdPWFyZ3VtZW50c1tfa2V5Ml07fXJldHVybihfQ29udGFpbmVyJHByb3RvdHlwZSQyPV9Db250YWluZXIucHJvdG90eXBlLnByZXBlbmQpLmNhbGwuYXBwbHkoX0NvbnRhaW5lciRwcm90b3R5cGUkMixbdGhpc10uY29uY2F0KGNoaWxkcmVuKSk7fS8qKlxuICAgKiBAbWVtYmVyb2YgQXRSdWxlI1xuICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWUgVGhlIGF0LXJ1bGXigJlzIG5hbWUgaW1tZWRpYXRlbHkgZm9sbG93cyB0aGUgYEBgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ICA9IHBvc3Rjc3MucGFyc2UoJ0BtZWRpYSBwcmludCB7fScpXG4gICAqIG1lZGlhLm5hbWUgLy89PiAnbWVkaWEnXG4gICAqIGNvbnN0IG1lZGlhID0gcm9vdC5maXJzdFxuICAgKi8gLyoqXG4gICAqIEBtZW1iZXJvZiBBdFJ1bGUjXG4gICAqIEBtZW1iZXIge3N0cmluZ30gcGFyYW1zIFRoZSBhdC1ydWxl4oCZcyBwYXJhbWV0ZXJzLCB0aGUgdmFsdWVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgZm9sbG93IHRoZSBhdC1ydWxl4oCZcyBuYW1lIGJ1dCBwcmVjZWRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGFueSB7fSBibG9jay5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCAgPSBwb3N0Y3NzLnBhcnNlKCdAbWVkaWEgcHJpbnQsIHNjcmVlbiB7fScpXG4gICAqIGNvbnN0IG1lZGlhID0gcm9vdC5maXJzdFxuICAgKiBtZWRpYS5wYXJhbXMgLy89PiAncHJpbnQsIHNjcmVlbidcbiAgICovIC8qKlxuICAgKiBAbWVtYmVyb2YgQXRSdWxlI1xuICAgKiBAbWVtYmVyIHtvYmplY3R9IHJhd3MgSW5mb3JtYXRpb24gdG8gZ2VuZXJhdGUgYnl0ZS10by1ieXRlIGVxdWFsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSBzdHJpbmcgYXMgaXQgd2FzIGluIHRoZSBvcmlnaW4gaW5wdXQuXG4gICAqXG4gICAqIEV2ZXJ5IHBhcnNlciBzYXZlcyBpdHMgb3duIHByb3BlcnRpZXMsXG4gICAqIGJ1dCB0aGUgZGVmYXVsdCBDU1MgcGFyc2VyIHVzZXM6XG4gICAqXG4gICAqICogYGJlZm9yZWA6IHRoZSBzcGFjZSBzeW1ib2xzIGJlZm9yZSB0aGUgbm9kZS4gSXQgYWxzbyBzdG9yZXMgYCpgXG4gICAqICAgYW5kIGBfYCBzeW1ib2xzIGJlZm9yZSB0aGUgZGVjbGFyYXRpb24gKElFIGhhY2spLlxuICAgKiAqIGBhZnRlcmA6IHRoZSBzcGFjZSBzeW1ib2xzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoZSBub2RlXG4gICAqICAgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZS5cbiAgICogKiBgYmV0d2VlbmA6IHRoZSBzeW1ib2xzIGJldHdlZW4gdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgKiAgIGZvciBkZWNsYXJhdGlvbnMsIHNlbGVjdG9yIGFuZCBge2AgZm9yIHJ1bGVzLCBvciBsYXN0IHBhcmFtZXRlclxuICAgKiAgIGFuZCBge2AgZm9yIGF0LXJ1bGVzLlxuICAgKiAqIGBzZW1pY29sb25gOiBjb250YWlucyB0cnVlIGlmIHRoZSBsYXN0IGNoaWxkIGhhc1xuICAgKiAgIGFuIChvcHRpb25hbCkgc2VtaWNvbG9uLlxuICAgKiAqIGBhZnRlck5hbWVgOiB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgYXQtcnVsZSBuYW1lIGFuZCBpdHMgcGFyYW1ldGVycy5cbiAgICpcbiAgICogUG9zdENTUyBjbGVhbnMgYXQtcnVsZSBwYXJhbWV0ZXJzIGZyb20gY29tbWVudHMgYW5kIGV4dHJhIHNwYWNlcyxcbiAgICogYnV0IGl0IHN0b3JlcyBvcmlnaW4gY29udGVudCBpbiByYXdzIHByb3BlcnRpZXMuXG4gICAqIEFzIHN1Y2gsIGlmIHlvdSBkb27igJl0IGNoYW5nZSBhIGRlY2xhcmF0aW9u4oCZcyB2YWx1ZSxcbiAgICogUG9zdENTUyB3aWxsIHVzZSB0aGUgcmF3IHZhbHVlIHdpdGggY29tbWVudHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCcgIEBtZWRpYVxcbnByaW50IHtcXG59JylcbiAgICogcm9vdC5maXJzdC5maXJzdC5yYXdzIC8vPT4geyBiZWZvcmU6ICcgICcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgYmV0d2VlbjogJyAnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGFmdGVyTmFtZTogJ1xcbicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgYWZ0ZXI6ICdcXG4nIH1cbiAgICovO3JldHVybiBBdFJ1bGU7fShfY29udGFpbmVyW1wiZGVmYXVsdFwiXSk7dmFyIF9kZWZhdWx0PUF0UnVsZTtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHtcIi4vY29udGFpbmVyXCI6MTcwfV0sMTY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9ub2RlPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZVwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO3N1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1zdWJDbGFzcztzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzczt9LyoqXG4gKiBSZXByZXNlbnRzIGEgY29tbWVudCBiZXR3ZWVuIGRlY2xhcmF0aW9ucyBvciBzdGF0ZW1lbnRzIChydWxlIGFuZCBhdC1ydWxlcykuXG4gKlxuICogQ29tbWVudHMgaW5zaWRlIHNlbGVjdG9ycywgYXQtcnVsZSBwYXJhbWV0ZXJzLCBvciBkZWNsYXJhdGlvbiB2YWx1ZXNcbiAqIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBgcmF3c2AgcHJvcGVydGllcyBleHBsYWluZWQgYWJvdmUuXG4gKlxuICogQGV4dGVuZHMgTm9kZVxuICovdmFyIENvbW1lbnQ9LyojX19QVVJFX18qL2Z1bmN0aW9uKF9Ob2RlKXtfaW5oZXJpdHNMb29zZShDb21tZW50LF9Ob2RlKTtmdW5jdGlvbiBDb21tZW50KGRlZmF1bHRzKXt2YXIgX3RoaXM7X3RoaXM9X05vZGUuY2FsbCh0aGlzLGRlZmF1bHRzKXx8dGhpcztfdGhpcy50eXBlPSdjb21tZW50JztyZXR1cm4gX3RoaXM7fS8qKlxuICAgKiBAbWVtYmVyb2YgQ29tbWVudCNcbiAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0IFRoZSBjb21tZW504oCZcyB0ZXh0LlxuICAgKi8gLyoqXG4gICAqIEBtZW1iZXJvZiBDb21tZW50I1xuICAgKiBAbWVtYmVyIHtvYmplY3R9IHJhd3MgSW5mb3JtYXRpb24gdG8gZ2VuZXJhdGUgYnl0ZS10by1ieXRlIGVxdWFsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBub2RlIHN0cmluZyBhcyBpdCB3YXMgaW4gdGhlIG9yaWdpbiBpbnB1dC5cbiAgICpcbiAgICogRXZlcnkgcGFyc2VyIHNhdmVzIGl0cyBvd24gcHJvcGVydGllcyxcbiAgICogYnV0IHRoZSBkZWZhdWx0IENTUyBwYXJzZXIgdXNlczpcbiAgICpcbiAgICogKiBgYmVmb3JlYDogdGhlIHNwYWNlIHN5bWJvbHMgYmVmb3JlIHRoZSBub2RlLlxuICAgKiAqIGBsZWZ0YDogdGhlIHNwYWNlIHN5bWJvbHMgYmV0d2VlbiBgLypgIGFuZCB0aGUgY29tbWVudOKAmXMgdGV4dC5cbiAgICogKiBgcmlnaHRgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZXR3ZWVuIHRoZSBjb21tZW504oCZcyB0ZXh0LlxuICAgKi9yZXR1cm4gQ29tbWVudDt9KF9ub2RlW1wiZGVmYXVsdFwiXSk7dmFyIF9kZWZhdWx0PUNvbW1lbnQ7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSx7XCIuL25vZGVcIjoxNzd9XSwxNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2RlY2xhcmF0aW9uPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGVjbGFyYXRpb25cIikpO3ZhciBfY29tbWVudD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRcIikpO3ZhciBfbm9kZT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian07fWZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpO3JldHVybiBDb25zdHJ1Y3Rvcjt9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO3N1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1zdWJDbGFzcztzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzczt9ZnVuY3Rpb24gY2xlYW5Tb3VyY2Uobm9kZXMpe3JldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24oaSl7aWYoaS5ub2RlcylpLm5vZGVzPWNsZWFuU291cmNlKGkubm9kZXMpO2RlbGV0ZSBpLnNvdXJjZTtyZXR1cm4gaTt9KTt9LyoqXG4gKiBUaGUge0BsaW5rIFJvb3R9LCB7QGxpbmsgQXRSdWxlfSwgYW5kIHtAbGluayBSdWxlfSBjb250YWluZXIgbm9kZXNcbiAqIGluaGVyaXQgc29tZSBjb21tb24gbWV0aG9kcyB0byBoZWxwIHdvcmsgd2l0aCB0aGVpciBjaGlsZHJlbi5cbiAqXG4gKiBOb3RlIHRoYXQgYWxsIGNvbnRhaW5lcnMgY2FuIHN0b3JlIGFueSBjb250ZW50LiBJZiB5b3Ugd3JpdGUgYSBydWxlIGluc2lkZVxuICogYSBydWxlLCBQb3N0Q1NTIHdpbGwgcGFyc2UgaXQuXG4gKlxuICogQGV4dGVuZHMgTm9kZVxuICogQGFic3RyYWN0XG4gKi92YXIgQ29udGFpbmVyPS8qI19fUFVSRV9fKi9mdW5jdGlvbihfTm9kZSl7X2luaGVyaXRzTG9vc2UoQ29udGFpbmVyLF9Ob2RlKTtmdW5jdGlvbiBDb250YWluZXIoKXtyZXR1cm4gX05vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO312YXIgX3Byb3RvPUNvbnRhaW5lci5wcm90b3R5cGU7X3Byb3RvLnB1c2g9ZnVuY3Rpb24gcHVzaChjaGlsZCl7Y2hpbGQucGFyZW50PXRoaXM7dGhpcy5ub2Rlcy5wdXNoKGNoaWxkKTtyZXR1cm4gdGhpczt9LyoqXG4gICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGNvbnRhaW5lcuKAmXMgaW1tZWRpYXRlIGNoaWxkcmVuLFxuICAgKiBjYWxsaW5nIGBjYWxsYmFja2AgZm9yIGVhY2ggY2hpbGQuXG4gICAqXG4gICAqIFJldHVybmluZyBgZmFsc2VgIGluIHRoZSBjYWxsYmFjayB3aWxsIGJyZWFrIGl0ZXJhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgb25seSBpdGVyYXRlcyB0aHJvdWdoIHRoZSBjb250YWluZXLigJlzIGltbWVkaWF0ZSBjaGlsZHJlbi5cbiAgICogSWYgeW91IG5lZWQgdG8gcmVjdXJzaXZlbHkgaXRlcmF0ZSB0aHJvdWdoIGFsbCB0aGUgY29udGFpbmVy4oCZcyBkZXNjZW5kYW50XG4gICAqIG5vZGVzLCB1c2Uge0BsaW5rIENvbnRhaW5lciN3YWxrfS5cbiAgICpcbiAgICogVW5saWtlIHRoZSBmb3IgYHt9YC1jeWNsZSBvciBgQXJyYXkjZm9yRWFjaGAgdGhpcyBpdGVyYXRvciBpcyBzYWZlXG4gICAqIGlmIHlvdSBhcmUgbXV0YXRpbmcgdGhlIGFycmF5IG9mIGNoaWxkIG5vZGVzIGR1cmluZyBpdGVyYXRpb24uXG4gICAqIFBvc3RDU1Mgd2lsbCBhZGp1c3QgdGhlIGN1cnJlbnQgaW5kZXggdG8gbWF0Y2ggdGhlIG11dGF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtjaGlsZEl0ZXJhdG9yfSBjYWxsYmFjayBJdGVyYXRvciByZWNlaXZlcyBlYWNoIG5vZGUgYW5kIGluZGV4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWxzZXx1bmRlZmluZWR9IFJldHVybnMgYGZhbHNlYCBpZiBpdGVyYXRpb24gd2FzIGJyb2tlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7IGNvbG9yOiBibGFjazsgei1pbmRleDogMSB9JylcbiAgICogY29uc3QgcnVsZSA9IHJvb3QuZmlyc3RcbiAgICpcbiAgICogZm9yIChjb25zdCBkZWNsIG9mIHJ1bGUubm9kZXMpIHtcbiAgICogICBkZWNsLmNsb25lQmVmb3JlKHsgcHJvcDogJy13ZWJraXQtJyArIGRlY2wucHJvcCB9KVxuICAgKiAgIC8vIEN5Y2xlIHdpbGwgYmUgaW5maW5pdGUsIGJlY2F1c2UgY2xvbmVCZWZvcmUgbW92ZXMgdGhlIGN1cnJlbnQgbm9kZVxuICAgKiAgIC8vIHRvIHRoZSBuZXh0IGluZGV4XG4gICAqIH1cbiAgICpcbiAgICogcnVsZS5lYWNoKGRlY2wgPT4ge1xuICAgKiAgIGRlY2wuY2xvbmVCZWZvcmUoeyBwcm9wOiAnLXdlYmtpdC0nICsgZGVjbC5wcm9wIH0pXG4gICAqICAgLy8gV2lsbCBiZSBleGVjdXRlZCBvbmx5IGZvciBjb2xvciBhbmQgei1pbmRleFxuICAgKiB9KVxuICAgKi87X3Byb3RvLmVhY2g9ZnVuY3Rpb24gZWFjaChjYWxsYmFjayl7aWYoIXRoaXMubGFzdEVhY2gpdGhpcy5sYXN0RWFjaD0wO2lmKCF0aGlzLmluZGV4ZXMpdGhpcy5pbmRleGVzPXt9O3RoaXMubGFzdEVhY2grPTE7dmFyIGlkPXRoaXMubGFzdEVhY2g7dGhpcy5pbmRleGVzW2lkXT0wO2lmKCF0aGlzLm5vZGVzKXJldHVybiB1bmRlZmluZWQ7dmFyIGluZGV4LHJlc3VsdDt3aGlsZSh0aGlzLmluZGV4ZXNbaWRdPHRoaXMubm9kZXMubGVuZ3RoKXtpbmRleD10aGlzLmluZGV4ZXNbaWRdO3Jlc3VsdD1jYWxsYmFjayh0aGlzLm5vZGVzW2luZGV4XSxpbmRleCk7aWYocmVzdWx0PT09ZmFsc2UpYnJlYWs7dGhpcy5pbmRleGVzW2lkXSs9MTt9ZGVsZXRlIHRoaXMuaW5kZXhlc1tpZF07cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgY29udGFpbmVy4oCZcyBkZXNjZW5kYW50IG5vZGVzLCBjYWxsaW5nIGNhbGxiYWNrXG4gICAqIGZvciBlYWNoIG5vZGUuXG4gICAqXG4gICAqIExpa2UgY29udGFpbmVyLmVhY2goKSwgdGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2VcbiAgICogaWYgeW91IGFyZSBtdXRhdGluZyBhcnJheXMgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICpcbiAgICogSWYgeW91IG9ubHkgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGNvbnRhaW5lcuKAmXMgaW1tZWRpYXRlIGNoaWxkcmVuLFxuICAgKiB1c2Uge0BsaW5rIENvbnRhaW5lciNlYWNofS5cbiAgICpcbiAgICogQHBhcmFtIHtjaGlsZEl0ZXJhdG9yfSBjYWxsYmFjayBJdGVyYXRvciByZWNlaXZlcyBlYWNoIG5vZGUgYW5kIGluZGV4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWxzZXx1bmRlZmluZWR9IFJldHVybnMgYGZhbHNlYCBpZiBpdGVyYXRpb24gd2FzIGJyb2tlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByb290LndhbGsobm9kZSA9PiB7XG4gICAqICAgLy8gVHJhdmVyc2VzIGFsbCBkZXNjZW5kYW50IG5vZGVzLlxuICAgKiB9KVxuICAgKi87X3Byb3RvLndhbGs9ZnVuY3Rpb24gd2FsayhjYWxsYmFjayl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjaGlsZCxpKXt2YXIgcmVzdWx0O3RyeXtyZXN1bHQ9Y2FsbGJhY2soY2hpbGQsaSk7fWNhdGNoKGUpe2UucG9zdGNzc05vZGU9Y2hpbGQ7aWYoZS5zdGFjayYmY2hpbGQuc291cmNlJiYvXFxuXFxzezR9YXQgLy50ZXN0KGUuc3RhY2spKXt2YXIgcz1jaGlsZC5zb3VyY2U7ZS5zdGFjaz1lLnN0YWNrLnJlcGxhY2UoL1xcblxcc3s0fWF0IC8sXCIkJlwiK3MuaW5wdXQuZnJvbStcIjpcIitzLnN0YXJ0LmxpbmUrXCI6XCIrcy5zdGFydC5jb2x1bW4rXCIkJlwiKTt9dGhyb3cgZTt9aWYocmVzdWx0IT09ZmFsc2UmJmNoaWxkLndhbGspe3Jlc3VsdD1jaGlsZC53YWxrKGNhbGxiYWNrKTt9cmV0dXJuIHJlc3VsdDt9KTt9LyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgY29udGFpbmVy4oCZcyBkZXNjZW5kYW50IG5vZGVzLCBjYWxsaW5nIGNhbGxiYWNrXG4gICAqIGZvciBlYWNoIGRlY2xhcmF0aW9uIG5vZGUuXG4gICAqXG4gICAqIElmIHlvdSBwYXNzIGEgZmlsdGVyLCBpdGVyYXRpb24gd2lsbCBvbmx5IGhhcHBlbiBvdmVyIGRlY2xhcmF0aW9uc1xuICAgKiB3aXRoIG1hdGNoaW5nIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIExpa2Uge0BsaW5rIENvbnRhaW5lciNlYWNofSwgdGhpcyBtZXRob2QgaXMgc2FmZVxuICAgKiB0byB1c2UgaWYgeW91IGFyZSBtdXRhdGluZyBhcnJheXMgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBbcHJvcF0gICBTdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gZmlsdGVyIGRlY2xhcmF0aW9ucyBieSBwcm9wZXJ0eSBuYW1lLlxuICAgKiBAcGFyYW0ge2NoaWxkSXRlcmF0b3J9IGNhbGxiYWNrIEl0ZXJhdG9yIHJlY2VpdmVzIGVhY2ggbm9kZSBhbmQgaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm4ge2ZhbHNlfHVuZGVmaW5lZH0gUmV0dXJucyBgZmFsc2VgIGlmIGl0ZXJhdGlvbiB3YXMgYnJva2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3Qud2Fsa0RlY2xzKGRlY2wgPT4ge1xuICAgKiAgIGNoZWNrUHJvcGVydHlTdXBwb3J0KGRlY2wucHJvcClcbiAgICogfSlcbiAgICpcbiAgICogcm9vdC53YWxrRGVjbHMoJ2JvcmRlci1yYWRpdXMnLCBkZWNsID0+IHtcbiAgICogICBkZWNsLnJlbW92ZSgpXG4gICAqIH0pXG4gICAqXG4gICAqIHJvb3Qud2Fsa0RlY2xzKC9eYmFja2dyb3VuZC8sIGRlY2wgPT4ge1xuICAgKiAgIGRlY2wudmFsdWUgPSB0YWtlRmlyc3RDb2xvckZyb21HcmFkaWVudChkZWNsLnZhbHVlKVxuICAgKiB9KVxuICAgKi87X3Byb3RvLndhbGtEZWNscz1mdW5jdGlvbiB3YWxrRGVjbHMocHJvcCxjYWxsYmFjayl7aWYoIWNhbGxiYWNrKXtjYWxsYmFjaz1wcm9wO3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdkZWNsJyl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9aWYocHJvcCBpbnN0YW5jZW9mIFJlZ0V4cCl7cmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCxpKXtpZihjaGlsZC50eXBlPT09J2RlY2wnJiZwcm9wLnRlc3QoY2hpbGQucHJvcCkpe3JldHVybiBjYWxsYmFjayhjaGlsZCxpKTt9fSk7fXJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdkZWNsJyYmY2hpbGQucHJvcD09PXByb3Ape3JldHVybiBjYWxsYmFjayhjaGlsZCxpKTt9fSk7fS8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIGNvbnRhaW5lcuKAmXMgZGVzY2VuZGFudCBub2RlcywgY2FsbGluZyBjYWxsYmFja1xuICAgKiBmb3IgZWFjaCBydWxlIG5vZGUuXG4gICAqXG4gICAqIElmIHlvdSBwYXNzIGEgZmlsdGVyLCBpdGVyYXRpb24gd2lsbCBvbmx5IGhhcHBlbiBvdmVyIHJ1bGVzXG4gICAqIHdpdGggbWF0Y2hpbmcgc2VsZWN0b3JzLlxuICAgKlxuICAgKiBMaWtlIHtAbGluayBDb250YWluZXIjZWFjaH0sIHRoaXMgbWV0aG9kIGlzIHNhZmVcbiAgICogdG8gdXNlIGlmIHlvdSBhcmUgbXV0YXRpbmcgYXJyYXlzIGR1cmluZyBpdGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gW3NlbGVjdG9yXSBTdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBmaWx0ZXIgcnVsZXMgYnkgc2VsZWN0b3IuXG4gICAqIEBwYXJhbSB7Y2hpbGRJdGVyYXRvcn0gY2FsbGJhY2sgICBJdGVyYXRvciByZWNlaXZlcyBlYWNoIG5vZGUgYW5kIGluZGV4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWxzZXx1bmRlZmluZWR9IHJldHVybnMgYGZhbHNlYCBpZiBpdGVyYXRpb24gd2FzIGJyb2tlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBzZWxlY3RvcnMgPSBbXVxuICAgKiByb290LndhbGtSdWxlcyhydWxlID0+IHtcbiAgICogICBzZWxlY3RvcnMucHVzaChydWxlLnNlbGVjdG9yKVxuICAgKiB9KVxuICAgKiBjb25zb2xlLmxvZyhgWW91ciBDU1MgdXNlcyAkeyBzZWxlY3RvcnMubGVuZ3RoIH0gc2VsZWN0b3JzYClcbiAgICovO19wcm90by53YWxrUnVsZXM9ZnVuY3Rpb24gd2Fsa1J1bGVzKHNlbGVjdG9yLGNhbGxiYWNrKXtpZighY2FsbGJhY2spe2NhbGxiYWNrPXNlbGVjdG9yO3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdydWxlJyl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9aWYoc2VsZWN0b3IgaW5zdGFuY2VvZiBSZWdFeHApe3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdydWxlJyYmc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3Rvcikpe3JldHVybiBjYWxsYmFjayhjaGlsZCxpKTt9fSk7fXJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdydWxlJyYmY2hpbGQuc2VsZWN0b3I9PT1zZWxlY3Rvcil7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9LyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgY29udGFpbmVy4oCZcyBkZXNjZW5kYW50IG5vZGVzLCBjYWxsaW5nIGNhbGxiYWNrXG4gICAqIGZvciBlYWNoIGF0LXJ1bGUgbm9kZS5cbiAgICpcbiAgICogSWYgeW91IHBhc3MgYSBmaWx0ZXIsIGl0ZXJhdGlvbiB3aWxsIG9ubHkgaGFwcGVuIG92ZXIgYXQtcnVsZXNcbiAgICogdGhhdCBoYXZlIG1hdGNoaW5nIG5hbWVzLlxuICAgKlxuICAgKiBMaWtlIHtAbGluayBDb250YWluZXIjZWFjaH0sIHRoaXMgbWV0aG9kIGlzIHNhZmVcbiAgICogdG8gdXNlIGlmIHlvdSBhcmUgbXV0YXRpbmcgYXJyYXlzIGR1cmluZyBpdGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gW25hbWVdICAgU3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGZpbHRlciBhdC1ydWxlcyBieSBuYW1lLlxuICAgKiBAcGFyYW0ge2NoaWxkSXRlcmF0b3J9IGNhbGxiYWNrIEl0ZXJhdG9yIHJlY2VpdmVzIGVhY2ggbm9kZSBhbmQgaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm4ge2ZhbHNlfHVuZGVmaW5lZH0gUmV0dXJucyBgZmFsc2VgIGlmIGl0ZXJhdGlvbiB3YXMgYnJva2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3Qud2Fsa0F0UnVsZXMocnVsZSA9PiB7XG4gICAqICAgaWYgKGlzT2xkKHJ1bGUubmFtZSkpIHJ1bGUucmVtb3ZlKClcbiAgICogfSlcbiAgICpcbiAgICogbGV0IGZpcnN0ID0gZmFsc2VcbiAgICogcm9vdC53YWxrQXRSdWxlcygnY2hhcnNldCcsIHJ1bGUgPT4ge1xuICAgKiAgIGlmICghZmlyc3QpIHtcbiAgICogICAgIGZpcnN0ID0gdHJ1ZVxuICAgKiAgIH0gZWxzZSB7XG4gICAqICAgICBydWxlLnJlbW92ZSgpXG4gICAqICAgfVxuICAgKiB9KVxuICAgKi87X3Byb3RvLndhbGtBdFJ1bGVzPWZ1bmN0aW9uIHdhbGtBdFJ1bGVzKG5hbWUsY2FsbGJhY2spe2lmKCFjYWxsYmFjayl7Y2FsbGJhY2s9bmFtZTtyZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLGkpe2lmKGNoaWxkLnR5cGU9PT0nYXRydWxlJyl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9aWYobmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCl7cmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCxpKXtpZihjaGlsZC50eXBlPT09J2F0cnVsZScmJm5hbWUudGVzdChjaGlsZC5uYW1lKSl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9cmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCxpKXtpZihjaGlsZC50eXBlPT09J2F0cnVsZScmJmNoaWxkLm5hbWU9PT1uYW1lKXtyZXR1cm4gY2FsbGJhY2soY2hpbGQsaSk7fX0pO30vKipcbiAgICogVHJhdmVyc2VzIHRoZSBjb250YWluZXLigJlzIGRlc2NlbmRhbnQgbm9kZXMsIGNhbGxpbmcgY2FsbGJhY2tcbiAgICogZm9yIGVhY2ggY29tbWVudCBub2RlLlxuICAgKlxuICAgKiBMaWtlIHtAbGluayBDb250YWluZXIjZWFjaH0sIHRoaXMgbWV0aG9kIGlzIHNhZmVcbiAgICogdG8gdXNlIGlmIHlvdSBhcmUgbXV0YXRpbmcgYXJyYXlzIGR1cmluZyBpdGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Y2hpbGRJdGVyYXRvcn0gY2FsbGJhY2sgSXRlcmF0b3IgcmVjZWl2ZXMgZWFjaCBub2RlIGFuZCBpbmRleC5cbiAgICpcbiAgICogQHJldHVybiB7ZmFsc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGBmYWxzZWAgaWYgaXRlcmF0aW9uIHdhcyBicm9rZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcm9vdC53YWxrQ29tbWVudHMoY29tbWVudCA9PiB7XG4gICAqICAgY29tbWVudC5yZW1vdmUoKVxuICAgKiB9KVxuICAgKi87X3Byb3RvLndhbGtDb21tZW50cz1mdW5jdGlvbiB3YWxrQ29tbWVudHMoY2FsbGJhY2spe3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdjb21tZW50Jyl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9LyoqXG4gICAqIEluc2VydHMgbmV3IG5vZGVzIHRvIHRoZSBlbmQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHsuLi4oTm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXSl9IGNoaWxkcmVuIE5ldyBub2Rlcy5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhpcyBub2RlIGZvciBtZXRob2RzIGNoYWluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkZWNsMSA9IHBvc3Rjc3MuZGVjbCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAnYmxhY2snIH0pXG4gICAqIGNvbnN0IGRlY2wyID0gcG9zdGNzcy5kZWNsKHsgcHJvcDogJ2JhY2tncm91bmQtY29sb3InLCB2YWx1ZTogJ3doaXRlJyB9KVxuICAgKiBydWxlLmFwcGVuZChkZWNsMSwgZGVjbDIpXG4gICAqXG4gICAqIHJvb3QuYXBwZW5kKHsgbmFtZTogJ2NoYXJzZXQnLCBwYXJhbXM6ICdcIlVURi04XCInIH0pICAvLyBhdC1ydWxlXG4gICAqIHJvb3QuYXBwZW5kKHsgc2VsZWN0b3I6ICdhJyB9KSAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVsZVxuICAgKiBydWxlLmFwcGVuZCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAnYmxhY2snIH0pICAgICAgIC8vIGRlY2xhcmF0aW9uXG4gICAqIHJ1bGUuYXBwZW5kKHsgdGV4dDogJ0NvbW1lbnQnIH0pICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWVudFxuICAgKlxuICAgKiByb290LmFwcGVuZCgnYSB7fScpXG4gICAqIHJvb3QuZmlyc3QuYXBwZW5kKCdjb2xvcjogYmxhY2s7IHotaW5kZXg6IDEnKVxuICAgKi87X3Byb3RvLmFwcGVuZD1mdW5jdGlvbiBhcHBlbmQoKXtmb3IodmFyIF9sZW49YXJndW1lbnRzLmxlbmd0aCxjaGlsZHJlbj1uZXcgQXJyYXkoX2xlbiksX2tleT0wO19rZXk8X2xlbjtfa2V5Kyspe2NoaWxkcmVuW19rZXldPWFyZ3VtZW50c1tfa2V5XTt9Zm9yKHZhciBfaT0wLF9jaGlsZHJlbj1jaGlsZHJlbjtfaTxfY2hpbGRyZW4ubGVuZ3RoO19pKyspe3ZhciBjaGlsZD1fY2hpbGRyZW5bX2ldO3ZhciBub2Rlcz10aGlzLm5vcm1hbGl6ZShjaGlsZCx0aGlzLmxhc3QpO2Zvcih2YXIgX2l0ZXJhdG9yPW5vZGVzLF9pc0FycmF5PUFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSxfaTI9MCxfaXRlcmF0b3I9X2lzQXJyYXk/X2l0ZXJhdG9yOl9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY7aWYoX2lzQXJyYXkpe2lmKF9pMj49X2l0ZXJhdG9yLmxlbmd0aClicmVhaztfcmVmPV9pdGVyYXRvcltfaTIrK107fWVsc2V7X2kyPV9pdGVyYXRvci5uZXh0KCk7aWYoX2kyLmRvbmUpYnJlYWs7X3JlZj1faTIudmFsdWU7fXZhciBub2RlPV9yZWY7dGhpcy5ub2Rlcy5wdXNoKG5vZGUpO319cmV0dXJuIHRoaXM7fS8qKlxuICAgKiBJbnNlcnRzIG5ldyBub2RlcyB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHsuLi4oTm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXSl9IGNoaWxkcmVuIE5ldyBub2Rlcy5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhpcyBub2RlIGZvciBtZXRob2RzIGNoYWluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkZWNsMSA9IHBvc3Rjc3MuZGVjbCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAnYmxhY2snIH0pXG4gICAqIGNvbnN0IGRlY2wyID0gcG9zdGNzcy5kZWNsKHsgcHJvcDogJ2JhY2tncm91bmQtY29sb3InLCB2YWx1ZTogJ3doaXRlJyB9KVxuICAgKiBydWxlLnByZXBlbmQoZGVjbDEsIGRlY2wyKVxuICAgKlxuICAgKiByb290LmFwcGVuZCh7IG5hbWU6ICdjaGFyc2V0JywgcGFyYW1zOiAnXCJVVEYtOFwiJyB9KSAgLy8gYXQtcnVsZVxuICAgKiByb290LmFwcGVuZCh7IHNlbGVjdG9yOiAnYScgfSkgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1bGVcbiAgICogcnVsZS5hcHBlbmQoeyBwcm9wOiAnY29sb3InLCB2YWx1ZTogJ2JsYWNrJyB9KSAgICAgICAvLyBkZWNsYXJhdGlvblxuICAgKiBydWxlLmFwcGVuZCh7IHRleHQ6ICdDb21tZW50JyB9KSAgICAgICAgICAgICAgICAgICAgIC8vIGNvbW1lbnRcbiAgICpcbiAgICogcm9vdC5hcHBlbmQoJ2Ege30nKVxuICAgKiByb290LmZpcnN0LmFwcGVuZCgnY29sb3I6IGJsYWNrOyB6LWluZGV4OiAxJylcbiAgICovO19wcm90by5wcmVwZW5kPWZ1bmN0aW9uIHByZXBlbmQoKXtmb3IodmFyIF9sZW4yPWFyZ3VtZW50cy5sZW5ndGgsY2hpbGRyZW49bmV3IEFycmF5KF9sZW4yKSxfa2V5Mj0wO19rZXkyPF9sZW4yO19rZXkyKyspe2NoaWxkcmVuW19rZXkyXT1hcmd1bWVudHNbX2tleTJdO31jaGlsZHJlbj1jaGlsZHJlbi5yZXZlcnNlKCk7Zm9yKHZhciBfaXRlcmF0b3IyPWNoaWxkcmVuLF9pc0FycmF5Mj1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLF9pMz0wLF9pdGVyYXRvcjI9X2lzQXJyYXkyP19pdGVyYXRvcjI6X2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWYyO2lmKF9pc0FycmF5Mil7aWYoX2kzPj1faXRlcmF0b3IyLmxlbmd0aClicmVhaztfcmVmMj1faXRlcmF0b3IyW19pMysrXTt9ZWxzZXtfaTM9X2l0ZXJhdG9yMi5uZXh0KCk7aWYoX2kzLmRvbmUpYnJlYWs7X3JlZjI9X2kzLnZhbHVlO312YXIgY2hpbGQ9X3JlZjI7dmFyIG5vZGVzPXRoaXMubm9ybWFsaXplKGNoaWxkLHRoaXMuZmlyc3QsJ3ByZXBlbmQnKS5yZXZlcnNlKCk7Zm9yKHZhciBfaXRlcmF0b3IzPW5vZGVzLF9pc0FycmF5Mz1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLF9pND0wLF9pdGVyYXRvcjM9X2lzQXJyYXkzP19pdGVyYXRvcjM6X2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWYzO2lmKF9pc0FycmF5Myl7aWYoX2k0Pj1faXRlcmF0b3IzLmxlbmd0aClicmVhaztfcmVmMz1faXRlcmF0b3IzW19pNCsrXTt9ZWxzZXtfaTQ9X2l0ZXJhdG9yMy5uZXh0KCk7aWYoX2k0LmRvbmUpYnJlYWs7X3JlZjM9X2k0LnZhbHVlO312YXIgbm9kZT1fcmVmMzt0aGlzLm5vZGVzLnVuc2hpZnQobm9kZSk7fWZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXt0aGlzLmluZGV4ZXNbaWRdPXRoaXMuaW5kZXhlc1tpZF0rbm9kZXMubGVuZ3RoO319cmV0dXJuIHRoaXM7fTtfcHJvdG8uY2xlYW5SYXdzPWZ1bmN0aW9uIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbil7X05vZGUucHJvdG90eXBlLmNsZWFuUmF3cy5jYWxsKHRoaXMsa2VlcEJldHdlZW4pO2lmKHRoaXMubm9kZXMpe2Zvcih2YXIgX2l0ZXJhdG9yND10aGlzLm5vZGVzLF9pc0FycmF5ND1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjQpLF9pNT0wLF9pdGVyYXRvcjQ9X2lzQXJyYXk0P19pdGVyYXRvcjQ6X2l0ZXJhdG9yNFtTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY0O2lmKF9pc0FycmF5NCl7aWYoX2k1Pj1faXRlcmF0b3I0Lmxlbmd0aClicmVhaztfcmVmND1faXRlcmF0b3I0W19pNSsrXTt9ZWxzZXtfaTU9X2l0ZXJhdG9yNC5uZXh0KCk7aWYoX2k1LmRvbmUpYnJlYWs7X3JlZjQ9X2k1LnZhbHVlO312YXIgbm9kZT1fcmVmNDtub2RlLmNsZWFuUmF3cyhrZWVwQmV0d2Vlbik7fX19LyoqXG4gICAqIEluc2VydCBuZXcgbm9kZSBiZWZvcmUgb2xkIG5vZGUgd2l0aGluIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZXxudW1iZXJ9IGV4aXN0ICAgICAgICAgICAgIENoaWxkIG9yIGNoaWxk4oCZcyBpbmRleC5cbiAgICogQHBhcmFtIHtOb2RlfG9iamVjdHxzdHJpbmd8Tm9kZVtdfSBhZGQgTmV3IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRoaXMgbm9kZSBmb3IgbWV0aG9kcyBjaGFpbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcnVsZS5pbnNlcnRCZWZvcmUoZGVjbCwgZGVjbC5jbG9uZSh7IHByb3A6ICctd2Via2l0LScgKyBkZWNsLnByb3AgfSkpXG4gICAqLztfcHJvdG8uaW5zZXJ0QmVmb3JlPWZ1bmN0aW9uIGluc2VydEJlZm9yZShleGlzdCxhZGQpe2V4aXN0PXRoaXMuaW5kZXgoZXhpc3QpO3ZhciB0eXBlPWV4aXN0PT09MD8ncHJlcGVuZCc6ZmFsc2U7dmFyIG5vZGVzPXRoaXMubm9ybWFsaXplKGFkZCx0aGlzLm5vZGVzW2V4aXN0XSx0eXBlKS5yZXZlcnNlKCk7Zm9yKHZhciBfaXRlcmF0b3I1PW5vZGVzLF9pc0FycmF5NT1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjUpLF9pNj0wLF9pdGVyYXRvcjU9X2lzQXJyYXk1P19pdGVyYXRvcjU6X2l0ZXJhdG9yNVtTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY1O2lmKF9pc0FycmF5NSl7aWYoX2k2Pj1faXRlcmF0b3I1Lmxlbmd0aClicmVhaztfcmVmNT1faXRlcmF0b3I1W19pNisrXTt9ZWxzZXtfaTY9X2l0ZXJhdG9yNS5uZXh0KCk7aWYoX2k2LmRvbmUpYnJlYWs7X3JlZjU9X2k2LnZhbHVlO312YXIgbm9kZT1fcmVmNTt0aGlzLm5vZGVzLnNwbGljZShleGlzdCwwLG5vZGUpO312YXIgaW5kZXg7Zm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe2luZGV4PXRoaXMuaW5kZXhlc1tpZF07aWYoZXhpc3Q8PWluZGV4KXt0aGlzLmluZGV4ZXNbaWRdPWluZGV4K25vZGVzLmxlbmd0aDt9fXJldHVybiB0aGlzO30vKipcbiAgICogSW5zZXJ0IG5ldyBub2RlIGFmdGVyIG9sZCBub2RlIHdpdGhpbiB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV8bnVtYmVyfSBleGlzdCAgICAgICAgICAgICBDaGlsZCBvciBjaGlsZOKAmXMgaW5kZXguXG4gICAqIEBwYXJhbSB7Tm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXX0gYWRkIE5ldyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqLztfcHJvdG8uaW5zZXJ0QWZ0ZXI9ZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoZXhpc3QsYWRkKXtleGlzdD10aGlzLmluZGV4KGV4aXN0KTt2YXIgbm9kZXM9dGhpcy5ub3JtYWxpemUoYWRkLHRoaXMubm9kZXNbZXhpc3RdKS5yZXZlcnNlKCk7Zm9yKHZhciBfaXRlcmF0b3I2PW5vZGVzLF9pc0FycmF5Nj1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjYpLF9pNz0wLF9pdGVyYXRvcjY9X2lzQXJyYXk2P19pdGVyYXRvcjY6X2l0ZXJhdG9yNltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY2O2lmKF9pc0FycmF5Nil7aWYoX2k3Pj1faXRlcmF0b3I2Lmxlbmd0aClicmVhaztfcmVmNj1faXRlcmF0b3I2W19pNysrXTt9ZWxzZXtfaTc9X2l0ZXJhdG9yNi5uZXh0KCk7aWYoX2k3LmRvbmUpYnJlYWs7X3JlZjY9X2k3LnZhbHVlO312YXIgbm9kZT1fcmVmNjt0aGlzLm5vZGVzLnNwbGljZShleGlzdCsxLDAsbm9kZSk7fXZhciBpbmRleDtmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7aW5kZXg9dGhpcy5pbmRleGVzW2lkXTtpZihleGlzdDxpbmRleCl7dGhpcy5pbmRleGVzW2lkXT1pbmRleCtub2Rlcy5sZW5ndGg7fX1yZXR1cm4gdGhpczt9LyoqXG4gICAqIFJlbW92ZXMgbm9kZSBmcm9tIHRoZSBjb250YWluZXIgYW5kIGNsZWFucyB0aGUgcGFyZW50IHByb3BlcnRpZXNcbiAgICogZnJvbSB0aGUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV8bnVtYmVyfSBjaGlsZCBDaGlsZCBvciBjaGlsZOKAmXMgaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRoaXMgbm9kZSBmb3IgbWV0aG9kcyBjaGFpblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBydWxlLm5vZGVzLmxlbmd0aCAgLy89PiA1XG4gICAqIHJ1bGUucmVtb3ZlQ2hpbGQoZGVjbClcbiAgICogcnVsZS5ub2Rlcy5sZW5ndGggIC8vPT4gNFxuICAgKiBkZWNsLnBhcmVudCAgICAgICAgLy89PiB1bmRlZmluZWRcbiAgICovO19wcm90by5yZW1vdmVDaGlsZD1mdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCl7Y2hpbGQ9dGhpcy5pbmRleChjaGlsZCk7dGhpcy5ub2Rlc1tjaGlsZF0ucGFyZW50PXVuZGVmaW5lZDt0aGlzLm5vZGVzLnNwbGljZShjaGlsZCwxKTt2YXIgaW5kZXg7Zm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe2luZGV4PXRoaXMuaW5kZXhlc1tpZF07aWYoaW5kZXg+PWNoaWxkKXt0aGlzLmluZGV4ZXNbaWRdPWluZGV4LTE7fX1yZXR1cm4gdGhpczt9LyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lclxuICAgKiBhbmQgY2xlYW5zIHRoZWlyIHBhcmVudCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJ1bGUucmVtb3ZlQWxsKClcbiAgICogcnVsZS5ub2Rlcy5sZW5ndGggLy89PiAwXG4gICAqLztfcHJvdG8ucmVtb3ZlQWxsPWZ1bmN0aW9uIHJlbW92ZUFsbCgpe2Zvcih2YXIgX2l0ZXJhdG9yNz10aGlzLm5vZGVzLF9pc0FycmF5Nz1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjcpLF9pOD0wLF9pdGVyYXRvcjc9X2lzQXJyYXk3P19pdGVyYXRvcjc6X2l0ZXJhdG9yN1tTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY3O2lmKF9pc0FycmF5Nyl7aWYoX2k4Pj1faXRlcmF0b3I3Lmxlbmd0aClicmVhaztfcmVmNz1faXRlcmF0b3I3W19pOCsrXTt9ZWxzZXtfaTg9X2l0ZXJhdG9yNy5uZXh0KCk7aWYoX2k4LmRvbmUpYnJlYWs7X3JlZjc9X2k4LnZhbHVlO312YXIgbm9kZT1fcmVmNztub2RlLnBhcmVudD11bmRlZmluZWQ7fXRoaXMubm9kZXM9W107cmV0dXJuIHRoaXM7fS8qKlxuICAgKiBQYXNzZXMgYWxsIGRlY2xhcmF0aW9uIHZhbHVlcyB3aXRoaW4gdGhlIGNvbnRhaW5lciB0aGF0IG1hdGNoIHBhdHRlcm5cbiAgICogdGhyb3VnaCBjYWxsYmFjaywgcmVwbGFjaW5nIHRob3NlIHZhbHVlcyB3aXRoIHRoZSByZXR1cm5lZCByZXN1bHRcbiAgICogb2YgY2FsbGJhY2suXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBpZiB5b3UgYXJlIHVzaW5nIGEgY3VzdG9tIHVuaXQgb3IgZnVuY3Rpb25cbiAgICogYW5kIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gcGF0dGVybiAgICAgIFJlcGxhY2UgcGF0dGVybi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgICAgICAgICAgICAgICAgT3B0aW9ucyB0byBzcGVlZCB1cCB0aGUgc2VhcmNoLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0cy5wcm9wcyBBbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZmFzdCAgICAgICAgICAgU3RyaW5nIHRoYXTigJlzIHVzZWQgdG8gbmFycm93IGRvd25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIGFuZCBzcGVlZCB1cCB0aGUgcmVnZXhwIHNlYXJjaC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbnxzdHJpbmd9IGNhbGxiYWNrICAgU3RyaW5nIHRvIHJlcGxhY2UgcGF0dGVybiBvciBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IHJldHVybnMgYSBuZXcgdmFsdWUuIFRoZSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHJlY2VpdmUgdGhlIHNhbWUgYXJndW1lbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIHRob3NlIHBhc3NlZCB0byBhIGZ1bmN0aW9uIHBhcmFtZXRlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBgU3RyaW5nI3JlcGxhY2VgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3QucmVwbGFjZVZhbHVlcygvXFxkK3JlbS8sIHsgZmFzdDogJ3JlbScgfSwgc3RyaW5nID0+IHtcbiAgICogICByZXR1cm4gMTUgKiBwYXJzZUludChzdHJpbmcpICsgJ3B4J1xuICAgKiB9KVxuICAgKi87X3Byb3RvLnJlcGxhY2VWYWx1ZXM9ZnVuY3Rpb24gcmVwbGFjZVZhbHVlcyhwYXR0ZXJuLG9wdHMsY2FsbGJhY2spe2lmKCFjYWxsYmFjayl7Y2FsbGJhY2s9b3B0cztvcHRzPXt9O310aGlzLndhbGtEZWNscyhmdW5jdGlvbihkZWNsKXtpZihvcHRzLnByb3BzJiZvcHRzLnByb3BzLmluZGV4T2YoZGVjbC5wcm9wKT09PS0xKXJldHVybjtpZihvcHRzLmZhc3QmJmRlY2wudmFsdWUuaW5kZXhPZihvcHRzLmZhc3QpPT09LTEpcmV0dXJuO2RlY2wudmFsdWU9ZGVjbC52YWx1ZS5yZXBsYWNlKHBhdHRlcm4sY2FsbGJhY2spO30pO3JldHVybiB0aGlzO30vKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWBcbiAgICogZm9yIGFsbCBvZiB0aGUgY29udGFpbmVy4oCZcyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHtjaGlsZENvbmRpdGlvbn0gY29uZGl0aW9uIEl0ZXJhdG9yIHJldHVybnMgdHJ1ZSBvciBmYWxzZS5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZXZlcnkgY2hpbGQgcGFzcyBjb25kaXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG5vUHJlZml4ZXMgPSBydWxlLmV2ZXJ5KGkgPT4gaS5wcm9wWzBdICE9PSAnLScpXG4gICAqLztfcHJvdG8uZXZlcnk9ZnVuY3Rpb24gZXZlcnkoY29uZGl0aW9uKXtyZXR1cm4gdGhpcy5ub2Rlcy5ldmVyeShjb25kaXRpb24pO30vKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIChhdCBsZWFzdCkgb25lXG4gICAqIG9mIHRoZSBjb250YWluZXLigJlzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge2NoaWxkQ29uZGl0aW9ufSBjb25kaXRpb24gSXRlcmF0b3IgcmV0dXJucyB0cnVlIG9yIGZhbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBzb21lIGNoaWxkIHBhc3MgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBoYXNQcmVmaXggPSBydWxlLnNvbWUoaSA9PiBpLnByb3BbMF0gPT09ICctJylcbiAgICovO19wcm90by5zb21lPWZ1bmN0aW9uIHNvbWUoY29uZGl0aW9uKXtyZXR1cm4gdGhpcy5ub2Rlcy5zb21lKGNvbmRpdGlvbik7fS8qKlxuICAgKiBSZXR1cm5zIGEgYGNoaWxkYOKAmXMgaW5kZXggd2l0aGluIHRoZSB7QGxpbmsgQ29udGFpbmVyI25vZGVzfSBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBjaGlsZCBDaGlsZCBvZiB0aGUgY3VycmVudCBjb250YWluZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQ2hpbGQgaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJ1bGUuaW5kZXgoIHJ1bGUubm9kZXNbMl0gKSAvLz0+IDJcbiAgICovO19wcm90by5pbmRleD1mdW5jdGlvbiBpbmRleChjaGlsZCl7aWYodHlwZW9mIGNoaWxkPT09J251bWJlcicpe3JldHVybiBjaGlsZDt9cmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZihjaGlsZCk7fS8qKlxuICAgKiBUaGUgY29udGFpbmVy4oCZcyBmaXJzdCBjaGlsZC5cbiAgICpcbiAgICogQHR5cGUge05vZGV9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJ1bGUuZmlyc3QgPT09IHJ1bGVzLm5vZGVzWzBdXG4gICAqLztfcHJvdG8ubm9ybWFsaXplPWZ1bmN0aW9uIG5vcm1hbGl6ZShub2RlcyxzYW1wbGUpe3ZhciBfdGhpcz10aGlzO2lmKHR5cGVvZiBub2Rlcz09PSdzdHJpbmcnKXt2YXIgcGFyc2U9cmVxdWlyZSgnLi9wYXJzZScpO25vZGVzPWNsZWFuU291cmNlKHBhcnNlKG5vZGVzKS5ub2Rlcyk7fWVsc2UgaWYoQXJyYXkuaXNBcnJheShub2Rlcykpe25vZGVzPW5vZGVzLnNsaWNlKDApO2Zvcih2YXIgX2l0ZXJhdG9yOD1ub2RlcyxfaXNBcnJheTg9QXJyYXkuaXNBcnJheShfaXRlcmF0b3I4KSxfaTk9MCxfaXRlcmF0b3I4PV9pc0FycmF5OD9faXRlcmF0b3I4Ol9pdGVyYXRvcjhbU3ltYm9sLml0ZXJhdG9yXSgpOzspe3ZhciBfcmVmODtpZihfaXNBcnJheTgpe2lmKF9pOT49X2l0ZXJhdG9yOC5sZW5ndGgpYnJlYWs7X3JlZjg9X2l0ZXJhdG9yOFtfaTkrK107fWVsc2V7X2k5PV9pdGVyYXRvcjgubmV4dCgpO2lmKF9pOS5kb25lKWJyZWFrO19yZWY4PV9pOS52YWx1ZTt9dmFyIGk9X3JlZjg7aWYoaS5wYXJlbnQpaS5wYXJlbnQucmVtb3ZlQ2hpbGQoaSwnaWdub3JlJyk7fX1lbHNlIGlmKG5vZGVzLnR5cGU9PT0ncm9vdCcpe25vZGVzPW5vZGVzLm5vZGVzLnNsaWNlKDApO2Zvcih2YXIgX2l0ZXJhdG9yOT1ub2RlcyxfaXNBcnJheTk9QXJyYXkuaXNBcnJheShfaXRlcmF0b3I5KSxfaTEwPTAsX2l0ZXJhdG9yOT1faXNBcnJheTk/X2l0ZXJhdG9yOTpfaXRlcmF0b3I5W1N5bWJvbC5pdGVyYXRvcl0oKTs7KXt2YXIgX3JlZjk7aWYoX2lzQXJyYXk5KXtpZihfaTEwPj1faXRlcmF0b3I5Lmxlbmd0aClicmVhaztfcmVmOT1faXRlcmF0b3I5W19pMTArK107fWVsc2V7X2kxMD1faXRlcmF0b3I5Lm5leHQoKTtpZihfaTEwLmRvbmUpYnJlYWs7X3JlZjk9X2kxMC52YWx1ZTt9dmFyIF9pMTE9X3JlZjk7aWYoX2kxMS5wYXJlbnQpX2kxMS5wYXJlbnQucmVtb3ZlQ2hpbGQoX2kxMSwnaWdub3JlJyk7fX1lbHNlIGlmKG5vZGVzLnR5cGUpe25vZGVzPVtub2Rlc107fWVsc2UgaWYobm9kZXMucHJvcCl7aWYodHlwZW9mIG5vZGVzLnZhbHVlPT09J3VuZGVmaW5lZCcpe3Rocm93IG5ldyBFcnJvcignVmFsdWUgZmllbGQgaXMgbWlzc2VkIGluIG5vZGUgY3JlYXRpb24nKTt9ZWxzZSBpZih0eXBlb2Ygbm9kZXMudmFsdWUhPT0nc3RyaW5nJyl7bm9kZXMudmFsdWU9U3RyaW5nKG5vZGVzLnZhbHVlKTt9bm9kZXM9W25ldyBfZGVjbGFyYXRpb25bXCJkZWZhdWx0XCJdKG5vZGVzKV07fWVsc2UgaWYobm9kZXMuc2VsZWN0b3Ipe3ZhciBSdWxlPXJlcXVpcmUoJy4vcnVsZScpO25vZGVzPVtuZXcgUnVsZShub2RlcyldO31lbHNlIGlmKG5vZGVzLm5hbWUpe3ZhciBBdFJ1bGU9cmVxdWlyZSgnLi9hdC1ydWxlJyk7bm9kZXM9W25ldyBBdFJ1bGUobm9kZXMpXTt9ZWxzZSBpZihub2Rlcy50ZXh0KXtub2Rlcz1bbmV3IF9jb21tZW50W1wiZGVmYXVsdFwiXShub2RlcyldO31lbHNle3Rocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGUgaW4gbm9kZSBjcmVhdGlvbicpO312YXIgcHJvY2Vzc2VkPW5vZGVzLm1hcChmdW5jdGlvbihpKXtpZihpLnBhcmVudClpLnBhcmVudC5yZW1vdmVDaGlsZChpKTtpZih0eXBlb2YgaS5yYXdzLmJlZm9yZT09PSd1bmRlZmluZWQnKXtpZihzYW1wbGUmJnR5cGVvZiBzYW1wbGUucmF3cy5iZWZvcmUhPT0ndW5kZWZpbmVkJyl7aS5yYXdzLmJlZm9yZT1zYW1wbGUucmF3cy5iZWZvcmUucmVwbGFjZSgvW15cXHNdL2csJycpO319aS5wYXJlbnQ9X3RoaXM7cmV0dXJuIGk7fSk7cmV0dXJuIHByb2Nlc3NlZDt9LyoqXG4gICAqIEBtZW1iZXJvZiBDb250YWluZXIjXG4gICAqIEBtZW1iZXIge05vZGVbXX0gbm9kZXMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgY29udGFpbmVy4oCZcyBjaGlsZHJlbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2EgeyBjb2xvcjogYmxhY2sgfScpXG4gICAqIHJvb3Qubm9kZXMubGVuZ3RoICAgICAgICAgICAvLz0+IDFcbiAgICogcm9vdC5ub2Rlc1swXS5zZWxlY3RvciAgICAgIC8vPT4gJ2EnXG4gICAqIHJvb3Qubm9kZXNbMF0ubm9kZXNbMF0ucHJvcCAvLz0+ICdjb2xvcidcbiAgICovO19jcmVhdGVDbGFzcyhDb250YWluZXIsW3trZXk6XCJmaXJzdFwiLGdldDpmdW5jdGlvbiBnZXQoKXtpZighdGhpcy5ub2RlcylyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLm5vZGVzWzBdO30vKipcbiAgICAgKiBUaGUgY29udGFpbmVy4oCZcyBsYXN0IGNoaWxkLlxuICAgICAqXG4gICAgICogQHR5cGUge05vZGV9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHJ1bGUubGFzdCA9PT0gcnVsZS5ub2Rlc1tydWxlLm5vZGVzLmxlbmd0aCAtIDFdXG4gICAgICovfSx7a2V5OlwibGFzdFwiLGdldDpmdW5jdGlvbiBnZXQoKXtpZighdGhpcy5ub2RlcylyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoLTFdO319XSk7cmV0dXJuIENvbnRhaW5lcjt9KF9ub2RlW1wiZGVmYXVsdFwiXSk7dmFyIF9kZWZhdWx0PUNvbnRhaW5lcjsvKipcbiAqIEBjYWxsYmFjayBjaGlsZENvbmRpdGlvblxuICogQHBhcmFtIHtOb2RlfSBub2RlICAgIENvbnRhaW5lciBjaGlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBDaGlsZCBpbmRleC5cbiAqIEBwYXJhbSB7Tm9kZVtdfSBub2RlcyBBbGwgY29udGFpbmVyIGNoaWxkcmVuLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqLyAvKipcbiAqIEBjYWxsYmFjayBjaGlsZEl0ZXJhdG9yXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgICAgQ29udGFpbmVyIGNoaWxkLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IENoaWxkIGluZGV4LlxuICogQHJldHVybiB7ZmFsc2V8dW5kZWZpbmVkfSBSZXR1cm5pbmcgYGZhbHNlYCB3aWxsIGJyZWFrIGl0ZXJhdGlvbi5cbiAqL2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se1wiLi9hdC1ydWxlXCI6MTY4LFwiLi9jb21tZW50XCI6MTY5LFwiLi9kZWNsYXJhdGlvblwiOjE3MixcIi4vbm9kZVwiOjE3NyxcIi4vcGFyc2VcIjoxNzgsXCIuL3J1bGVcIjoxODV9XSwxNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX3N1cHBvcnRzQ29sb3I9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwic3VwcG9ydHMtY29sb3JcIikpO3ZhciBfY2hhbGs9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2hhbGtcIikpO3ZhciBfdGVybWluYWxIaWdobGlnaHQ9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90ZXJtaW5hbC1oaWdobGlnaHRcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian07fWZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZil7aWYoc2VsZj09PXZvaWQgMCl7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO31yZXR1cm4gc2VsZjt9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO3N1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1zdWJDbGFzcztzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzczt9ZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyl7dmFyIF9jYWNoZT10eXBlb2YgTWFwPT09XCJmdW5jdGlvblwiP25ldyBNYXAoKTp1bmRlZmluZWQ7X3dyYXBOYXRpdmVTdXBlcj1mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKXtpZihDbGFzcz09PW51bGx8fCFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpcmV0dXJuIENsYXNzO2lmKHR5cGVvZiBDbGFzcyE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO31pZih0eXBlb2YgX2NhY2hlIT09XCJ1bmRlZmluZWRcIil7aWYoX2NhY2hlLmhhcyhDbGFzcykpcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO19jYWNoZS5zZXQoQ2xhc3MsV3JhcHBlcik7fWZ1bmN0aW9uIFdyYXBwZXIoKXtyZXR1cm4gX2NvbnN0cnVjdChDbGFzcyxhcmd1bWVudHMsX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTt9V3JhcHBlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpXcmFwcGVyLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX19KTtyZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsQ2xhc3MpO307cmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO31mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKXtpZih0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCJ8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4gZmFsc2U7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4gZmFsc2U7aWYodHlwZW9mIFByb3h5PT09XCJmdW5jdGlvblwiKXJldHVybiB0cnVlO3RyeXtEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsW10sZnVuY3Rpb24oKXt9KSk7cmV0dXJuIHRydWU7fWNhdGNoKGUpe3JldHVybiBmYWxzZTt9fWZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LGFyZ3MsQ2xhc3Mpe2lmKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKXtfY29uc3RydWN0PVJlZmxlY3QuY29uc3RydWN0O31lbHNle19jb25zdHJ1Y3Q9ZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsYXJncyxDbGFzcyl7dmFyIGE9W251bGxdO2EucHVzaC5hcHBseShhLGFyZ3MpO3ZhciBDb25zdHJ1Y3Rvcj1GdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCxhKTt2YXIgaW5zdGFuY2U9bmV3IENvbnN0cnVjdG9yKCk7aWYoQ2xhc3MpX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLENsYXNzLnByb3RvdHlwZSk7cmV0dXJuIGluc3RhbmNlO307fXJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsYXJndW1lbnRzKTt9ZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pe3JldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSE9PS0xO31mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobyxwKXtfc2V0UHJvdG90eXBlT2Y9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobyxwKXtvLl9fcHJvdG9fXz1wO3JldHVybiBvO307cmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLHApO31mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobyl7X2dldFByb3RvdHlwZU9mPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pe3JldHVybiBvLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO307cmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTt9LyoqXG4gKiBUaGUgQ1NTIHBhcnNlciB0aHJvd3MgdGhpcyBlcnJvciBmb3IgYnJva2VuIENTUy5cbiAqXG4gKiBDdXN0b20gcGFyc2VycyBjYW4gdGhyb3cgdGhpcyBlcnJvciBmb3IgYnJva2VuIGN1c3RvbSBzeW50YXggdXNpbmdcbiAqIHRoZSB7QGxpbmsgTm9kZSNlcnJvcn0gbWV0aG9kLlxuICpcbiAqIFBvc3RDU1Mgd2lsbCB1c2UgdGhlIGlucHV0IHNvdXJjZSBtYXAgdG8gZGV0ZWN0IHRoZSBvcmlnaW5hbCBlcnJvciBsb2NhdGlvbi5cbiAqIElmIHlvdSB3cm90ZSBhIFNhc3MgZmlsZSwgY29tcGlsZWQgaXQgdG8gQ1NTIGFuZCB0aGVuIHBhcnNlZCBpdCB3aXRoIFBvc3RDU1MsXG4gKiBQb3N0Q1NTIHdpbGwgc2hvdyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaW4gdGhlIFNhc3MgZmlsZS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0aGUgcG9zaXRpb24gaW4gdGhlIFBvc3RDU1MgaW5wdXRcbiAqIChlLmcuLCB0byBkZWJ1ZyB0aGUgcHJldmlvdXMgY29tcGlsZXIpLCB1c2UgYGVycm9yLmlucHV0LmZpbGVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDYXRjaGluZyBhbmQgY2hlY2tpbmcgc3ludGF4IGVycm9yXG4gKiB0cnkge1xuICogICBwb3N0Y3NzLnBhcnNlKCdheycpXG4gKiB9IGNhdGNoIChlcnJvcikge1xuICogICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Nzc1N5bnRheEVycm9yJykge1xuICogICAgIGVycm9yIC8vPT4gQ3NzU3ludGF4RXJyb3JcbiAqICAgfVxuICogfVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSYWlzaW5nIGVycm9yIGZyb20gcGx1Z2luXG4gKiB0aHJvdyBub2RlLmVycm9yKCdVbmtub3duIHZhcmlhYmxlJywgeyBwbHVnaW46ICdwb3N0Y3NzLXZhcnMnIH0pXG4gKi92YXIgQ3NzU3ludGF4RXJyb3I9LyojX19QVVJFX18qL2Z1bmN0aW9uKF9FcnJvcil7X2luaGVyaXRzTG9vc2UoQ3NzU3ludGF4RXJyb3IsX0Vycm9yKTsvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgIEVycm9yIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGluZV0gICBTb3VyY2UgbGluZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sdW1uXSBTb3VyY2UgY29sdW1uIG9mIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VdIFNvdXJjZSBjb2RlIG9mIHRoZSBicm9rZW4gZmlsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmaWxlXSAgIEFic29sdXRlIHBhdGggdG8gdGhlIGJyb2tlbiBmaWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BsdWdpbl0gUG9zdENTUyBwbHVnaW4gbmFtZSwgaWYgZXJyb3IgY2FtZSBmcm9tIHBsdWdpbi5cbiAgICovZnVuY3Rpb24gQ3NzU3ludGF4RXJyb3IobWVzc2FnZSxsaW5lLGNvbHVtbixzb3VyY2UsZmlsZSxwbHVnaW4pe3ZhciBfdGhpcztfdGhpcz1fRXJyb3IuY2FsbCh0aGlzLG1lc3NhZ2UpfHx0aGlzOy8qKlxuICAgICAqIEFsd2F5cyBlcXVhbCB0byBgJ0Nzc1N5bnRheEVycm9yJ2AuIFlvdSBzaG91bGQgYWx3YXlzIGNoZWNrIGVycm9yIHR5cGVcbiAgICAgKiBieSBgZXJyb3IubmFtZSA9PT0gJ0Nzc1N5bnRheEVycm9yJ2BcbiAgICAgKiBpbnN0ZWFkIG9mIGBlcnJvciBpbnN0YW5jZW9mIENzc1N5bnRheEVycm9yYCxcbiAgICAgKiBiZWNhdXNlIG5wbSBjb3VsZCBoYXZlIHNldmVyYWwgUG9zdENTUyB2ZXJzaW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlmIChlcnJvci5uYW1lID09PSAnQ3NzU3ludGF4RXJyb3InKSB7XG4gICAgICogICBlcnJvciAvLz0+IENzc1N5bnRheEVycm9yXG4gICAgICogfVxuICAgICAqL190aGlzLm5hbWU9J0Nzc1N5bnRheEVycm9yJzsvKipcbiAgICAgKiBFcnJvciBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZXJyb3IubWVzc2FnZSAvLz0+ICdVbmNsb3NlZCBibG9jaydcbiAgICAgKi9fdGhpcy5yZWFzb249bWVzc2FnZTtpZihmaWxlKXsvKipcbiAgICAgICAqIEFic29sdXRlIHBhdGggdG8gdGhlIGJyb2tlbiBmaWxlLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGVycm9yLmZpbGUgICAgICAgLy89PiAnYS5zYXNzJ1xuICAgICAgICogZXJyb3IuaW5wdXQuZmlsZSAvLz0+ICdhLmNzcydcbiAgICAgICAqL190aGlzLmZpbGU9ZmlsZTt9aWYoc291cmNlKXsvKipcbiAgICAgICAqIFNvdXJjZSBjb2RlIG9mIHRoZSBicm9rZW4gZmlsZS5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBlcnJvci5zb3VyY2UgICAgICAgLy89PiAnYSB7IGIge30gfSdcbiAgICAgICAqIGVycm9yLmlucHV0LmNvbHVtbiAvLz0+ICdhIGIgeyB9J1xuICAgICAgICovX3RoaXMuc291cmNlPXNvdXJjZTt9aWYocGx1Z2luKXsvKipcbiAgICAgICAqIFBsdWdpbiBuYW1lLCBpZiBlcnJvciBjYW1lIGZyb20gcGx1Z2luLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGVycm9yLnBsdWdpbiAvLz0+ICdwb3N0Y3NzLXZhcnMnXG4gICAgICAgKi9fdGhpcy5wbHVnaW49cGx1Z2luO31pZih0eXBlb2YgbGluZSE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgY29sdW1uIT09J3VuZGVmaW5lZCcpey8qKlxuICAgICAgICogU291cmNlIGxpbmUgb2YgdGhlIGVycm9yLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGVycm9yLmxpbmUgICAgICAgLy89PiAyXG4gICAgICAgKiBlcnJvci5pbnB1dC5saW5lIC8vPT4gNFxuICAgICAgICovX3RoaXMubGluZT1saW5lOy8qKlxuICAgICAgICogU291cmNlIGNvbHVtbiBvZiB0aGUgZXJyb3IuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogZXJyb3IuY29sdW1uICAgICAgIC8vPT4gMVxuICAgICAgICogZXJyb3IuaW5wdXQuY29sdW1uIC8vPT4gNFxuICAgICAgICovX3RoaXMuY29sdW1uPWNvbHVtbjt9X3RoaXMuc2V0TWVzc2FnZSgpO2lmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKXtFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSxDc3NTeW50YXhFcnJvcik7fXJldHVybiBfdGhpczt9dmFyIF9wcm90bz1Dc3NTeW50YXhFcnJvci5wcm90b3R5cGU7X3Byb3RvLnNldE1lc3NhZ2U9ZnVuY3Rpb24gc2V0TWVzc2FnZSgpey8qKlxuICAgICAqIEZ1bGwgZXJyb3IgdGV4dCBpbiB0aGUgR05VIGVycm9yIGZvcm1hdFxuICAgICAqIHdpdGggcGx1Z2luLCBmaWxlLCBsaW5lIGFuZCBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBlcnJvci5tZXNzYWdlIC8vPT4gJ2EuY3NzOjE6MTogVW5jbG9zZWQgYmxvY2snXG4gICAgICovdGhpcy5tZXNzYWdlPXRoaXMucGx1Z2luP3RoaXMucGx1Z2luKyc6ICc6Jyc7dGhpcy5tZXNzYWdlKz10aGlzLmZpbGU/dGhpcy5maWxlOic8Y3NzIGlucHV0Pic7aWYodHlwZW9mIHRoaXMubGluZSE9PSd1bmRlZmluZWQnKXt0aGlzLm1lc3NhZ2UrPSc6Jyt0aGlzLmxpbmUrJzonK3RoaXMuY29sdW1uO310aGlzLm1lc3NhZ2UrPSc6ICcrdGhpcy5yZWFzb247fS8qKlxuICAgKiBSZXR1cm5zIGEgZmV3IGxpbmVzIG9mIENTUyBzb3VyY2UgdGhhdCBjYXVzZWQgdGhlIGVycm9yLlxuICAgKlxuICAgKiBJZiB0aGUgQ1NTIGhhcyBhbiBpbnB1dCBzb3VyY2UgbWFwIHdpdGhvdXQgYHNvdXJjZUNvbnRlbnRgLFxuICAgKiB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbG9yXSBXaGV0aGVyIGFycm93IHdpbGwgYmUgY29sb3JlZCByZWQgYnkgdGVybWluYWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yIGNvZGVzLiBCeSBkZWZhdWx0LCBQb3N0Q1NTIHdpbGwgZGV0ZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciBzdXBwb3J0IGJ5IGBwcm9jZXNzLnN0ZG91dC5pc1RUWWBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBgcHJvY2Vzcy5lbnYuTk9ERV9ESVNBQkxFX0NPTE9SU2AuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVycm9yLnNob3dTb3VyY2VDb2RlKCkgLy89PiBcIiAgNCB8IH1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIDUgfCBhIHtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAvLyAgICA+IDYgfCAgIGJhZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICB8ICAgXlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgNyB8IH1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIDggfCBiIHtcIlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEZldyBsaW5lcyBvZiBDU1Mgc291cmNlIHRoYXQgY2F1c2VkIHRoZSBlcnJvci5cbiAgICovO19wcm90by5zaG93U291cmNlQ29kZT1mdW5jdGlvbiBzaG93U291cmNlQ29kZShjb2xvcil7dmFyIF90aGlzMj10aGlzO2lmKCF0aGlzLnNvdXJjZSlyZXR1cm4nJzt2YXIgY3NzPXRoaXMuc291cmNlO2lmKF90ZXJtaW5hbEhpZ2hsaWdodFtcImRlZmF1bHRcIl0pe2lmKHR5cGVvZiBjb2xvcj09PSd1bmRlZmluZWQnKWNvbG9yPV9zdXBwb3J0c0NvbG9yW1wiZGVmYXVsdFwiXS5zdGRvdXQ7aWYoY29sb3IpY3NzPSgwLF90ZXJtaW5hbEhpZ2hsaWdodFtcImRlZmF1bHRcIl0pKGNzcyk7fXZhciBsaW5lcz1jc3Muc3BsaXQoL1xccj9cXG4vKTt2YXIgc3RhcnQ9TWF0aC5tYXgodGhpcy5saW5lLTMsMCk7dmFyIGVuZD1NYXRoLm1pbih0aGlzLmxpbmUrMixsaW5lcy5sZW5ndGgpO3ZhciBtYXhXaWR0aD1TdHJpbmcoZW5kKS5sZW5ndGg7ZnVuY3Rpb24gbWFyayh0ZXh0KXtpZihjb2xvciYmX2NoYWxrW1wiZGVmYXVsdFwiXS5yZWQpe3JldHVybiBfY2hhbGtbXCJkZWZhdWx0XCJdLnJlZC5ib2xkKHRleHQpO31yZXR1cm4gdGV4dDt9ZnVuY3Rpb24gYXNpZGUodGV4dCl7aWYoY29sb3ImJl9jaGFsa1tcImRlZmF1bHRcIl0uZ3JheSl7cmV0dXJuIF9jaGFsa1tcImRlZmF1bHRcIl0uZ3JheSh0ZXh0KTt9cmV0dXJuIHRleHQ7fXJldHVybiBsaW5lcy5zbGljZShzdGFydCxlbmQpLm1hcChmdW5jdGlvbihsaW5lLGluZGV4KXt2YXIgbnVtYmVyPXN0YXJ0KzEraW5kZXg7dmFyIGd1dHRlcj0nICcrKCcgJytudW1iZXIpLnNsaWNlKC1tYXhXaWR0aCkrJyB8ICc7aWYobnVtYmVyPT09X3RoaXMyLmxpbmUpe3ZhciBzcGFjaW5nPWFzaWRlKGd1dHRlci5yZXBsYWNlKC9cXGQvZywnICcpKStsaW5lLnNsaWNlKDAsX3RoaXMyLmNvbHVtbi0xKS5yZXBsYWNlKC9bXlxcdF0vZywnICcpO3JldHVybiBtYXJrKCc+JykrYXNpZGUoZ3V0dGVyKStsaW5lKydcXG4gJytzcGFjaW5nK21hcmsoJ14nKTt9cmV0dXJuJyAnK2FzaWRlKGd1dHRlcikrbGluZTt9KS5qb2luKCdcXG4nKTt9LyoqXG4gICAqIFJldHVybnMgZXJyb3IgcG9zaXRpb24sIG1lc3NhZ2UgYW5kIHNvdXJjZSBjb2RlIG9mIHRoZSBicm9rZW4gcGFydC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZXJyb3IudG9TdHJpbmcoKSAvLz0+IFwiQ3NzU3ludGF4RXJyb3I6IGFwcC5jc3M6MToxOiBVbmNsb3NlZCBibG9ja1xuICAgKiAgICAgICAgICAgICAgICAgIC8vICAgID4gMSB8IGEge1xuICAgKiAgICAgICAgICAgICAgICAgIC8vICAgICAgICB8IF5cIlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVycm9yIHBvc2l0aW9uLCBtZXNzYWdlIGFuZCBzb3VyY2UgY29kZS5cbiAgICovO19wcm90by50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBjb2RlPXRoaXMuc2hvd1NvdXJjZUNvZGUoKTtpZihjb2RlKXtjb2RlPSdcXG5cXG4nK2NvZGUrJ1xcbic7fXJldHVybiB0aGlzLm5hbWUrJzogJyt0aGlzLm1lc3NhZ2UrY29kZTt9LyoqXG4gICAqIEBtZW1iZXJvZiBDc3NTeW50YXhFcnJvciNcbiAgICogQG1lbWJlciB7SW5wdXR9IGlucHV0IElucHV0IG9iamVjdCB3aXRoIFBvc3RDU1MgaW50ZXJuYWwgaW5mb3JtYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgIGFib3V0IGlucHV0IGZpbGUuIElmIGlucHV0IGhhcyBzb3VyY2UgbWFwXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHByZXZpb3VzIHRvb2wsIFBvc3RDU1Mgd2lsbCB1c2Ugb3JpZ2luXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAoZm9yIGV4YW1wbGUsIFNhc3MpIHNvdXJjZS4gWW91IGNhbiB1c2UgdGhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHRvIGdldCBQb3N0Q1NTIGlucHV0IHNvdXJjZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZXJyb3IuaW5wdXQuZmlsZSAvLz0+ICdhLmNzcydcbiAgICogZXJyb3IuZmlsZSAgICAgICAvLz0+ICdhLnNhc3MnXG4gICAqLztyZXR1cm4gQ3NzU3ludGF4RXJyb3I7fShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7dmFyIF9kZWZhdWx0PUNzc1N5bnRheEVycm9yO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se1wiLi90ZXJtaW5hbC1oaWdobGlnaHRcIjoyLFwiY2hhbGtcIjoyLFwic3VwcG9ydHMtY29sb3JcIjoyfV0sMTcyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9ub2RlPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZVwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO3N1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1zdWJDbGFzcztzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzczt9LyoqXG4gKiBSZXByZXNlbnRzIGEgQ1NTIGRlY2xhcmF0aW9uLlxuICpcbiAqIEBleHRlbmRzIE5vZGVcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2EgeyBjb2xvcjogYmxhY2sgfScpXG4gKiBjb25zdCBkZWNsID0gcm9vdC5maXJzdC5maXJzdFxuICogZGVjbC50eXBlICAgICAgIC8vPT4gJ2RlY2wnXG4gKiBkZWNsLnRvU3RyaW5nKCkgLy89PiAnIGNvbG9yOiBibGFjaydcbiAqL3ZhciBEZWNsYXJhdGlvbj0vKiNfX1BVUkVfXyovZnVuY3Rpb24oX05vZGUpe19pbmhlcml0c0xvb3NlKERlY2xhcmF0aW9uLF9Ob2RlKTtmdW5jdGlvbiBEZWNsYXJhdGlvbihkZWZhdWx0cyl7dmFyIF90aGlzO190aGlzPV9Ob2RlLmNhbGwodGhpcyxkZWZhdWx0cyl8fHRoaXM7X3RoaXMudHlwZT0nZGVjbCc7cmV0dXJuIF90aGlzO30vKipcbiAgICogQG1lbWJlcm9mIERlY2xhcmF0aW9uI1xuICAgKiBAbWVtYmVyIHtzdHJpbmd9IHByb3AgVGhlIGRlY2xhcmF0aW9u4oCZcyBwcm9wZXJ0eSBuYW1lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7IGNvbG9yOiBibGFjayB9JylcbiAgICogY29uc3QgZGVjbCA9IHJvb3QuZmlyc3QuZmlyc3RcbiAgICogZGVjbC5wcm9wIC8vPT4gJ2NvbG9yJ1xuICAgKi8gLyoqXG4gICAqIEBtZW1iZXJvZiBEZWNsYXJhdGlvbiNcbiAgICogQG1lbWJlciB7c3RyaW5nfSB2YWx1ZSBUaGUgZGVjbGFyYXRpb27igJlzIHZhbHVlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7IGNvbG9yOiBibGFjayB9JylcbiAgICogY29uc3QgZGVjbCA9IHJvb3QuZmlyc3QuZmlyc3RcbiAgICogZGVjbC52YWx1ZSAvLz0+ICdibGFjaydcbiAgICovIC8qKlxuICAgKiBAbWVtYmVyb2YgRGVjbGFyYXRpb24jXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59IGltcG9ydGFudCBgdHJ1ZWAgaWYgdGhlIGRlY2xhcmF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYW4gIWltcG9ydGFudCBhbm5vdGF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7IGNvbG9yOiBibGFjayAhaW1wb3J0YW50OyBjb2xvcjogcmVkIH0nKVxuICAgKiByb290LmZpcnN0LmZpcnN0LmltcG9ydGFudCAvLz0+IHRydWVcbiAgICogcm9vdC5maXJzdC5sYXN0LmltcG9ydGFudCAgLy89PiB1bmRlZmluZWRcbiAgICovIC8qKlxuICAgKiBAbWVtYmVyb2YgRGVjbGFyYXRpb24jXG4gICAqIEBtZW1iZXIge29iamVjdH0gcmF3cyBJbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBieXRlLXRvLWJ5dGUgZXF1YWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIG5vZGUgc3RyaW5nIGFzIGl0IHdhcyBpbiB0aGUgb3JpZ2luIGlucHV0LlxuICAgKlxuICAgKiBFdmVyeSBwYXJzZXIgc2F2ZXMgaXRzIG93biBwcm9wZXJ0aWVzLFxuICAgKiBidXQgdGhlIGRlZmF1bHQgQ1NTIHBhcnNlciB1c2VzOlxuICAgKlxuICAgKiAqIGBiZWZvcmVgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZWZvcmUgdGhlIG5vZGUuIEl0IGFsc28gc3RvcmVzIGAqYFxuICAgKiAgIGFuZCBgX2Agc3ltYm9scyBiZWZvcmUgdGhlIGRlY2xhcmF0aW9uIChJRSBoYWNrKS5cbiAgICogKiBgYmV0d2VlbmA6IHRoZSBzeW1ib2xzIGJldHdlZW4gdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgKiAgIGZvciBkZWNsYXJhdGlvbnMuXG4gICAqICogYGltcG9ydGFudGA6IHRoZSBjb250ZW50IG9mIHRoZSBpbXBvcnRhbnQgc3RhdGVtZW50LFxuICAgKiAgIGlmIGl0IGlzIG5vdCBqdXN0IGAhaW1wb3J0YW50YC5cbiAgICpcbiAgICogUG9zdENTUyBjbGVhbnMgZGVjbGFyYXRpb24gZnJvbSBjb21tZW50cyBhbmQgZXh0cmEgc3BhY2VzLFxuICAgKiBidXQgaXQgc3RvcmVzIG9yaWdpbiBjb250ZW50IGluIHJhd3MgcHJvcGVydGllcy5cbiAgICogQXMgc3VjaCwgaWYgeW91IGRvbuKAmXQgY2hhbmdlIGEgZGVjbGFyYXRpb27igJlzIHZhbHVlLFxuICAgKiBQb3N0Q1NTIHdpbGwgdXNlIHRoZSByYXcgdmFsdWUgd2l0aCBjb21tZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2Ege1xcbiAgY29sb3I6YmxhY2tcXG59JylcbiAgICogcm9vdC5maXJzdC5maXJzdC5yYXdzIC8vPT4geyBiZWZvcmU6ICdcXG4gICcsIGJldHdlZW46ICc6JyB9XG4gICAqL3JldHVybiBEZWNsYXJhdGlvbjt9KF9ub2RlW1wiZGVmYXVsdFwiXSk7dmFyIF9kZWZhdWx0PURlY2xhcmF0aW9uO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se1wiLi9ub2RlXCI6MTc3fV0sMTczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9wYXRoPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInBhdGhcIikpO3ZhciBfY3NzU3ludGF4RXJyb3I9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jc3Mtc3ludGF4LWVycm9yXCIpKTt2YXIgX3ByZXZpb3VzTWFwPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcHJldmlvdXMtbWFwXCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O31mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpO2lmKHN0YXRpY1Byb3BzKV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7fXZhciBzZXF1ZW5jZT0wOy8qKlxuICogUmVwcmVzZW50cyB0aGUgc291cmNlIENTUy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgcm9vdCAgPSBwb3N0Y3NzLnBhcnNlKGNzcywgeyBmcm9tOiBmaWxlIH0pXG4gKiBjb25zdCBpbnB1dCA9IHJvb3Quc291cmNlLmlucHV0XG4gKi92YXIgSW5wdXQ9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7LyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3MgICAgSW5wdXQgQ1NTIHNvdXJjZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9IG9wdGlvbnMuXG4gICAqL2Z1bmN0aW9uIElucHV0KGNzcyxvcHRzKXtpZihvcHRzPT09dm9pZCAwKXtvcHRzPXt9O31pZihjc3M9PT1udWxsfHxfdHlwZW9mKGNzcyk9PT0nb2JqZWN0JyYmIWNzcy50b1N0cmluZyl7dGhyb3cgbmV3IEVycm9yKFwiUG9zdENTUyByZWNlaXZlZCBcIitjc3MrXCIgaW5zdGVhZCBvZiBDU1Mgc3RyaW5nXCIpO30vKipcbiAgICAgKiBJbnB1dCBDU1Mgc291cmNlXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBpbnB1dCA9IHBvc3Rjc3MucGFyc2UoJ2F7fScsIHsgZnJvbTogZmlsZSB9KS5pbnB1dFxuICAgICAqIGlucHV0LmNzcyAvLz0+IFwiYXt9XCJcbiAgICAgKi90aGlzLmNzcz1jc3MudG9TdHJpbmcoKTtpZih0aGlzLmNzc1swXT09PVwiXFx1RkVGRlwifHx0aGlzLmNzc1swXT09PVwiXFx1RkZGRVwiKXt0aGlzLmhhc0JPTT10cnVlO3RoaXMuY3NzPXRoaXMuY3NzLnNsaWNlKDEpO31lbHNle3RoaXMuaGFzQk9NPWZhbHNlO31pZihvcHRzLmZyb20pe2lmKC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKXx8X3BhdGhbXCJkZWZhdWx0XCJdLmlzQWJzb2x1dGUob3B0cy5mcm9tKSl7LyoqXG4gICAgICAgICAqIFRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBDU1Mgc291cmNlIGZpbGUgZGVmaW5lZFxuICAgICAgICAgKiB3aXRoIHRoZSBgZnJvbWAgb3B0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZShjc3MsIHsgZnJvbTogJ2EuY3NzJyB9KVxuICAgICAgICAgKiByb290LnNvdXJjZS5pbnB1dC5maWxlIC8vPT4gJy9ob21lL2FpL2EuY3NzJ1xuICAgICAgICAgKi90aGlzLmZpbGU9b3B0cy5mcm9tO31lbHNle3RoaXMuZmlsZT1fcGF0aFtcImRlZmF1bHRcIl0ucmVzb2x2ZShvcHRzLmZyb20pO319dmFyIG1hcD1uZXcgX3ByZXZpb3VzTWFwW1wiZGVmYXVsdFwiXSh0aGlzLmNzcyxvcHRzKTtpZihtYXAudGV4dCl7LyoqXG4gICAgICAgKiBUaGUgaW5wdXQgc291cmNlIG1hcCBwYXNzZWQgZnJvbSBhIGNvbXBpbGF0aW9uIHN0ZXAgYmVmb3JlIFBvc3RDU1NcbiAgICAgICAqIChmb3IgZXhhbXBsZSwgZnJvbSBTYXNzIGNvbXBpbGVyKS5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7UHJldmlvdXNNYXB9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIHJvb3Quc291cmNlLmlucHV0Lm1hcC5jb25zdW1lcigpLnNvdXJjZXMgLy89PiBbJ2Euc2FzcyddXG4gICAgICAgKi90aGlzLm1hcD1tYXA7dmFyIGZpbGU9bWFwLmNvbnN1bWVyKCkuZmlsZTtpZighdGhpcy5maWxlJiZmaWxlKXRoaXMuZmlsZT10aGlzLm1hcFJlc29sdmUoZmlsZSk7fWlmKCF0aGlzLmZpbGUpe3NlcXVlbmNlKz0xOy8qKlxuICAgICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgQ1NTIHNvdXJjZS4gSXQgd2lsbCBiZSBjcmVhdGVkIGlmIGBmcm9tYCBvcHRpb25cbiAgICAgICAqIGlzIG5vdCBwcm92aWRlZCAoYmVjYXVzZSBQb3N0Q1NTIGRvZXMgbm90IGtub3cgdGhlIGZpbGUgcGF0aCkuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoY3NzKVxuICAgICAgICogcm9vdC5zb3VyY2UuaW5wdXQuZmlsZSAvLz0+IHVuZGVmaW5lZFxuICAgICAgICogcm9vdC5zb3VyY2UuaW5wdXQuaWQgICAvLz0+IFwiPGlucHV0IGNzcyAxPlwiXG4gICAgICAgKi90aGlzLmlkPSc8aW5wdXQgY3NzICcrc2VxdWVuY2UrJz4nO31pZih0aGlzLm1hcCl0aGlzLm1hcC5maWxlPXRoaXMuZnJvbTt9dmFyIF9wcm90bz1JbnB1dC5wcm90b3R5cGU7X3Byb3RvLmVycm9yPWZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsbGluZSxjb2x1bW4sb3B0cyl7aWYob3B0cz09PXZvaWQgMCl7b3B0cz17fTt9dmFyIHJlc3VsdDt2YXIgb3JpZ2luPXRoaXMub3JpZ2luKGxpbmUsY29sdW1uKTtpZihvcmlnaW4pe3Jlc3VsdD1uZXcgX2Nzc1N5bnRheEVycm9yW1wiZGVmYXVsdFwiXShtZXNzYWdlLG9yaWdpbi5saW5lLG9yaWdpbi5jb2x1bW4sb3JpZ2luLnNvdXJjZSxvcmlnaW4uZmlsZSxvcHRzLnBsdWdpbik7fWVsc2V7cmVzdWx0PW5ldyBfY3NzU3ludGF4RXJyb3JbXCJkZWZhdWx0XCJdKG1lc3NhZ2UsbGluZSxjb2x1bW4sdGhpcy5jc3MsdGhpcy5maWxlLG9wdHMucGx1Z2luKTt9cmVzdWx0LmlucHV0PXtsaW5lOmxpbmUsY29sdW1uOmNvbHVtbixzb3VyY2U6dGhpcy5jc3N9O2lmKHRoaXMuZmlsZSlyZXN1bHQuaW5wdXQuZmlsZT10aGlzLmZpbGU7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAqIFJlYWRzIHRoZSBpbnB1dCBzb3VyY2UgbWFwIGFuZCByZXR1cm5zIGEgc3ltYm9sIHBvc2l0aW9uXG4gICAqIGluIHRoZSBpbnB1dCBzb3VyY2UgKGUuZy4sIGluIGEgU2FzcyBmaWxlIHRoYXQgd2FzIGNvbXBpbGVkXG4gICAqIHRvIENTUyBiZWZvcmUgYmVpbmcgcGFzc2VkIHRvIFBvc3RDU1MpLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZSAgIExpbmUgaW4gaW5wdXQgQ1NTLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIENvbHVtbiBpbiBpbnB1dCBDU1MuXG4gICAqXG4gICAqIEByZXR1cm4ge2ZpbGVQb3NpdGlvbn0gUG9zaXRpb24gaW4gaW5wdXQgc291cmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByb290LnNvdXJjZS5pbnB1dC5vcmlnaW4oMSwgMSkgLy89PiB7IGZpbGU6ICdhLmNzcycsIGxpbmU6IDMsIGNvbHVtbjogMSB9XG4gICAqLztfcHJvdG8ub3JpZ2luPWZ1bmN0aW9uIG9yaWdpbihsaW5lLGNvbHVtbil7aWYoIXRoaXMubWFwKXJldHVybiBmYWxzZTt2YXIgY29uc3VtZXI9dGhpcy5tYXAuY29uc3VtZXIoKTt2YXIgZnJvbT1jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtsaW5lOmxpbmUsY29sdW1uOmNvbHVtbn0pO2lmKCFmcm9tLnNvdXJjZSlyZXR1cm4gZmFsc2U7dmFyIHJlc3VsdD17ZmlsZTp0aGlzLm1hcFJlc29sdmUoZnJvbS5zb3VyY2UpLGxpbmU6ZnJvbS5saW5lLGNvbHVtbjpmcm9tLmNvbHVtbn07dmFyIHNvdXJjZT1jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGZyb20uc291cmNlKTtpZihzb3VyY2UpcmVzdWx0LnNvdXJjZT1zb3VyY2U7cmV0dXJuIHJlc3VsdDt9O19wcm90by5tYXBSZXNvbHZlPWZ1bmN0aW9uIG1hcFJlc29sdmUoZmlsZSl7aWYoL15cXHcrOlxcL1xcLy8udGVzdChmaWxlKSl7cmV0dXJuIGZpbGU7fXJldHVybiBfcGF0aFtcImRlZmF1bHRcIl0ucmVzb2x2ZSh0aGlzLm1hcC5jb25zdW1lcigpLnNvdXJjZVJvb3R8fCcuJyxmaWxlKTt9LyoqXG4gICAqIFRoZSBDU1Mgc291cmNlIGlkZW50aWZpZXIuIENvbnRhaW5zIHtAbGluayBJbnB1dCNmaWxlfSBpZiB0aGUgdXNlclxuICAgKiBzZXQgdGhlIGBmcm9tYCBvcHRpb24sIG9yIHtAbGluayBJbnB1dCNpZH0gaWYgdGhleSBkaWQgbm90LlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZShjc3MsIHsgZnJvbTogJ2EuY3NzJyB9KVxuICAgKiByb290LnNvdXJjZS5pbnB1dC5mcm9tIC8vPT4gXCIvaG9tZS9haS9hLmNzc1wiXG4gICAqXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKGNzcylcbiAgICogcm9vdC5zb3VyY2UuaW5wdXQuZnJvbSAvLz0+IFwiPGlucHV0IGNzcyAxPlwiXG4gICAqLztfY3JlYXRlQ2xhc3MoSW5wdXQsW3trZXk6XCJmcm9tXCIsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLmZpbGV8fHRoaXMuaWQ7fX1dKTtyZXR1cm4gSW5wdXQ7fSgpO3ZhciBfZGVmYXVsdD1JbnB1dDsvKipcbiAqIEB0eXBlZGVmICB7b2JqZWN0fSBmaWxlUG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWxlICAgUGF0aCB0byBmaWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmUgICBTb3VyY2UgbGluZSBpbiBmaWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbHVtbiBTb3VyY2UgY29sdW1uIGluIGZpbGUuXG4gKi9leHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHtcIi4vY3NzLXN5bnRheC1lcnJvclwiOjE3MSxcIi4vcHJldmlvdXMtbWFwXCI6MTgxLFwicGF0aFwiOjE2N31dLDE3NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3Mpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX21hcEdlbmVyYXRvcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21hcC1nZW5lcmF0b3JcIikpO3ZhciBfc3RyaW5naWZ5Mj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeVwiKSk7dmFyIF93YXJuT25jZT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3dhcm4tb25jZVwiKSk7dmFyIF9yZXN1bHQ9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZXN1bHRcIikpO3ZhciBfcGFyc2U9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZVwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fGZhbHNlO2Rlc2NyaXB0b3IuY29uZmlndXJhYmxlPXRydWU7aWYoXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvcilkZXNjcmlwdG9yLndyaXRhYmxlPXRydWU7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKTt9fWZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtpZihwcm90b1Byb3BzKV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKTtpZihzdGF0aWNQcm9wcylfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO31mdW5jdGlvbiBpc1Byb21pc2Uob2JqKXtyZXR1cm4gX3R5cGVvZihvYmopPT09J29iamVjdCcmJnR5cGVvZiBvYmoudGhlbj09PSdmdW5jdGlvbic7fS8qKlxuICogQSBQcm9taXNlIHByb3h5IGZvciB0aGUgcmVzdWx0IG9mIFBvc3RDU1MgdHJhbnNmb3JtYXRpb25zLlxuICpcbiAqIEEgYExhenlSZXN1bHRgIGluc3RhbmNlIGlzIHJldHVybmVkIGJ5IHtAbGluayBQcm9jZXNzb3IjcHJvY2Vzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGxhenkgPSBwb3N0Y3NzKFthdXRvcHJlZml4ZXJdKS5wcm9jZXNzKGNzcylcbiAqL3ZhciBMYXp5UmVzdWx0PS8qI19fUFVSRV9fKi9mdW5jdGlvbigpe2Z1bmN0aW9uIExhenlSZXN1bHQocHJvY2Vzc29yLGNzcyxvcHRzKXt0aGlzLnN0cmluZ2lmaWVkPWZhbHNlO3RoaXMucHJvY2Vzc2VkPWZhbHNlO3ZhciByb290O2lmKF90eXBlb2YoY3NzKT09PSdvYmplY3QnJiZjc3MhPT1udWxsJiZjc3MudHlwZT09PSdyb290Jyl7cm9vdD1jc3M7fWVsc2UgaWYoY3NzIGluc3RhbmNlb2YgTGF6eVJlc3VsdHx8Y3NzIGluc3RhbmNlb2YgX3Jlc3VsdFtcImRlZmF1bHRcIl0pe3Jvb3Q9Y3NzLnJvb3Q7aWYoY3NzLm1hcCl7aWYodHlwZW9mIG9wdHMubWFwPT09J3VuZGVmaW5lZCcpb3B0cy5tYXA9e307aWYoIW9wdHMubWFwLmlubGluZSlvcHRzLm1hcC5pbmxpbmU9ZmFsc2U7b3B0cy5tYXAucHJldj1jc3MubWFwO319ZWxzZXt2YXIgcGFyc2VyPV9wYXJzZVtcImRlZmF1bHRcIl07aWYob3B0cy5zeW50YXgpcGFyc2VyPW9wdHMuc3ludGF4LnBhcnNlO2lmKG9wdHMucGFyc2VyKXBhcnNlcj1vcHRzLnBhcnNlcjtpZihwYXJzZXIucGFyc2UpcGFyc2VyPXBhcnNlci5wYXJzZTt0cnl7cm9vdD1wYXJzZXIoY3NzLG9wdHMpO31jYXRjaChlcnJvcil7dGhpcy5lcnJvcj1lcnJvcjt9fXRoaXMucmVzdWx0PW5ldyBfcmVzdWx0W1wiZGVmYXVsdFwiXShwcm9jZXNzb3Iscm9vdCxvcHRzKTt9LyoqXG4gICAqIFJldHVybnMgYSB7QGxpbmsgUHJvY2Vzc29yfSBpbnN0YW5jZSwgd2hpY2ggd2lsbCBiZSB1c2VkXG4gICAqIGZvciBDU1MgdHJhbnNmb3JtYXRpb25zLlxuICAgKlxuICAgKiBAdHlwZSB7UHJvY2Vzc29yfVxuICAgKi92YXIgX3Byb3RvPUxhenlSZXN1bHQucHJvdG90eXBlOy8qKlxuICAgKiBQcm9jZXNzZXMgaW5wdXQgQ1NTIHRocm91Z2ggc3luY2hyb25vdXMgcGx1Z2luc1xuICAgKiBhbmQgY2FsbHMge0BsaW5rIFJlc3VsdCN3YXJuaW5ncygpfS5cbiAgICpcbiAgICogQHJldHVybiB7V2FybmluZ1tdfSBXYXJuaW5ncyBmcm9tIHBsdWdpbnMuXG4gICAqL19wcm90by53YXJuaW5ncz1mdW5jdGlvbiB3YXJuaW5ncygpe3JldHVybiB0aGlzLnN5bmMoKS53YXJuaW5ncygpO30vKipcbiAgICogQWxpYXMgZm9yIHRoZSB7QGxpbmsgTGF6eVJlc3VsdCNjc3N9IHByb3BlcnR5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsYXp5ICsgJycgPT09IGxhenkuY3NzXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gT3V0cHV0IENTUy5cbiAgICovO19wcm90by50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3JldHVybiB0aGlzLmNzczt9LyoqXG4gICAqIFByb2Nlc3NlcyBpbnB1dCBDU1MgdGhyb3VnaCBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICogYW5kIGNhbGxzIGBvbkZ1bGZpbGxlZGAgd2l0aCBhIFJlc3VsdCBpbnN0YW5jZS4gSWYgYSBwbHVnaW4gdGhyb3dzXG4gICAqIGFuIGVycm9yLCB0aGUgYG9uUmVqZWN0ZWRgIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAqXG4gICAqIEl0IGltcGxlbWVudHMgc3RhbmRhcmQgUHJvbWlzZSBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSB7b25GdWxmaWxsZWR9IG9uRnVsZmlsbGVkIENhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiBhbGwgcGx1Z2lucyB3aWxsIGZpbmlzaCB3b3JrLlxuICAgKiBAcGFyYW0ge29uUmVqZWN0ZWR9ICBvblJlamVjdGVkICBDYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9uIGFueSBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSBBUEkgdG8gbWFrZSBxdWV1ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcyhbYXV0b3ByZWZpeGVyXSkucHJvY2Vzcyhjc3MsIHsgZnJvbTogY3NzUGF0aCB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAqICAgY29uc29sZS5sb2cocmVzdWx0LmNzcylcbiAgICogfSlcbiAgICovO19wcm90by50aGVuPWZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsb25SZWplY3RlZCl7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpe2lmKCEoJ2Zyb20naW4gdGhpcy5vcHRzKSl7KDAsX3dhcm5PbmNlW1wiZGVmYXVsdFwiXSkoJ1dpdGhvdXQgYGZyb21gIG9wdGlvbiBQb3N0Q1NTIGNvdWxkIGdlbmVyYXRlIHdyb25nIHNvdXJjZSBtYXAgJysnYW5kIHdpbGwgbm90IGZpbmQgQnJvd3NlcnNsaXN0IGNvbmZpZy4gU2V0IGl0IHRvIENTUyBmaWxlIHBhdGggJysnb3IgdG8gYHVuZGVmaW5lZGAgdG8gcHJldmVudCB0aGlzIHdhcm5pbmcuJyk7fX1yZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsb25SZWplY3RlZCk7fS8qKlxuICAgKiBQcm9jZXNzZXMgaW5wdXQgQ1NTIHRocm91Z2ggc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91cyBwbHVnaW5zXG4gICAqIGFuZCBjYWxscyBvblJlamVjdGVkIGZvciBlYWNoIGVycm9yIHRocm93biBpbiBhbnkgcGx1Z2luLlxuICAgKlxuICAgKiBJdCBpbXBsZW1lbnRzIHN0YW5kYXJkIFByb21pc2UgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0ge29uUmVqZWN0ZWR9IG9uUmVqZWN0ZWQgQ2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbiBhbnkgZXJyb3IuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgQVBJIHRvIG1ha2UgcXVldWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHBvc3Rjc3MoW2F1dG9wcmVmaXhlcl0pLnByb2Nlc3MoY3NzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAqICAgY29uc29sZS5sb2cocmVzdWx0LmNzcylcbiAgICogfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgKiAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAqIH0pXG4gICAqLztfcHJvdG9bXCJjYXRjaFwiXT1mdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCl7cmV0dXJuIHRoaXMuYXN5bmMoKVtcImNhdGNoXCJdKG9uUmVqZWN0ZWQpO30vKipcbiAgICogUHJvY2Vzc2VzIGlucHV0IENTUyB0aHJvdWdoIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgcGx1Z2luc1xuICAgKiBhbmQgY2FsbHMgb25GaW5hbGx5IG9uIGFueSBlcnJvciBvciB3aGVuIGFsbCBwbHVnaW5zIHdpbGwgZmluaXNoIHdvcmsuXG4gICAqXG4gICAqIEl0IGltcGxlbWVudHMgc3RhbmRhcmQgUHJvbWlzZSBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSB7b25GaW5hbGx5fSBvbkZpbmFsbHkgQ2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbiBhbnkgZXJyb3Igb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIGFsbCBwbHVnaW5zIHdpbGwgZmluaXNoIHdvcmsuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgQVBJIHRvIG1ha2UgcXVldWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHBvc3Rjc3MoW2F1dG9wcmVmaXhlcl0pLnByb2Nlc3MoY3NzKS5maW5hbGx5KCgpID0+IHtcbiAgICogICBjb25zb2xlLmxvZygncHJvY2Vzc2luZyBlbmRlZCcpXG4gICAqIH0pXG4gICAqLztfcHJvdG9bXCJmaW5hbGx5XCJdPWZ1bmN0aW9uIF9maW5hbGx5KG9uRmluYWxseSl7cmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSxvbkZpbmFsbHkpO307X3Byb3RvLmhhbmRsZUVycm9yPWZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLHBsdWdpbil7dHJ5e3RoaXMuZXJyb3I9ZXJyb3I7aWYoZXJyb3IubmFtZT09PSdDc3NTeW50YXhFcnJvcicmJiFlcnJvci5wbHVnaW4pe2Vycm9yLnBsdWdpbj1wbHVnaW4ucG9zdGNzc1BsdWdpbjtlcnJvci5zZXRNZXNzYWdlKCk7fWVsc2UgaWYocGx1Z2luLnBvc3Rjc3NWZXJzaW9uKXtpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7dmFyIHBsdWdpbk5hbWU9cGx1Z2luLnBvc3Rjc3NQbHVnaW47dmFyIHBsdWdpblZlcj1wbHVnaW4ucG9zdGNzc1ZlcnNpb247dmFyIHJ1bnRpbWVWZXI9dGhpcy5yZXN1bHQucHJvY2Vzc29yLnZlcnNpb247dmFyIGE9cGx1Z2luVmVyLnNwbGl0KCcuJyk7dmFyIGI9cnVudGltZVZlci5zcGxpdCgnLicpO2lmKGFbMF0hPT1iWzBdfHxwYXJzZUludChhWzFdKT5wYXJzZUludChiWzFdKSl7Y29uc29sZS5lcnJvcignVW5rbm93biBlcnJvciBmcm9tIFBvc3RDU1MgcGx1Z2luLiBZb3VyIGN1cnJlbnQgUG9zdENTUyAnKyd2ZXJzaW9uIGlzICcrcnVudGltZVZlcisnLCBidXQgJytwbHVnaW5OYW1lKycgdXNlcyAnK3BsdWdpblZlcisnLiBQZXJoYXBzIHRoaXMgaXMgdGhlIHNvdXJjZSBvZiB0aGUgZXJyb3IgYmVsb3cuJyk7fX19fWNhdGNoKGVycil7aWYoY29uc29sZSYmY29uc29sZS5lcnJvciljb25zb2xlLmVycm9yKGVycik7fX07X3Byb3RvLmFzeW5jVGljaz1mdW5jdGlvbiBhc3luY1RpY2socmVzb2x2ZSxyZWplY3Qpe3ZhciBfdGhpcz10aGlzO2lmKHRoaXMucGx1Z2luPj10aGlzLnByb2Nlc3Nvci5wbHVnaW5zLmxlbmd0aCl7dGhpcy5wcm9jZXNzZWQ9dHJ1ZTtyZXR1cm4gcmVzb2x2ZSgpO310cnl7dmFyIHBsdWdpbj10aGlzLnByb2Nlc3Nvci5wbHVnaW5zW3RoaXMucGx1Z2luXTt2YXIgcHJvbWlzZT10aGlzLnJ1bihwbHVnaW4pO3RoaXMucGx1Z2luKz0xO2lmKGlzUHJvbWlzZShwcm9taXNlKSl7cHJvbWlzZS50aGVuKGZ1bmN0aW9uKCl7X3RoaXMuYXN5bmNUaWNrKHJlc29sdmUscmVqZWN0KTt9KVtcImNhdGNoXCJdKGZ1bmN0aW9uKGVycm9yKXtfdGhpcy5oYW5kbGVFcnJvcihlcnJvcixwbHVnaW4pO190aGlzLnByb2Nlc3NlZD10cnVlO3JlamVjdChlcnJvcik7fSk7fWVsc2V7dGhpcy5hc3luY1RpY2socmVzb2x2ZSxyZWplY3QpO319Y2F0Y2goZXJyb3Ipe3RoaXMucHJvY2Vzc2VkPXRydWU7cmVqZWN0KGVycm9yKTt9fTtfcHJvdG8uYXN5bmM9ZnVuY3Rpb24gYXN5bmMoKXt2YXIgX3RoaXMyPXRoaXM7aWYodGhpcy5wcm9jZXNzZWQpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7aWYoX3RoaXMyLmVycm9yKXtyZWplY3QoX3RoaXMyLmVycm9yKTt9ZWxzZXtyZXNvbHZlKF90aGlzMi5zdHJpbmdpZnkoKSk7fX0pO31pZih0aGlzLnByb2Nlc3Npbmcpe3JldHVybiB0aGlzLnByb2Nlc3Npbmc7fXRoaXMucHJvY2Vzc2luZz1uZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7aWYoX3RoaXMyLmVycm9yKXJldHVybiByZWplY3QoX3RoaXMyLmVycm9yKTtfdGhpczIucGx1Z2luPTA7X3RoaXMyLmFzeW5jVGljayhyZXNvbHZlLHJlamVjdCk7fSkudGhlbihmdW5jdGlvbigpe190aGlzMi5wcm9jZXNzZWQ9dHJ1ZTtyZXR1cm4gX3RoaXMyLnN0cmluZ2lmeSgpO30pO3JldHVybiB0aGlzLnByb2Nlc3Npbmc7fTtfcHJvdG8uc3luYz1mdW5jdGlvbiBzeW5jKCl7aWYodGhpcy5wcm9jZXNzZWQpcmV0dXJuIHRoaXMucmVzdWx0O3RoaXMucHJvY2Vzc2VkPXRydWU7aWYodGhpcy5wcm9jZXNzaW5nKXt0aHJvdyBuZXcgRXJyb3IoJ1VzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnMnKTt9aWYodGhpcy5lcnJvcil0aHJvdyB0aGlzLmVycm9yO2Zvcih2YXIgX2l0ZXJhdG9yPXRoaXMucmVzdWx0LnByb2Nlc3Nvci5wbHVnaW5zLF9pc0FycmF5PUFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSxfaT0wLF9pdGVyYXRvcj1faXNBcnJheT9faXRlcmF0b3I6X2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KXt2YXIgX3JlZjtpZihfaXNBcnJheSl7aWYoX2k+PV9pdGVyYXRvci5sZW5ndGgpYnJlYWs7X3JlZj1faXRlcmF0b3JbX2krK107fWVsc2V7X2k9X2l0ZXJhdG9yLm5leHQoKTtpZihfaS5kb25lKWJyZWFrO19yZWY9X2kudmFsdWU7fXZhciBwbHVnaW49X3JlZjt2YXIgcHJvbWlzZT10aGlzLnJ1bihwbHVnaW4pO2lmKGlzUHJvbWlzZShwcm9taXNlKSl7dGhyb3cgbmV3IEVycm9yKCdVc2UgcHJvY2Vzcyhjc3MpLnRoZW4oY2IpIHRvIHdvcmsgd2l0aCBhc3luYyBwbHVnaW5zJyk7fX1yZXR1cm4gdGhpcy5yZXN1bHQ7fTtfcHJvdG8ucnVuPWZ1bmN0aW9uIHJ1bihwbHVnaW4pe3RoaXMucmVzdWx0Lmxhc3RQbHVnaW49cGx1Z2luO3RyeXtyZXR1cm4gcGx1Z2luKHRoaXMucmVzdWx0LnJvb3QsdGhpcy5yZXN1bHQpO31jYXRjaChlcnJvcil7dGhpcy5oYW5kbGVFcnJvcihlcnJvcixwbHVnaW4pO3Rocm93IGVycm9yO319O19wcm90by5zdHJpbmdpZnk9ZnVuY3Rpb24gc3RyaW5naWZ5KCl7aWYodGhpcy5zdHJpbmdpZmllZClyZXR1cm4gdGhpcy5yZXN1bHQ7dGhpcy5zdHJpbmdpZmllZD10cnVlO3RoaXMuc3luYygpO3ZhciBvcHRzPXRoaXMucmVzdWx0Lm9wdHM7dmFyIHN0cj1fc3RyaW5naWZ5MltcImRlZmF1bHRcIl07aWYob3B0cy5zeW50YXgpc3RyPW9wdHMuc3ludGF4LnN0cmluZ2lmeTtpZihvcHRzLnN0cmluZ2lmaWVyKXN0cj1vcHRzLnN0cmluZ2lmaWVyO2lmKHN0ci5zdHJpbmdpZnkpc3RyPXN0ci5zdHJpbmdpZnk7dmFyIG1hcD1uZXcgX21hcEdlbmVyYXRvcltcImRlZmF1bHRcIl0oc3RyLHRoaXMucmVzdWx0LnJvb3QsdGhpcy5yZXN1bHQub3B0cyk7dmFyIGRhdGE9bWFwLmdlbmVyYXRlKCk7dGhpcy5yZXN1bHQuY3NzPWRhdGFbMF07dGhpcy5yZXN1bHQubWFwPWRhdGFbMV07cmV0dXJuIHRoaXMucmVzdWx0O307X2NyZWF0ZUNsYXNzKExhenlSZXN1bHQsW3trZXk6XCJwcm9jZXNzb3JcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMucmVzdWx0LnByb2Nlc3Nvcjt9LyoqXG4gICAgICogT3B0aW9ucyBmcm9tIHRoZSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9IGNhbGwuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7cHJvY2Vzc09wdGlvbnN9XG4gICAgICovfSx7a2V5Olwib3B0c1wiLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5yZXN1bHQub3B0czt9LyoqXG4gICAgICogUHJvY2Vzc2VzIGlucHV0IENTUyB0aHJvdWdoIHN5bmNocm9ub3VzIHBsdWdpbnMsIGNvbnZlcnRzIGBSb290YFxuICAgICAqIHRvIGEgQ1NTIHN0cmluZyBhbmQgcmV0dXJucyB7QGxpbmsgUmVzdWx0I2Nzc30uXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IHdpbGwgb25seSB3b3JrIHdpdGggc3luY2hyb25vdXMgcGx1Z2lucy5cbiAgICAgKiBJZiB0aGUgcHJvY2Vzc29yIGNvbnRhaW5zIGFueSBhc3luY2hyb25vdXMgcGx1Z2luc1xuICAgICAqIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgd2h5IHRoaXMgbWV0aG9kIGlzIG9ubHlcbiAgICAgKiBmb3IgZGVidWcgcHVycG9zZSwgeW91IHNob3VsZCBhbHdheXMgdXNlIHtAbGluayBMYXp5UmVzdWx0I3RoZW59LlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAc2VlIFJlc3VsdCNjc3NcbiAgICAgKi99LHtrZXk6XCJjc3NcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY3NzO30vKipcbiAgICAgKiBBbiBhbGlhcyBmb3IgdGhlIGBjc3NgIHByb3BlcnR5LiBVc2UgaXQgd2l0aCBzeW50YXhlc1xuICAgICAqIHRoYXQgZ2VuZXJhdGUgbm9uLUNTUyBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IHdpbGwgb25seSB3b3JrIHdpdGggc3luY2hyb25vdXMgcGx1Z2lucy5cbiAgICAgKiBJZiB0aGUgcHJvY2Vzc29yIGNvbnRhaW5zIGFueSBhc3luY2hyb25vdXMgcGx1Z2luc1xuICAgICAqIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgd2h5IHRoaXMgbWV0aG9kIGlzIG9ubHlcbiAgICAgKiBmb3IgZGVidWcgcHVycG9zZSwgeW91IHNob3VsZCBhbHdheXMgdXNlIHtAbGluayBMYXp5UmVzdWx0I3RoZW59LlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAc2VlIFJlc3VsdCNjb250ZW50XG4gICAgICovfSx7a2V5OlwiY29udGVudFwiLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jb250ZW50O30vKipcbiAgICAgKiBQcm9jZXNzZXMgaW5wdXQgQ1NTIHRocm91Z2ggc3luY2hyb25vdXMgcGx1Z2luc1xuICAgICAqIGFuZCByZXR1cm5zIHtAbGluayBSZXN1bHQjbWFwfS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgd2lsbCBvbmx5IHdvcmsgd2l0aCBzeW5jaHJvbm91cyBwbHVnaW5zLlxuICAgICAqIElmIHRoZSBwcm9jZXNzb3IgY29udGFpbnMgYW55IGFzeW5jaHJvbm91cyBwbHVnaW5zXG4gICAgICogaXQgd2lsbCB0aHJvdyBhbiBlcnJvci4gVGhpcyBpcyB3aHkgdGhpcyBtZXRob2QgaXMgb25seVxuICAgICAqIGZvciBkZWJ1ZyBwdXJwb3NlLCB5b3Ugc2hvdWxkIGFsd2F5cyB1c2Uge0BsaW5rIExhenlSZXN1bHQjdGhlbn0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U291cmNlTWFwR2VuZXJhdG9yfVxuICAgICAqIEBzZWUgUmVzdWx0I21hcFxuICAgICAqL30se2tleTpcIm1hcFwiLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5tYXA7fS8qKlxuICAgICAqIFByb2Nlc3NlcyBpbnB1dCBDU1MgdGhyb3VnaCBzeW5jaHJvbm91cyBwbHVnaW5zXG4gICAgICogYW5kIHJldHVybnMge0BsaW5rIFJlc3VsdCNyb290fS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgd2lsbCBvbmx5IHdvcmsgd2l0aCBzeW5jaHJvbm91cyBwbHVnaW5zLiBJZiB0aGUgcHJvY2Vzc29yXG4gICAgICogY29udGFpbnMgYW55IGFzeW5jaHJvbm91cyBwbHVnaW5zIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHdoeSB0aGlzIG1ldGhvZCBpcyBvbmx5IGZvciBkZWJ1ZyBwdXJwb3NlLFxuICAgICAqIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB7QGxpbmsgTGF6eVJlc3VsdCN0aGVufS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtSb290fVxuICAgICAqIEBzZWUgUmVzdWx0I3Jvb3RcbiAgICAgKi99LHtrZXk6XCJyb290XCIsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLnN5bmMoKS5yb290O30vKipcbiAgICAgKiBQcm9jZXNzZXMgaW5wdXQgQ1NTIHRocm91Z2ggc3luY2hyb25vdXMgcGx1Z2luc1xuICAgICAqIGFuZCByZXR1cm5zIHtAbGluayBSZXN1bHQjbWVzc2FnZXN9LlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSB3aWxsIG9ubHkgd29yayB3aXRoIHN5bmNocm9ub3VzIHBsdWdpbnMuIElmIHRoZSBwcm9jZXNzb3JcbiAgICAgKiBjb250YWlucyBhbnkgYXN5bmNocm9ub3VzIHBsdWdpbnMgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgd2h5IHRoaXMgbWV0aG9kIGlzIG9ubHkgZm9yIGRlYnVnIHB1cnBvc2UsXG4gICAgICogeW91IHNob3VsZCBhbHdheXMgdXNlIHtAbGluayBMYXp5UmVzdWx0I3RoZW59LlxuICAgICAqXG4gICAgICogQHR5cGUge01lc3NhZ2VbXX1cbiAgICAgKiBAc2VlIFJlc3VsdCNtZXNzYWdlc1xuICAgICAqL30se2tleTpcIm1lc3NhZ2VzXCIsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLnN5bmMoKS5tZXNzYWdlczt9fV0pO3JldHVybiBMYXp5UmVzdWx0O30oKTt2YXIgX2RlZmF1bHQ9TGF6eVJlc3VsdDsvKipcbiAqIEBjYWxsYmFjayBvbkZ1bGZpbGxlZFxuICogQHBhcmFtIHtSZXN1bHR9IHJlc3VsdFxuICovIC8qKlxuICogQGNhbGxiYWNrIG9uUmVqZWN0ZWRcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKi9leHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSk7fSx7XCIuL21hcC1nZW5lcmF0b3JcIjoxNzYsXCIuL3BhcnNlXCI6MTc4LFwiLi9yZXN1bHRcIjoxODMsXCIuL3N0cmluZ2lmeVwiOjE4NyxcIi4vd2Fybi1vbmNlXCI6MTkwLFwiX3Byb2Nlc3NcIjoxOTJ9XSwxNzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDsvKipcbiAqIENvbnRhaW5zIGhlbHBlcnMgZm9yIHNhZmVseSBzcGxpdHRpbmcgbGlzdHMgb2YgQ1NTIHZhbHVlcyxcbiAqIHByZXNlcnZpbmcgcGFyZW50aGVzZXMgYW5kIHF1b3Rlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbGlzdCA9IHBvc3Rjc3MubGlzdFxuICpcbiAqIEBuYW1lc3BhY2UgbGlzdFxuICovdmFyIGxpc3Q9e3NwbGl0OmZ1bmN0aW9uIHNwbGl0KHN0cmluZyxzZXBhcmF0b3JzLGxhc3Qpe3ZhciBhcnJheT1bXTt2YXIgY3VycmVudD0nJzt2YXIgc3BsaXQ9ZmFsc2U7dmFyIGZ1bmM9MDt2YXIgcXVvdGU9ZmFsc2U7dmFyIGVzY2FwZT1mYWxzZTtmb3IodmFyIGk9MDtpPHN0cmluZy5sZW5ndGg7aSsrKXt2YXIgbGV0dGVyPXN0cmluZ1tpXTtpZihxdW90ZSl7aWYoZXNjYXBlKXtlc2NhcGU9ZmFsc2U7fWVsc2UgaWYobGV0dGVyPT09J1xcXFwnKXtlc2NhcGU9dHJ1ZTt9ZWxzZSBpZihsZXR0ZXI9PT1xdW90ZSl7cXVvdGU9ZmFsc2U7fX1lbHNlIGlmKGxldHRlcj09PSdcIid8fGxldHRlcj09PSdcXCcnKXtxdW90ZT1sZXR0ZXI7fWVsc2UgaWYobGV0dGVyPT09JygnKXtmdW5jKz0xO31lbHNlIGlmKGxldHRlcj09PScpJyl7aWYoZnVuYz4wKWZ1bmMtPTE7fWVsc2UgaWYoZnVuYz09PTApe2lmKHNlcGFyYXRvcnMuaW5kZXhPZihsZXR0ZXIpIT09LTEpc3BsaXQ9dHJ1ZTt9aWYoc3BsaXQpe2lmKGN1cnJlbnQhPT0nJylhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtjdXJyZW50PScnO3NwbGl0PWZhbHNlO31lbHNle2N1cnJlbnQrPWxldHRlcjt9fWlmKGxhc3R8fGN1cnJlbnQhPT0nJylhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtyZXR1cm4gYXJyYXk7fSwvKipcbiAgICogU2FmZWx5IHNwbGl0cyBzcGFjZS1zZXBhcmF0ZWQgdmFsdWVzIChzdWNoIGFzIHRob3NlIGZvciBgYmFja2dyb3VuZGAsXG4gICAqIGBib3JkZXItcmFkaXVzYCwgYW5kIG90aGVyIHNob3J0aGFuZCBwcm9wZXJ0aWVzKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTcGFjZS1zZXBhcmF0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gU3BsaXQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwb3N0Y3NzLmxpc3Quc3BhY2UoJzFweCBjYWxjKDEwJSArIDFweCknKSAvLz0+IFsnMXB4JywgJ2NhbGMoMTAlICsgMXB4KSddXG4gICAqL3NwYWNlOmZ1bmN0aW9uIHNwYWNlKHN0cmluZyl7dmFyIHNwYWNlcz1bJyAnLCdcXG4nLCdcXHQnXTtyZXR1cm4gbGlzdC5zcGxpdChzdHJpbmcsc3BhY2VzKTt9LC8qKlxuICAgKiBTYWZlbHkgc3BsaXRzIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXMgKHN1Y2ggYXMgdGhvc2UgZm9yIGB0cmFuc2l0aW9uLSpgXG4gICAqIGFuZCBgYmFja2dyb3VuZGAgcHJvcGVydGllcykuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQ29tbWEtc2VwYXJhdGVkIHZhbHVlcy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nW119IFNwbGl0IHZhbHVlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcy5saXN0LmNvbW1hKCdibGFjaywgbGluZWFyLWdyYWRpZW50KHdoaXRlLCBibGFjayknKVxuICAgKiAvLz0+IFsnYmxhY2snLCAnbGluZWFyLWdyYWRpZW50KHdoaXRlLCBibGFjayknXVxuICAgKi9jb21tYTpmdW5jdGlvbiBjb21tYShzdHJpbmcpe3JldHVybiBsaXN0LnNwbGl0KHN0cmluZyxbJywnXSx0cnVlKTt9fTt2YXIgX2RlZmF1bHQ9bGlzdDtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHt9XSwxNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihCdWZmZXIpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX3NvdXJjZU1hcD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpKTt2YXIgX3BhdGg9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicGF0aFwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9dmFyIE1hcEdlbmVyYXRvcj0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXtmdW5jdGlvbiBNYXBHZW5lcmF0b3Ioc3RyaW5naWZ5LHJvb3Qsb3B0cyl7dGhpcy5zdHJpbmdpZnk9c3RyaW5naWZ5O3RoaXMubWFwT3B0cz1vcHRzLm1hcHx8e307dGhpcy5yb290PXJvb3Q7dGhpcy5vcHRzPW9wdHM7fXZhciBfcHJvdG89TWFwR2VuZXJhdG9yLnByb3RvdHlwZTtfcHJvdG8uaXNNYXA9ZnVuY3Rpb24gaXNNYXAoKXtpZih0eXBlb2YgdGhpcy5vcHRzLm1hcCE9PSd1bmRlZmluZWQnKXtyZXR1cm4hIXRoaXMub3B0cy5tYXA7fXJldHVybiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoPjA7fTtfcHJvdG8ucHJldmlvdXM9ZnVuY3Rpb24gcHJldmlvdXMoKXt2YXIgX3RoaXM9dGhpcztpZighdGhpcy5wcmV2aW91c01hcHMpe3RoaXMucHJldmlvdXNNYXBzPVtdO3RoaXMucm9vdC53YWxrKGZ1bmN0aW9uKG5vZGUpe2lmKG5vZGUuc291cmNlJiZub2RlLnNvdXJjZS5pbnB1dC5tYXApe3ZhciBtYXA9bm9kZS5zb3VyY2UuaW5wdXQubWFwO2lmKF90aGlzLnByZXZpb3VzTWFwcy5pbmRleE9mKG1hcCk9PT0tMSl7X3RoaXMucHJldmlvdXNNYXBzLnB1c2gobWFwKTt9fX0pO31yZXR1cm4gdGhpcy5wcmV2aW91c01hcHM7fTtfcHJvdG8uaXNJbmxpbmU9ZnVuY3Rpb24gaXNJbmxpbmUoKXtpZih0eXBlb2YgdGhpcy5tYXBPcHRzLmlubGluZSE9PSd1bmRlZmluZWQnKXtyZXR1cm4gdGhpcy5tYXBPcHRzLmlubGluZTt9dmFyIGFubm90YXRpb249dGhpcy5tYXBPcHRzLmFubm90YXRpb247aWYodHlwZW9mIGFubm90YXRpb24hPT0ndW5kZWZpbmVkJyYmYW5ub3RhdGlvbiE9PXRydWUpe3JldHVybiBmYWxzZTt9aWYodGhpcy5wcmV2aW91cygpLmxlbmd0aCl7cmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGZ1bmN0aW9uKGkpe3JldHVybiBpLmlubGluZTt9KTt9cmV0dXJuIHRydWU7fTtfcHJvdG8uaXNTb3VyY2VzQ29udGVudD1mdW5jdGlvbiBpc1NvdXJjZXNDb250ZW50KCl7aWYodHlwZW9mIHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCE9PSd1bmRlZmluZWQnKXtyZXR1cm4gdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50O31pZih0aGlzLnByZXZpb3VzKCkubGVuZ3RoKXtyZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaSl7cmV0dXJuIGkud2l0aENvbnRlbnQoKTt9KTt9cmV0dXJuIHRydWU7fTtfcHJvdG8uY2xlYXJBbm5vdGF0aW9uPWZ1bmN0aW9uIGNsZWFyQW5ub3RhdGlvbigpe2lmKHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uPT09ZmFsc2UpcmV0dXJuO3ZhciBub2RlO2Zvcih2YXIgaT10aGlzLnJvb3Qubm9kZXMubGVuZ3RoLTE7aT49MDtpLS0pe25vZGU9dGhpcy5yb290Lm5vZGVzW2ldO2lmKG5vZGUudHlwZSE9PSdjb21tZW50Jyljb250aW51ZTtpZihub2RlLnRleHQuaW5kZXhPZignIyBzb3VyY2VNYXBwaW5nVVJMPScpPT09MCl7dGhpcy5yb290LnJlbW92ZUNoaWxkKGkpO319fTtfcHJvdG8uc2V0U291cmNlc0NvbnRlbnQ9ZnVuY3Rpb24gc2V0U291cmNlc0NvbnRlbnQoKXt2YXIgX3RoaXMyPXRoaXM7dmFyIGFscmVhZHk9e307dGhpcy5yb290LndhbGsoZnVuY3Rpb24obm9kZSl7aWYobm9kZS5zb3VyY2Upe3ZhciBmcm9tPW5vZGUuc291cmNlLmlucHV0LmZyb207aWYoZnJvbSYmIWFscmVhZHlbZnJvbV0pe2FscmVhZHlbZnJvbV09dHJ1ZTt2YXIgcmVsYXRpdmU9X3RoaXMyLnJlbGF0aXZlKGZyb20pO190aGlzMi5tYXAuc2V0U291cmNlQ29udGVudChyZWxhdGl2ZSxub2RlLnNvdXJjZS5pbnB1dC5jc3MpO319fSk7fTtfcHJvdG8uYXBwbHlQcmV2TWFwcz1mdW5jdGlvbiBhcHBseVByZXZNYXBzKCl7Zm9yKHZhciBfaXRlcmF0b3I9dGhpcy5wcmV2aW91cygpLF9pc0FycmF5PUFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSxfaT0wLF9pdGVyYXRvcj1faXNBcnJheT9faXRlcmF0b3I6X2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KXt2YXIgX3JlZjtpZihfaXNBcnJheSl7aWYoX2k+PV9pdGVyYXRvci5sZW5ndGgpYnJlYWs7X3JlZj1faXRlcmF0b3JbX2krK107fWVsc2V7X2k9X2l0ZXJhdG9yLm5leHQoKTtpZihfaS5kb25lKWJyZWFrO19yZWY9X2kudmFsdWU7fXZhciBwcmV2PV9yZWY7dmFyIGZyb209dGhpcy5yZWxhdGl2ZShwcmV2LmZpbGUpO3ZhciByb290PXByZXYucm9vdHx8X3BhdGhbXCJkZWZhdWx0XCJdLmRpcm5hbWUocHJldi5maWxlKTt2YXIgbWFwPXZvaWQgMDtpZih0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQ9PT1mYWxzZSl7bWFwPW5ldyBfc291cmNlTWFwW1wiZGVmYXVsdFwiXS5Tb3VyY2VNYXBDb25zdW1lcihwcmV2LnRleHQpO2lmKG1hcC5zb3VyY2VzQ29udGVudCl7bWFwLnNvdXJjZXNDb250ZW50PW1hcC5zb3VyY2VzQ29udGVudC5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gbnVsbDt9KTt9fWVsc2V7bWFwPXByZXYuY29uc3VtZXIoKTt9dGhpcy5tYXAuYXBwbHlTb3VyY2VNYXAobWFwLGZyb20sdGhpcy5yZWxhdGl2ZShyb290KSk7fX07X3Byb3RvLmlzQW5ub3RhdGlvbj1mdW5jdGlvbiBpc0Fubm90YXRpb24oKXtpZih0aGlzLmlzSW5saW5lKCkpe3JldHVybiB0cnVlO31pZih0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24hPT0ndW5kZWZpbmVkJyl7cmV0dXJuIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO31pZih0aGlzLnByZXZpb3VzKCkubGVuZ3RoKXtyZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaSl7cmV0dXJuIGkuYW5ub3RhdGlvbjt9KTt9cmV0dXJuIHRydWU7fTtfcHJvdG8udG9CYXNlNjQ9ZnVuY3Rpb24gdG9CYXNlNjQoc3RyKXtpZihCdWZmZXIpe3JldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKCdiYXNlNjQnKTt9cmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7fTtfcHJvdG8uYWRkQW5ub3RhdGlvbj1mdW5jdGlvbiBhZGRBbm5vdGF0aW9uKCl7dmFyIGNvbnRlbnQ7aWYodGhpcy5pc0lubGluZSgpKXtjb250ZW50PSdkYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcrdGhpcy50b0Jhc2U2NCh0aGlzLm1hcC50b1N0cmluZygpKTt9ZWxzZSBpZih0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb249PT0nc3RyaW5nJyl7Y29udGVudD10aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjt9ZWxzZXtjb250ZW50PXRoaXMub3V0cHV0RmlsZSgpKycubWFwJzt9dmFyIGVvbD0nXFxuJztpZih0aGlzLmNzcy5pbmRleE9mKCdcXHJcXG4nKSE9PS0xKWVvbD0nXFxyXFxuJzt0aGlzLmNzcys9ZW9sKycvKiMgc291cmNlTWFwcGluZ1VSTD0nK2NvbnRlbnQrJyAqLyc7fTtfcHJvdG8ub3V0cHV0RmlsZT1mdW5jdGlvbiBvdXRwdXRGaWxlKCl7aWYodGhpcy5vcHRzLnRvKXtyZXR1cm4gdGhpcy5yZWxhdGl2ZSh0aGlzLm9wdHMudG8pO31pZih0aGlzLm9wdHMuZnJvbSl7cmV0dXJuIHRoaXMucmVsYXRpdmUodGhpcy5vcHRzLmZyb20pO31yZXR1cm4ndG8uY3NzJzt9O19wcm90by5nZW5lcmF0ZU1hcD1mdW5jdGlvbiBnZW5lcmF0ZU1hcCgpe3RoaXMuZ2VuZXJhdGVTdHJpbmcoKTtpZih0aGlzLmlzU291cmNlc0NvbnRlbnQoKSl0aGlzLnNldFNvdXJjZXNDb250ZW50KCk7aWYodGhpcy5wcmV2aW91cygpLmxlbmd0aD4wKXRoaXMuYXBwbHlQcmV2TWFwcygpO2lmKHRoaXMuaXNBbm5vdGF0aW9uKCkpdGhpcy5hZGRBbm5vdGF0aW9uKCk7aWYodGhpcy5pc0lubGluZSgpKXtyZXR1cm5bdGhpcy5jc3NdO31yZXR1cm5bdGhpcy5jc3MsdGhpcy5tYXBdO307X3Byb3RvLnJlbGF0aXZlPWZ1bmN0aW9uIHJlbGF0aXZlKGZpbGUpe2lmKGZpbGUuaW5kZXhPZignPCcpPT09MClyZXR1cm4gZmlsZTtpZigvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKXJldHVybiBmaWxlO3ZhciBmcm9tPXRoaXMub3B0cy50bz9fcGF0aFtcImRlZmF1bHRcIl0uZGlybmFtZSh0aGlzLm9wdHMudG8pOicuJztpZih0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb249PT0nc3RyaW5nJyl7ZnJvbT1fcGF0aFtcImRlZmF1bHRcIl0uZGlybmFtZShfcGF0aFtcImRlZmF1bHRcIl0ucmVzb2x2ZShmcm9tLHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKSk7fWZpbGU9X3BhdGhbXCJkZWZhdWx0XCJdLnJlbGF0aXZlKGZyb20sZmlsZSk7aWYoX3BhdGhbXCJkZWZhdWx0XCJdLnNlcD09PSdcXFxcJyl7cmV0dXJuIGZpbGUucmVwbGFjZSgvXFxcXC9nLCcvJyk7fXJldHVybiBmaWxlO307X3Byb3RvLnNvdXJjZVBhdGg9ZnVuY3Rpb24gc291cmNlUGF0aChub2RlKXtpZih0aGlzLm1hcE9wdHMuZnJvbSl7cmV0dXJuIHRoaXMubWFwT3B0cy5mcm9tO31yZXR1cm4gdGhpcy5yZWxhdGl2ZShub2RlLnNvdXJjZS5pbnB1dC5mcm9tKTt9O19wcm90by5nZW5lcmF0ZVN0cmluZz1mdW5jdGlvbiBnZW5lcmF0ZVN0cmluZygpe3ZhciBfdGhpczM9dGhpczt0aGlzLmNzcz0nJzt0aGlzLm1hcD1uZXcgX3NvdXJjZU1hcFtcImRlZmF1bHRcIl0uU291cmNlTWFwR2VuZXJhdG9yKHtmaWxlOnRoaXMub3V0cHV0RmlsZSgpfSk7dmFyIGxpbmU9MTt2YXIgY29sdW1uPTE7dmFyIGxpbmVzLGxhc3Q7dGhpcy5zdHJpbmdpZnkodGhpcy5yb290LGZ1bmN0aW9uKHN0cixub2RlLHR5cGUpe190aGlzMy5jc3MrPXN0cjtpZihub2RlJiZ0eXBlIT09J2VuZCcpe2lmKG5vZGUuc291cmNlJiZub2RlLnNvdXJjZS5zdGFydCl7X3RoaXMzLm1hcC5hZGRNYXBwaW5nKHtzb3VyY2U6X3RoaXMzLnNvdXJjZVBhdGgobm9kZSksZ2VuZXJhdGVkOntsaW5lOmxpbmUsY29sdW1uOmNvbHVtbi0xfSxvcmlnaW5hbDp7bGluZTpub2RlLnNvdXJjZS5zdGFydC5saW5lLGNvbHVtbjpub2RlLnNvdXJjZS5zdGFydC5jb2x1bW4tMX19KTt9ZWxzZXtfdGhpczMubWFwLmFkZE1hcHBpbmcoe3NvdXJjZTonPG5vIHNvdXJjZT4nLG9yaWdpbmFsOntsaW5lOjEsY29sdW1uOjB9LGdlbmVyYXRlZDp7bGluZTpsaW5lLGNvbHVtbjpjb2x1bW4tMX19KTt9fWxpbmVzPXN0ci5tYXRjaCgvXFxuL2cpO2lmKGxpbmVzKXtsaW5lKz1saW5lcy5sZW5ndGg7bGFzdD1zdHIubGFzdEluZGV4T2YoJ1xcbicpO2NvbHVtbj1zdHIubGVuZ3RoLWxhc3Q7fWVsc2V7Y29sdW1uKz1zdHIubGVuZ3RoO31pZihub2RlJiZ0eXBlIT09J3N0YXJ0Jyl7dmFyIHA9bm9kZS5wYXJlbnR8fHtyYXdzOnt9fTtpZihub2RlLnR5cGUhPT0nZGVjbCd8fG5vZGUhPT1wLmxhc3R8fHAucmF3cy5zZW1pY29sb24pe2lmKG5vZGUuc291cmNlJiZub2RlLnNvdXJjZS5lbmQpe190aGlzMy5tYXAuYWRkTWFwcGluZyh7c291cmNlOl90aGlzMy5zb3VyY2VQYXRoKG5vZGUpLGdlbmVyYXRlZDp7bGluZTpsaW5lLGNvbHVtbjpjb2x1bW4tMn0sb3JpZ2luYWw6e2xpbmU6bm9kZS5zb3VyY2UuZW5kLmxpbmUsY29sdW1uOm5vZGUuc291cmNlLmVuZC5jb2x1bW4tMX19KTt9ZWxzZXtfdGhpczMubWFwLmFkZE1hcHBpbmcoe3NvdXJjZTonPG5vIHNvdXJjZT4nLG9yaWdpbmFsOntsaW5lOjEsY29sdW1uOjB9LGdlbmVyYXRlZDp7bGluZTpsaW5lLGNvbHVtbjpjb2x1bW4tMX19KTt9fX19KTt9O19wcm90by5nZW5lcmF0ZT1mdW5jdGlvbiBnZW5lcmF0ZSgpe3RoaXMuY2xlYXJBbm5vdGF0aW9uKCk7aWYodGhpcy5pc01hcCgpKXtyZXR1cm4gdGhpcy5nZW5lcmF0ZU1hcCgpO312YXIgcmVzdWx0PScnO3RoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCxmdW5jdGlvbihpKXtyZXN1bHQrPWk7fSk7cmV0dXJuW3Jlc3VsdF07fTtyZXR1cm4gTWFwR2VuZXJhdG9yO30oKTt2YXIgX2RlZmF1bHQ9TWFwR2VuZXJhdG9yO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcik7fSx7XCJidWZmZXJcIjozLFwicGF0aFwiOjE2NyxcInNvdXJjZS1tYXBcIjoyMDd9XSwxNzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihwcm9jZXNzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9jc3NTeW50YXhFcnJvcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nzcy1zeW50YXgtZXJyb3JcIikpO3ZhciBfc3RyaW5naWZpZXI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpbmdpZmllclwiKSk7dmFyIF9zdHJpbmdpZnk9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpbmdpZnlcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian07fWZ1bmN0aW9uIGNsb25lTm9kZShvYmoscGFyZW50KXt2YXIgY2xvbmVkPW5ldyBvYmouY29uc3RydWN0b3IoKTtmb3IodmFyIGkgaW4gb2JqKXtpZighb2JqLmhhc093blByb3BlcnR5KGkpKWNvbnRpbnVlO3ZhciB2YWx1ZT1vYmpbaV07dmFyIHR5cGU9X3R5cGVvZih2YWx1ZSk7aWYoaT09PSdwYXJlbnQnJiZ0eXBlPT09J29iamVjdCcpe2lmKHBhcmVudCljbG9uZWRbaV09cGFyZW50O31lbHNlIGlmKGk9PT0nc291cmNlJyl7Y2xvbmVkW2ldPXZhbHVlO31lbHNlIGlmKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpe2Nsb25lZFtpXT12YWx1ZS5tYXAoZnVuY3Rpb24oail7cmV0dXJuIGNsb25lTm9kZShqLGNsb25lZCk7fSk7fWVsc2V7aWYodHlwZT09PSdvYmplY3QnJiZ2YWx1ZSE9PW51bGwpdmFsdWU9Y2xvbmVOb2RlKHZhbHVlKTtjbG9uZWRbaV09dmFsdWU7fX1yZXR1cm4gY2xvbmVkO30vKipcbiAqIEFsbCBub2RlIGNsYXNzZXMgaW5oZXJpdCB0aGUgZm9sbG93aW5nIGNvbW1vbiBtZXRob2RzLlxuICpcbiAqIEBhYnN0cmFjdFxuICovdmFyIE5vZGU9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7LyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZGVmYXVsdHNdIFZhbHVlIGZvciBub2RlIHByb3BlcnRpZXMuXG4gICAqL2Z1bmN0aW9uIE5vZGUoZGVmYXVsdHMpe2lmKGRlZmF1bHRzPT09dm9pZCAwKXtkZWZhdWx0cz17fTt9dGhpcy5yYXdzPXt9O2lmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09J3Byb2R1Y3Rpb24nKXtpZihfdHlwZW9mKGRlZmF1bHRzKSE9PSdvYmplY3QnJiZ0eXBlb2YgZGVmYXVsdHMhPT0ndW5kZWZpbmVkJyl7dGhyb3cgbmV3IEVycm9yKCdQb3N0Q1NTIG5vZGVzIGNvbnN0cnVjdG9yIGFjY2VwdHMgb2JqZWN0LCBub3QgJytKU09OLnN0cmluZ2lmeShkZWZhdWx0cykpO319Zm9yKHZhciBuYW1lIGluIGRlZmF1bHRzKXt0aGlzW25hbWVdPWRlZmF1bHRzW25hbWVdO319LyoqXG4gICAqIFJldHVybnMgYSBgQ3NzU3ludGF4RXJyb3JgIGluc3RhbmNlIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAqIG9mIHRoZSBub2RlIGluIHRoZSBzb3VyY2UsIHNob3dpbmcgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgYW5kIGFsc29cbiAgICogYSBzbWFsbCBleGNlcnB0IHRvIGZhY2lsaXRhdGUgZGVidWdnaW5nLlxuICAgKlxuICAgKiBJZiBwcmVzZW50LCBhbiBpbnB1dCBzb3VyY2UgbWFwIHdpbGwgYmUgdXNlZCB0byBnZXQgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAqIG9mIHRoZSBzb3VyY2UsIGV2ZW4gZnJvbSBhIHByZXZpb3VzIGNvbXBpbGF0aW9uIHN0ZXBcbiAgICogKGUuZy4sIGZyb20gU2FzcyBjb21waWxhdGlvbikuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHByb2R1Y2VzIHZlcnkgdXNlZnVsIGVycm9yIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAgICAgRXJyb3IgZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gICAgICBPcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5wbHVnaW4gUGx1Z2luIG5hbWUgdGhhdCBjcmVhdGVkIHRoaXMgZXJyb3IuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3N0Q1NTIHdpbGwgc2V0IGl0IGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndvcmQgICBBIHdvcmQgaW5zaWRlIGEgbm9kZeKAmXMgc3RyaW5nIHRoYXQgc2hvdWxkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBoaWdobGlnaHRlZCBhcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuaW5kZXggIEFuIGluZGV4IGluc2lkZSBhIG5vZGXigJlzIHN0cmluZyB0aGF0IHNob3VsZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgaGlnaGxpZ2h0ZWQgYXMgdGhlIHNvdXJjZSBvZiB0aGUgZXJyb3IuXG4gICAqXG4gICAqIEByZXR1cm4ge0Nzc1N5bnRheEVycm9yfSBFcnJvciBvYmplY3QgdG8gdGhyb3cgaXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGlmICghdmFyaWFibGVzW25hbWVdKSB7XG4gICAqICAgdGhyb3cgZGVjbC5lcnJvcignVW5rbm93biB2YXJpYWJsZSAnICsgbmFtZSwgeyB3b3JkOiBuYW1lIH0pXG4gICAqICAgLy8gQ3NzU3ludGF4RXJyb3I6IHBvc3Rjc3MtdmFyczphLnNhc3M6NDozOiBVbmtub3duIHZhcmlhYmxlICRibGFja1xuICAgKiAgIC8vICAgY29sb3I6ICRibGFja1xuICAgKiAgIC8vIGFcbiAgICogICAvLyAgICAgICAgICBeXG4gICAqICAgLy8gICBiYWNrZ3JvdW5kOiB3aGl0ZVxuICAgKiB9XG4gICAqL3ZhciBfcHJvdG89Tm9kZS5wcm90b3R5cGU7X3Byb3RvLmVycm9yPWZ1bmN0aW9uIGVycm9yKG1lc3NhZ2Usb3B0cyl7aWYob3B0cz09PXZvaWQgMCl7b3B0cz17fTt9aWYodGhpcy5zb3VyY2Upe3ZhciBwb3M9dGhpcy5wb3NpdGlvbkJ5KG9wdHMpO3JldHVybiB0aGlzLnNvdXJjZS5pbnB1dC5lcnJvcihtZXNzYWdlLHBvcy5saW5lLHBvcy5jb2x1bW4sb3B0cyk7fXJldHVybiBuZXcgX2Nzc1N5bnRheEVycm9yW1wiZGVmYXVsdFwiXShtZXNzYWdlKTt9LyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGEgY29udmVuaWVuY2Ugd3JhcHBlciBmb3Ige0BsaW5rIFJlc3VsdCN3YXJufS5cbiAgICpcbiAgICogQHBhcmFtIHtSZXN1bHR9IHJlc3VsdCAgICAgIFRoZSB7QGxpbmsgUmVzdWx0fSBpbnN0YW5jZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIHdhcm5pbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICAgICAgICBXYXJuaW5nIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gICAgICBPcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnBsdWdpbiBQbHVnaW4gbmFtZSB0aGF0IGNyZWF0ZWQgdGhpcyB3YXJuaW5nLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zdENTUyB3aWxsIHNldCBpdCBhdXRvbWF0aWNhbGx5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53b3JkICAgQSB3b3JkIGluc2lkZSBhIG5vZGXigJlzIHN0cmluZyB0aGF0IHNob3VsZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgaGlnaGxpZ2h0ZWQgYXMgdGhlIHNvdXJjZSBvZiB0aGUgd2FybmluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuaW5kZXggIEFuIGluZGV4IGluc2lkZSBhIG5vZGXigJlzIHN0cmluZyB0aGF0IHNob3VsZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgaGlnaGxpZ2h0ZWQgYXMgdGhlIHNvdXJjZSBvZiB0aGUgd2FybmluZy5cbiAgICpcbiAgICogQHJldHVybiB7V2FybmluZ30gQ3JlYXRlZCB3YXJuaW5nIG9iamVjdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcGx1Z2luID0gcG9zdGNzcy5wbHVnaW4oJ3Bvc3Rjc3MtZGVwcmVjYXRlZCcsICgpID0+IHtcbiAgICogICByZXR1cm4gKHJvb3QsIHJlc3VsdCkgPT4ge1xuICAgKiAgICAgcm9vdC53YWxrRGVjbHMoJ2JhZCcsIGRlY2wgPT4ge1xuICAgKiAgICAgICBkZWNsLndhcm4ocmVzdWx0LCAnRGVwcmVjYXRlZCBwcm9wZXJ0eSBiYWQnKVxuICAgKiAgICAgfSlcbiAgICogICB9XG4gICAqIH0pXG4gICAqLztfcHJvdG8ud2Fybj1mdW5jdGlvbiB3YXJuKHJlc3VsdCx0ZXh0LG9wdHMpe3ZhciBkYXRhPXtub2RlOnRoaXN9O2Zvcih2YXIgaSBpbiBvcHRzKXtkYXRhW2ldPW9wdHNbaV07fXJldHVybiByZXN1bHQud2Fybih0ZXh0LGRhdGEpO30vKipcbiAgICogUmVtb3ZlcyB0aGUgbm9kZSBmcm9tIGl0cyBwYXJlbnQgYW5kIGNsZWFucyB0aGUgcGFyZW50IHByb3BlcnRpZXNcbiAgICogZnJvbSB0aGUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAoZGVjbC5wcm9wLm1hdGNoKC9eLXdlYmtpdC0vKSkge1xuICAgKiAgIGRlY2wucmVtb3ZlKClcbiAgICogfVxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBOb2RlIHRvIG1ha2UgY2FsbHMgY2hhaW4uXG4gICAqLztfcHJvdG8ucmVtb3ZlPWZ1bmN0aW9uIHJlbW92ZSgpe2lmKHRoaXMucGFyZW50KXt0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTt9dGhpcy5wYXJlbnQ9dW5kZWZpbmVkO3JldHVybiB0aGlzO30vKipcbiAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ2lmaWVyfHN5bnRheH0gW3N0cmluZ2lmaWVyXSBBIHN5bnRheCB0byB1c2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gc3RyaW5nIGdlbmVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ1NTIHN0cmluZyBvZiB0aGlzIG5vZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHBvc3Rjc3MucnVsZSh7IHNlbGVjdG9yOiAnYScgfSkudG9TdHJpbmcoKSAvLz0+IFwiYSB7fVwiXG4gICAqLztfcHJvdG8udG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZpZXIpe2lmKHN0cmluZ2lmaWVyPT09dm9pZCAwKXtzdHJpbmdpZmllcj1fc3RyaW5naWZ5W1wiZGVmYXVsdFwiXTt9aWYoc3RyaW5naWZpZXIuc3RyaW5naWZ5KXN0cmluZ2lmaWVyPXN0cmluZ2lmaWVyLnN0cmluZ2lmeTt2YXIgcmVzdWx0PScnO3N0cmluZ2lmaWVyKHRoaXMsZnVuY3Rpb24oaSl7cmVzdWx0Kz1pO30pO3JldHVybiByZXN1bHQ7fS8qKlxuICAgKiBSZXR1cm5zIGFuIGV4YWN0IGNsb25lIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBUaGUgcmVzdWx0aW5nIGNsb25lZCBub2RlIGFuZCBpdHMgKGNsb25lZCkgY2hpbGRyZW4gd2lsbCByZXRhaW5cbiAgICogY29kZSBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW292ZXJyaWRlc10gTmV3IHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgaW4gdGhlIGNsb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBkZWNsLnJhd3MuYmVmb3JlICAgIC8vPT4gXCJcXG4gIFwiXG4gICAqIGNvbnN0IGNsb25lZCA9IGRlY2wuY2xvbmUoeyBwcm9wOiAnLW1vei0nICsgZGVjbC5wcm9wIH0pXG4gICAqIGNsb25lZC5yYXdzLmJlZm9yZSAgLy89PiBcIlxcbiAgXCJcbiAgICogY2xvbmVkLnRvU3RyaW5nKCkgICAvLz0+IC1tb3otdHJhbnNmb3JtOiBzY2FsZSgwKVxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBDbG9uZSBvZiB0aGUgbm9kZS5cbiAgICovO19wcm90by5jbG9uZT1mdW5jdGlvbiBjbG9uZShvdmVycmlkZXMpe2lmKG92ZXJyaWRlcz09PXZvaWQgMCl7b3ZlcnJpZGVzPXt9O312YXIgY2xvbmVkPWNsb25lTm9kZSh0aGlzKTtmb3IodmFyIG5hbWUgaW4gb3ZlcnJpZGVzKXtjbG9uZWRbbmFtZV09b3ZlcnJpZGVzW25hbWVdO31yZXR1cm4gY2xvbmVkO30vKipcbiAgICogU2hvcnRjdXQgdG8gY2xvbmUgdGhlIG5vZGUgYW5kIGluc2VydCB0aGUgcmVzdWx0aW5nIGNsb25lZCBub2RlXG4gICAqIGJlZm9yZSB0aGUgY3VycmVudCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW292ZXJyaWRlc10gTWV3IHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgaW4gdGhlIGNsb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBkZWNsLmNsb25lQmVmb3JlKHsgcHJvcDogJy1tb3otJyArIGRlY2wucHJvcCB9KVxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBOZXcgbm9kZVxuICAgKi87X3Byb3RvLmNsb25lQmVmb3JlPWZ1bmN0aW9uIGNsb25lQmVmb3JlKG92ZXJyaWRlcyl7aWYob3ZlcnJpZGVzPT09dm9pZCAwKXtvdmVycmlkZXM9e307fXZhciBjbG9uZWQ9dGhpcy5jbG9uZShvdmVycmlkZXMpO3RoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLGNsb25lZCk7cmV0dXJuIGNsb25lZDt9LyoqXG4gICAqIFNob3J0Y3V0IHRvIGNsb25lIHRoZSBub2RlIGFuZCBpbnNlcnQgdGhlIHJlc3VsdGluZyBjbG9uZWQgbm9kZVxuICAgKiBhZnRlciB0aGUgY3VycmVudCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW292ZXJyaWRlc10gTmV3IHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgaW4gdGhlIGNsb25lLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBOZXcgbm9kZS5cbiAgICovO19wcm90by5jbG9uZUFmdGVyPWZ1bmN0aW9uIGNsb25lQWZ0ZXIob3ZlcnJpZGVzKXtpZihvdmVycmlkZXM9PT12b2lkIDApe292ZXJyaWRlcz17fTt9dmFyIGNsb25lZD10aGlzLmNsb25lKG92ZXJyaWRlcyk7dGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcyxjbG9uZWQpO3JldHVybiBjbG9uZWQ7fS8qKlxuICAgKiBJbnNlcnRzIG5vZGUocykgYmVmb3JlIHRoZSBjdXJyZW50IG5vZGUgYW5kIHJlbW92ZXMgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHsuLi5Ob2RlfSBub2RlcyBNb2RlKHMpIHRvIHJlcGxhY2UgY3VycmVudCBvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGlmIChhdHJ1bGUubmFtZSA9PT0gJ21peGluJykge1xuICAgKiAgIGF0cnVsZS5yZXBsYWNlV2l0aChtaXhpblJ1bGVzW2F0cnVsZS5wYXJhbXNdKVxuICAgKiB9XG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IEN1cnJlbnQgbm9kZSB0byBtZXRob2RzIGNoYWluLlxuICAgKi87X3Byb3RvLnJlcGxhY2VXaXRoPWZ1bmN0aW9uIHJlcGxhY2VXaXRoKCl7aWYodGhpcy5wYXJlbnQpe2Zvcih2YXIgX2xlbj1hcmd1bWVudHMubGVuZ3RoLG5vZGVzPW5ldyBBcnJheShfbGVuKSxfa2V5PTA7X2tleTxfbGVuO19rZXkrKyl7bm9kZXNbX2tleV09YXJndW1lbnRzW19rZXldO31mb3IodmFyIF9pPTAsX25vZGVzPW5vZGVzO19pPF9ub2Rlcy5sZW5ndGg7X2krKyl7dmFyIG5vZGU9X25vZGVzW19pXTt0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcyxub2RlKTt9dGhpcy5yZW1vdmUoKTt9cmV0dXJuIHRoaXM7fS8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IGNoaWxkIG9mIHRoZSBub2Rl4oCZcyBwYXJlbnQuXG4gICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyB0aGUgbGFzdCBjaGlsZC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IE5leHQgbm9kZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKGNvbW1lbnQudGV4dCA9PT0gJ2RlbGV0ZSBuZXh0Jykge1xuICAgKiAgIGNvbnN0IG5leHQgPSBjb21tZW50Lm5leHQoKVxuICAgKiAgIGlmIChuZXh0KSB7XG4gICAqICAgICBuZXh0LnJlbW92ZSgpXG4gICAqICAgfVxuICAgKiB9XG4gICAqLztfcHJvdG8ubmV4dD1mdW5jdGlvbiBuZXh0KCl7aWYoIXRoaXMucGFyZW50KXJldHVybiB1bmRlZmluZWQ7dmFyIGluZGV4PXRoaXMucGFyZW50LmluZGV4KHRoaXMpO3JldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCsxXTt9LyoqXG4gICAqIFJldHVybnMgdGhlIHByZXZpb3VzIGNoaWxkIG9mIHRoZSBub2Rl4oCZcyBwYXJlbnQuXG4gICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyB0aGUgZmlyc3QgY2hpbGQuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV8dW5kZWZpbmVkfSBQcmV2aW91cyBub2RlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBhbm5vdGF0aW9uID0gZGVjbC5wcmV2KClcbiAgICogaWYgKGFubm90YXRpb24udHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAqICAgcmVhZEFubm90YXRpb24oYW5ub3RhdGlvbi50ZXh0KVxuICAgKiB9XG4gICAqLztfcHJvdG8ucHJldj1mdW5jdGlvbiBwcmV2KCl7aWYoIXRoaXMucGFyZW50KXJldHVybiB1bmRlZmluZWQ7dmFyIGluZGV4PXRoaXMucGFyZW50LmluZGV4KHRoaXMpO3JldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleC0xXTt9LyoqXG4gICAqIEluc2VydCBuZXcgbm9kZSBiZWZvcmUgY3VycmVudCBub2RlIHRvIGN1cnJlbnQgbm9kZeKAmXMgcGFyZW50LlxuICAgKlxuICAgKiBKdXN0IGFsaWFzIGZvciBgbm9kZS5wYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFkZClgLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV8b2JqZWN0fHN0cmluZ3xOb2RlW119IGFkZCBOZXcgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhpcyBub2RlIGZvciBtZXRob2RzIGNoYWluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBkZWNsLmJlZm9yZSgnY29udGVudDogXCJcIicpXG4gICAqLztfcHJvdG8uYmVmb3JlPWZ1bmN0aW9uIGJlZm9yZShhZGQpe3RoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLGFkZCk7cmV0dXJuIHRoaXM7fS8qKlxuICAgKiBJbnNlcnQgbmV3IG5vZGUgYWZ0ZXIgY3VycmVudCBub2RlIHRvIGN1cnJlbnQgbm9kZeKAmXMgcGFyZW50LlxuICAgKlxuICAgKiBKdXN0IGFsaWFzIGZvciBgbm9kZS5wYXJlbnQuaW5zZXJ0QWZ0ZXIobm9kZSwgYWRkKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXX0gYWRkIE5ldyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGRlY2wuYWZ0ZXIoJ2NvbG9yOiBibGFjaycpXG4gICAqLztfcHJvdG8uYWZ0ZXI9ZnVuY3Rpb24gYWZ0ZXIoYWRkKXt0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLGFkZCk7cmV0dXJuIHRoaXM7fTtfcHJvdG8udG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe3ZhciBmaXhlZD17fTtmb3IodmFyIG5hbWUgaW4gdGhpcyl7aWYoIXRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkpY29udGludWU7aWYobmFtZT09PSdwYXJlbnQnKWNvbnRpbnVlO3ZhciB2YWx1ZT10aGlzW25hbWVdO2lmKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpe2ZpeGVkW25hbWVdPXZhbHVlLm1hcChmdW5jdGlvbihpKXtpZihfdHlwZW9mKGkpPT09J29iamVjdCcmJmkudG9KU09OKXtyZXR1cm4gaS50b0pTT04oKTt9ZWxzZXtyZXR1cm4gaTt9fSk7fWVsc2UgaWYoX3R5cGVvZih2YWx1ZSk9PT0nb2JqZWN0JyYmdmFsdWUudG9KU09OKXtmaXhlZFtuYW1lXT12YWx1ZS50b0pTT04oKTt9ZWxzZXtmaXhlZFtuYW1lXT12YWx1ZTt9fXJldHVybiBmaXhlZDt9LyoqXG4gICAqIFJldHVybnMgYSB7QGxpbmsgTm9kZSNyYXdzfSB2YWx1ZS4gSWYgdGhlIG5vZGUgaXMgbWlzc2luZ1xuICAgKiB0aGUgY29kZSBzdHlsZSBwcm9wZXJ0eSAoYmVjYXVzZSB0aGUgbm9kZSB3YXMgbWFudWFsbHkgYnVpbHQgb3IgY2xvbmVkKSxcbiAgICogUG9zdENTUyB3aWxsIHRyeSB0byBhdXRvZGV0ZWN0IHRoZSBjb2RlIHN0eWxlIHByb3BlcnR5IGJ5IGxvb2tpbmdcbiAgICogYXQgb3RoZXIgbm9kZXMgaW4gdGhlIHRyZWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wICAgICAgICAgIE5hbWUgb2YgY29kZSBzdHlsZSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0VHlwZV0gTmFtZSBvZiBkZWZhdWx0IHZhbHVlLCBpdCBjYW4gYmUgbWlzc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSBhcyBwcm9wLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7IGJhY2tncm91bmQ6IHdoaXRlIH0nKVxuICAgKiByb290Lm5vZGVzWzBdLmFwcGVuZCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAnYmxhY2snIH0pXG4gICAqIHJvb3Qubm9kZXNbMF0ubm9kZXNbMV0ucmF3cy5iZWZvcmUgICAvLz0+IHVuZGVmaW5lZFxuICAgKiByb290Lm5vZGVzWzBdLm5vZGVzWzFdLnJhdygnYmVmb3JlJykgLy89PiAnICdcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb2RlIHN0eWxlIHZhbHVlLlxuICAgKi87X3Byb3RvLnJhdz1mdW5jdGlvbiByYXcocHJvcCxkZWZhdWx0VHlwZSl7dmFyIHN0cj1uZXcgX3N0cmluZ2lmaWVyW1wiZGVmYXVsdFwiXSgpO3JldHVybiBzdHIucmF3KHRoaXMscHJvcCxkZWZhdWx0VHlwZSk7fS8qKlxuICAgKiBGaW5kcyB0aGUgUm9vdCBpbnN0YW5jZSBvZiB0aGUgbm9kZeKAmXMgdHJlZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcm9vdC5ub2Rlc1swXS5ub2Rlc1swXS5yb290KCkgPT09IHJvb3RcbiAgICpcbiAgICogQHJldHVybiB7Um9vdH0gUm9vdCBwYXJlbnQuXG4gICAqLztfcHJvdG8ucm9vdD1mdW5jdGlvbiByb290KCl7dmFyIHJlc3VsdD10aGlzO3doaWxlKHJlc3VsdC5wYXJlbnQpe3Jlc3VsdD1yZXN1bHQucGFyZW50O31yZXR1cm4gcmVzdWx0O30vKipcbiAgICogQ2xlYXIgdGhlIGNvZGUgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhlIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBba2VlcEJldHdlZW5dIEtlZXAgdGhlIHJhd3MuYmV0d2VlbiBzeW1ib2xzLlxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5vZGUucmF3cy5iZWZvcmUgIC8vPT4gJyAnXG4gICAqIG5vZGUuY2xlYW5SYXdzKClcbiAgICogbm9kZS5yYXdzLmJlZm9yZSAgLy89PiB1bmRlZmluZWRcbiAgICovO19wcm90by5jbGVhblJhd3M9ZnVuY3Rpb24gY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKXtkZWxldGUgdGhpcy5yYXdzLmJlZm9yZTtkZWxldGUgdGhpcy5yYXdzLmFmdGVyO2lmKCFrZWVwQmV0d2VlbilkZWxldGUgdGhpcy5yYXdzLmJldHdlZW47fTtfcHJvdG8ucG9zaXRpb25JbnNpZGU9ZnVuY3Rpb24gcG9zaXRpb25JbnNpZGUoaW5kZXgpe3ZhciBzdHJpbmc9dGhpcy50b1N0cmluZygpO3ZhciBjb2x1bW49dGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uO3ZhciBsaW5lPXRoaXMuc291cmNlLnN0YXJ0LmxpbmU7Zm9yKHZhciBpPTA7aTxpbmRleDtpKyspe2lmKHN0cmluZ1tpXT09PSdcXG4nKXtjb2x1bW49MTtsaW5lKz0xO31lbHNle2NvbHVtbis9MTt9fXJldHVybntsaW5lOmxpbmUsY29sdW1uOmNvbHVtbn07fTtfcHJvdG8ucG9zaXRpb25CeT1mdW5jdGlvbiBwb3NpdGlvbkJ5KG9wdHMpe3ZhciBwb3M9dGhpcy5zb3VyY2Uuc3RhcnQ7aWYob3B0cy5pbmRleCl7cG9zPXRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCk7fWVsc2UgaWYob3B0cy53b3JkKXt2YXIgaW5kZXg9dGhpcy50b1N0cmluZygpLmluZGV4T2Yob3B0cy53b3JkKTtpZihpbmRleCE9PS0xKXBvcz10aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4KTt9cmV0dXJuIHBvczt9LyoqXG4gICAqIEBtZW1iZXJvZiBOb2RlI1xuICAgKiBAbWVtYmVyIHtzdHJpbmd9IHR5cGUgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbm9kZeKAmXMgdHlwZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIHZhbHVlcyBhcmUgYHJvb3RgLCBgYXRydWxlYCwgYHJ1bGVgLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgYGRlY2xgLCBvciBgY29tbWVudGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHBvc3Rjc3MuZGVjbCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAnYmxhY2snIH0pLnR5cGUgLy89PiAnZGVjbCdcbiAgICovIC8qKlxuICAgKiBAbWVtYmVyb2YgTm9kZSNcbiAgICogQG1lbWJlciB7Q29udGFpbmVyfSBwYXJlbnQgVGhlIG5vZGXigJlzIHBhcmVudCBub2RlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByb290Lm5vZGVzWzBdLnBhcmVudCA9PT0gcm9vdFxuICAgKi8gLyoqXG4gICAqIEBtZW1iZXJvZiBOb2RlI1xuICAgKiBAbWVtYmVyIHtzb3VyY2V9IHNvdXJjZSBUaGUgaW5wdXQgc291cmNlIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBUaGUgcHJvcGVydHkgaXMgdXNlZCBpbiBzb3VyY2UgbWFwIGdlbmVyYXRpb24uXG4gICAqXG4gICAqIElmIHlvdSBjcmVhdGUgYSBub2RlIG1hbnVhbGx5IChlLmcuLCB3aXRoIGBwb3N0Y3NzLmRlY2woKWApLFxuICAgKiB0aGF0IG5vZGUgd2lsbCBub3QgaGF2ZSBhIGBzb3VyY2VgIHByb3BlcnR5IGFuZCB3aWxsIGJlIGFic2VudFxuICAgKiBmcm9tIHRoZSBzb3VyY2UgbWFwLiBGb3IgdGhpcyByZWFzb24sIHRoZSBwbHVnaW4gZGV2ZWxvcGVyIHNob3VsZFxuICAgKiBjb25zaWRlciBjbG9uaW5nIG5vZGVzIHRvIGNyZWF0ZSBuZXcgb25lcyAoaW4gd2hpY2ggY2FzZSB0aGUgbmV3IG5vZGXigJlzXG4gICAqIHNvdXJjZSB3aWxsIHJlZmVyZW5jZSB0aGUgb3JpZ2luYWwsIGNsb25lZCBub2RlKSBvciBzZXR0aW5nXG4gICAqIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBtYW51YWxseS5cbiAgICpcbiAgICogYGBganNcbiAgICogLy8gQmFkXG4gICAqIGNvbnN0IHByZWZpeGVkID0gcG9zdGNzcy5kZWNsKHtcbiAgICogICBwcm9wOiAnLW1vei0nICsgZGVjbC5wcm9wLFxuICAgKiAgIHZhbHVlOiBkZWNsLnZhbHVlXG4gICAqIH0pXG4gICAqXG4gICAqIC8vIEdvb2RcbiAgICogY29uc3QgcHJlZml4ZWQgPSBkZWNsLmNsb25lKHsgcHJvcDogJy1tb3otJyArIGRlY2wucHJvcCB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogYGBganNcbiAgICogaWYgKGF0cnVsZS5uYW1lID09PSAnYWRkLWxpbmsnKSB7XG4gICAqICAgY29uc3QgcnVsZSA9IHBvc3Rjc3MucnVsZSh7IHNlbGVjdG9yOiAnYScsIHNvdXJjZTogYXRydWxlLnNvdXJjZSB9KVxuICAgKiAgIGF0cnVsZS5wYXJlbnQuaW5zZXJ0QmVmb3JlKGF0cnVsZSwgcnVsZSlcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZGVjbC5zb3VyY2UuaW5wdXQuZnJvbSAvLz0+ICcvaG9tZS9haS9hLnNhc3MnXG4gICAqIGRlY2wuc291cmNlLnN0YXJ0ICAgICAgLy89PiB7IGxpbmU6IDEwLCBjb2x1bW46IDIgfVxuICAgKiBkZWNsLnNvdXJjZS5lbmQgICAgICAgIC8vPT4geyBsaW5lOiAxMCwgY29sdW1uOiAxMiB9XG4gICAqLyAvKipcbiAgICogQG1lbWJlcm9mIE5vZGUjXG4gICAqIEBtZW1iZXIge29iamVjdH0gcmF3cyBJbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBieXRlLXRvLWJ5dGUgZXF1YWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIG5vZGUgc3RyaW5nIGFzIGl0IHdhcyBpbiB0aGUgb3JpZ2luIGlucHV0LlxuICAgKlxuICAgKiBFdmVyeSBwYXJzZXIgc2F2ZXMgaXRzIG93biBwcm9wZXJ0aWVzLFxuICAgKiBidXQgdGhlIGRlZmF1bHQgQ1NTIHBhcnNlciB1c2VzOlxuICAgKlxuICAgKiAqIGBiZWZvcmVgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZWZvcmUgdGhlIG5vZGUuIEl0IGFsc28gc3RvcmVzIGAqYFxuICAgKiAgIGFuZCBgX2Agc3ltYm9scyBiZWZvcmUgdGhlIGRlY2xhcmF0aW9uIChJRSBoYWNrKS5cbiAgICogKiBgYWZ0ZXJgOiB0aGUgc3BhY2Ugc3ltYm9scyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGUgbm9kZVxuICAgKiAgIHRvIHRoZSBlbmQgb2YgdGhlIG5vZGUuXG4gICAqICogYGJldHdlZW5gOiB0aGUgc3ltYm9scyBiZXR3ZWVuIHRoZSBwcm9wZXJ0eSBhbmQgdmFsdWVcbiAgICogICBmb3IgZGVjbGFyYXRpb25zLCBzZWxlY3RvciBhbmQgYHtgIGZvciBydWxlcywgb3IgbGFzdCBwYXJhbWV0ZXJcbiAgICogICBhbmQgYHtgIGZvciBhdC1ydWxlcy5cbiAgICogKiBgc2VtaWNvbG9uYDogY29udGFpbnMgdHJ1ZSBpZiB0aGUgbGFzdCBjaGlsZCBoYXNcbiAgICogICBhbiAob3B0aW9uYWwpIHNlbWljb2xvbi5cbiAgICogKiBgYWZ0ZXJOYW1lYDogdGhlIHNwYWNlIGJldHdlZW4gdGhlIGF0LXJ1bGUgbmFtZSBhbmQgaXRzIHBhcmFtZXRlcnMuXG4gICAqICogYGxlZnRgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZXR3ZWVuIGAvKmAgYW5kIHRoZSBjb21tZW504oCZcyB0ZXh0LlxuICAgKiAqIGByaWdodGA6IHRoZSBzcGFjZSBzeW1ib2xzIGJldHdlZW4gdGhlIGNvbW1lbnTigJlzIHRleHRcbiAgICogICBhbmQgPGNvZGU+KiYjNDc7PC9jb2RlPi5cbiAgICogKiBgaW1wb3J0YW50YDogdGhlIGNvbnRlbnQgb2YgdGhlIGltcG9ydGFudCBzdGF0ZW1lbnQsXG4gICAqICAgaWYgaXQgaXMgbm90IGp1c3QgYCFpbXBvcnRhbnRgLlxuICAgKlxuICAgKiBQb3N0Q1NTIGNsZWFucyBzZWxlY3RvcnMsIGRlY2xhcmF0aW9uIHZhbHVlcyBhbmQgYXQtcnVsZSBwYXJhbWV0ZXJzXG4gICAqIGZyb20gY29tbWVudHMgYW5kIGV4dHJhIHNwYWNlcywgYnV0IGl0IHN0b3JlcyBvcmlnaW4gY29udGVudCBpbiByYXdzXG4gICAqIHByb3BlcnRpZXMuIEFzIHN1Y2gsIGlmIHlvdSBkb27igJl0IGNoYW5nZSBhIGRlY2xhcmF0aW9u4oCZcyB2YWx1ZSxcbiAgICogUG9zdENTUyB3aWxsIHVzZSB0aGUgcmF3IHZhbHVlIHdpdGggY29tbWVudHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhIHtcXG4gIGNvbG9yOmJsYWNrXFxufScpXG4gICAqIHJvb3QuZmlyc3QuZmlyc3QucmF3cyAvLz0+IHsgYmVmb3JlOiAnXFxuICAnLCBiZXR3ZWVuOiAnOicgfVxuICAgKi87cmV0dXJuIE5vZGU7fSgpO3ZhciBfZGVmYXVsdD1Ob2RlOy8qKlxuICogQHR5cGVkZWYge29iamVjdH0gcG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lICAgU291cmNlIGxpbmUgaW4gZmlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2x1bW4gU291cmNlIGNvbHVtbiBpbiBmaWxlLlxuICovIC8qKlxuICogQHR5cGVkZWYge29iamVjdH0gc291cmNlXG4gKiBAcHJvcGVydHkge0lucHV0fSBpbnB1dCAgICB7QGxpbmsgSW5wdXR9IHdpdGggaW5wdXQgZmlsZVxuICogQHByb3BlcnR5IHtwb3NpdGlvbn0gc3RhcnQgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSBub2Rl4oCZcyBzb3VyY2UuXG4gKiBAcHJvcGVydHkge3Bvc2l0aW9ufSBlbmQgICBUaGUgZW5kaW5nIHBvc2l0aW9uIG9mIHRoZSBub2Rl4oCZcyBzb3VyY2UuXG4gKi9leHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSk7fSx7XCIuL2Nzcy1zeW50YXgtZXJyb3JcIjoxNzEsXCIuL3N0cmluZ2lmaWVyXCI6MTg2LFwiLi9zdHJpbmdpZnlcIjoxODcsXCJfcHJvY2Vzc1wiOjE5Mn1dLDE3ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3Mpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX3BhcnNlcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlclwiKSk7dmFyIF9pbnB1dD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lucHV0XCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O31mdW5jdGlvbiBwYXJzZShjc3Msb3B0cyl7dmFyIGlucHV0PW5ldyBfaW5wdXRbXCJkZWZhdWx0XCJdKGNzcyxvcHRzKTt2YXIgcGFyc2VyPW5ldyBfcGFyc2VyW1wiZGVmYXVsdFwiXShpbnB1dCk7dHJ5e3BhcnNlci5wYXJzZSgpO31jYXRjaChlKXtpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7aWYoZS5uYW1lPT09J0Nzc1N5bnRheEVycm9yJyYmb3B0cyYmb3B0cy5mcm9tKXtpZigvXFwuc2NzcyQvaS50ZXN0KG9wdHMuZnJvbSkpe2UubWVzc2FnZSs9J1xcbllvdSB0cmllZCB0byBwYXJzZSBTQ1NTIHdpdGggJysndGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7ICcrJ3RyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyJzt9ZWxzZSBpZigvXFwuc2Fzcy9pLnRlc3Qob3B0cy5mcm9tKSl7ZS5tZXNzYWdlKz0nXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNhc3Mgd2l0aCAnKyd0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgJysndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXInO31lbHNlIGlmKC9cXC5sZXNzJC9pLnRlc3Qob3B0cy5mcm9tKSl7ZS5tZXNzYWdlKz0nXFxuWW91IHRyaWVkIHRvIHBhcnNlIExlc3Mgd2l0aCAnKyd0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgJysndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXInO319fXRocm93IGU7fXJldHVybiBwYXJzZXIucm9vdDt9dmFyIF9kZWZhdWx0PXBhcnNlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKTt9LHtcIi4vaW5wdXRcIjoxNzMsXCIuL3BhcnNlclwiOjE3OSxcIl9wcm9jZXNzXCI6MTkyfV0sMTc5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9kZWNsYXJhdGlvbj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2RlY2xhcmF0aW9uXCIpKTt2YXIgX3Rva2VuaXplPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdG9rZW5pemVcIikpO3ZhciBfY29tbWVudD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRcIikpO3ZhciBfYXRSdWxlPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYXQtcnVsZVwiKSk7dmFyIF9yb290PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm9vdFwiKSk7dmFyIF9ydWxlPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcnVsZVwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9dmFyIFBhcnNlcj0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXtmdW5jdGlvbiBQYXJzZXIoaW5wdXQpe3RoaXMuaW5wdXQ9aW5wdXQ7dGhpcy5yb290PW5ldyBfcm9vdFtcImRlZmF1bHRcIl0oKTt0aGlzLmN1cnJlbnQ9dGhpcy5yb290O3RoaXMuc3BhY2VzPScnO3RoaXMuc2VtaWNvbG9uPWZhbHNlO3RoaXMuY3JlYXRlVG9rZW5pemVyKCk7dGhpcy5yb290LnNvdXJjZT17aW5wdXQ6aW5wdXQsc3RhcnQ6e2xpbmU6MSxjb2x1bW46MX19O312YXIgX3Byb3RvPVBhcnNlci5wcm90b3R5cGU7X3Byb3RvLmNyZWF0ZVRva2VuaXplcj1mdW5jdGlvbiBjcmVhdGVUb2tlbml6ZXIoKXt0aGlzLnRva2VuaXplcj0oMCxfdG9rZW5pemVbXCJkZWZhdWx0XCJdKSh0aGlzLmlucHV0KTt9O19wcm90by5wYXJzZT1mdW5jdGlvbiBwYXJzZSgpe3ZhciB0b2tlbjt3aGlsZSghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpe3Rva2VuPXRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO3N3aXRjaCh0b2tlblswXSl7Y2FzZSdzcGFjZSc6dGhpcy5zcGFjZXMrPXRva2VuWzFdO2JyZWFrO2Nhc2UnOyc6dGhpcy5mcmVlU2VtaWNvbG9uKHRva2VuKTticmVhaztjYXNlJ30nOnRoaXMuZW5kKHRva2VuKTticmVhaztjYXNlJ2NvbW1lbnQnOnRoaXMuY29tbWVudCh0b2tlbik7YnJlYWs7Y2FzZSdhdC13b3JkJzp0aGlzLmF0cnVsZSh0b2tlbik7YnJlYWs7Y2FzZSd7Jzp0aGlzLmVtcHR5UnVsZSh0b2tlbik7YnJlYWs7ZGVmYXVsdDp0aGlzLm90aGVyKHRva2VuKTticmVhazt9fXRoaXMuZW5kRmlsZSgpO307X3Byb3RvLmNvbW1lbnQ9ZnVuY3Rpb24gY29tbWVudCh0b2tlbil7dmFyIG5vZGU9bmV3IF9jb21tZW50W1wiZGVmYXVsdFwiXSgpO3RoaXMuaW5pdChub2RlLHRva2VuWzJdLHRva2VuWzNdKTtub2RlLnNvdXJjZS5lbmQ9e2xpbmU6dG9rZW5bNF0sY29sdW1uOnRva2VuWzVdfTt2YXIgdGV4dD10b2tlblsxXS5zbGljZSgyLC0yKTtpZigvXlxccyokLy50ZXN0KHRleHQpKXtub2RlLnRleHQ9Jyc7bm9kZS5yYXdzLmxlZnQ9dGV4dDtub2RlLnJhd3MucmlnaHQ9Jyc7fWVsc2V7dmFyIG1hdGNoPXRleHQubWF0Y2goL14oXFxzKikoW15dKlteXFxzXSkoXFxzKikkLyk7bm9kZS50ZXh0PW1hdGNoWzJdO25vZGUucmF3cy5sZWZ0PW1hdGNoWzFdO25vZGUucmF3cy5yaWdodD1tYXRjaFszXTt9fTtfcHJvdG8uZW1wdHlSdWxlPWZ1bmN0aW9uIGVtcHR5UnVsZSh0b2tlbil7dmFyIG5vZGU9bmV3IF9ydWxlW1wiZGVmYXVsdFwiXSgpO3RoaXMuaW5pdChub2RlLHRva2VuWzJdLHRva2VuWzNdKTtub2RlLnNlbGVjdG9yPScnO25vZGUucmF3cy5iZXR3ZWVuPScnO3RoaXMuY3VycmVudD1ub2RlO307X3Byb3RvLm90aGVyPWZ1bmN0aW9uIG90aGVyKHN0YXJ0KXt2YXIgZW5kPWZhbHNlO3ZhciB0eXBlPW51bGw7dmFyIGNvbG9uPWZhbHNlO3ZhciBicmFja2V0PW51bGw7dmFyIGJyYWNrZXRzPVtdO3ZhciB0b2tlbnM9W107dmFyIHRva2VuPXN0YXJ0O3doaWxlKHRva2VuKXt0eXBlPXRva2VuWzBdO3Rva2Vucy5wdXNoKHRva2VuKTtpZih0eXBlPT09JygnfHx0eXBlPT09J1snKXtpZighYnJhY2tldClicmFja2V0PXRva2VuO2JyYWNrZXRzLnB1c2godHlwZT09PScoJz8nKSc6J10nKTt9ZWxzZSBpZihicmFja2V0cy5sZW5ndGg9PT0wKXtpZih0eXBlPT09JzsnKXtpZihjb2xvbil7dGhpcy5kZWNsKHRva2Vucyk7cmV0dXJuO31lbHNle2JyZWFrO319ZWxzZSBpZih0eXBlPT09J3snKXt0aGlzLnJ1bGUodG9rZW5zKTtyZXR1cm47fWVsc2UgaWYodHlwZT09PSd9Jyl7dGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO2VuZD10cnVlO2JyZWFrO31lbHNlIGlmKHR5cGU9PT0nOicpe2NvbG9uPXRydWU7fX1lbHNlIGlmKHR5cGU9PT1icmFja2V0c1ticmFja2V0cy5sZW5ndGgtMV0pe2JyYWNrZXRzLnBvcCgpO2lmKGJyYWNrZXRzLmxlbmd0aD09PTApYnJhY2tldD1udWxsO310b2tlbj10aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTt9aWYodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpZW5kPXRydWU7aWYoYnJhY2tldHMubGVuZ3RoPjApdGhpcy51bmNsb3NlZEJyYWNrZXQoYnJhY2tldCk7aWYoZW5kJiZjb2xvbil7d2hpbGUodG9rZW5zLmxlbmd0aCl7dG9rZW49dG9rZW5zW3Rva2Vucy5sZW5ndGgtMV1bMF07aWYodG9rZW4hPT0nc3BhY2UnJiZ0b2tlbiE9PSdjb21tZW50JylicmVhazt0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7fXRoaXMuZGVjbCh0b2tlbnMpO31lbHNle3RoaXMudW5rbm93bldvcmQodG9rZW5zKTt9fTtfcHJvdG8ucnVsZT1mdW5jdGlvbiBydWxlKHRva2Vucyl7dG9rZW5zLnBvcCgpO3ZhciBub2RlPW5ldyBfcnVsZVtcImRlZmF1bHRcIl0oKTt0aGlzLmluaXQobm9kZSx0b2tlbnNbMF1bMl0sdG9rZW5zWzBdWzNdKTtub2RlLnJhd3MuYmV0d2Vlbj10aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpO3RoaXMucmF3KG5vZGUsJ3NlbGVjdG9yJyx0b2tlbnMpO3RoaXMuY3VycmVudD1ub2RlO307X3Byb3RvLmRlY2w9ZnVuY3Rpb24gZGVjbCh0b2tlbnMpe3ZhciBub2RlPW5ldyBfZGVjbGFyYXRpb25bXCJkZWZhdWx0XCJdKCk7dGhpcy5pbml0KG5vZGUpO3ZhciBsYXN0PXRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdO2lmKGxhc3RbMF09PT0nOycpe3RoaXMuc2VtaWNvbG9uPXRydWU7dG9rZW5zLnBvcCgpO31pZihsYXN0WzRdKXtub2RlLnNvdXJjZS5lbmQ9e2xpbmU6bGFzdFs0XSxjb2x1bW46bGFzdFs1XX07fWVsc2V7bm9kZS5zb3VyY2UuZW5kPXtsaW5lOmxhc3RbMl0sY29sdW1uOmxhc3RbM119O313aGlsZSh0b2tlbnNbMF1bMF0hPT0nd29yZCcpe2lmKHRva2Vucy5sZW5ndGg9PT0xKXRoaXMudW5rbm93bldvcmQodG9rZW5zKTtub2RlLnJhd3MuYmVmb3JlKz10b2tlbnMuc2hpZnQoKVsxXTt9bm9kZS5zb3VyY2Uuc3RhcnQ9e2xpbmU6dG9rZW5zWzBdWzJdLGNvbHVtbjp0b2tlbnNbMF1bM119O25vZGUucHJvcD0nJzt3aGlsZSh0b2tlbnMubGVuZ3RoKXt2YXIgdHlwZT10b2tlbnNbMF1bMF07aWYodHlwZT09PSc6J3x8dHlwZT09PSdzcGFjZSd8fHR5cGU9PT0nY29tbWVudCcpe2JyZWFrO31ub2RlLnByb3ArPXRva2Vucy5zaGlmdCgpWzFdO31ub2RlLnJhd3MuYmV0d2Vlbj0nJzt2YXIgdG9rZW47d2hpbGUodG9rZW5zLmxlbmd0aCl7dG9rZW49dG9rZW5zLnNoaWZ0KCk7aWYodG9rZW5bMF09PT0nOicpe25vZGUucmF3cy5iZXR3ZWVuKz10b2tlblsxXTticmVhazt9ZWxzZXtpZih0b2tlblswXT09PSd3b3JkJyYmL1xcdy8udGVzdCh0b2tlblsxXSkpe3RoaXMudW5rbm93bldvcmQoW3Rva2VuXSk7fW5vZGUucmF3cy5iZXR3ZWVuKz10b2tlblsxXTt9fWlmKG5vZGUucHJvcFswXT09PSdfJ3x8bm9kZS5wcm9wWzBdPT09JyonKXtub2RlLnJhd3MuYmVmb3JlKz1ub2RlLnByb3BbMF07bm9kZS5wcm9wPW5vZGUucHJvcC5zbGljZSgxKTt9bm9kZS5yYXdzLmJldHdlZW4rPXRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQodG9rZW5zKTt0aGlzLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7Zm9yKHZhciBpPXRva2Vucy5sZW5ndGgtMTtpPjA7aS0tKXt0b2tlbj10b2tlbnNbaV07aWYodG9rZW5bMV0udG9Mb3dlckNhc2UoKT09PSchaW1wb3J0YW50Jyl7bm9kZS5pbXBvcnRhbnQ9dHJ1ZTt2YXIgc3RyaW5nPXRoaXMuc3RyaW5nRnJvbSh0b2tlbnMsaSk7c3RyaW5nPXRoaXMuc3BhY2VzRnJvbUVuZCh0b2tlbnMpK3N0cmluZztpZihzdHJpbmchPT0nICFpbXBvcnRhbnQnKW5vZGUucmF3cy5pbXBvcnRhbnQ9c3RyaW5nO2JyZWFrO31lbHNlIGlmKHRva2VuWzFdLnRvTG93ZXJDYXNlKCk9PT0naW1wb3J0YW50Jyl7dmFyIGNhY2hlPXRva2Vucy5zbGljZSgwKTt2YXIgc3RyPScnO2Zvcih2YXIgaj1pO2o+MDtqLS0pe3ZhciBfdHlwZT1jYWNoZVtqXVswXTtpZihzdHIudHJpbSgpLmluZGV4T2YoJyEnKT09PTAmJl90eXBlIT09J3NwYWNlJyl7YnJlYWs7fXN0cj1jYWNoZS5wb3AoKVsxXStzdHI7fWlmKHN0ci50cmltKCkuaW5kZXhPZignIScpPT09MCl7bm9kZS5pbXBvcnRhbnQ9dHJ1ZTtub2RlLnJhd3MuaW1wb3J0YW50PXN0cjt0b2tlbnM9Y2FjaGU7fX1pZih0b2tlblswXSE9PSdzcGFjZScmJnRva2VuWzBdIT09J2NvbW1lbnQnKXticmVhazt9fXRoaXMucmF3KG5vZGUsJ3ZhbHVlJyx0b2tlbnMpO2lmKG5vZGUudmFsdWUuaW5kZXhPZignOicpIT09LTEpdGhpcy5jaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpO307X3Byb3RvLmF0cnVsZT1mdW5jdGlvbiBhdHJ1bGUodG9rZW4pe3ZhciBub2RlPW5ldyBfYXRSdWxlW1wiZGVmYXVsdFwiXSgpO25vZGUubmFtZT10b2tlblsxXS5zbGljZSgxKTtpZihub2RlLm5hbWU9PT0nJyl7dGhpcy51bm5hbWVkQXRydWxlKG5vZGUsdG9rZW4pO310aGlzLmluaXQobm9kZSx0b2tlblsyXSx0b2tlblszXSk7dmFyIHByZXY7dmFyIHNoaWZ0O3ZhciBsYXN0PWZhbHNlO3ZhciBvcGVuPWZhbHNlO3ZhciBwYXJhbXM9W107d2hpbGUoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKXt0b2tlbj10aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtpZih0b2tlblswXT09PSc7Jyl7bm9kZS5zb3VyY2UuZW5kPXtsaW5lOnRva2VuWzJdLGNvbHVtbjp0b2tlblszXX07dGhpcy5zZW1pY29sb249dHJ1ZTticmVhazt9ZWxzZSBpZih0b2tlblswXT09PSd7Jyl7b3Blbj10cnVlO2JyZWFrO31lbHNlIGlmKHRva2VuWzBdPT09J30nKXtpZihwYXJhbXMubGVuZ3RoPjApe3NoaWZ0PXBhcmFtcy5sZW5ndGgtMTtwcmV2PXBhcmFtc1tzaGlmdF07d2hpbGUocHJldiYmcHJldlswXT09PSdzcGFjZScpe3ByZXY9cGFyYW1zWy0tc2hpZnRdO31pZihwcmV2KXtub2RlLnNvdXJjZS5lbmQ9e2xpbmU6cHJldls0XSxjb2x1bW46cHJldls1XX07fX10aGlzLmVuZCh0b2tlbik7YnJlYWs7fWVsc2V7cGFyYW1zLnB1c2godG9rZW4pO31pZih0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSl7bGFzdD10cnVlO2JyZWFrO319bm9kZS5yYXdzLmJldHdlZW49dGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQocGFyYW1zKTtpZihwYXJhbXMubGVuZ3RoKXtub2RlLnJhd3MuYWZ0ZXJOYW1lPXRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQocGFyYW1zKTt0aGlzLnJhdyhub2RlLCdwYXJhbXMnLHBhcmFtcyk7aWYobGFzdCl7dG9rZW49cGFyYW1zW3BhcmFtcy5sZW5ndGgtMV07bm9kZS5zb3VyY2UuZW5kPXtsaW5lOnRva2VuWzRdLGNvbHVtbjp0b2tlbls1XX07dGhpcy5zcGFjZXM9bm9kZS5yYXdzLmJldHdlZW47bm9kZS5yYXdzLmJldHdlZW49Jyc7fX1lbHNle25vZGUucmF3cy5hZnRlck5hbWU9Jyc7bm9kZS5wYXJhbXM9Jyc7fWlmKG9wZW4pe25vZGUubm9kZXM9W107dGhpcy5jdXJyZW50PW5vZGU7fX07X3Byb3RvLmVuZD1mdW5jdGlvbiBlbmQodG9rZW4pe2lmKHRoaXMuY3VycmVudC5ub2RlcyYmdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCl7dGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uPXRoaXMuc2VtaWNvbG9uO310aGlzLnNlbWljb2xvbj1mYWxzZTt0aGlzLmN1cnJlbnQucmF3cy5hZnRlcj0odGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXJ8fCcnKSt0aGlzLnNwYWNlczt0aGlzLnNwYWNlcz0nJztpZih0aGlzLmN1cnJlbnQucGFyZW50KXt0aGlzLmN1cnJlbnQuc291cmNlLmVuZD17bGluZTp0b2tlblsyXSxjb2x1bW46dG9rZW5bM119O3RoaXMuY3VycmVudD10aGlzLmN1cnJlbnQucGFyZW50O31lbHNle3RoaXMudW5leHBlY3RlZENsb3NlKHRva2VuKTt9fTtfcHJvdG8uZW5kRmlsZT1mdW5jdGlvbiBlbmRGaWxlKCl7aWYodGhpcy5jdXJyZW50LnBhcmVudCl0aGlzLnVuY2xvc2VkQmxvY2soKTtpZih0aGlzLmN1cnJlbnQubm9kZXMmJnRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpe3RoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbj10aGlzLnNlbWljb2xvbjt9dGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXI9KHRoaXMuY3VycmVudC5yYXdzLmFmdGVyfHwnJykrdGhpcy5zcGFjZXM7fTtfcHJvdG8uZnJlZVNlbWljb2xvbj1mdW5jdGlvbiBmcmVlU2VtaWNvbG9uKHRva2VuKXt0aGlzLnNwYWNlcys9dG9rZW5bMV07aWYodGhpcy5jdXJyZW50Lm5vZGVzKXt2YXIgcHJldj10aGlzLmN1cnJlbnQubm9kZXNbdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aC0xXTtpZihwcmV2JiZwcmV2LnR5cGU9PT0ncnVsZScmJiFwcmV2LnJhd3Mub3duU2VtaWNvbG9uKXtwcmV2LnJhd3Mub3duU2VtaWNvbG9uPXRoaXMuc3BhY2VzO3RoaXMuc3BhY2VzPScnO319fS8vIEhlbHBlcnNcbjtfcHJvdG8uaW5pdD1mdW5jdGlvbiBpbml0KG5vZGUsbGluZSxjb2x1bW4pe3RoaXMuY3VycmVudC5wdXNoKG5vZGUpO25vZGUuc291cmNlPXtzdGFydDp7bGluZTpsaW5lLGNvbHVtbjpjb2x1bW59LGlucHV0OnRoaXMuaW5wdXR9O25vZGUucmF3cy5iZWZvcmU9dGhpcy5zcGFjZXM7dGhpcy5zcGFjZXM9Jyc7aWYobm9kZS50eXBlIT09J2NvbW1lbnQnKXRoaXMuc2VtaWNvbG9uPWZhbHNlO307X3Byb3RvLnJhdz1mdW5jdGlvbiByYXcobm9kZSxwcm9wLHRva2Vucyl7dmFyIHRva2VuLHR5cGU7dmFyIGxlbmd0aD10b2tlbnMubGVuZ3RoO3ZhciB2YWx1ZT0nJzt2YXIgY2xlYW49dHJ1ZTt2YXIgbmV4dCxwcmV2O3ZhciBwYXR0ZXJuPS9eKFsufCNdKT8oW1xcd10pKy9pO2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krPTEpe3Rva2VuPXRva2Vuc1tpXTt0eXBlPXRva2VuWzBdO2lmKHR5cGU9PT0nY29tbWVudCcmJm5vZGUudHlwZT09PSdydWxlJyl7cHJldj10b2tlbnNbaS0xXTtuZXh0PXRva2Vuc1tpKzFdO2lmKHByZXZbMF0hPT0nc3BhY2UnJiZuZXh0WzBdIT09J3NwYWNlJyYmcGF0dGVybi50ZXN0KHByZXZbMV0pJiZwYXR0ZXJuLnRlc3QobmV4dFsxXSkpe3ZhbHVlKz10b2tlblsxXTt9ZWxzZXtjbGVhbj1mYWxzZTt9Y29udGludWU7fWlmKHR5cGU9PT0nY29tbWVudCd8fHR5cGU9PT0nc3BhY2UnJiZpPT09bGVuZ3RoLTEpe2NsZWFuPWZhbHNlO31lbHNle3ZhbHVlKz10b2tlblsxXTt9fWlmKCFjbGVhbil7dmFyIHJhdz10b2tlbnMucmVkdWNlKGZ1bmN0aW9uKGFsbCxpKXtyZXR1cm4gYWxsK2lbMV07fSwnJyk7bm9kZS5yYXdzW3Byb3BdPXt2YWx1ZTp2YWx1ZSxyYXc6cmF3fTt9bm9kZVtwcm9wXT12YWx1ZTt9O19wcm90by5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQ9ZnVuY3Rpb24gc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucyl7dmFyIGxhc3RUb2tlblR5cGU7dmFyIHNwYWNlcz0nJzt3aGlsZSh0b2tlbnMubGVuZ3RoKXtsYXN0VG9rZW5UeXBlPXRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdWzBdO2lmKGxhc3RUb2tlblR5cGUhPT0nc3BhY2UnJiZsYXN0VG9rZW5UeXBlIT09J2NvbW1lbnQnKWJyZWFrO3NwYWNlcz10b2tlbnMucG9wKClbMV0rc3BhY2VzO31yZXR1cm4gc3BhY2VzO307X3Byb3RvLnNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0PWZ1bmN0aW9uIHNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHRva2Vucyl7dmFyIG5leHQ7dmFyIHNwYWNlcz0nJzt3aGlsZSh0b2tlbnMubGVuZ3RoKXtuZXh0PXRva2Vuc1swXVswXTtpZihuZXh0IT09J3NwYWNlJyYmbmV4dCE9PSdjb21tZW50JylicmVhaztzcGFjZXMrPXRva2Vucy5zaGlmdCgpWzFdO31yZXR1cm4gc3BhY2VzO307X3Byb3RvLnNwYWNlc0Zyb21FbmQ9ZnVuY3Rpb24gc3BhY2VzRnJvbUVuZCh0b2tlbnMpe3ZhciBsYXN0VG9rZW5UeXBlO3ZhciBzcGFjZXM9Jyc7d2hpbGUodG9rZW5zLmxlbmd0aCl7bGFzdFRva2VuVHlwZT10b2tlbnNbdG9rZW5zLmxlbmd0aC0xXVswXTtpZihsYXN0VG9rZW5UeXBlIT09J3NwYWNlJylicmVhaztzcGFjZXM9dG9rZW5zLnBvcCgpWzFdK3NwYWNlczt9cmV0dXJuIHNwYWNlczt9O19wcm90by5zdHJpbmdGcm9tPWZ1bmN0aW9uIHN0cmluZ0Zyb20odG9rZW5zLGZyb20pe3ZhciByZXN1bHQ9Jyc7Zm9yKHZhciBpPWZyb207aTx0b2tlbnMubGVuZ3RoO2krKyl7cmVzdWx0Kz10b2tlbnNbaV1bMV07fXRva2Vucy5zcGxpY2UoZnJvbSx0b2tlbnMubGVuZ3RoLWZyb20pO3JldHVybiByZXN1bHQ7fTtfcHJvdG8uY29sb249ZnVuY3Rpb24gY29sb24odG9rZW5zKXt2YXIgYnJhY2tldHM9MDt2YXIgdG9rZW4sdHlwZSxwcmV2O2Zvcih2YXIgaT0wO2k8dG9rZW5zLmxlbmd0aDtpKyspe3Rva2VuPXRva2Vuc1tpXTt0eXBlPXRva2VuWzBdO2lmKHR5cGU9PT0nKCcpe2JyYWNrZXRzKz0xO31pZih0eXBlPT09JyknKXticmFja2V0cy09MTt9aWYoYnJhY2tldHM9PT0wJiZ0eXBlPT09JzonKXtpZighcHJldil7dGhpcy5kb3VibGVDb2xvbih0b2tlbik7fWVsc2UgaWYocHJldlswXT09PSd3b3JkJyYmcHJldlsxXT09PSdwcm9naWQnKXtjb250aW51ZTt9ZWxzZXtyZXR1cm4gaTt9fXByZXY9dG9rZW47fXJldHVybiBmYWxzZTt9Ly8gRXJyb3JzXG47X3Byb3RvLnVuY2xvc2VkQnJhY2tldD1mdW5jdGlvbiB1bmNsb3NlZEJyYWNrZXQoYnJhY2tldCl7dGhyb3cgdGhpcy5pbnB1dC5lcnJvcignVW5jbG9zZWQgYnJhY2tldCcsYnJhY2tldFsyXSxicmFja2V0WzNdKTt9O19wcm90by51bmtub3duV29yZD1mdW5jdGlvbiB1bmtub3duV29yZCh0b2tlbnMpe3Rocm93IHRoaXMuaW5wdXQuZXJyb3IoJ1Vua25vd24gd29yZCcsdG9rZW5zWzBdWzJdLHRva2Vuc1swXVszXSk7fTtfcHJvdG8udW5leHBlY3RlZENsb3NlPWZ1bmN0aW9uIHVuZXhwZWN0ZWRDbG9zZSh0b2tlbil7dGhyb3cgdGhpcy5pbnB1dC5lcnJvcignVW5leHBlY3RlZCB9Jyx0b2tlblsyXSx0b2tlblszXSk7fTtfcHJvdG8udW5jbG9zZWRCbG9jaz1mdW5jdGlvbiB1bmNsb3NlZEJsb2NrKCl7dmFyIHBvcz10aGlzLmN1cnJlbnQuc291cmNlLnN0YXJ0O3Rocm93IHRoaXMuaW5wdXQuZXJyb3IoJ1VuY2xvc2VkIGJsb2NrJyxwb3MubGluZSxwb3MuY29sdW1uKTt9O19wcm90by5kb3VibGVDb2xvbj1mdW5jdGlvbiBkb3VibGVDb2xvbih0b2tlbil7dGhyb3cgdGhpcy5pbnB1dC5lcnJvcignRG91YmxlIGNvbG9uJyx0b2tlblsyXSx0b2tlblszXSk7fTtfcHJvdG8udW5uYW1lZEF0cnVsZT1mdW5jdGlvbiB1bm5hbWVkQXRydWxlKG5vZGUsdG9rZW4pe3Rocm93IHRoaXMuaW5wdXQuZXJyb3IoJ0F0LXJ1bGUgd2l0aG91dCBuYW1lJyx0b2tlblsyXSx0b2tlblszXSk7fTtfcHJvdG8ucHJlY2hlY2tNaXNzZWRTZW1pY29sb249ZnVuY3Rpb24gcHJlY2hlY2tNaXNzZWRTZW1pY29sb24oKS8qIHRva2VucyAqL3svLyBIb29rIGZvciBTYWZlIFBhcnNlclxufTtfcHJvdG8uY2hlY2tNaXNzZWRTZW1pY29sb249ZnVuY3Rpb24gY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKXt2YXIgY29sb249dGhpcy5jb2xvbih0b2tlbnMpO2lmKGNvbG9uPT09ZmFsc2UpcmV0dXJuO3ZhciBmb3VuZGVkPTA7dmFyIHRva2VuO2Zvcih2YXIgaj1jb2xvbi0xO2o+PTA7ai0tKXt0b2tlbj10b2tlbnNbal07aWYodG9rZW5bMF0hPT0nc3BhY2UnKXtmb3VuZGVkKz0xO2lmKGZvdW5kZWQ9PT0yKWJyZWFrO319dGhyb3cgdGhpcy5pbnB1dC5lcnJvcignTWlzc2VkIHNlbWljb2xvbicsdG9rZW5bMl0sdG9rZW5bM10pO307cmV0dXJuIFBhcnNlcjt9KCk7ZXhwb3J0c1tcImRlZmF1bHRcIl09UGFyc2VyO21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se1wiLi9hdC1ydWxlXCI6MTY4LFwiLi9jb21tZW50XCI6MTY5LFwiLi9kZWNsYXJhdGlvblwiOjE3MixcIi4vcm9vdFwiOjE4NCxcIi4vcnVsZVwiOjE4NSxcIi4vdG9rZW5pemVcIjoxODh9XSwxODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2RlY2xhcmF0aW9uPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGVjbGFyYXRpb25cIikpO3ZhciBfcHJvY2Vzc29yPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcHJvY2Vzc29yXCIpKTt2YXIgX3N0cmluZ2lmeT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeVwiKSk7dmFyIF9jb21tZW50PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tbWVudFwiKSk7dmFyIF9hdFJ1bGU9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9hdC1ydWxlXCIpKTt2YXIgX3ZlbmRvcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZlbmRvclwiKSk7dmFyIF9wYXJzZT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlXCIpKTt2YXIgX2xpc3Q9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saXN0XCIpKTt2YXIgX3J1bGU9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ydWxlXCIpKTt2YXIgX3Jvb3Q9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb290XCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O30vKipcbiAqIENyZWF0ZSBhIG5ldyB7QGxpbmsgUHJvY2Vzc29yfSBpbnN0YW5jZSB0aGF0IHdpbGwgYXBwbHkgYHBsdWdpbnNgXG4gKiBhcyBDU1MgcHJvY2Vzc29ycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxQbHVnaW58cGx1Z2luRnVuY3Rpb24+fFByb2Nlc3Nvcn0gcGx1Z2lucyBQb3N0Q1NTIHBsdWdpbnMuXG4gKiAgICAgICAgU2VlIHtAbGluayBQcm9jZXNzb3IjdXNlfSBmb3IgcGx1Z2luIGZvcm1hdC5cbiAqXG4gKiBAcmV0dXJuIHtQcm9jZXNzb3J9IFByb2Nlc3NvciB0byBwcm9jZXNzIG11bHRpcGxlIENTUy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHBvc3Rjc3MgZnJvbSAncG9zdGNzcydcbiAqXG4gKiBwb3N0Y3NzKHBsdWdpbnMpLnByb2Nlc3MoY3NzLCB7IGZyb20sIHRvIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAqICAgY29uc29sZS5sb2cocmVzdWx0LmNzcylcbiAqIH0pXG4gKlxuICogQG5hbWVzcGFjZSBwb3N0Y3NzXG4gKi9mdW5jdGlvbiBwb3N0Y3NzKCl7Zm9yKHZhciBfbGVuPWFyZ3VtZW50cy5sZW5ndGgscGx1Z2lucz1uZXcgQXJyYXkoX2xlbiksX2tleT0wO19rZXk8X2xlbjtfa2V5Kyspe3BsdWdpbnNbX2tleV09YXJndW1lbnRzW19rZXldO31pZihwbHVnaW5zLmxlbmd0aD09PTEmJkFycmF5LmlzQXJyYXkocGx1Z2luc1swXSkpe3BsdWdpbnM9cGx1Z2luc1swXTt9cmV0dXJuIG5ldyBfcHJvY2Vzc29yW1wiZGVmYXVsdFwiXShwbHVnaW5zKTt9LyoqXG4gKiBDcmVhdGVzIGEgUG9zdENTUyBwbHVnaW4gd2l0aCBhIHN0YW5kYXJkIEFQSS5cbiAqXG4gKiBUaGUgbmV3bHktd3JhcHBlZCBmdW5jdGlvbiB3aWxsIHByb3ZpZGUgYm90aCB0aGUgbmFtZSBhbmQgUG9zdENTU1xuICogdmVyc2lvbiBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwcm9jZXNzb3IgPSBwb3N0Y3NzKFtyZXBsYWNlXSlcbiAqIHByb2Nlc3Nvci5wbHVnaW5zWzBdLnBvc3Rjc3NQbHVnaW4gIC8vPT4gJ3Bvc3Rjc3MtcmVwbGFjZSdcbiAqIHByb2Nlc3Nvci5wbHVnaW5zWzBdLnBvc3Rjc3NWZXJzaW9uIC8vPT4gJzYuMC4wJ1xuICogYGBgXG4gKlxuICogVGhlIHBsdWdpbiBmdW5jdGlvbiByZWNlaXZlcyAyIGFyZ3VtZW50czoge0BsaW5rIFJvb3R9XG4gKiBhbmQge0BsaW5rIFJlc3VsdH0gaW5zdGFuY2UuIFRoZSBmdW5jdGlvbiBzaG91bGQgbXV0YXRlIHRoZSBwcm92aWRlZFxuICogYFJvb3RgIG5vZGUuIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gY3JlYXRlIGEgbmV3IGBSb290YCBub2RlXG4gKiBhbmQgb3ZlcnJpZGUgdGhlIGByZXN1bHQucm9vdGAgcHJvcGVydHkuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGNsZWFuZXIgPSBwb3N0Y3NzLnBsdWdpbigncG9zdGNzcy1jbGVhbmVyJywgKCkgPT4ge1xuICogICByZXR1cm4gKHJvb3QsIHJlc3VsdCkgPT4ge1xuICogICAgIHJlc3VsdC5yb290ID0gcG9zdGNzcy5yb290KClcbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEFzIGEgY29udmVuaWVuY2UsIHBsdWdpbnMgYWxzbyBleHBvc2UgYSBgcHJvY2Vzc2AgbWV0aG9kIHNvIHRoYXQgeW91IGNhbiB1c2VcbiAqIHRoZW0gYXMgc3RhbmRhbG9uZSB0b29scy5cbiAqXG4gKiBgYGBqc1xuICogY2xlYW5lci5wcm9jZXNzKGNzcywgcHJvY2Vzc09wdHMsIHBsdWdpbk9wdHMpXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiBwb3N0Y3NzKFsgY2xlYW5lcihwbHVnaW5PcHRzKSBdKS5wcm9jZXNzKGNzcywgcHJvY2Vzc09wdHMpXG4gKiBgYGBcbiAqXG4gKiBBc3luY2hyb25vdXMgcGx1Z2lucyBzaG91bGQgcmV0dXJuIGEgYFByb21pc2VgIGluc3RhbmNlLlxuICpcbiAqIGBgYGpzXG4gKiBwb3N0Y3NzLnBsdWdpbigncG9zdGNzcy1pbXBvcnQnLCAoKSA9PiB7XG4gKiAgIHJldHVybiAocm9vdCwgcmVzdWx0KSA9PiB7XG4gKiAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gKiAgICAgICBmcy5yZWFkRmlsZSgnYmFzZS5jc3MnLCAoYmFzZSkgPT4ge1xuICogICAgICAgICByb290LnByZXBlbmQoYmFzZSlcbiAqICAgICAgICAgcmVzb2x2ZSgpXG4gKiAgICAgICB9KVxuICogICAgIH0pXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBBZGQgd2FybmluZ3MgdXNpbmcgdGhlIHtAbGluayBOb2RlI3dhcm59IG1ldGhvZC5cbiAqIFNlbmQgZGF0YSB0byBvdGhlciBwbHVnaW5zIHVzaW5nIHRoZSB7QGxpbmsgUmVzdWx0I21lc3NhZ2VzfSBhcnJheS5cbiAqXG4gKiBgYGBqc1xuICogcG9zdGNzcy5wbHVnaW4oJ3Bvc3Rjc3MtY2FuaXVzZS10ZXN0JywgKCkgPT4ge1xuICogICByZXR1cm4gKHJvb3QsIHJlc3VsdCkgPT4ge1xuICogICAgIHJvb3Qud2Fsa0RlY2xzKGRlY2wgPT4ge1xuICogICAgICAgaWYgKCFjYW5pdXNlLnN1cHBvcnQoZGVjbC5wcm9wKSkge1xuICogICAgICAgICBkZWNsLndhcm4ocmVzdWx0LCAnU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCAnICsgZGVjbC5wcm9wKVxuICogICAgICAgfVxuICogICAgIH0pXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgICAgICBQb3N0Q1NTIHBsdWdpbiBuYW1lLiBTYW1lIGFzIGluIGBuYW1lYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgaW4gYHBhY2thZ2UuanNvbmAuIEl0IHdpbGwgYmUgc2F2ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIGBwbHVnaW4ucG9zdGNzc1BsdWdpbmAgcHJvcGVydHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpbml0aWFsaXplciBXaWxsIHJlY2VpdmUgcGx1Z2luIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzaG91bGQgcmV0dXJuIHtAbGluayBwbHVnaW5GdW5jdGlvbn1cbiAqXG4gKiBAcmV0dXJuIHtQbHVnaW59IFBvc3RDU1MgcGx1Z2luLlxuICovcG9zdGNzcy5wbHVnaW49ZnVuY3Rpb24gcGx1Z2luKG5hbWUsaW5pdGlhbGl6ZXIpe2Z1bmN0aW9uIGNyZWF0b3IoKXt2YXIgdHJhbnNmb3JtZXI9aW5pdGlhbGl6ZXIuYXBwbHkodm9pZCAwLGFyZ3VtZW50cyk7dHJhbnNmb3JtZXIucG9zdGNzc1BsdWdpbj1uYW1lO3RyYW5zZm9ybWVyLnBvc3Rjc3NWZXJzaW9uPW5ldyBfcHJvY2Vzc29yW1wiZGVmYXVsdFwiXSgpLnZlcnNpb247cmV0dXJuIHRyYW5zZm9ybWVyO312YXIgY2FjaGU7T2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0b3IsJ3Bvc3Rjc3MnLHtnZXQ6ZnVuY3Rpb24gZ2V0KCl7aWYoIWNhY2hlKWNhY2hlPWNyZWF0b3IoKTtyZXR1cm4gY2FjaGU7fX0pO2NyZWF0b3IucHJvY2Vzcz1mdW5jdGlvbihjc3MscHJvY2Vzc09wdHMscGx1Z2luT3B0cyl7cmV0dXJuIHBvc3Rjc3MoW2NyZWF0b3IocGx1Z2luT3B0cyldKS5wcm9jZXNzKGNzcyxwcm9jZXNzT3B0cyk7fTtyZXR1cm4gY3JlYXRvcjt9Oy8qKlxuICogRGVmYXVsdCBmdW5jdGlvbiB0byBjb252ZXJ0IGEgbm9kZSB0cmVlIGludG8gYSBDU1Mgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgICAgICBTdGFydCBub2RlIGZvciBzdHJpbmdpZmluZy4gVXN1YWxseSB7QGxpbmsgUm9vdH0uXG4gKiBAcGFyYW0ge2J1aWxkZXJ9IGJ1aWxkZXIgRnVuY3Rpb24gdG8gY29uY2F0ZW5hdGUgQ1NTIGZyb20gbm9kZeKAmXMgcGFydHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBnZW5lcmF0ZSBzdHJpbmcgYW5kIHNvdXJjZSBtYXAuXG4gKlxuICogQHJldHVybiB7dm9pZH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL3Bvc3Rjc3Muc3RyaW5naWZ5PV9zdHJpbmdpZnlbXCJkZWZhdWx0XCJdOy8qKlxuICogUGFyc2VzIHNvdXJjZSBjc3MgYW5kIHJldHVybnMgYSBuZXcge0BsaW5rIFJvb3R9IG5vZGUsXG4gKiB3aGljaCBjb250YWlucyB0aGUgc291cmNlIENTUyBub2Rlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3x0b1N0cmluZ30gY3NzICAgU3RyaW5nIHdpdGggaW5wdXQgQ1NTIG9yIGFueSBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRvU3RyaW5nKCkgbWV0aG9kLCBsaWtlIGEgQnVmZmVyXG4gKiBAcGFyYW0ge3Byb2Nlc3NPcHRpb25zfSBbb3B0c10gT3B0aW9ucyB3aXRoIG9ubHkgYGZyb21gIGFuZCBgbWFwYCBrZXlzLlxuICpcbiAqIEByZXR1cm4ge1Jvb3R9IFBvc3RDU1MgQVNULlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTaW1wbGUgQ1NTIGNvbmNhdGVuYXRpb24gd2l0aCBzb3VyY2UgbWFwIHN1cHBvcnRcbiAqIGNvbnN0IHJvb3QxID0gcG9zdGNzcy5wYXJzZShjc3MxLCB7IGZyb206IGZpbGUxIH0pXG4gKiBjb25zdCByb290MiA9IHBvc3Rjc3MucGFyc2UoY3NzMiwgeyBmcm9tOiBmaWxlMiB9KVxuICogcm9vdDEuYXBwZW5kKHJvb3QyKS50b1Jlc3VsdCgpLmNzc1xuICpcbiAqIEBmdW5jdGlvblxuICovcG9zdGNzcy5wYXJzZT1fcGFyc2VbXCJkZWZhdWx0XCJdOy8qKlxuICogQ29udGFpbnMgdGhlIHtAbGluayB2ZW5kb3J9IG1vZHVsZS5cbiAqXG4gKiBAdHlwZSB7dmVuZG9yfVxuICpcbiAqIEBleGFtcGxlXG4gKiBwb3N0Y3NzLnZlbmRvci51bnByZWZpeGVkKCctbW96LXRhYicpIC8vPT4gWyd0YWInXVxuICovcG9zdGNzcy52ZW5kb3I9X3ZlbmRvcltcImRlZmF1bHRcIl07LyoqXG4gKiBDb250YWlucyB0aGUge0BsaW5rIGxpc3R9IG1vZHVsZS5cbiAqXG4gKiBAbWVtYmVyIHtsaXN0fVxuICpcbiAqIEBleGFtcGxlXG4gKiBwb3N0Y3NzLmxpc3Quc3BhY2UoJzVweCBjYWxjKDEwJSArIDVweCknKSAvLz0+IFsnNXB4JywgJ2NhbGMoMTAlICsgNXB4KSddXG4gKi9wb3N0Y3NzLmxpc3Q9X2xpc3RbXCJkZWZhdWx0XCJdOy8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQ29tbWVudH0gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW2RlZmF1bHRzXSBQcm9wZXJ0aWVzIGZvciB0aGUgbmV3IG5vZGUuXG4gKlxuICogQHJldHVybiB7Q29tbWVudH0gTmV3IGNvbW1lbnQgbm9kZVxuICpcbiAqIEBleGFtcGxlXG4gKiBwb3N0Y3NzLmNvbW1lbnQoeyB0ZXh0OiAndGVzdCcgfSlcbiAqL3Bvc3Rjc3MuY29tbWVudD1mdW5jdGlvbihkZWZhdWx0cyl7cmV0dXJuIG5ldyBfY29tbWVudFtcImRlZmF1bHRcIl0oZGVmYXVsdHMpO307LyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBBdFJ1bGV9IG5vZGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtkZWZhdWx0c10gUHJvcGVydGllcyBmb3IgdGhlIG5ldyBub2RlLlxuICpcbiAqIEByZXR1cm4ge0F0UnVsZX0gbmV3IGF0LXJ1bGUgbm9kZVxuICpcbiAqIEBleGFtcGxlXG4gKiBwb3N0Y3NzLmF0UnVsZSh7IG5hbWU6ICdjaGFyc2V0JyB9KS50b1N0cmluZygpIC8vPT4gXCJAY2hhcnNldFwiXG4gKi9wb3N0Y3NzLmF0UnVsZT1mdW5jdGlvbihkZWZhdWx0cyl7cmV0dXJuIG5ldyBfYXRSdWxlW1wiZGVmYXVsdFwiXShkZWZhdWx0cyk7fTsvKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIERlY2xhcmF0aW9ufSBub2RlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGVmYXVsdHNdIFByb3BlcnRpZXMgZm9yIHRoZSBuZXcgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHtEZWNsYXJhdGlvbn0gbmV3IGRlY2xhcmF0aW9uIG5vZGVcbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcy5kZWNsKHsgcHJvcDogJ2NvbG9yJywgdmFsdWU6ICdyZWQnIH0pLnRvU3RyaW5nKCkgLy89PiBcImNvbG9yOiByZWRcIlxuICovcG9zdGNzcy5kZWNsPWZ1bmN0aW9uKGRlZmF1bHRzKXtyZXR1cm4gbmV3IF9kZWNsYXJhdGlvbltcImRlZmF1bHRcIl0oZGVmYXVsdHMpO307LyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBSdWxlfSBub2RlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGVmYXVsdHNdIFByb3BlcnRpZXMgZm9yIHRoZSBuZXcgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHtSdWxlfSBuZXcgcnVsZSBub2RlXG4gKlxuICogQGV4YW1wbGVcbiAqIHBvc3Rjc3MucnVsZSh7IHNlbGVjdG9yOiAnYScgfSkudG9TdHJpbmcoKSAvLz0+IFwiYSB7XFxufVwiXG4gKi9wb3N0Y3NzLnJ1bGU9ZnVuY3Rpb24oZGVmYXVsdHMpe3JldHVybiBuZXcgX3J1bGVbXCJkZWZhdWx0XCJdKGRlZmF1bHRzKTt9Oy8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUm9vdH0gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW2RlZmF1bHRzXSBQcm9wZXJ0aWVzIGZvciB0aGUgbmV3IG5vZGUuXG4gKlxuICogQHJldHVybiB7Um9vdH0gbmV3IHJvb3Qgbm9kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcy5yb290KHsgYWZ0ZXI6ICdcXG4nIH0pLnRvU3RyaW5nKCkgLy89PiBcIlxcblwiXG4gKi9wb3N0Y3NzLnJvb3Q9ZnVuY3Rpb24oZGVmYXVsdHMpe3JldHVybiBuZXcgX3Jvb3RbXCJkZWZhdWx0XCJdKGRlZmF1bHRzKTt9O3ZhciBfZGVmYXVsdD1wb3N0Y3NzO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se1wiLi9hdC1ydWxlXCI6MTY4LFwiLi9jb21tZW50XCI6MTY5LFwiLi9kZWNsYXJhdGlvblwiOjE3MixcIi4vbGlzdFwiOjE3NSxcIi4vcGFyc2VcIjoxNzgsXCIuL3Byb2Nlc3NvclwiOjE4MixcIi4vcm9vdFwiOjE4NCxcIi4vcnVsZVwiOjE4NSxcIi4vc3RyaW5naWZ5XCI6MTg3LFwiLi92ZW5kb3JcIjoxODl9XSwxODE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihCdWZmZXIpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX3NvdXJjZU1hcD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpKTt2YXIgX3BhdGg9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicGF0aFwiKSk7dmFyIF9mcz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJmc1wiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gZnJvbUJhc2U2NChzdHIpe2lmKEJ1ZmZlcil7cmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwnYmFzZTY0JykudG9TdHJpbmcoKTt9ZWxzZXtyZXR1cm4gd2luZG93LmF0b2Ioc3RyKTt9fS8qKlxuICogU291cmNlIG1hcCBpbmZvcm1hdGlvbiBmcm9tIGlucHV0IENTUy5cbiAqIEZvciBleGFtcGxlLCBzb3VyY2UgbWFwIGFmdGVyIFNhc3MgY29tcGlsZXIuXG4gKlxuICogVGhpcyBjbGFzcyB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBzb3VyY2UgbWFwIGluIGlucHV0IENTUyBvciBpbiBmaWxlIHN5c3RlbVxuICogbmVhciBpbnB1dCBmaWxlIChhY2NvcmRpbmcgYGZyb21gIG9wdGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKGNzcywgeyBmcm9tOiAnYS5zYXNzLmNzcycgfSlcbiAqIHJvb3QuaW5wdXQubWFwIC8vPT4gUHJldmlvdXNNYXBcbiAqL3ZhciBQcmV2aW91c01hcD0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXsvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgY3NzICAgIElucHV0IENTUyBzb3VyY2UuXG4gICAqIEBwYXJhbSB7cHJvY2Vzc09wdGlvbnN9IFtvcHRzXSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9IG9wdGlvbnMuXG4gICAqL2Z1bmN0aW9uIFByZXZpb3VzTWFwKGNzcyxvcHRzKXt0aGlzLmxvYWRBbm5vdGF0aW9uKGNzcyk7LyoqXG4gICAgICogV2FzIHNvdXJjZSBtYXAgaW5saW5lZCBieSBkYXRhLXVyaSB0byBpbnB1dCBDU1MuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi90aGlzLmlubGluZT10aGlzLnN0YXJ0V2l0aCh0aGlzLmFubm90YXRpb24sJ2RhdGE6Jyk7dmFyIHByZXY9b3B0cy5tYXA/b3B0cy5tYXAucHJldjp1bmRlZmluZWQ7dmFyIHRleHQ9dGhpcy5sb2FkTWFwKG9wdHMuZnJvbSxwcmV2KTtpZih0ZXh0KXRoaXMudGV4dD10ZXh0O30vKipcbiAgICogQ3JlYXRlIGEgaW5zdGFuY2Ugb2YgYFNvdXJjZU1hcEdlbmVyYXRvcmAgY2xhc3NcbiAgICogZnJvbSB0aGUgYHNvdXJjZS1tYXBgIGxpYnJhcnkgdG8gd29yayB3aXRoIHNvdXJjZSBtYXAgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEl0IGlzIGxhenkgbWV0aG9kLCBzbyBpdCB3aWxsIGNyZWF0ZSBvYmplY3Qgb25seSBvbiBmaXJzdCBjYWxsXG4gICAqIGFuZCB0aGVuIGl0IHdpbGwgdXNlIGNhY2hlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTb3VyY2VNYXBHZW5lcmF0b3J9IE9iamVjdCB3aXRoIHNvdXJjZSBtYXAgaW5mb3JtYXRpb24uXG4gICAqL3ZhciBfcHJvdG89UHJldmlvdXNNYXAucHJvdG90eXBlO19wcm90by5jb25zdW1lcj1mdW5jdGlvbiBjb25zdW1lcigpe2lmKCF0aGlzLmNvbnN1bWVyQ2FjaGUpe3RoaXMuY29uc3VtZXJDYWNoZT1uZXcgX3NvdXJjZU1hcFtcImRlZmF1bHRcIl0uU291cmNlTWFwQ29uc3VtZXIodGhpcy50ZXh0KTt9cmV0dXJuIHRoaXMuY29uc3VtZXJDYWNoZTt9LyoqXG4gICAqIERvZXMgc291cmNlIG1hcCBjb250YWlucyBgc291cmNlc0NvbnRlbnRgIHdpdGggaW5wdXQgc291cmNlIHRleHQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGBzb3VyY2VzQ29udGVudGAgcHJlc2VudC5cbiAgICovO19wcm90by53aXRoQ29udGVudD1mdW5jdGlvbiB3aXRoQ29udGVudCgpe3JldHVybiEhKHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudCYmdGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50Lmxlbmd0aD4wKTt9O19wcm90by5zdGFydFdpdGg9ZnVuY3Rpb24gc3RhcnRXaXRoKHN0cmluZyxzdGFydCl7aWYoIXN0cmluZylyZXR1cm4gZmFsc2U7cmV0dXJuIHN0cmluZy5zdWJzdHIoMCxzdGFydC5sZW5ndGgpPT09c3RhcnQ7fTtfcHJvdG8uZ2V0QW5ub3RhdGlvblVSTD1mdW5jdGlvbiBnZXRBbm5vdGF0aW9uVVJMKHNvdXJjZU1hcFN0cmluZyl7cmV0dXJuIHNvdXJjZU1hcFN0cmluZy5tYXRjaCgvXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0oLiopXFxzKlxcKlxcLy8pWzFdLnRyaW0oKTt9O19wcm90by5sb2FkQW5ub3RhdGlvbj1mdW5jdGlvbiBsb2FkQW5ub3RhdGlvbihjc3Mpe3ZhciBhbm5vdGF0aW9ucz1jc3MubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9KC4qKVxccypcXCpcXC8vbWcpO2lmKGFubm90YXRpb25zJiZhbm5vdGF0aW9ucy5sZW5ndGg+MCl7Ly8gTG9jYXRlIHRoZSBsYXN0IHNvdXJjZU1hcHBpbmdVUkwgdG8gYXZvaWQgcGlja2luZyB1cFxuLy8gc291cmNlTWFwcGluZ1VSTHMgZnJvbSBjb21tZW50cywgc3RyaW5ncywgZXRjLlxudmFyIGxhc3RBbm5vdGF0aW9uPWFubm90YXRpb25zW2Fubm90YXRpb25zLmxlbmd0aC0xXTtpZihsYXN0QW5ub3RhdGlvbil7dGhpcy5hbm5vdGF0aW9uPXRoaXMuZ2V0QW5ub3RhdGlvblVSTChsYXN0QW5ub3RhdGlvbik7fX19O19wcm90by5kZWNvZGVJbmxpbmU9ZnVuY3Rpb24gZGVjb2RlSW5saW5lKHRleHQpe3ZhciBiYXNlQ2hhcnNldFVyaT0vXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84O2Jhc2U2NCwvO3ZhciBiYXNlVXJpPS9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247YmFzZTY0LC87dmFyIHVyaT0nZGF0YTphcHBsaWNhdGlvbi9qc29uLCc7aWYodGhpcy5zdGFydFdpdGgodGV4dCx1cmkpKXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHRleHQuc3Vic3RyKHVyaS5sZW5ndGgpKTt9aWYoYmFzZUNoYXJzZXRVcmkudGVzdCh0ZXh0KXx8YmFzZVVyaS50ZXN0KHRleHQpKXtyZXR1cm4gZnJvbUJhc2U2NCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO312YXIgZW5jb2Rpbmc9dGV4dC5tYXRjaCgvZGF0YTphcHBsaWNhdGlvblxcL2pzb247KFteLF0rKSwvKVsxXTt0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNvdXJjZSBtYXAgZW5jb2RpbmcgJytlbmNvZGluZyk7fTtfcHJvdG8ubG9hZE1hcD1mdW5jdGlvbiBsb2FkTWFwKGZpbGUscHJldil7aWYocHJldj09PWZhbHNlKXJldHVybiBmYWxzZTtpZihwcmV2KXtpZih0eXBlb2YgcHJldj09PSdzdHJpbmcnKXtyZXR1cm4gcHJldjt9ZWxzZSBpZih0eXBlb2YgcHJldj09PSdmdW5jdGlvbicpe3ZhciBwcmV2UGF0aD1wcmV2KGZpbGUpO2lmKHByZXZQYXRoJiZfZnNbXCJkZWZhdWx0XCJdLmV4aXN0c1N5bmMmJl9mc1tcImRlZmF1bHRcIl0uZXhpc3RzU3luYyhwcmV2UGF0aCkpe3JldHVybiBfZnNbXCJkZWZhdWx0XCJdLnJlYWRGaWxlU3luYyhwcmV2UGF0aCwndXRmLTgnKS50b1N0cmluZygpLnRyaW0oKTt9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2FkIHByZXZpb3VzIHNvdXJjZSBtYXA6ICcrcHJldlBhdGgudG9TdHJpbmcoKSk7fX1lbHNlIGlmKHByZXYgaW5zdGFuY2VvZiBfc291cmNlTWFwW1wiZGVmYXVsdFwiXS5Tb3VyY2VNYXBDb25zdW1lcil7cmV0dXJuIF9zb3VyY2VNYXBbXCJkZWZhdWx0XCJdLlNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwKHByZXYpLnRvU3RyaW5nKCk7fWVsc2UgaWYocHJldiBpbnN0YW5jZW9mIF9zb3VyY2VNYXBbXCJkZWZhdWx0XCJdLlNvdXJjZU1hcEdlbmVyYXRvcil7cmV0dXJuIHByZXYudG9TdHJpbmcoKTt9ZWxzZSBpZih0aGlzLmlzTWFwKHByZXYpKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJldik7fWVsc2V7dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwcmV2aW91cyBzb3VyY2UgbWFwIGZvcm1hdDogJytwcmV2LnRvU3RyaW5nKCkpO319ZWxzZSBpZih0aGlzLmlubGluZSl7cmV0dXJuIHRoaXMuZGVjb2RlSW5saW5lKHRoaXMuYW5ub3RhdGlvbik7fWVsc2UgaWYodGhpcy5hbm5vdGF0aW9uKXt2YXIgbWFwPXRoaXMuYW5ub3RhdGlvbjtpZihmaWxlKW1hcD1fcGF0aFtcImRlZmF1bHRcIl0uam9pbihfcGF0aFtcImRlZmF1bHRcIl0uZGlybmFtZShmaWxlKSxtYXApO3RoaXMucm9vdD1fcGF0aFtcImRlZmF1bHRcIl0uZGlybmFtZShtYXApO2lmKF9mc1tcImRlZmF1bHRcIl0uZXhpc3RzU3luYyYmX2ZzW1wiZGVmYXVsdFwiXS5leGlzdHNTeW5jKG1hcCkpe3JldHVybiBfZnNbXCJkZWZhdWx0XCJdLnJlYWRGaWxlU3luYyhtYXAsJ3V0Zi04JykudG9TdHJpbmcoKS50cmltKCk7fWVsc2V7cmV0dXJuIGZhbHNlO319fTtfcHJvdG8uaXNNYXA9ZnVuY3Rpb24gaXNNYXAobWFwKXtpZihfdHlwZW9mKG1hcCkhPT0nb2JqZWN0JylyZXR1cm4gZmFsc2U7cmV0dXJuIHR5cGVvZiBtYXAubWFwcGluZ3M9PT0nc3RyaW5nJ3x8dHlwZW9mIG1hcC5fbWFwcGluZ3M9PT0nc3RyaW5nJzt9O3JldHVybiBQcmV2aW91c01hcDt9KCk7dmFyIF9kZWZhdWx0PVByZXZpb3VzTWFwO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcik7fSx7XCJidWZmZXJcIjozLFwiZnNcIjoyLFwicGF0aFwiOjE2NyxcInNvdXJjZS1tYXBcIjoyMDd9XSwxODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihwcm9jZXNzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9sYXp5UmVzdWx0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGF6eS1yZXN1bHRcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian07fS8qKlxuICogQ29udGFpbnMgcGx1Z2lucyB0byBwcm9jZXNzIENTUy4gQ3JlYXRlIG9uZSBgUHJvY2Vzc29yYCBpbnN0YW5jZSxcbiAqIGluaXRpYWxpemUgaXRzIHBsdWdpbnMsIGFuZCB0aGVuIHVzZSB0aGF0IGluc3RhbmNlIG9uIG51bWVyb3VzIENTUyBmaWxlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcHJvY2Vzc29yID0gcG9zdGNzcyhbYXV0b3ByZWZpeGVyLCBwcmVjc3NdKVxuICogcHJvY2Vzc29yLnByb2Nlc3MoY3NzMSkudGhlbihyZXN1bHQgPT4gY29uc29sZS5sb2cocmVzdWx0LmNzcykpXG4gKiBwcm9jZXNzb3IucHJvY2Vzcyhjc3MyKS50aGVuKHJlc3VsdCA9PiBjb25zb2xlLmxvZyhyZXN1bHQuY3NzKSlcbiAqL3ZhciBQcm9jZXNzb3I9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7LyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPFBsdWdpbnxwbHVnaW5GdW5jdGlvbj58UHJvY2Vzc29yfSBwbHVnaW5zIFBvc3RDU1MgcGx1Z2lucy5cbiAgICogICAgICAgIFNlZSB7QGxpbmsgUHJvY2Vzc29yI3VzZX0gZm9yIHBsdWdpbiBmb3JtYXQuXG4gICAqL2Z1bmN0aW9uIFByb2Nlc3NvcihwbHVnaW5zKXtpZihwbHVnaW5zPT09dm9pZCAwKXtwbHVnaW5zPVtdO30vKipcbiAgICAgKiBDdXJyZW50IFBvc3RDU1MgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlmIChyZXN1bHQucHJvY2Vzc29yLnZlcnNpb24uc3BsaXQoJy4nKVswXSAhPT0gJzYnKSB7XG4gICAgICogICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgcGx1Z2luIHdvcmtzIG9ubHkgd2l0aCBQb3N0Q1NTIDYnKVxuICAgICAqIH1cbiAgICAgKi90aGlzLnZlcnNpb249JzcuMC4zMSc7LyoqXG4gICAgICogUGx1Z2lucyBhZGRlZCB0byB0aGlzIHByb2Nlc3Nvci5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtwbHVnaW5GdW5jdGlvbltdfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBwcm9jZXNzb3IgPSBwb3N0Y3NzKFthdXRvcHJlZml4ZXIsIHByZWNzc10pXG4gICAgICogcHJvY2Vzc29yLnBsdWdpbnMubGVuZ3RoIC8vPT4gMlxuICAgICAqL3RoaXMucGx1Z2lucz10aGlzLm5vcm1hbGl6ZShwbHVnaW5zKTt9LyoqXG4gICAqIEFkZHMgYSBwbHVnaW4gdG8gYmUgdXNlZCBhcyBhIENTUyBwcm9jZXNzb3IuXG4gICAqXG4gICAqIFBvc3RDU1MgcGx1Z2luIGNhbiBiZSBpbiA0IGZvcm1hdHM6XG4gICAqICogQSBwbHVnaW4gY3JlYXRlZCBieSB7QGxpbmsgcG9zdGNzcy5wbHVnaW59IG1ldGhvZC5cbiAgICogKiBBIGZ1bmN0aW9uLiBQb3N0Q1NTIHdpbGwgcGFzcyB0aGUgZnVuY3Rpb24gYSBAe2xpbmsgUm9vdH1cbiAgICogICBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIGN1cnJlbnQge0BsaW5rIFJlc3VsdH0gaW5zdGFuY2VcbiAgICogICBhcyB0aGUgc2Vjb25kLlxuICAgKiAqIEFuIG9iamVjdCB3aXRoIGEgYHBvc3Rjc3NgIG1ldGhvZC4gUG9zdENTUyB3aWxsIHVzZSB0aGF0IG1ldGhvZFxuICAgKiAgIGFzIGRlc2NyaWJlZCBpbiAjMi5cbiAgICogKiBBbm90aGVyIHtAbGluayBQcm9jZXNzb3J9IGluc3RhbmNlLiBQb3N0Q1NTIHdpbGwgY29weSBwbHVnaW5zXG4gICAqICAgZnJvbSB0aGF0IGluc3RhbmNlIGludG8gdGhpcyBvbmUuXG4gICAqXG4gICAqIFBsdWdpbnMgY2FuIGFsc28gYmUgYWRkZWQgYnkgcGFzc2luZyB0aGVtIGFzIGFyZ3VtZW50cyB3aGVuIGNyZWF0aW5nXG4gICAqIGEgYHBvc3Rjc3NgIGluc3RhbmNlIChzZWUgW2Bwb3N0Y3NzKHBsdWdpbnMpYF0pLlxuICAgKlxuICAgKiBBc3luY2hyb25vdXMgcGx1Z2lucyBzaG91bGQgcmV0dXJuIGEgYFByb21pc2VgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsdWdpbnxwbHVnaW5GdW5jdGlvbnxQcm9jZXNzb3J9IHBsdWdpbiBQb3N0Q1NTIHBsdWdpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciB7QGxpbmsgUHJvY2Vzc29yfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBsdWdpbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHByb2Nlc3NvciA9IHBvc3Rjc3MoKVxuICAgKiAgIC51c2UoYXV0b3ByZWZpeGVyKVxuICAgKiAgIC51c2UocHJlY3NzKVxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9jZXNzZXN9IEN1cnJlbnQgcHJvY2Vzc29yIHRvIG1ha2UgbWV0aG9kcyBjaGFpbi5cbiAgICovdmFyIF9wcm90bz1Qcm9jZXNzb3IucHJvdG90eXBlO19wcm90by51c2U9ZnVuY3Rpb24gdXNlKHBsdWdpbil7dGhpcy5wbHVnaW5zPXRoaXMucGx1Z2lucy5jb25jYXQodGhpcy5ub3JtYWxpemUoW3BsdWdpbl0pKTtyZXR1cm4gdGhpczt9LyoqXG4gICAqIFBhcnNlcyBzb3VyY2UgQ1NTIGFuZCByZXR1cm5zIGEge0BsaW5rIExhenlSZXN1bHR9IFByb21pc2UgcHJveHkuXG4gICAqIEJlY2F1c2Ugc29tZSBwbHVnaW5zIGNhbiBiZSBhc3luY2hyb25vdXMgaXQgZG9lc27igJl0IG1ha2VcbiAgICogYW55IHRyYW5zZm9ybWF0aW9ucy4gVHJhbnNmb3JtYXRpb25zIHdpbGwgYmUgYXBwbGllZFxuICAgKiBpbiB0aGUge0BsaW5rIExhenlSZXN1bHR9IG1ldGhvZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHRvU3RyaW5nfFJlc3VsdH0gY3NzIFN0cmluZyB3aXRoIGlucHV0IENTUyBvciBhbnkgb2JqZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggYSBgdG9TdHJpbmcoKWAgbWV0aG9kLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWtlIGEgQnVmZmVyLiBPcHRpb25hbGx5LCBzZW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEge0BsaW5rIFJlc3VsdH0gaW5zdGFuY2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHRoZSBwcm9jZXNzb3Igd2lsbCB0YWtlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB7QGxpbmsgUm9vdH0gZnJvbSBpdC5cbiAgICogQHBhcmFtIHtwcm9jZXNzT3B0aW9uc30gW29wdHNdICAgICAgT3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB7TGF6eVJlc3VsdH0gUHJvbWlzZSBwcm94eS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcHJvY2Vzc29yLnByb2Nlc3MoY3NzLCB7IGZyb206ICdhLmNzcycsIHRvOiAnYS5vdXQuY3NzJyB9KVxuICAgKiAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAqICAgICAgY29uc29sZS5sb2cocmVzdWx0LmNzcylcbiAgICogICB9KVxuICAgKi87X3Byb3RvLnByb2Nlc3M9ZnVuY3Rpb24oX3Byb2Nlc3Mpe2Z1bmN0aW9uIHByb2Nlc3MoX3gpe3JldHVybiBfcHJvY2Vzcy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fXByb2Nlc3MudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gX3Byb2Nlc3MudG9TdHJpbmcoKTt9O3JldHVybiBwcm9jZXNzO30oZnVuY3Rpb24oY3NzLG9wdHMpe2lmKG9wdHM9PT12b2lkIDApe29wdHM9e307fWlmKHRoaXMucGx1Z2lucy5sZW5ndGg9PT0wJiZvcHRzLnBhcnNlcj09PW9wdHMuc3RyaW5naWZpZXIpe2lmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09J3Byb2R1Y3Rpb24nKXtpZih0eXBlb2YgY29uc29sZSE9PSd1bmRlZmluZWQnJiZjb25zb2xlLndhcm4pe2NvbnNvbGUud2FybignWW91IGRpZCBub3Qgc2V0IGFueSBwbHVnaW5zLCBwYXJzZXIsIG9yIHN0cmluZ2lmaWVyLiAnKydSaWdodCBub3csIFBvc3RDU1MgZG9lcyBub3RoaW5nLiBQaWNrIHBsdWdpbnMgZm9yIHlvdXIgY2FzZSAnKydvbiBodHRwczovL3d3dy5wb3N0Y3NzLnBhcnRzLyBhbmQgdXNlIHRoZW0gaW4gcG9zdGNzcy5jb25maWcuanMuJyk7fX19cmV0dXJuIG5ldyBfbGF6eVJlc3VsdFtcImRlZmF1bHRcIl0odGhpcyxjc3Msb3B0cyk7fSk7X3Byb3RvLm5vcm1hbGl6ZT1mdW5jdGlvbiBub3JtYWxpemUocGx1Z2lucyl7dmFyIG5vcm1hbGl6ZWQ9W107Zm9yKHZhciBfaXRlcmF0b3I9cGx1Z2lucyxfaXNBcnJheT1BcnJheS5pc0FycmF5KF9pdGVyYXRvciksX2k9MCxfaXRlcmF0b3I9X2lzQXJyYXk/X2l0ZXJhdG9yOl9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY7aWYoX2lzQXJyYXkpe2lmKF9pPj1faXRlcmF0b3IubGVuZ3RoKWJyZWFrO19yZWY9X2l0ZXJhdG9yW19pKytdO31lbHNle19pPV9pdGVyYXRvci5uZXh0KCk7aWYoX2kuZG9uZSlicmVhaztfcmVmPV9pLnZhbHVlO312YXIgaT1fcmVmO2lmKGkucG9zdGNzcylpPWkucG9zdGNzcztpZihfdHlwZW9mKGkpPT09J29iamVjdCcmJkFycmF5LmlzQXJyYXkoaS5wbHVnaW5zKSl7bm9ybWFsaXplZD1ub3JtYWxpemVkLmNvbmNhdChpLnBsdWdpbnMpO31lbHNlIGlmKHR5cGVvZiBpPT09J2Z1bmN0aW9uJyl7bm9ybWFsaXplZC5wdXNoKGkpO31lbHNlIGlmKF90eXBlb2YoaSk9PT0nb2JqZWN0JyYmKGkucGFyc2V8fGkuc3RyaW5naWZ5KSl7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpe3Rocm93IG5ldyBFcnJvcignUG9zdENTUyBzeW50YXhlcyBjYW5ub3QgYmUgdXNlZCBhcyBwbHVnaW5zLiBJbnN0ZWFkLCBwbGVhc2UgdXNlICcrJ29uZSBvZiB0aGUgc3ludGF4L3BhcnNlci9zdHJpbmdpZmllciBvcHRpb25zIGFzIG91dGxpbmVkICcrJ2luIHlvdXIgUG9zdENTUyBydW5uZXIgZG9jdW1lbnRhdGlvbi4nKTt9fWVsc2V7dGhyb3cgbmV3IEVycm9yKGkrJyBpcyBub3QgYSBQb3N0Q1NTIHBsdWdpbicpO319cmV0dXJuIG5vcm1hbGl6ZWQ7fTtyZXR1cm4gUHJvY2Vzc29yO30oKTt2YXIgX2RlZmF1bHQ9UHJvY2Vzc29yOy8qKlxuICogQGNhbGxiYWNrIGJ1aWxkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJ0ICAgICAgICAgIFBhcnQgb2YgZ2VuZXJhdGVkIENTUyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICogQHBhcmFtIHtOb2RlfSAgIG5vZGUgICAgICAgICAgQVNUIG5vZGUuXG4gKiBAcGFyYW0ge1wic3RhcnRcInxcImVuZFwifSBbdHlwZV0gTm9kZeKAmXMgcGFydCB0eXBlLlxuICovIC8qKlxuICogQGNhbGxiYWNrIHBhcnNlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHRvU3RyaW5nfSBjc3MgICBTdHJpbmcgd2l0aCBpbnB1dCBDU1Mgb3IgYW55IG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdG9TdHJpbmcoKSBtZXRob2QsIGxpa2UgYSBCdWZmZXIuXG4gKiBAcGFyYW0ge3Byb2Nlc3NPcHRpb25zfSBbb3B0c10gT3B0aW9ucyB3aXRoIG9ubHkgYGZyb21gIGFuZCBgbWFwYCBrZXlzLlxuICpcbiAqIEByZXR1cm4ge1Jvb3R9IFBvc3RDU1MgQVNUXG4gKi8gLyoqXG4gKiBAY2FsbGJhY2sgc3RyaW5naWZpZXJcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgICAgICAgU3RhcnQgbm9kZSBmb3Igc3RyaW5naWZpbmcuIFVzdWFsbHkge0BsaW5rIFJvb3R9LlxuICogQHBhcmFtIHtidWlsZGVyfSBidWlsZGVyIEZ1bmN0aW9uIHRvIGNvbmNhdGVuYXRlIENTUyBmcm9tIG5vZGXigJlzIHBhcnRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgZ2VuZXJhdGUgc3RyaW5nIGFuZCBzb3VyY2UgbWFwLlxuICpcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi8gLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBzeW50YXhcbiAqIEBwcm9wZXJ0eSB7cGFyc2VyfSBwYXJzZSAgICAgICAgICBGdW5jdGlvbiB0byBnZW5lcmF0ZSBBU1QgYnkgc3RyaW5nLlxuICogQHByb3BlcnR5IHtzdHJpbmdpZmllcn0gc3RyaW5naWZ5IEZ1bmN0aW9uIHRvIGdlbmVyYXRlIHN0cmluZyBieSBBU1QuXG4gKi8gLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSB0b1N0cmluZ1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gdG9TdHJpbmdcbiAqLyAvKipcbiAqIEBjYWxsYmFjayBwbHVnaW5GdW5jdGlvblxuICogQHBhcmFtIHtSb290fSByb290ICAgICBQYXJzZWQgaW5wdXQgQ1NTLlxuICogQHBhcmFtIHtSZXN1bHR9IHJlc3VsdCBSZXN1bHQgdG8gc2V0IHdhcm5pbmdzIG9yIGNoZWNrIG90aGVyIHBsdWdpbnMuXG4gKi8gLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQbHVnaW5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHBvc3Rjc3MgUG9zdENTUyBwbHVnaW4gZnVuY3Rpb24uXG4gKi8gLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBwcm9jZXNzT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGZyb20gICAgICAgICAgICAgVGhlIHBhdGggb2YgdGhlIENTUyBzb3VyY2UgZmlsZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBzaG91bGQgYWx3YXlzIHNldCBgZnJvbWAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWNhdXNlIGl0IGlzIHVzZWQgaW4gc291cmNlIG1hcFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbiBhbmQgc3ludGF4IGVycm9yIG1lc3NhZ2VzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRvICAgICAgICAgICAgICAgVGhlIHBhdGggd2hlcmUgeW914oCZbGwgcHV0IHRoZSBvdXRwdXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENTUyBmaWxlLiBZb3Ugc2hvdWxkIGFsd2F5cyBzZXQgYHRvYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gZ2VuZXJhdGUgY29ycmVjdCBzb3VyY2UgbWFwcy5cbiAqIEBwcm9wZXJ0eSB7cGFyc2VyfSBwYXJzZXIgICAgICAgICAgIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIEFTVCBieSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge3N0cmluZ2lmaWVyfSBzdHJpbmdpZmllciBDbGFzcyB0byBnZW5lcmF0ZSBzdHJpbmcgYnkgQVNULlxuICogQHByb3BlcnR5IHtzeW50YXh9IHN5bnRheCAgICAgICAgICAgT2JqZWN0IHdpdGggYHBhcnNlYCBhbmQgYHN0cmluZ2lmeWAuXG4gKiBAcHJvcGVydHkge29iamVjdH0gbWFwICAgICAgICAgICAgICBTb3VyY2UgbWFwIG9wdGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG1hcC5pbmxpbmUgICAgICAgICAgICAgICAgICAgIERvZXMgc291cmNlIG1hcCBzaG91bGRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgZW1iZWRkZWQgaW4gdGhlIG91dHB1dFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDU1MgYXMgYSBiYXNlNjQtZW5jb2RlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd8b2JqZWN0fGZhbHNlfGZ1bmN0aW9ufSBtYXAucHJldiBTb3VyY2UgbWFwIGNvbnRlbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBhIHByZXZpb3VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Npbmcgc3RlcFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZm9yIGV4YW1wbGUsIFNhc3MpLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3N0Q1NTIHdpbGwgdHJ5IHRvIGZpbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgbWFwIGF1dG9tYXRpY2FsbHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvIHlvdSBjb3VsZCBkaXNhYmxlIGl0IGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBmYWxzZWAgdmFsdWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG1hcC5zb3VyY2VzQ29udGVudCAgICAgICAgICAgIERvZXMgUG9zdENTUyBzaG91bGQgc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvcmlnaW4gY29udGVudCB0byBtYXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xmYWxzZX0gbWFwLmFubm90YXRpb24gICAgICAgICAgIERvZXMgUG9zdENTUyBzaG91bGQgc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb24gY29tbWVudCB0byBtYXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWFwLmZyb20gICAgICAgICAgICAgICAgICAgICAgIE92ZXJyaWRlIGBmcm9tYCBpbiBtYXDigJlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXNgLlxuICovZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpO30se1wiLi9sYXp5LXJlc3VsdFwiOjE3NCxcIl9wcm9jZXNzXCI6MTkyfV0sMTgzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF93YXJuaW5nPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vd2FybmluZ1wiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fGZhbHNlO2Rlc2NyaXB0b3IuY29uZmlndXJhYmxlPXRydWU7aWYoXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvcilkZXNjcmlwdG9yLndyaXRhYmxlPXRydWU7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKTt9fWZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtpZihwcm90b1Byb3BzKV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKTtpZihzdGF0aWNQcm9wcylfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO30vKipcbiAqIFByb3ZpZGVzIHRoZSByZXN1bHQgb2YgdGhlIFBvc3RDU1MgdHJhbnNmb3JtYXRpb25zLlxuICpcbiAqIEEgUmVzdWx0IGluc3RhbmNlIGlzIHJldHVybmVkIGJ5IHtAbGluayBMYXp5UmVzdWx0I3RoZW59XG4gKiBvciB7QGxpbmsgUm9vdCN0b1Jlc3VsdH0gbWV0aG9kcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcyhbYXV0b3ByZWZpeGVyXSkucHJvY2Vzcyhjc3MpLnRoZW4ocmVzdWx0ID0+IHtcbiAqICBjb25zb2xlLmxvZyhyZXN1bHQuY3NzKVxuICogfSlcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcmVzdWx0MiA9IHBvc3Rjc3MucGFyc2UoY3NzKS50b1Jlc3VsdCgpXG4gKi92YXIgUmVzdWx0PS8qI19fUFVSRV9fKi9mdW5jdGlvbigpey8qKlxuICAgKiBAcGFyYW0ge1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIFByb2Nlc3NvciB1c2VkIGZvciB0aGlzIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0ge1Jvb3R9ICAgICAgcm9vdCAgICAgIFJvb3Qgbm9kZSBhZnRlciBhbGwgdHJhbnNmb3JtYXRpb25zLlxuICAgKiBAcGFyYW0ge3Byb2Nlc3NPcHRpb25zfSBvcHRzIE9wdGlvbnMgZnJvbSB0aGUge0BsaW5rIFByb2Nlc3NvciNwcm9jZXNzfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIHtAbGluayBSb290I3RvUmVzdWx0fS5cbiAgICovZnVuY3Rpb24gUmVzdWx0KHByb2Nlc3Nvcixyb290LG9wdHMpey8qKlxuICAgICAqIFRoZSBQcm9jZXNzb3IgaW5zdGFuY2UgdXNlZCBmb3IgdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtQcm9jZXNzb3J9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGZvciAoY29uc3QgcGx1Z2luIG9mIHJlc3VsdC5wcm9jZXNzb3IucGx1Z2lucykge1xuICAgICAqICAgaWYgKHBsdWdpbi5wb3N0Y3NzUGx1Z2luID09PSAncG9zdGNzcy1iYWQnKSB7XG4gICAgICogICAgIHRocm93ICdwb3N0Y3NzLWdvb2QgaXMgaW5jb21wYXRpYmxlIHdpdGggcG9zdGNzcy1iYWQnXG4gICAgICogICB9XG4gICAgICogfSlcbiAgICAgKi90aGlzLnByb2Nlc3Nvcj1wcm9jZXNzb3I7LyoqXG4gICAgICogQ29udGFpbnMgbWVzc2FnZXMgZnJvbSBwbHVnaW5zIChlLmcuLCB3YXJuaW5ncyBvciBjdXN0b20gbWVzc2FnZXMpLlxuICAgICAqIEVhY2ggbWVzc2FnZSBzaG91bGQgaGF2ZSB0eXBlIGFuZCBwbHVnaW4gcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNZXNzYWdlW119XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHBvc3Rjc3MucGx1Z2luKCdwb3N0Y3NzLW1pbi1icm93c2VyJywgKCkgPT4ge1xuICAgICAqICAgcmV0dXJuIChyb290LCByZXN1bHQpID0+IHtcbiAgICAgKiAgICAgY29uc3QgYnJvd3NlcnMgPSBkZXRlY3RNaW5Ccm93c2Vyc0J5Q2FuSVVzZShyb290KVxuICAgICAqICAgICByZXN1bHQubWVzc2FnZXMucHVzaCh7XG4gICAgICogICAgICAgdHlwZTogJ21pbi1icm93c2VyJyxcbiAgICAgKiAgICAgICBwbHVnaW46ICdwb3N0Y3NzLW1pbi1icm93c2VyJyxcbiAgICAgKiAgICAgICBicm93c2Vyc1xuICAgICAqICAgICB9KVxuICAgICAqICAgfVxuICAgICAqIH0pXG4gICAgICovdGhpcy5tZXNzYWdlcz1bXTsvKipcbiAgICAgKiBSb290IG5vZGUgYWZ0ZXIgYWxsIHRyYW5zZm9ybWF0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtSb290fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiByb290LnRvUmVzdWx0KCkucm9vdCA9PT0gcm9vdFxuICAgICAqL3RoaXMucm9vdD1yb290Oy8qKlxuICAgICAqIE9wdGlvbnMgZnJvbSB0aGUge0BsaW5rIFByb2Nlc3NvciNwcm9jZXNzfSBvciB7QGxpbmsgUm9vdCN0b1Jlc3VsdH0gY2FsbFxuICAgICAqIHRoYXQgcHJvZHVjZWQgdGhpcyBSZXN1bHQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7cHJvY2Vzc09wdGlvbnN9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHJvb3QudG9SZXN1bHQob3B0cykub3B0cyA9PT0gb3B0c1xuICAgICAqL3RoaXMub3B0cz1vcHRzOy8qKlxuICAgICAqIEEgQ1NTIHN0cmluZyByZXByZXNlbnRpbmcgb2Yge0BsaW5rIFJlc3VsdCNyb290fS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHBvc3Rjc3MucGFyc2UoJ2F7fScpLnRvUmVzdWx0KCkuY3NzIC8vPT4gXCJhe31cIlxuICAgICAqL3RoaXMuY3NzPXVuZGVmaW5lZDsvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiBgU291cmNlTWFwR2VuZXJhdG9yYCBjbGFzcyBmcm9tIHRoZSBgc291cmNlLW1hcGAgbGlicmFyeSxcbiAgICAgKiByZXByZXNlbnRpbmcgY2hhbmdlcyB0byB0aGUge0BsaW5rIFJlc3VsdCNyb290fSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTb3VyY2VNYXBHZW5lcmF0b3J9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHJlc3VsdC5tYXAudG9KU09OKCkgLy89PiB7IHZlcnNpb246IDMsIGZpbGU6ICdhLmNzcycsIOKApiB9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlmIChyZXN1bHQubWFwKSB7XG4gICAgICogICBmcy53cml0ZUZpbGVTeW5jKHJlc3VsdC5vcHRzLnRvICsgJy5tYXAnLCByZXN1bHQubWFwLnRvU3RyaW5nKCkpXG4gICAgICogfVxuICAgICAqL3RoaXMubWFwPXVuZGVmaW5lZDt9LyoqXG4gICAqIFJldHVybnMgZm9yIEB7bGluayBSZXN1bHQjY3NzfSBjb250ZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByZXN1bHQgKyAnJyA9PT0gcmVzdWx0LmNzc1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRpbmcgb2Yge0BsaW5rIFJlc3VsdCNyb290fS5cbiAgICovdmFyIF9wcm90bz1SZXN1bHQucHJvdG90eXBlO19wcm90by50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3JldHVybiB0aGlzLmNzczt9LyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFdhcm5pbmd9IGFuZCBhZGRzIGl0XG4gICAqIHRvIHtAbGluayBSZXN1bHQjbWVzc2FnZXN9LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgICAgICAgV2FybmluZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdICAgICAgV2FybmluZyBvcHRpb25zLlxuICAgKiBAcGFyYW0ge05vZGV9ICAgb3B0cy5ub2RlICAgQ1NTIG5vZGUgdGhhdCBjYXVzZWQgdGhlIHdhcm5pbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndvcmQgICBXb3JkIGluIENTUyBzb3VyY2UgdGhhdCBjYXVzZWQgdGhlIHdhcm5pbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmluZGV4ICBJbmRleCBpbiBDU1Mgbm9kZSBzdHJpbmcgdGhhdCBjYXVzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB3YXJuaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5wbHVnaW4gTmFtZSBvZiB0aGUgcGx1Z2luIHRoYXQgY3JlYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3YXJuaW5nLiB7QGxpbmsgUmVzdWx0I3dhcm59IGZpbGxzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHByb3BlcnR5IGF1dG9tYXRpY2FsbHkuXG4gICAqXG4gICAqIEByZXR1cm4ge1dhcm5pbmd9IENyZWF0ZWQgd2FybmluZy5cbiAgICovO19wcm90by53YXJuPWZ1bmN0aW9uIHdhcm4odGV4dCxvcHRzKXtpZihvcHRzPT09dm9pZCAwKXtvcHRzPXt9O31pZighb3B0cy5wbHVnaW4pe2lmKHRoaXMubGFzdFBsdWdpbiYmdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW4pe29wdHMucGx1Z2luPXRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luO319dmFyIHdhcm5pbmc9bmV3IF93YXJuaW5nW1wiZGVmYXVsdFwiXSh0ZXh0LG9wdHMpO3RoaXMubWVzc2FnZXMucHVzaCh3YXJuaW5nKTtyZXR1cm4gd2FybmluZzt9LyoqXG4gICAgICogUmV0dXJucyB3YXJuaW5ncyBmcm9tIHBsdWdpbnMuIEZpbHRlcnMge0BsaW5rIFdhcm5pbmd9IGluc3RhbmNlc1xuICAgICAqIGZyb20ge0BsaW5rIFJlc3VsdCNtZXNzYWdlc30uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHJlc3VsdC53YXJuaW5ncygpLmZvckVhY2god2FybiA9PiB7XG4gICAgICogICBjb25zb2xlLndhcm4od2Fybi50b1N0cmluZygpKVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtXYXJuaW5nW119IFdhcm5pbmdzIGZyb20gcGx1Z2lucy5cbiAgICAgKi87X3Byb3RvLndhcm5pbmdzPWZ1bmN0aW9uIHdhcm5pbmdzKCl7cmV0dXJuIHRoaXMubWVzc2FnZXMuZmlsdGVyKGZ1bmN0aW9uKGkpe3JldHVybiBpLnR5cGU9PT0nd2FybmluZyc7fSk7fS8qKlxuICAgKiBBbiBhbGlhcyBmb3IgdGhlIHtAbGluayBSZXN1bHQjY3NzfSBwcm9wZXJ0eS5cbiAgICogVXNlIGl0IHdpdGggc3ludGF4ZXMgdGhhdCBnZW5lcmF0ZSBub24tQ1NTIG91dHB1dC5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcmVzdWx0LmNzcyA9PT0gcmVzdWx0LmNvbnRlbnRcbiAgICovO19jcmVhdGVDbGFzcyhSZXN1bHQsW3trZXk6XCJjb250ZW50XCIsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLmNzczt9fV0pO3JldHVybiBSZXN1bHQ7fSgpO3ZhciBfZGVmYXVsdD1SZXN1bHQ7LyoqXG4gKiBAdHlwZWRlZiAge29iamVjdH0gTWVzc2FnZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgICBNZXNzYWdlIHR5cGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGx1Z2luIFNvdXJjZSBQb3N0Q1NTIHBsdWdpbiBuYW1lLlxuICovZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSx7XCIuL3dhcm5pbmdcIjoxOTF9XSwxODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2NvbnRhaW5lcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnRhaW5lclwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO3N1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1zdWJDbGFzcztzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzczt9LyoqXG4gKiBSZXByZXNlbnRzIGEgQ1NTIGZpbGUgYW5kIGNvbnRhaW5zIGFsbCBpdHMgcGFyc2VkIG5vZGVzLlxuICpcbiAqIEBleHRlbmRzIENvbnRhaW5lclxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYXtjb2xvcjpibGFja30gYnt6LWluZGV4OjJ9JylcbiAqIHJvb3QudHlwZSAgICAgICAgIC8vPT4gJ3Jvb3QnXG4gKiByb290Lm5vZGVzLmxlbmd0aCAvLz0+IDJcbiAqL3ZhciBSb290PS8qI19fUFVSRV9fKi9mdW5jdGlvbihfQ29udGFpbmVyKXtfaW5oZXJpdHNMb29zZShSb290LF9Db250YWluZXIpO2Z1bmN0aW9uIFJvb3QoZGVmYXVsdHMpe3ZhciBfdGhpcztfdGhpcz1fQ29udGFpbmVyLmNhbGwodGhpcyxkZWZhdWx0cyl8fHRoaXM7X3RoaXMudHlwZT0ncm9vdCc7aWYoIV90aGlzLm5vZGVzKV90aGlzLm5vZGVzPVtdO3JldHVybiBfdGhpczt9dmFyIF9wcm90bz1Sb290LnByb3RvdHlwZTtfcHJvdG8ucmVtb3ZlQ2hpbGQ9ZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQsaWdub3JlKXt2YXIgaW5kZXg9dGhpcy5pbmRleChjaGlsZCk7aWYoIWlnbm9yZSYmaW5kZXg9PT0wJiZ0aGlzLm5vZGVzLmxlbmd0aD4xKXt0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlPXRoaXMubm9kZXNbaW5kZXhdLnJhd3MuYmVmb3JlO31yZXR1cm4gX0NvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLGNoaWxkKTt9O19wcm90by5ub3JtYWxpemU9ZnVuY3Rpb24gbm9ybWFsaXplKGNoaWxkLHNhbXBsZSx0eXBlKXt2YXIgbm9kZXM9X0NvbnRhaW5lci5wcm90b3R5cGUubm9ybWFsaXplLmNhbGwodGhpcyxjaGlsZCk7aWYoc2FtcGxlKXtpZih0eXBlPT09J3ByZXBlbmQnKXtpZih0aGlzLm5vZGVzLmxlbmd0aD4xKXtzYW1wbGUucmF3cy5iZWZvcmU9dGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZTt9ZWxzZXtkZWxldGUgc2FtcGxlLnJhd3MuYmVmb3JlO319ZWxzZSBpZih0aGlzLmZpcnN0IT09c2FtcGxlKXtmb3IodmFyIF9pdGVyYXRvcj1ub2RlcyxfaXNBcnJheT1BcnJheS5pc0FycmF5KF9pdGVyYXRvciksX2k9MCxfaXRlcmF0b3I9X2lzQXJyYXk/X2l0ZXJhdG9yOl9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY7aWYoX2lzQXJyYXkpe2lmKF9pPj1faXRlcmF0b3IubGVuZ3RoKWJyZWFrO19yZWY9X2l0ZXJhdG9yW19pKytdO31lbHNle19pPV9pdGVyYXRvci5uZXh0KCk7aWYoX2kuZG9uZSlicmVhaztfcmVmPV9pLnZhbHVlO312YXIgbm9kZT1fcmVmO25vZGUucmF3cy5iZWZvcmU9c2FtcGxlLnJhd3MuYmVmb3JlO319fXJldHVybiBub2Rlczt9LyoqXG4gICAqIFJldHVybnMgYSB7QGxpbmsgUmVzdWx0fSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIHJvb3TigJlzIENTUy5cbiAgICpcbiAgICogQHBhcmFtIHtwcm9jZXNzT3B0aW9uc30gW29wdHNdIE9wdGlvbnMgd2l0aCBvbmx5IGB0b2AgYW5kIGBtYXBgIGtleXMuXG4gICAqXG4gICAqIEByZXR1cm4ge1Jlc3VsdH0gUmVzdWx0IHdpdGggY3VycmVudCByb2904oCZcyBDU1MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QxID0gcG9zdGNzcy5wYXJzZShjc3MxLCB7IGZyb206ICdhLmNzcycgfSlcbiAgICogY29uc3Qgcm9vdDIgPSBwb3N0Y3NzLnBhcnNlKGNzczIsIHsgZnJvbTogJ2IuY3NzJyB9KVxuICAgKiByb290MS5hcHBlbmQocm9vdDIpXG4gICAqIGNvbnN0IHJlc3VsdCA9IHJvb3QxLnRvUmVzdWx0KHsgdG86ICdhbGwuY3NzJywgbWFwOiB0cnVlIH0pXG4gICAqLztfcHJvdG8udG9SZXN1bHQ9ZnVuY3Rpb24gdG9SZXN1bHQob3B0cyl7aWYob3B0cz09PXZvaWQgMCl7b3B0cz17fTt9dmFyIExhenlSZXN1bHQ9cmVxdWlyZSgnLi9sYXp5LXJlc3VsdCcpO3ZhciBQcm9jZXNzb3I9cmVxdWlyZSgnLi9wcm9jZXNzb3InKTt2YXIgbGF6eT1uZXcgTGF6eVJlc3VsdChuZXcgUHJvY2Vzc29yKCksdGhpcyxvcHRzKTtyZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTt9LyoqXG4gICAqIEBtZW1iZXJvZiBSb290I1xuICAgKiBAbWVtYmVyIHtvYmplY3R9IHJhd3MgSW5mb3JtYXRpb24gdG8gZ2VuZXJhdGUgYnl0ZS10by1ieXRlIGVxdWFsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBub2RlIHN0cmluZyBhcyBpdCB3YXMgaW4gdGhlIG9yaWdpbiBpbnB1dC5cbiAgICpcbiAgICogRXZlcnkgcGFyc2VyIHNhdmVzIGl0cyBvd24gcHJvcGVydGllcyxcbiAgICogYnV0IHRoZSBkZWZhdWx0IENTUyBwYXJzZXIgdXNlczpcbiAgICpcbiAgICogKiBgYWZ0ZXJgOiB0aGUgc3BhY2Ugc3ltYm9scyBhZnRlciB0aGUgbGFzdCBjaGlsZCB0byB0aGUgZW5kIG9mIGZpbGUuXG4gICAqICogYHNlbWljb2xvbmA6IGlzIHRoZSBsYXN0IGNoaWxkIGhhcyBhbiAob3B0aW9uYWwpIHNlbWljb2xvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcy5wYXJzZSgnYSB7fVxcbicpLnJhd3MgLy89PiB7IGFmdGVyOiAnXFxuJyB9XG4gICAqIHBvc3Rjc3MucGFyc2UoJ2Ege30nKS5yYXdzICAgLy89PiB7IGFmdGVyOiAnJyB9XG4gICAqLztyZXR1cm4gUm9vdDt9KF9jb250YWluZXJbXCJkZWZhdWx0XCJdKTt2YXIgX2RlZmF1bHQ9Um9vdDtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHtcIi4vY29udGFpbmVyXCI6MTcwLFwiLi9sYXp5LXJlc3VsdFwiOjE3NCxcIi4vcHJvY2Vzc29yXCI6MTgyfV0sMTg1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9jb250YWluZXI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb250YWluZXJcIikpO3ZhciBfbGlzdD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpc3RcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian07fWZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpO3JldHVybiBDb25zdHJ1Y3Rvcjt9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO3N1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1zdWJDbGFzcztzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzczt9LyoqXG4gKiBSZXByZXNlbnRzIGEgQ1NTIHJ1bGU6IGEgc2VsZWN0b3IgZm9sbG93ZWQgYnkgYSBkZWNsYXJhdGlvbiBibG9jay5cbiAqXG4gKiBAZXh0ZW5kcyBDb250YWluZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2F7fScpXG4gKiBjb25zdCBydWxlID0gcm9vdC5maXJzdFxuICogcnVsZS50eXBlICAgICAgIC8vPT4gJ3J1bGUnXG4gKiBydWxlLnRvU3RyaW5nKCkgLy89PiAnYXt9J1xuICovdmFyIFJ1bGU9LyojX19QVVJFX18qL2Z1bmN0aW9uKF9Db250YWluZXIpe19pbmhlcml0c0xvb3NlKFJ1bGUsX0NvbnRhaW5lcik7ZnVuY3Rpb24gUnVsZShkZWZhdWx0cyl7dmFyIF90aGlzO190aGlzPV9Db250YWluZXIuY2FsbCh0aGlzLGRlZmF1bHRzKXx8dGhpcztfdGhpcy50eXBlPSdydWxlJztpZighX3RoaXMubm9kZXMpX3RoaXMubm9kZXM9W107cmV0dXJuIF90aGlzO30vKipcbiAgICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcnVsZeKAmXMgaW5kaXZpZHVhbCBzZWxlY3RvcnMuXG4gICAqIEdyb3VwcyBvZiBzZWxlY3RvcnMgYXJlIHNwbGl0IGF0IGNvbW1hcy5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSwgYiB7IH0nKVxuICAgKiBjb25zdCBydWxlID0gcm9vdC5maXJzdFxuICAgKlxuICAgKiBydWxlLnNlbGVjdG9yICAvLz0+ICdhLCBiJ1xuICAgKiBydWxlLnNlbGVjdG9ycyAvLz0+IFsnYScsICdiJ11cbiAgICpcbiAgICogcnVsZS5zZWxlY3RvcnMgPSBbJ2EnLCAnc3Ryb25nJ11cbiAgICogcnVsZS5zZWxlY3RvciAvLz0+ICdhLCBzdHJvbmcnXG4gICAqL19jcmVhdGVDbGFzcyhSdWxlLFt7a2V5Olwic2VsZWN0b3JzXCIsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiBfbGlzdFtcImRlZmF1bHRcIl0uY29tbWEodGhpcy5zZWxlY3Rvcik7fSxzZXQ6ZnVuY3Rpb24gc2V0KHZhbHVlcyl7dmFyIG1hdGNoPXRoaXMuc2VsZWN0b3I/dGhpcy5zZWxlY3Rvci5tYXRjaCgvLFxccyovKTpudWxsO3ZhciBzZXA9bWF0Y2g/bWF0Y2hbMF06JywnK3RoaXMucmF3KCdiZXR3ZWVuJywnYmVmb3JlT3BlbicpO3RoaXMuc2VsZWN0b3I9dmFsdWVzLmpvaW4oc2VwKTt9LyoqXG4gICAgICogQG1lbWJlcm9mIFJ1bGUjXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBzZWxlY3RvciBUaGUgcnVsZeKAmXMgZnVsbCBzZWxlY3RvciByZXByZXNlbnRlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhLCBiIHsgfScpXG4gICAgICogY29uc3QgcnVsZSA9IHJvb3QuZmlyc3RcbiAgICAgKiBydWxlLnNlbGVjdG9yIC8vPT4gJ2EsIGInXG4gICAgICovIC8qKlxuICAgICAqIEBtZW1iZXJvZiBSdWxlI1xuICAgICAqIEBtZW1iZXIge29iamVjdH0gcmF3cyBJbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBieXRlLXRvLWJ5dGUgZXF1YWxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgbm9kZSBzdHJpbmcgYXMgaXQgd2FzIGluIHRoZSBvcmlnaW4gaW5wdXQuXG4gICAgICpcbiAgICAgKiBFdmVyeSBwYXJzZXIgc2F2ZXMgaXRzIG93biBwcm9wZXJ0aWVzLFxuICAgICAqIGJ1dCB0aGUgZGVmYXVsdCBDU1MgcGFyc2VyIHVzZXM6XG4gICAgICpcbiAgICAgKiAqIGBiZWZvcmVgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZWZvcmUgdGhlIG5vZGUuIEl0IGFsc28gc3RvcmVzIGAqYFxuICAgICAqICAgYW5kIGBfYCBzeW1ib2xzIGJlZm9yZSB0aGUgZGVjbGFyYXRpb24gKElFIGhhY2spLlxuICAgICAqICogYGFmdGVyYDogdGhlIHNwYWNlIHN5bWJvbHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhlIG5vZGVcbiAgICAgKiAgIHRvIHRoZSBlbmQgb2YgdGhlIG5vZGUuXG4gICAgICogKiBgYmV0d2VlbmA6IHRoZSBzeW1ib2xzIGJldHdlZW4gdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgICAqICAgZm9yIGRlY2xhcmF0aW9ucywgc2VsZWN0b3IgYW5kIGB7YCBmb3IgcnVsZXMsIG9yIGxhc3QgcGFyYW1ldGVyXG4gICAgICogICBhbmQgYHtgIGZvciBhdC1ydWxlcy5cbiAgICAgKiAqIGBzZW1pY29sb25gOiBjb250YWlucyBgdHJ1ZWAgaWYgdGhlIGxhc3QgY2hpbGQgaGFzXG4gICAgICogICBhbiAob3B0aW9uYWwpIHNlbWljb2xvbi5cbiAgICAgKiAqIGBvd25TZW1pY29sb25gOiBjb250YWlucyBgdHJ1ZWAgaWYgdGhlcmUgaXMgc2VtaWNvbG9uIGFmdGVyIHJ1bGUuXG4gICAgICpcbiAgICAgKiBQb3N0Q1NTIGNsZWFucyBzZWxlY3RvcnMgZnJvbSBjb21tZW50cyBhbmQgZXh0cmEgc3BhY2VzLFxuICAgICAqIGJ1dCBpdCBzdG9yZXMgb3JpZ2luIGNvbnRlbnQgaW4gcmF3cyBwcm9wZXJ0aWVzLlxuICAgICAqIEFzIHN1Y2gsIGlmIHlvdSBkb27igJl0IGNoYW5nZSBhIGRlY2xhcmF0aW9u4oCZcyB2YWx1ZSxcbiAgICAgKiBQb3N0Q1NTIHdpbGwgdXNlIHRoZSByYXcgdmFsdWUgd2l0aCBjb21tZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2Ege1xcbiAgY29sb3I6YmxhY2tcXG59JylcbiAgICAgKiByb290LmZpcnN0LmZpcnN0LnJhd3MgLy89PiB7IGJlZm9yZTogJycsIGJldHdlZW46ICcgJywgYWZ0ZXI6ICdcXG4nIH1cbiAgICAgKi99XSk7cmV0dXJuIFJ1bGU7fShfY29udGFpbmVyW1wiZGVmYXVsdFwiXSk7dmFyIF9kZWZhdWx0PVJ1bGU7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSx7XCIuL2NvbnRhaW5lclwiOjE3MCxcIi4vbGlzdFwiOjE3NX1dLDE4NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBERUZBVUxUX1JBVz17Y29sb246JzogJyxpbmRlbnQ6JyAgICAnLGJlZm9yZURlY2w6J1xcbicsYmVmb3JlUnVsZTonXFxuJyxiZWZvcmVPcGVuOicgJyxiZWZvcmVDbG9zZTonXFxuJyxiZWZvcmVDb21tZW50OidcXG4nLGFmdGVyOidcXG4nLGVtcHR5Qm9keTonJyxjb21tZW50TGVmdDonICcsY29tbWVudFJpZ2h0OicgJyxzZW1pY29sb246ZmFsc2V9O2Z1bmN0aW9uIGNhcGl0YWxpemUoc3RyKXtyZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkrc3RyLnNsaWNlKDEpO312YXIgU3RyaW5naWZpZXI9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gU3RyaW5naWZpZXIoYnVpbGRlcil7dGhpcy5idWlsZGVyPWJ1aWxkZXI7fXZhciBfcHJvdG89U3RyaW5naWZpZXIucHJvdG90eXBlO19wcm90by5zdHJpbmdpZnk9ZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUsc2VtaWNvbG9uKXt0aGlzW25vZGUudHlwZV0obm9kZSxzZW1pY29sb24pO307X3Byb3RvLnJvb3Q9ZnVuY3Rpb24gcm9vdChub2RlKXt0aGlzLmJvZHkobm9kZSk7aWYobm9kZS5yYXdzLmFmdGVyKXRoaXMuYnVpbGRlcihub2RlLnJhd3MuYWZ0ZXIpO307X3Byb3RvLmNvbW1lbnQ9ZnVuY3Rpb24gY29tbWVudChub2RlKXt2YXIgbGVmdD10aGlzLnJhdyhub2RlLCdsZWZ0JywnY29tbWVudExlZnQnKTt2YXIgcmlnaHQ9dGhpcy5yYXcobm9kZSwncmlnaHQnLCdjb21tZW50UmlnaHQnKTt0aGlzLmJ1aWxkZXIoJy8qJytsZWZ0K25vZGUudGV4dCtyaWdodCsnKi8nLG5vZGUpO307X3Byb3RvLmRlY2w9ZnVuY3Rpb24gZGVjbChub2RlLHNlbWljb2xvbil7dmFyIGJldHdlZW49dGhpcy5yYXcobm9kZSwnYmV0d2VlbicsJ2NvbG9uJyk7dmFyIHN0cmluZz1ub2RlLnByb3ArYmV0d2Vlbit0aGlzLnJhd1ZhbHVlKG5vZGUsJ3ZhbHVlJyk7aWYobm9kZS5pbXBvcnRhbnQpe3N0cmluZys9bm9kZS5yYXdzLmltcG9ydGFudHx8JyAhaW1wb3J0YW50Jzt9aWYoc2VtaWNvbG9uKXN0cmluZys9JzsnO3RoaXMuYnVpbGRlcihzdHJpbmcsbm9kZSk7fTtfcHJvdG8ucnVsZT1mdW5jdGlvbiBydWxlKG5vZGUpe3RoaXMuYmxvY2sobm9kZSx0aGlzLnJhd1ZhbHVlKG5vZGUsJ3NlbGVjdG9yJykpO2lmKG5vZGUucmF3cy5vd25TZW1pY29sb24pe3RoaXMuYnVpbGRlcihub2RlLnJhd3Mub3duU2VtaWNvbG9uLG5vZGUsJ2VuZCcpO319O19wcm90by5hdHJ1bGU9ZnVuY3Rpb24gYXRydWxlKG5vZGUsc2VtaWNvbG9uKXt2YXIgbmFtZT0nQCcrbm9kZS5uYW1lO3ZhciBwYXJhbXM9bm9kZS5wYXJhbXM/dGhpcy5yYXdWYWx1ZShub2RlLCdwYXJhbXMnKTonJztpZih0eXBlb2Ygbm9kZS5yYXdzLmFmdGVyTmFtZSE9PSd1bmRlZmluZWQnKXtuYW1lKz1ub2RlLnJhd3MuYWZ0ZXJOYW1lO31lbHNlIGlmKHBhcmFtcyl7bmFtZSs9JyAnO31pZihub2RlLm5vZGVzKXt0aGlzLmJsb2NrKG5vZGUsbmFtZStwYXJhbXMpO31lbHNle3ZhciBlbmQ9KG5vZGUucmF3cy5iZXR3ZWVufHwnJykrKHNlbWljb2xvbj8nOyc6JycpO3RoaXMuYnVpbGRlcihuYW1lK3BhcmFtcytlbmQsbm9kZSk7fX07X3Byb3RvLmJvZHk9ZnVuY3Rpb24gYm9keShub2RlKXt2YXIgbGFzdD1ub2RlLm5vZGVzLmxlbmd0aC0xO3doaWxlKGxhc3Q+MCl7aWYobm9kZS5ub2Rlc1tsYXN0XS50eXBlIT09J2NvbW1lbnQnKWJyZWFrO2xhc3QtPTE7fXZhciBzZW1pY29sb249dGhpcy5yYXcobm9kZSwnc2VtaWNvbG9uJyk7Zm9yKHZhciBpPTA7aTxub2RlLm5vZGVzLmxlbmd0aDtpKyspe3ZhciBjaGlsZD1ub2RlLm5vZGVzW2ldO3ZhciBiZWZvcmU9dGhpcy5yYXcoY2hpbGQsJ2JlZm9yZScpO2lmKGJlZm9yZSl0aGlzLmJ1aWxkZXIoYmVmb3JlKTt0aGlzLnN0cmluZ2lmeShjaGlsZCxsYXN0IT09aXx8c2VtaWNvbG9uKTt9fTtfcHJvdG8uYmxvY2s9ZnVuY3Rpb24gYmxvY2sobm9kZSxzdGFydCl7dmFyIGJldHdlZW49dGhpcy5yYXcobm9kZSwnYmV0d2VlbicsJ2JlZm9yZU9wZW4nKTt0aGlzLmJ1aWxkZXIoc3RhcnQrYmV0d2Vlbisneycsbm9kZSwnc3RhcnQnKTt2YXIgYWZ0ZXI7aWYobm9kZS5ub2RlcyYmbm9kZS5ub2Rlcy5sZW5ndGgpe3RoaXMuYm9keShub2RlKTthZnRlcj10aGlzLnJhdyhub2RlLCdhZnRlcicpO31lbHNle2FmdGVyPXRoaXMucmF3KG5vZGUsJ2FmdGVyJywnZW1wdHlCb2R5Jyk7fWlmKGFmdGVyKXRoaXMuYnVpbGRlcihhZnRlcik7dGhpcy5idWlsZGVyKCd9Jyxub2RlLCdlbmQnKTt9O19wcm90by5yYXc9ZnVuY3Rpb24gcmF3KG5vZGUsb3duLGRldGVjdCl7dmFyIHZhbHVlO2lmKCFkZXRlY3QpZGV0ZWN0PW93bjsvLyBBbHJlYWR5IGhhZFxuaWYob3duKXt2YWx1ZT1ub2RlLnJhd3Nbb3duXTtpZih0eXBlb2YgdmFsdWUhPT0ndW5kZWZpbmVkJylyZXR1cm4gdmFsdWU7fXZhciBwYXJlbnQ9bm9kZS5wYXJlbnQ7Ly8gSGFjayBmb3IgZmlyc3QgcnVsZSBpbiBDU1NcbmlmKGRldGVjdD09PSdiZWZvcmUnKXtpZighcGFyZW50fHxwYXJlbnQudHlwZT09PSdyb290JyYmcGFyZW50LmZpcnN0PT09bm9kZSl7cmV0dXJuJyc7fX0vLyBGbG9hdGluZyBjaGlsZCB3aXRob3V0IHBhcmVudFxuaWYoIXBhcmVudClyZXR1cm4gREVGQVVMVF9SQVdbZGV0ZWN0XTsvLyBEZXRlY3Qgc3R5bGUgYnkgb3RoZXIgbm9kZXNcbnZhciByb290PW5vZGUucm9vdCgpO2lmKCFyb290LnJhd0NhY2hlKXJvb3QucmF3Q2FjaGU9e307aWYodHlwZW9mIHJvb3QucmF3Q2FjaGVbZGV0ZWN0XSE9PSd1bmRlZmluZWQnKXtyZXR1cm4gcm9vdC5yYXdDYWNoZVtkZXRlY3RdO31pZihkZXRlY3Q9PT0nYmVmb3JlJ3x8ZGV0ZWN0PT09J2FmdGVyJyl7cmV0dXJuIHRoaXMuYmVmb3JlQWZ0ZXIobm9kZSxkZXRlY3QpO31lbHNle3ZhciBtZXRob2Q9J3JhdycrY2FwaXRhbGl6ZShkZXRlY3QpO2lmKHRoaXNbbWV0aG9kXSl7dmFsdWU9dGhpc1ttZXRob2RdKHJvb3Qsbm9kZSk7fWVsc2V7cm9vdC53YWxrKGZ1bmN0aW9uKGkpe3ZhbHVlPWkucmF3c1tvd25dO2lmKHR5cGVvZiB2YWx1ZSE9PSd1bmRlZmluZWQnKXJldHVybiBmYWxzZTt9KTt9fWlmKHR5cGVvZiB2YWx1ZT09PSd1bmRlZmluZWQnKXZhbHVlPURFRkFVTFRfUkFXW2RldGVjdF07cm9vdC5yYXdDYWNoZVtkZXRlY3RdPXZhbHVlO3JldHVybiB2YWx1ZTt9O19wcm90by5yYXdTZW1pY29sb249ZnVuY3Rpb24gcmF3U2VtaWNvbG9uKHJvb3Qpe3ZhciB2YWx1ZTtyb290LndhbGsoZnVuY3Rpb24oaSl7aWYoaS5ub2RlcyYmaS5ub2Rlcy5sZW5ndGgmJmkubGFzdC50eXBlPT09J2RlY2wnKXt2YWx1ZT1pLnJhd3Muc2VtaWNvbG9uO2lmKHR5cGVvZiB2YWx1ZSE9PSd1bmRlZmluZWQnKXJldHVybiBmYWxzZTt9fSk7cmV0dXJuIHZhbHVlO307X3Byb3RvLnJhd0VtcHR5Qm9keT1mdW5jdGlvbiByYXdFbXB0eUJvZHkocm9vdCl7dmFyIHZhbHVlO3Jvb3Qud2FsayhmdW5jdGlvbihpKXtpZihpLm5vZGVzJiZpLm5vZGVzLmxlbmd0aD09PTApe3ZhbHVlPWkucmF3cy5hZnRlcjtpZih0eXBlb2YgdmFsdWUhPT0ndW5kZWZpbmVkJylyZXR1cm4gZmFsc2U7fX0pO3JldHVybiB2YWx1ZTt9O19wcm90by5yYXdJbmRlbnQ9ZnVuY3Rpb24gcmF3SW5kZW50KHJvb3Qpe2lmKHJvb3QucmF3cy5pbmRlbnQpcmV0dXJuIHJvb3QucmF3cy5pbmRlbnQ7dmFyIHZhbHVlO3Jvb3Qud2FsayhmdW5jdGlvbihpKXt2YXIgcD1pLnBhcmVudDtpZihwJiZwIT09cm9vdCYmcC5wYXJlbnQmJnAucGFyZW50PT09cm9vdCl7aWYodHlwZW9mIGkucmF3cy5iZWZvcmUhPT0ndW5kZWZpbmVkJyl7dmFyIHBhcnRzPWkucmF3cy5iZWZvcmUuc3BsaXQoJ1xcbicpO3ZhbHVlPXBhcnRzW3BhcnRzLmxlbmd0aC0xXTt2YWx1ZT12YWx1ZS5yZXBsYWNlKC9bXlxcc10vZywnJyk7cmV0dXJuIGZhbHNlO319fSk7cmV0dXJuIHZhbHVlO307X3Byb3RvLnJhd0JlZm9yZUNvbW1lbnQ9ZnVuY3Rpb24gcmF3QmVmb3JlQ29tbWVudChyb290LG5vZGUpe3ZhciB2YWx1ZTtyb290LndhbGtDb21tZW50cyhmdW5jdGlvbihpKXtpZih0eXBlb2YgaS5yYXdzLmJlZm9yZSE9PSd1bmRlZmluZWQnKXt2YWx1ZT1pLnJhd3MuYmVmb3JlO2lmKHZhbHVlLmluZGV4T2YoJ1xcbicpIT09LTEpe3ZhbHVlPXZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywnJyk7fXJldHVybiBmYWxzZTt9fSk7aWYodHlwZW9mIHZhbHVlPT09J3VuZGVmaW5lZCcpe3ZhbHVlPXRoaXMucmF3KG5vZGUsbnVsbCwnYmVmb3JlRGVjbCcpO31lbHNlIGlmKHZhbHVlKXt2YWx1ZT12YWx1ZS5yZXBsYWNlKC9bXlxcc10vZywnJyk7fXJldHVybiB2YWx1ZTt9O19wcm90by5yYXdCZWZvcmVEZWNsPWZ1bmN0aW9uIHJhd0JlZm9yZURlY2wocm9vdCxub2RlKXt2YXIgdmFsdWU7cm9vdC53YWxrRGVjbHMoZnVuY3Rpb24oaSl7aWYodHlwZW9mIGkucmF3cy5iZWZvcmUhPT0ndW5kZWZpbmVkJyl7dmFsdWU9aS5yYXdzLmJlZm9yZTtpZih2YWx1ZS5pbmRleE9mKCdcXG4nKSE9PS0xKXt2YWx1ZT12YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sJycpO31yZXR1cm4gZmFsc2U7fX0pO2lmKHR5cGVvZiB2YWx1ZT09PSd1bmRlZmluZWQnKXt2YWx1ZT10aGlzLnJhdyhub2RlLG51bGwsJ2JlZm9yZVJ1bGUnKTt9ZWxzZSBpZih2YWx1ZSl7dmFsdWU9dmFsdWUucmVwbGFjZSgvW15cXHNdL2csJycpO31yZXR1cm4gdmFsdWU7fTtfcHJvdG8ucmF3QmVmb3JlUnVsZT1mdW5jdGlvbiByYXdCZWZvcmVSdWxlKHJvb3Qpe3ZhciB2YWx1ZTtyb290LndhbGsoZnVuY3Rpb24oaSl7aWYoaS5ub2RlcyYmKGkucGFyZW50IT09cm9vdHx8cm9vdC5maXJzdCE9PWkpKXtpZih0eXBlb2YgaS5yYXdzLmJlZm9yZSE9PSd1bmRlZmluZWQnKXt2YWx1ZT1pLnJhd3MuYmVmb3JlO2lmKHZhbHVlLmluZGV4T2YoJ1xcbicpIT09LTEpe3ZhbHVlPXZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywnJyk7fXJldHVybiBmYWxzZTt9fX0pO2lmKHZhbHVlKXZhbHVlPXZhbHVlLnJlcGxhY2UoL1teXFxzXS9nLCcnKTtyZXR1cm4gdmFsdWU7fTtfcHJvdG8ucmF3QmVmb3JlQ2xvc2U9ZnVuY3Rpb24gcmF3QmVmb3JlQ2xvc2Uocm9vdCl7dmFyIHZhbHVlO3Jvb3Qud2FsayhmdW5jdGlvbihpKXtpZihpLm5vZGVzJiZpLm5vZGVzLmxlbmd0aD4wKXtpZih0eXBlb2YgaS5yYXdzLmFmdGVyIT09J3VuZGVmaW5lZCcpe3ZhbHVlPWkucmF3cy5hZnRlcjtpZih2YWx1ZS5pbmRleE9mKCdcXG4nKSE9PS0xKXt2YWx1ZT12YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sJycpO31yZXR1cm4gZmFsc2U7fX19KTtpZih2YWx1ZSl2YWx1ZT12YWx1ZS5yZXBsYWNlKC9bXlxcc10vZywnJyk7cmV0dXJuIHZhbHVlO307X3Byb3RvLnJhd0JlZm9yZU9wZW49ZnVuY3Rpb24gcmF3QmVmb3JlT3Blbihyb290KXt2YXIgdmFsdWU7cm9vdC53YWxrKGZ1bmN0aW9uKGkpe2lmKGkudHlwZSE9PSdkZWNsJyl7dmFsdWU9aS5yYXdzLmJldHdlZW47aWYodHlwZW9mIHZhbHVlIT09J3VuZGVmaW5lZCcpcmV0dXJuIGZhbHNlO319KTtyZXR1cm4gdmFsdWU7fTtfcHJvdG8ucmF3Q29sb249ZnVuY3Rpb24gcmF3Q29sb24ocm9vdCl7dmFyIHZhbHVlO3Jvb3Qud2Fsa0RlY2xzKGZ1bmN0aW9uKGkpe2lmKHR5cGVvZiBpLnJhd3MuYmV0d2VlbiE9PSd1bmRlZmluZWQnKXt2YWx1ZT1pLnJhd3MuYmV0d2Vlbi5yZXBsYWNlKC9bXlxcczpdL2csJycpO3JldHVybiBmYWxzZTt9fSk7cmV0dXJuIHZhbHVlO307X3Byb3RvLmJlZm9yZUFmdGVyPWZ1bmN0aW9uIGJlZm9yZUFmdGVyKG5vZGUsZGV0ZWN0KXt2YXIgdmFsdWU7aWYobm9kZS50eXBlPT09J2RlY2wnKXt2YWx1ZT10aGlzLnJhdyhub2RlLG51bGwsJ2JlZm9yZURlY2wnKTt9ZWxzZSBpZihub2RlLnR5cGU9PT0nY29tbWVudCcpe3ZhbHVlPXRoaXMucmF3KG5vZGUsbnVsbCwnYmVmb3JlQ29tbWVudCcpO31lbHNlIGlmKGRldGVjdD09PSdiZWZvcmUnKXt2YWx1ZT10aGlzLnJhdyhub2RlLG51bGwsJ2JlZm9yZVJ1bGUnKTt9ZWxzZXt2YWx1ZT10aGlzLnJhdyhub2RlLG51bGwsJ2JlZm9yZUNsb3NlJyk7fXZhciBidWY9bm9kZS5wYXJlbnQ7dmFyIGRlcHRoPTA7d2hpbGUoYnVmJiZidWYudHlwZSE9PSdyb290Jyl7ZGVwdGgrPTE7YnVmPWJ1Zi5wYXJlbnQ7fWlmKHZhbHVlLmluZGV4T2YoJ1xcbicpIT09LTEpe3ZhciBpbmRlbnQ9dGhpcy5yYXcobm9kZSxudWxsLCdpbmRlbnQnKTtpZihpbmRlbnQubGVuZ3RoKXtmb3IodmFyIHN0ZXA9MDtzdGVwPGRlcHRoO3N0ZXArKyl7dmFsdWUrPWluZGVudDt9fX1yZXR1cm4gdmFsdWU7fTtfcHJvdG8ucmF3VmFsdWU9ZnVuY3Rpb24gcmF3VmFsdWUobm9kZSxwcm9wKXt2YXIgdmFsdWU9bm9kZVtwcm9wXTt2YXIgcmF3PW5vZGUucmF3c1twcm9wXTtpZihyYXcmJnJhdy52YWx1ZT09PXZhbHVlKXtyZXR1cm4gcmF3LnJhdzt9cmV0dXJuIHZhbHVlO307cmV0dXJuIFN0cmluZ2lmaWVyO30oKTt2YXIgX2RlZmF1bHQ9U3RyaW5naWZpZXI7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSx7fV0sMTg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9zdHJpbmdpZmllcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmaWVyXCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O31mdW5jdGlvbiBzdHJpbmdpZnkobm9kZSxidWlsZGVyKXt2YXIgc3RyPW5ldyBfc3RyaW5naWZpZXJbXCJkZWZhdWx0XCJdKGJ1aWxkZXIpO3N0ci5zdHJpbmdpZnkobm9kZSk7fXZhciBfZGVmYXVsdD1zdHJpbmdpZnk7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSx7XCIuL3N0cmluZ2lmaWVyXCI6MTg2fV0sMTg4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT10b2tlbml6ZXI7dmFyIFNJTkdMRV9RVU9URT0nXFwnJy5jaGFyQ29kZUF0KDApO3ZhciBET1VCTEVfUVVPVEU9J1wiJy5jaGFyQ29kZUF0KDApO3ZhciBCQUNLU0xBU0g9J1xcXFwnLmNoYXJDb2RlQXQoMCk7dmFyIFNMQVNIPScvJy5jaGFyQ29kZUF0KDApO3ZhciBORVdMSU5FPSdcXG4nLmNoYXJDb2RlQXQoMCk7dmFyIFNQQUNFPScgJy5jaGFyQ29kZUF0KDApO3ZhciBGRUVEPSdcXGYnLmNoYXJDb2RlQXQoMCk7dmFyIFRBQj0nXFx0Jy5jaGFyQ29kZUF0KDApO3ZhciBDUj0nXFxyJy5jaGFyQ29kZUF0KDApO3ZhciBPUEVOX1NRVUFSRT0nWycuY2hhckNvZGVBdCgwKTt2YXIgQ0xPU0VfU1FVQVJFPSddJy5jaGFyQ29kZUF0KDApO3ZhciBPUEVOX1BBUkVOVEhFU0VTPScoJy5jaGFyQ29kZUF0KDApO3ZhciBDTE9TRV9QQVJFTlRIRVNFUz0nKScuY2hhckNvZGVBdCgwKTt2YXIgT1BFTl9DVVJMWT0neycuY2hhckNvZGVBdCgwKTt2YXIgQ0xPU0VfQ1VSTFk9J30nLmNoYXJDb2RlQXQoMCk7dmFyIFNFTUlDT0xPTj0nOycuY2hhckNvZGVBdCgwKTt2YXIgQVNURVJJU0s9JyonLmNoYXJDb2RlQXQoMCk7dmFyIENPTE9OPSc6Jy5jaGFyQ29kZUF0KDApO3ZhciBBVD0nQCcuY2hhckNvZGVBdCgwKTt2YXIgUkVfQVRfRU5EPS9bIFxcblxcdFxcclxcZnt9KCknXCJcXFxcOy9bXFxdI10vZzt2YXIgUkVfV09SRF9FTkQ9L1sgXFxuXFx0XFxyXFxmKCl7fTo7QCEnXCJcXFxcXFxdWyNdfFxcLyg/PVxcKikvZzt2YXIgUkVfQkFEX0JSQUNLRVQ9Ly5bXFxcXC8oXCInXFxuXS87dmFyIFJFX0hFWF9FU0NBUEU9L1thLWYwLTldL2k7ZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LG9wdGlvbnMpe2lmKG9wdGlvbnM9PT12b2lkIDApe29wdGlvbnM9e307fXZhciBjc3M9aW5wdXQuY3NzLnZhbHVlT2YoKTt2YXIgaWdub3JlPW9wdGlvbnMuaWdub3JlRXJyb3JzO3ZhciBjb2RlLG5leHQscXVvdGUsbGluZXMsbGFzdCxjb250ZW50LGVzY2FwZTt2YXIgbmV4dExpbmUsbmV4dE9mZnNldCxlc2NhcGVkLGVzY2FwZVBvcyxwcmV2LG4sY3VycmVudFRva2VuO3ZhciBsZW5ndGg9Y3NzLmxlbmd0aDt2YXIgb2Zmc2V0PS0xO3ZhciBsaW5lPTE7dmFyIHBvcz0wO3ZhciBidWZmZXI9W107dmFyIHJldHVybmVkPVtdO2Z1bmN0aW9uIHBvc2l0aW9uKCl7cmV0dXJuIHBvczt9ZnVuY3Rpb24gdW5jbG9zZWQod2hhdCl7dGhyb3cgaW5wdXQuZXJyb3IoJ1VuY2xvc2VkICcrd2hhdCxsaW5lLHBvcy1vZmZzZXQpO31mdW5jdGlvbiBlbmRPZkZpbGUoKXtyZXR1cm4gcmV0dXJuZWQubGVuZ3RoPT09MCYmcG9zPj1sZW5ndGg7fWZ1bmN0aW9uIG5leHRUb2tlbihvcHRzKXtpZihyZXR1cm5lZC5sZW5ndGgpcmV0dXJuIHJldHVybmVkLnBvcCgpO2lmKHBvcz49bGVuZ3RoKXJldHVybjt2YXIgaWdub3JlVW5jbG9zZWQ9b3B0cz9vcHRzLmlnbm9yZVVuY2xvc2VkOmZhbHNlO2NvZGU9Y3NzLmNoYXJDb2RlQXQocG9zKTtpZihjb2RlPT09TkVXTElORXx8Y29kZT09PUZFRUR8fGNvZGU9PT1DUiYmY3NzLmNoYXJDb2RlQXQocG9zKzEpIT09TkVXTElORSl7b2Zmc2V0PXBvcztsaW5lKz0xO31zd2l0Y2goY29kZSl7Y2FzZSBORVdMSU5FOmNhc2UgU1BBQ0U6Y2FzZSBUQUI6Y2FzZSBDUjpjYXNlIEZFRUQ6bmV4dD1wb3M7ZG97bmV4dCs9MTtjb2RlPWNzcy5jaGFyQ29kZUF0KG5leHQpO2lmKGNvZGU9PT1ORVdMSU5FKXtvZmZzZXQ9bmV4dDtsaW5lKz0xO319d2hpbGUoY29kZT09PVNQQUNFfHxjb2RlPT09TkVXTElORXx8Y29kZT09PVRBQnx8Y29kZT09PUNSfHxjb2RlPT09RkVFRCk7Y3VycmVudFRva2VuPVsnc3BhY2UnLGNzcy5zbGljZShwb3MsbmV4dCldO3Bvcz1uZXh0LTE7YnJlYWs7Y2FzZSBPUEVOX1NRVUFSRTpjYXNlIENMT1NFX1NRVUFSRTpjYXNlIE9QRU5fQ1VSTFk6Y2FzZSBDTE9TRV9DVVJMWTpjYXNlIENPTE9OOmNhc2UgU0VNSUNPTE9OOmNhc2UgQ0xPU0VfUEFSRU5USEVTRVM6dmFyIGNvbnRyb2xDaGFyPVN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7Y3VycmVudFRva2VuPVtjb250cm9sQ2hhcixjb250cm9sQ2hhcixsaW5lLHBvcy1vZmZzZXRdO2JyZWFrO2Nhc2UgT1BFTl9QQVJFTlRIRVNFUzpwcmV2PWJ1ZmZlci5sZW5ndGg/YnVmZmVyLnBvcCgpWzFdOicnO249Y3NzLmNoYXJDb2RlQXQocG9zKzEpO2lmKHByZXY9PT0ndXJsJyYmbiE9PVNJTkdMRV9RVU9URSYmbiE9PURPVUJMRV9RVU9URSYmbiE9PVNQQUNFJiZuIT09TkVXTElORSYmbiE9PVRBQiYmbiE9PUZFRUQmJm4hPT1DUil7bmV4dD1wb3M7ZG97ZXNjYXBlZD1mYWxzZTtuZXh0PWNzcy5pbmRleE9mKCcpJyxuZXh0KzEpO2lmKG5leHQ9PT0tMSl7aWYoaWdub3JlfHxpZ25vcmVVbmNsb3NlZCl7bmV4dD1wb3M7YnJlYWs7fWVsc2V7dW5jbG9zZWQoJ2JyYWNrZXQnKTt9fWVzY2FwZVBvcz1uZXh0O3doaWxlKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcy0xKT09PUJBQ0tTTEFTSCl7ZXNjYXBlUG9zLT0xO2VzY2FwZWQ9IWVzY2FwZWQ7fX13aGlsZShlc2NhcGVkKTtjdXJyZW50VG9rZW49WydicmFja2V0cycsY3NzLnNsaWNlKHBvcyxuZXh0KzEpLGxpbmUscG9zLW9mZnNldCxsaW5lLG5leHQtb2Zmc2V0XTtwb3M9bmV4dDt9ZWxzZXtuZXh0PWNzcy5pbmRleE9mKCcpJyxwb3MrMSk7Y29udGVudD1jc3Muc2xpY2UocG9zLG5leHQrMSk7aWYobmV4dD09PS0xfHxSRV9CQURfQlJBQ0tFVC50ZXN0KGNvbnRlbnQpKXtjdXJyZW50VG9rZW49WycoJywnKCcsbGluZSxwb3Mtb2Zmc2V0XTt9ZWxzZXtjdXJyZW50VG9rZW49WydicmFja2V0cycsY29udGVudCxsaW5lLHBvcy1vZmZzZXQsbGluZSxuZXh0LW9mZnNldF07cG9zPW5leHQ7fX1icmVhaztjYXNlIFNJTkdMRV9RVU9URTpjYXNlIERPVUJMRV9RVU9URTpxdW90ZT1jb2RlPT09U0lOR0xFX1FVT1RFPydcXCcnOidcIic7bmV4dD1wb3M7ZG97ZXNjYXBlZD1mYWxzZTtuZXh0PWNzcy5pbmRleE9mKHF1b3RlLG5leHQrMSk7aWYobmV4dD09PS0xKXtpZihpZ25vcmV8fGlnbm9yZVVuY2xvc2VkKXtuZXh0PXBvcysxO2JyZWFrO31lbHNle3VuY2xvc2VkKCdzdHJpbmcnKTt9fWVzY2FwZVBvcz1uZXh0O3doaWxlKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcy0xKT09PUJBQ0tTTEFTSCl7ZXNjYXBlUG9zLT0xO2VzY2FwZWQ9IWVzY2FwZWQ7fX13aGlsZShlc2NhcGVkKTtjb250ZW50PWNzcy5zbGljZShwb3MsbmV4dCsxKTtsaW5lcz1jb250ZW50LnNwbGl0KCdcXG4nKTtsYXN0PWxpbmVzLmxlbmd0aC0xO2lmKGxhc3Q+MCl7bmV4dExpbmU9bGluZStsYXN0O25leHRPZmZzZXQ9bmV4dC1saW5lc1tsYXN0XS5sZW5ndGg7fWVsc2V7bmV4dExpbmU9bGluZTtuZXh0T2Zmc2V0PW9mZnNldDt9Y3VycmVudFRva2VuPVsnc3RyaW5nJyxjc3Muc2xpY2UocG9zLG5leHQrMSksbGluZSxwb3Mtb2Zmc2V0LG5leHRMaW5lLG5leHQtbmV4dE9mZnNldF07b2Zmc2V0PW5leHRPZmZzZXQ7bGluZT1uZXh0TGluZTtwb3M9bmV4dDticmVhaztjYXNlIEFUOlJFX0FUX0VORC5sYXN0SW5kZXg9cG9zKzE7UkVfQVRfRU5ELnRlc3QoY3NzKTtpZihSRV9BVF9FTkQubGFzdEluZGV4PT09MCl7bmV4dD1jc3MubGVuZ3RoLTE7fWVsc2V7bmV4dD1SRV9BVF9FTkQubGFzdEluZGV4LTI7fWN1cnJlbnRUb2tlbj1bJ2F0LXdvcmQnLGNzcy5zbGljZShwb3MsbmV4dCsxKSxsaW5lLHBvcy1vZmZzZXQsbGluZSxuZXh0LW9mZnNldF07cG9zPW5leHQ7YnJlYWs7Y2FzZSBCQUNLU0xBU0g6bmV4dD1wb3M7ZXNjYXBlPXRydWU7d2hpbGUoY3NzLmNoYXJDb2RlQXQobmV4dCsxKT09PUJBQ0tTTEFTSCl7bmV4dCs9MTtlc2NhcGU9IWVzY2FwZTt9Y29kZT1jc3MuY2hhckNvZGVBdChuZXh0KzEpO2lmKGVzY2FwZSYmY29kZSE9PVNMQVNIJiZjb2RlIT09U1BBQ0UmJmNvZGUhPT1ORVdMSU5FJiZjb2RlIT09VEFCJiZjb2RlIT09Q1ImJmNvZGUhPT1GRUVEKXtuZXh0Kz0xO2lmKFJFX0hFWF9FU0NBUEUudGVzdChjc3MuY2hhckF0KG5leHQpKSl7d2hpbGUoUkVfSEVYX0VTQ0FQRS50ZXN0KGNzcy5jaGFyQXQobmV4dCsxKSkpe25leHQrPTE7fWlmKGNzcy5jaGFyQ29kZUF0KG5leHQrMSk9PT1TUEFDRSl7bmV4dCs9MTt9fX1jdXJyZW50VG9rZW49Wyd3b3JkJyxjc3Muc2xpY2UocG9zLG5leHQrMSksbGluZSxwb3Mtb2Zmc2V0LGxpbmUsbmV4dC1vZmZzZXRdO3Bvcz1uZXh0O2JyZWFrO2RlZmF1bHQ6aWYoY29kZT09PVNMQVNIJiZjc3MuY2hhckNvZGVBdChwb3MrMSk9PT1BU1RFUklTSyl7bmV4dD1jc3MuaW5kZXhPZignKi8nLHBvcysyKSsxO2lmKG5leHQ9PT0wKXtpZihpZ25vcmV8fGlnbm9yZVVuY2xvc2VkKXtuZXh0PWNzcy5sZW5ndGg7fWVsc2V7dW5jbG9zZWQoJ2NvbW1lbnQnKTt9fWNvbnRlbnQ9Y3NzLnNsaWNlKHBvcyxuZXh0KzEpO2xpbmVzPWNvbnRlbnQuc3BsaXQoJ1xcbicpO2xhc3Q9bGluZXMubGVuZ3RoLTE7aWYobGFzdD4wKXtuZXh0TGluZT1saW5lK2xhc3Q7bmV4dE9mZnNldD1uZXh0LWxpbmVzW2xhc3RdLmxlbmd0aDt9ZWxzZXtuZXh0TGluZT1saW5lO25leHRPZmZzZXQ9b2Zmc2V0O31jdXJyZW50VG9rZW49Wydjb21tZW50Jyxjb250ZW50LGxpbmUscG9zLW9mZnNldCxuZXh0TGluZSxuZXh0LW5leHRPZmZzZXRdO29mZnNldD1uZXh0T2Zmc2V0O2xpbmU9bmV4dExpbmU7cG9zPW5leHQ7fWVsc2V7UkVfV09SRF9FTkQubGFzdEluZGV4PXBvcysxO1JFX1dPUkRfRU5ELnRlc3QoY3NzKTtpZihSRV9XT1JEX0VORC5sYXN0SW5kZXg9PT0wKXtuZXh0PWNzcy5sZW5ndGgtMTt9ZWxzZXtuZXh0PVJFX1dPUkRfRU5ELmxhc3RJbmRleC0yO31jdXJyZW50VG9rZW49Wyd3b3JkJyxjc3Muc2xpY2UocG9zLG5leHQrMSksbGluZSxwb3Mtb2Zmc2V0LGxpbmUsbmV4dC1vZmZzZXRdO2J1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbik7cG9zPW5leHQ7fWJyZWFrO31wb3MrKztyZXR1cm4gY3VycmVudFRva2VuO31mdW5jdGlvbiBiYWNrKHRva2VuKXtyZXR1cm5lZC5wdXNoKHRva2VuKTt9cmV0dXJue2JhY2s6YmFjayxuZXh0VG9rZW46bmV4dFRva2VuLGVuZE9mRmlsZTplbmRPZkZpbGUscG9zaXRpb246cG9zaXRpb259O31tb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHt9XSwxODk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDsvKipcbiAqIENvbnRhaW5zIGhlbHBlcnMgZm9yIHdvcmtpbmcgd2l0aCB2ZW5kb3IgcHJlZml4ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHZlbmRvciA9IHBvc3Rjc3MudmVuZG9yXG4gKlxuICogQG5hbWVzcGFjZSB2ZW5kb3JcbiAqL3ZhciB2ZW5kb3I9ey8qKlxuICAgKiBSZXR1cm5zIHRoZSB2ZW5kb3IgcHJlZml4IGV4dHJhY3RlZCBmcm9tIGFuIGlucHV0IHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgU3RyaW5nIHdpdGggb3Igd2l0aG91dCB2ZW5kb3IgcHJlZml4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHZlbmRvciBwcmVmaXggb3IgZW1wdHkgc3RyaW5nXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHBvc3Rjc3MudmVuZG9yLnByZWZpeCgnLW1vei10YWItc2l6ZScpIC8vPT4gJy1tb3otJ1xuICAgKiBwb3N0Y3NzLnZlbmRvci5wcmVmaXgoJ3RhYi1zaXplJykgICAgICAvLz0+ICcnXG4gICAqL3ByZWZpeDpmdW5jdGlvbiBwcmVmaXgocHJvcCl7dmFyIG1hdGNoPXByb3AubWF0Y2goL14oLVxcdystKS8pO2lmKG1hdGNoKXtyZXR1cm4gbWF0Y2hbMF07fXJldHVybicnO30sLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5wdXQgc3RyaW5nIHN0cmlwcGVkIG9mIGl0cyB2ZW5kb3IgcHJlZml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgU3RyaW5nIHdpdGggb3Igd2l0aG91dCB2ZW5kb3IgcHJlZml4LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgbmFtZSB3aXRob3V0IHZlbmRvciBwcmVmaXhlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogcG9zdGNzcy52ZW5kb3IudW5wcmVmaXhlZCgnLW1vei10YWItc2l6ZScpIC8vPT4gJ3RhYi1zaXplJ1xuICAgICAqL3VucHJlZml4ZWQ6ZnVuY3Rpb24gdW5wcmVmaXhlZChwcm9wKXtyZXR1cm4gcHJvcC5yZXBsYWNlKC9eLVxcdystLywnJyk7fX07dmFyIF9kZWZhdWx0PXZlbmRvcjtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHt9XSwxOTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXdhcm5PbmNlO3ZhciBwcmludGVkPXt9O2Z1bmN0aW9uIHdhcm5PbmNlKG1lc3NhZ2Upe2lmKHByaW50ZWRbbWVzc2FnZV0pcmV0dXJuO3ByaW50ZWRbbWVzc2FnZV09dHJ1ZTtpZih0eXBlb2YgY29uc29sZSE9PSd1bmRlZmluZWQnJiZjb25zb2xlLndhcm4pe2NvbnNvbGUud2FybihtZXNzYWdlKTt9fW1vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se31dLDE5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwOy8qKlxuICogUmVwcmVzZW50cyBhIHBsdWdpbuKAmXMgd2FybmluZy4gSXQgY2FuIGJlIGNyZWF0ZWQgdXNpbmcge0BsaW5rIE5vZGUjd2Fybn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGlmIChkZWNsLmltcG9ydGFudCkge1xuICogICBkZWNsLndhcm4ocmVzdWx0LCAnQXZvaWQgIWltcG9ydGFudCcsIHsgd29yZDogJyFpbXBvcnRhbnQnIH0pXG4gKiB9XG4gKi92YXIgV2FybmluZz0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXsvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgICAgICAgIFdhcm5pbmcgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAgICAgIFdhcm5pbmcgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOb2RlfSAgIG9wdHMubm9kZSAgIENTUyBub2RlIHRoYXQgY2F1c2VkIHRoZSB3YXJuaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53b3JkICAgV29yZCBpbiBDU1Mgc291cmNlIHRoYXQgY2F1c2VkIHRoZSB3YXJuaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5pbmRleCAgSW5kZXggaW4gQ1NTIG5vZGUgc3RyaW5nIHRoYXQgY2F1c2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgd2FybmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMucGx1Z2luIE5hbWUgb2YgdGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2FybmluZy4ge0BsaW5rIFJlc3VsdCN3YXJufSBmaWxsc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBwcm9wZXJ0eSBhdXRvbWF0aWNhbGx5LlxuICAgKi9mdW5jdGlvbiBXYXJuaW5nKHRleHQsb3B0cyl7aWYob3B0cz09PXZvaWQgMCl7b3B0cz17fTt9LyoqXG4gICAgICogVHlwZSB0byBmaWx0ZXIgd2FybmluZ3MgZnJvbSB7QGxpbmsgUmVzdWx0I21lc3NhZ2VzfS5cbiAgICAgKiBBbHdheXMgZXF1YWwgdG8gYFwid2FybmluZ1wiYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG5vbldhcm5pbmcgPSByZXN1bHQubWVzc2FnZXMuZmlsdGVyKGkgPT4gaS50eXBlICE9PSAnd2FybmluZycpXG4gICAgICovdGhpcy50eXBlPSd3YXJuaW5nJzsvKipcbiAgICAgKiBUaGUgd2FybmluZyBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogd2FybmluZy50ZXh0IC8vPT4gJ1RyeSB0byBhdm9pZCAhaW1wb3J0YW50J1xuICAgICAqL3RoaXMudGV4dD10ZXh0O2lmKG9wdHMubm9kZSYmb3B0cy5ub2RlLnNvdXJjZSl7dmFyIHBvcz1vcHRzLm5vZGUucG9zaXRpb25CeShvcHRzKTsvKipcbiAgICAgICAqIExpbmUgaW4gdGhlIGlucHV0IGZpbGUgd2l0aCB0aGlzIHdhcm5pbmfigJlzIHNvdXJjZS5cbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIHdhcm5pbmcubGluZSAvLz0+IDVcbiAgICAgICAqL3RoaXMubGluZT1wb3MubGluZTsvKipcbiAgICAgICAqIENvbHVtbiBpbiB0aGUgaW5wdXQgZmlsZSB3aXRoIHRoaXMgd2FybmluZ+KAmXMgc291cmNlLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIHdhcm5pbmcuY29sdW1uIC8vPT4gNlxuICAgICAgICovdGhpcy5jb2x1bW49cG9zLmNvbHVtbjt9Zm9yKHZhciBvcHQgaW4gb3B0cyl7dGhpc1tvcHRdPW9wdHNbb3B0XTt9fS8qKlxuICAgKiBSZXR1cm5zIGEgd2FybmluZyBwb3NpdGlvbiBhbmQgbWVzc2FnZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogd2FybmluZy50b1N0cmluZygpIC8vPT4gJ3Bvc3Rjc3MtbGludDphLmNzczoxMDoxNDogQXZvaWQgIWltcG9ydGFudCdcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBXYXJuaW5nIHBvc2l0aW9uIGFuZCBtZXNzYWdlLlxuICAgKi92YXIgX3Byb3RvPVdhcm5pbmcucHJvdG90eXBlO19wcm90by50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe2lmKHRoaXMubm9kZSl7cmV0dXJuIHRoaXMubm9kZS5lcnJvcih0aGlzLnRleHQse3BsdWdpbjp0aGlzLnBsdWdpbixpbmRleDp0aGlzLmluZGV4LHdvcmQ6dGhpcy53b3JkfSkubWVzc2FnZTt9aWYodGhpcy5wbHVnaW4pe3JldHVybiB0aGlzLnBsdWdpbisnOiAnK3RoaXMudGV4dDt9cmV0dXJuIHRoaXMudGV4dDt9LyoqXG4gICAqIEBtZW1iZXJvZiBXYXJuaW5nI1xuICAgKiBAbWVtYmVyIHtzdHJpbmd9IHBsdWdpbiBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRoYXQgY3JlYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBpdCB3aWxsIGZpbGwgdGhpcyBwcm9wZXJ0eSBhdXRvbWF0aWNhbGx5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdhcm5pbmcuIFdoZW4geW91IGNhbGwge0BsaW5rIE5vZGUjd2Fybn1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogd2FybmluZy5wbHVnaW4gLy89PiAncG9zdGNzcy1pbXBvcnRhbnQnXG4gICAqLyAvKipcbiAgICogQG1lbWJlcm9mIFdhcm5pbmcjXG4gICAqIEBtZW1iZXIge05vZGV9IG5vZGUgQ29udGFpbnMgdGhlIENTUyBub2RlIHRoYXQgY2F1c2VkIHRoZSB3YXJuaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB3YXJuaW5nLm5vZGUudG9TdHJpbmcoKSAvLz0+ICdjb2xvcjogd2hpdGUgIWltcG9ydGFudCdcbiAgICovO3JldHVybiBXYXJuaW5nO30oKTt2YXIgX2RlZmF1bHQ9V2FybmluZztleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHt9XSwxOTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3M9bW9kdWxlLmV4cG9ydHM9e307Ly8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG52YXIgY2FjaGVkU2V0VGltZW91dDt2YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTt9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7fShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PSdmdW5jdGlvbicpe2NhY2hlZFNldFRpbWVvdXQ9c2V0VGltZW91dDt9ZWxzZXtjYWNoZWRTZXRUaW1lb3V0PWRlZmF1bHRTZXRUaW1vdXQ7fX1jYXRjaChlKXtjYWNoZWRTZXRUaW1lb3V0PWRlZmF1bHRTZXRUaW1vdXQ7fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09J2Z1bmN0aW9uJyl7Y2FjaGVkQ2xlYXJUaW1lb3V0PWNsZWFyVGltZW91dDt9ZWxzZXtjYWNoZWRDbGVhclRpbWVvdXQ9ZGVmYXVsdENsZWFyVGltZW91dDt9fWNhdGNoKGUpe2NhY2hlZENsZWFyVGltZW91dD1kZWZhdWx0Q2xlYXJUaW1lb3V0O319KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKXtpZihjYWNoZWRTZXRUaW1lb3V0PT09c2V0VGltZW91dCl7Ly9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG5yZXR1cm4gc2V0VGltZW91dChmdW4sMCk7fS8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5pZigoY2FjaGVkU2V0VGltZW91dD09PWRlZmF1bHRTZXRUaW1vdXR8fCFjYWNoZWRTZXRUaW1lb3V0KSYmc2V0VGltZW91dCl7Y2FjaGVkU2V0VGltZW91dD1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGZ1biwwKTt9dHJ5ey8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbnJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwwKTt9Y2F0Y2goZSl7dHJ5ey8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxucmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLGZ1biwwKTt9Y2F0Y2goZSl7Ly8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbnJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcyxmdW4sMCk7fX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcil7aWYoY2FjaGVkQ2xlYXJUaW1lb3V0PT09Y2xlYXJUaW1lb3V0KXsvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbnJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTt9Ly8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuaWYoKGNhY2hlZENsZWFyVGltZW91dD09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFjYWNoZWRDbGVhclRpbWVvdXQpJiZjbGVhclRpbWVvdXQpe2NhY2hlZENsZWFyVGltZW91dD1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO310cnl7Ly8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xucmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO31jYXRjaChlKXt0cnl7Ly8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxucmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsbWFya2VyKTt9Y2F0Y2goZSl7Ly8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4vLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG5yZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcyxtYXJrZXIpO319fXZhciBxdWV1ZT1bXTt2YXIgZHJhaW5pbmc9ZmFsc2U7dmFyIGN1cnJlbnRRdWV1ZTt2YXIgcXVldWVJbmRleD0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighZHJhaW5pbmd8fCFjdXJyZW50UXVldWUpe3JldHVybjt9ZHJhaW5pbmc9ZmFsc2U7aWYoY3VycmVudFF1ZXVlLmxlbmd0aCl7cXVldWU9Y3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7fWVsc2V7cXVldWVJbmRleD0tMTt9aWYocXVldWUubGVuZ3RoKXtkcmFpblF1ZXVlKCk7fX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYoZHJhaW5pbmcpe3JldHVybjt9dmFyIHRpbWVvdXQ9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO2RyYWluaW5nPXRydWU7dmFyIGxlbj1xdWV1ZS5sZW5ndGg7d2hpbGUobGVuKXtjdXJyZW50UXVldWU9cXVldWU7cXVldWU9W107d2hpbGUoKytxdWV1ZUluZGV4PGxlbil7aWYoY3VycmVudFF1ZXVlKXtjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7fX1xdWV1ZUluZGV4PS0xO2xlbj1xdWV1ZS5sZW5ndGg7fWN1cnJlbnRRdWV1ZT1udWxsO2RyYWluaW5nPWZhbHNlO3J1bkNsZWFyVGltZW91dCh0aW1lb3V0KTt9cHJvY2Vzcy5uZXh0VGljaz1mdW5jdGlvbihmdW4pe3ZhciBhcmdzPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciBpPTE7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7YXJnc1tpLTFdPWFyZ3VtZW50c1tpXTt9fXF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLGFyZ3MpKTtpZihxdWV1ZS5sZW5ndGg9PT0xJiYhZHJhaW5pbmcpe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSk7fX07Ly8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sYXJyYXkpe3RoaXMuZnVuPWZ1bjt0aGlzLmFycmF5PWFycmF5O31JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpO307cHJvY2Vzcy50aXRsZT0nYnJvd3Nlcic7cHJvY2Vzcy5icm93c2VyPXRydWU7cHJvY2Vzcy5lbnY9e307cHJvY2Vzcy5hcmd2PVtdO3Byb2Nlc3MudmVyc2lvbj0nJzsvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXByb2Nlc3Mub249bm9vcDtwcm9jZXNzLmFkZExpc3RlbmVyPW5vb3A7cHJvY2Vzcy5vbmNlPW5vb3A7cHJvY2Vzcy5vZmY9bm9vcDtwcm9jZXNzLnJlbW92ZUxpc3RlbmVyPW5vb3A7cHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDtwcm9jZXNzLmVtaXQ9bm9vcDtwcm9jZXNzLnByZXBlbmRMaXN0ZW5lcj1ub29wO3Byb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3Byb2Nlc3MubGlzdGVuZXJzPWZ1bmN0aW9uKG5hbWUpe3JldHVybltdO307cHJvY2Vzcy5iaW5kaW5nPWZ1bmN0aW9uKG5hbWUpe3Rocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTt9O3Byb2Nlc3MuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuJy8nO307cHJvY2Vzcy5jaGRpcj1mdW5jdGlvbihkaXIpe3Rocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7fTtwcm9jZXNzLnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDA7fTt9LHt9XSwxOTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpey8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovOyhmdW5jdGlvbihyb290KXsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovdmFyIGZyZWVFeHBvcnRzPV90eXBlb2YoZXhwb3J0cyk9PSdvYmplY3QnJiZleHBvcnRzJiYhZXhwb3J0cy5ub2RlVHlwZSYmZXhwb3J0czt2YXIgZnJlZU1vZHVsZT1fdHlwZW9mKG1vZHVsZSk9PSdvYmplY3QnJiZtb2R1bGUmJiFtb2R1bGUubm9kZVR5cGUmJm1vZHVsZTt2YXIgZnJlZUdsb2JhbD1fdHlwZW9mKGdsb2JhbCk9PSdvYmplY3QnJiZnbG9iYWw7aWYoZnJlZUdsb2JhbC5nbG9iYWw9PT1mcmVlR2xvYmFsfHxmcmVlR2xvYmFsLndpbmRvdz09PWZyZWVHbG9iYWx8fGZyZWVHbG9iYWwuc2VsZj09PWZyZWVHbG9iYWwpe3Jvb3Q9ZnJlZUdsb2JhbDt9LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL3ZhciBwdW55Y29kZSwvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovbWF4SW50PTIxNDc0ODM2NDcsLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL2Jhc2U9MzYsdE1pbj0xLHRNYXg9MjYsc2tldz0zOCxkYW1wPTcwMCxpbml0aWFsQmlhcz03Mixpbml0aWFsTj0xMjgsLy8gMHg4MFxuZGVsaW1pdGVyPSctJywvLyAnXFx4MkQnXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL3JlZ2V4UHVueWNvZGU9L154bi0tLyxyZWdleE5vbkFTQ0lJPS9bXlxceDIwLVxceDdFXS8sLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcbnJlZ2V4U2VwYXJhdG9ycz0vW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcbi8qKiBFcnJvciBtZXNzYWdlcyAqL2Vycm9ycz17J292ZXJmbG93JzonT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLCdub3QtYmFzaWMnOidJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJywnaW52YWxpZC1pbnB1dCc6J0ludmFsaWQgaW5wdXQnfSwvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovYmFzZU1pbnVzVE1pbj1iYXNlLXRNaW4sZmxvb3I9TWF0aC5mbG9vcixzdHJpbmdGcm9tQ2hhckNvZGU9U3RyaW5nLmZyb21DaGFyQ29kZSwvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICova2V5Oy8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLyAvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL2Z1bmN0aW9uIGVycm9yKHR5cGUpe3Rocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7fS8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovZnVuY3Rpb24gbWFwKGFycmF5LGZuKXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aDt2YXIgcmVzdWx0PVtdO3doaWxlKGxlbmd0aC0tKXtyZXN1bHRbbGVuZ3RoXT1mbihhcnJheVtsZW5ndGhdKTt9cmV0dXJuIHJlc3VsdDt9LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9mdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLGZuKXt2YXIgcGFydHM9c3RyaW5nLnNwbGl0KCdAJyk7dmFyIHJlc3VsdD0nJztpZihwYXJ0cy5sZW5ndGg+MSl7Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuLy8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cbnJlc3VsdD1wYXJ0c1swXSsnQCc7c3RyaW5nPXBhcnRzWzFdO30vLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5zdHJpbmc9c3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCdcXHgyRScpO3ZhciBsYWJlbHM9c3RyaW5nLnNwbGl0KCcuJyk7dmFyIGVuY29kZWQ9bWFwKGxhYmVscyxmbikuam9pbignLicpO3JldHVybiByZXN1bHQrZW5jb2RlZDt9LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL2Z1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKXt2YXIgb3V0cHV0PVtdLGNvdW50ZXI9MCxsZW5ndGg9c3RyaW5nLmxlbmd0aCx2YWx1ZSxleHRyYTt3aGlsZShjb3VudGVyPGxlbmd0aCl7dmFsdWU9c3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtpZih2YWx1ZT49MHhEODAwJiZ2YWx1ZTw9MHhEQkZGJiZjb3VudGVyPGxlbmd0aCl7Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5leHRyYT1zdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO2lmKChleHRyYSYweEZDMDApPT0weERDMDApey8vIGxvdyBzdXJyb2dhdGVcbm91dHB1dC5wdXNoKCgodmFsdWUmMHgzRkYpPDwxMCkrKGV4dHJhJjB4M0ZGKSsweDEwMDAwKTt9ZWxzZXsvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuLy8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5vdXRwdXQucHVzaCh2YWx1ZSk7Y291bnRlci0tO319ZWxzZXtvdXRwdXQucHVzaCh2YWx1ZSk7fX1yZXR1cm4gb3V0cHV0O30vKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSl7cmV0dXJuIG1hcChhcnJheSxmdW5jdGlvbih2YWx1ZSl7dmFyIG91dHB1dD0nJztpZih2YWx1ZT4weEZGRkYpe3ZhbHVlLT0weDEwMDAwO291dHB1dCs9c3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlPj4+MTAmMHgzRkZ8MHhEODAwKTt2YWx1ZT0weERDMDB8dmFsdWUmMHgzRkY7fW91dHB1dCs9c3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtyZXR1cm4gb3V0cHV0O30pLmpvaW4oJycpO30vKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCl7aWYoY29kZVBvaW50LTQ4PDEwKXtyZXR1cm4gY29kZVBvaW50LTIyO31pZihjb2RlUG9pbnQtNjU8MjYpe3JldHVybiBjb2RlUG9pbnQtNjU7fWlmKGNvZGVQb2ludC05NzwyNil7cmV0dXJuIGNvZGVQb2ludC05Nzt9cmV0dXJuIGJhc2U7fS8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LGZsYWcpey8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG4vLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbnJldHVybiBkaWdpdCsyMis3NSooZGlnaXQ8MjYpLSgoZmxhZyE9MCk8PDUpO30vKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovZnVuY3Rpb24gYWRhcHQoZGVsdGEsbnVtUG9pbnRzLGZpcnN0VGltZSl7dmFyIGs9MDtkZWx0YT1maXJzdFRpbWU/Zmxvb3IoZGVsdGEvZGFtcCk6ZGVsdGE+PjE7ZGVsdGErPWZsb29yKGRlbHRhL251bVBvaW50cyk7Zm9yKDsvKiBubyBpbml0aWFsaXphdGlvbiAqL2RlbHRhPmJhc2VNaW51c1RNaW4qdE1heD4+MTtrKz1iYXNlKXtkZWx0YT1mbG9vcihkZWx0YS9iYXNlTWludXNUTWluKTt9cmV0dXJuIGZsb29yKGsrKGJhc2VNaW51c1RNaW4rMSkqZGVsdGEvKGRlbHRhK3NrZXcpKTt9LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovZnVuY3Rpb24gZGVjb2RlKGlucHV0KXsvLyBEb24ndCB1c2UgVUNTLTJcbnZhciBvdXRwdXQ9W10saW5wdXRMZW5ndGg9aW5wdXQubGVuZ3RoLG91dCxpPTAsbj1pbml0aWFsTixiaWFzPWluaXRpYWxCaWFzLGJhc2ljLGosaW5kZXgsb2xkaSx3LGssZGlnaXQsdCwvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9iYXNlTWludXNUOy8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuLy8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcbi8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuYmFzaWM9aW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtpZihiYXNpYzwwKXtiYXNpYz0wO31mb3Ioaj0wO2o8YmFzaWM7KytqKXsvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcbmlmKGlucHV0LmNoYXJDb2RlQXQoaik+PTB4ODApe2Vycm9yKCdub3QtYmFzaWMnKTt9b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7fS8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcbi8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5mb3IoaW5kZXg9YmFzaWM+MD9iYXNpYysxOjA7aW5kZXg8aW5wdXRMZW5ndGg7KS8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi97Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuLy8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuLy8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcbi8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG4vLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuZm9yKG9sZGk9aSx3PTEsaz1iYXNlOzsvKiBubyBjb25kaXRpb24gKi9rKz1iYXNlKXtpZihpbmRleD49aW5wdXRMZW5ndGgpe2Vycm9yKCdpbnZhbGlkLWlucHV0Jyk7fWRpZ2l0PWJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtpZihkaWdpdD49YmFzZXx8ZGlnaXQ+Zmxvb3IoKG1heEludC1pKS93KSl7ZXJyb3IoJ292ZXJmbG93Jyk7fWkrPWRpZ2l0Knc7dD1rPD1iaWFzP3RNaW46az49Ymlhcyt0TWF4P3RNYXg6ay1iaWFzO2lmKGRpZ2l0PHQpe2JyZWFrO31iYXNlTWludXNUPWJhc2UtdDtpZih3PmZsb29yKG1heEludC9iYXNlTWludXNUKSl7ZXJyb3IoJ292ZXJmbG93Jyk7fXcqPWJhc2VNaW51c1Q7fW91dD1vdXRwdXQubGVuZ3RoKzE7Ymlhcz1hZGFwdChpLW9sZGksb3V0LG9sZGk9PTApOy8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG4vLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuaWYoZmxvb3IoaS9vdXQpPm1heEludC1uKXtlcnJvcignb3ZlcmZsb3cnKTt9bis9Zmxvb3IoaS9vdXQpO2klPW91dDsvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5vdXRwdXQuc3BsaWNlKGkrKywwLG4pO31yZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO30vKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9mdW5jdGlvbiBlbmNvZGUoaW5wdXQpe3ZhciBuLGRlbHRhLGhhbmRsZWRDUENvdW50LGJhc2ljTGVuZ3RoLGJpYXMsaixtLHEsayx0LGN1cnJlbnRWYWx1ZSxvdXRwdXQ9W10sLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9pbnB1dExlbmd0aCwvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9oYW5kbGVkQ1BDb3VudFBsdXNPbmUsYmFzZU1pbnVzVCxxTWludXNUOy8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcbmlucHV0PXVjczJkZWNvZGUoaW5wdXQpOy8vIENhY2hlIHRoZSBsZW5ndGhcbmlucHV0TGVuZ3RoPWlucHV0Lmxlbmd0aDsvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxubj1pbml0aWFsTjtkZWx0YT0wO2JpYXM9aW5pdGlhbEJpYXM7Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuZm9yKGo9MDtqPGlucHV0TGVuZ3RoOysrail7Y3VycmVudFZhbHVlPWlucHV0W2pdO2lmKGN1cnJlbnRWYWx1ZTwweDgwKXtvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7fX1oYW5kbGVkQ1BDb3VudD1iYXNpY0xlbmd0aD1vdXRwdXQubGVuZ3RoOy8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuLy8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuLy8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5pZihiYXNpY0xlbmd0aCl7b3V0cHV0LnB1c2goZGVsaW1pdGVyKTt9Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxud2hpbGUoaGFuZGxlZENQQ291bnQ8aW5wdXRMZW5ndGgpey8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcbi8vIGxhcmdlciBvbmU6XG5mb3IobT1tYXhJbnQsaj0wO2o8aW5wdXRMZW5ndGg7KytqKXtjdXJyZW50VmFsdWU9aW5wdXRbal07aWYoY3VycmVudFZhbHVlPj1uJiZjdXJyZW50VmFsdWU8bSl7bT1jdXJyZW50VmFsdWU7fX0vLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG4vLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuaGFuZGxlZENQQ291bnRQbHVzT25lPWhhbmRsZWRDUENvdW50KzE7aWYobS1uPmZsb29yKChtYXhJbnQtZGVsdGEpL2hhbmRsZWRDUENvdW50UGx1c09uZSkpe2Vycm9yKCdvdmVyZmxvdycpO31kZWx0YSs9KG0tbikqaGFuZGxlZENQQ291bnRQbHVzT25lO249bTtmb3Ioaj0wO2o8aW5wdXRMZW5ndGg7KytqKXtjdXJyZW50VmFsdWU9aW5wdXRbal07aWYoY3VycmVudFZhbHVlPG4mJisrZGVsdGE+bWF4SW50KXtlcnJvcignb3ZlcmZsb3cnKTt9aWYoY3VycmVudFZhbHVlPT1uKXsvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuZm9yKHE9ZGVsdGEsaz1iYXNlOzsvKiBubyBjb25kaXRpb24gKi9rKz1iYXNlKXt0PWs8PWJpYXM/dE1pbjprPj1iaWFzK3RNYXg/dE1heDprLWJpYXM7aWYocTx0KXticmVhazt9cU1pbnVzVD1xLXQ7YmFzZU1pbnVzVD1iYXNlLXQ7b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0K3FNaW51c1QlYmFzZU1pbnVzVCwwKSkpO3E9Zmxvb3IocU1pbnVzVC9iYXNlTWludXNUKTt9b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLDApKSk7Ymlhcz1hZGFwdChkZWx0YSxoYW5kbGVkQ1BDb3VudFBsdXNPbmUsaGFuZGxlZENQQ291bnQ9PWJhc2ljTGVuZ3RoKTtkZWx0YT0wOysraGFuZGxlZENQQ291bnQ7fX0rK2RlbHRhOysrbjt9cmV0dXJuIG91dHB1dC5qb2luKCcnKTt9LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KXtyZXR1cm4gbWFwRG9tYWluKGlucHV0LGZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpP2RlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSk6c3RyaW5nO30pO30vKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9mdW5jdGlvbiB0b0FTQ0lJKGlucHV0KXtyZXR1cm4gbWFwRG9tYWluKGlucHV0LGZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpPyd4bi0tJytlbmNvZGUoc3RyaW5nKTpzdHJpbmc7fSk7fS8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLyAvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovcHVueWNvZGU9ey8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi8ndmVyc2lvbic6JzEuNC4xJywvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovJ3VjczInOnsnZGVjb2RlJzp1Y3MyZGVjb2RlLCdlbmNvZGUnOnVjczJlbmNvZGV9LCdkZWNvZGUnOmRlY29kZSwnZW5jb2RlJzplbmNvZGUsJ3RvQVNDSUknOnRvQVNDSUksJ3RvVW5pY29kZSc6dG9Vbmljb2RlfTsvKiogRXhwb3NlIGBwdW55Y29kZWAgKi8gLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG4vLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5pZih0eXBlb2YgZGVmaW5lPT0nZnVuY3Rpb24nJiZfdHlwZW9mKGRlZmluZS5hbWQpPT0nb2JqZWN0JyYmZGVmaW5lLmFtZCl7ZGVmaW5lKCdwdW55Y29kZScsZnVuY3Rpb24oKXtyZXR1cm4gcHVueWNvZGU7fSk7fWVsc2UgaWYoZnJlZUV4cG9ydHMmJmZyZWVNb2R1bGUpe2lmKG1vZHVsZS5leHBvcnRzPT1mcmVlRXhwb3J0cyl7Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuZnJlZU1vZHVsZS5leHBvcnRzPXB1bnljb2RlO31lbHNley8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5mb3Ioa2V5IGluIHB1bnljb2RlKXtwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpJiYoZnJlZUV4cG9ydHNba2V5XT1wdW55Y29kZVtrZXldKTt9fX1lbHNley8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcbnJvb3QucHVueWNvZGU9cHVueWNvZGU7fX0pKHRoaXMpO30pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIj9nbG9iYWw6dHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KTt9LHt9XSwxOTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnOy8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaixwcm9wKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaixwcm9wKTt9bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24ocXMsc2VwLGVxLG9wdGlvbnMpe3NlcD1zZXB8fCcmJztlcT1lcXx8Jz0nO3ZhciBvYmo9e307aWYodHlwZW9mIHFzIT09J3N0cmluZyd8fHFzLmxlbmd0aD09PTApe3JldHVybiBvYmo7fXZhciByZWdleHA9L1xcKy9nO3FzPXFzLnNwbGl0KHNlcCk7dmFyIG1heEtleXM9MTAwMDtpZihvcHRpb25zJiZ0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzPT09J251bWJlcicpe21heEtleXM9b3B0aW9ucy5tYXhLZXlzO312YXIgbGVuPXFzLmxlbmd0aDsvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbmlmKG1heEtleXM+MCYmbGVuPm1heEtleXMpe2xlbj1tYXhLZXlzO31mb3IodmFyIGk9MDtpPGxlbjsrK2kpe3ZhciB4PXFzW2ldLnJlcGxhY2UocmVnZXhwLCclMjAnKSxpZHg9eC5pbmRleE9mKGVxKSxrc3RyLHZzdHIsayx2O2lmKGlkeD49MCl7a3N0cj14LnN1YnN0cigwLGlkeCk7dnN0cj14LnN1YnN0cihpZHgrMSk7fWVsc2V7a3N0cj14O3ZzdHI9Jyc7fWs9ZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO3Y9ZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO2lmKCFoYXNPd25Qcm9wZXJ0eShvYmosaykpe29ialtrXT12O31lbHNlIGlmKGlzQXJyYXkob2JqW2tdKSl7b2JqW2tdLnB1c2godik7fWVsc2V7b2JqW2tdPVtvYmpba10sdl07fX1yZXR1cm4gb2JqO307dmFyIGlzQXJyYXk9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oeHMpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpPT09J1tvYmplY3QgQXJyYXldJzt9O30se31dLDE5NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7Ly8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7dmFyIHN0cmluZ2lmeVByaW1pdGl2ZT1mdW5jdGlvbiBzdHJpbmdpZnlQcmltaXRpdmUodil7c3dpdGNoKF90eXBlb2Yodikpe2Nhc2Unc3RyaW5nJzpyZXR1cm4gdjtjYXNlJ2Jvb2xlYW4nOnJldHVybiB2Pyd0cnVlJzonZmFsc2UnO2Nhc2UnbnVtYmVyJzpyZXR1cm4gaXNGaW5pdGUodik/djonJztkZWZhdWx0OnJldHVybicnO319O21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKG9iaixzZXAsZXEsbmFtZSl7c2VwPXNlcHx8JyYnO2VxPWVxfHwnPSc7aWYob2JqPT09bnVsbCl7b2JqPXVuZGVmaW5lZDt9aWYoX3R5cGVvZihvYmopPT09J29iamVjdCcpe3JldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLGZ1bmN0aW9uKGspe3ZhciBrcz1lbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKStlcTtpZihpc0FycmF5KG9ialtrXSkpe3JldHVybiBtYXAob2JqW2tdLGZ1bmN0aW9uKHYpe3JldHVybiBrcytlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTt9KS5qb2luKHNlcCk7fWVsc2V7cmV0dXJuIGtzK2VuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7fX0pLmpvaW4oc2VwKTt9aWYoIW5hbWUpcmV0dXJuJyc7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpK2VxK2VuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7fTt2YXIgaXNBcnJheT1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih4cyl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cyk9PT0nW29iamVjdCBBcnJheV0nO307ZnVuY3Rpb24gbWFwKHhzLGYpe2lmKHhzLm1hcClyZXR1cm4geHMubWFwKGYpO3ZhciByZXM9W107Zm9yKHZhciBpPTA7aTx4cy5sZW5ndGg7aSsrKXtyZXMucHVzaChmKHhzW2ldLGkpKTt9cmV0dXJuIHJlczt9dmFyIG9iamVjdEtleXM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKG9iail7dmFyIHJlcz1bXTtmb3IodmFyIGtleSBpbiBvYmope2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSlyZXMucHVzaChrZXkpO31yZXR1cm4gcmVzO307fSx7fV0sMTk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsndXNlIHN0cmljdCc7ZXhwb3J0cy5kZWNvZGU9ZXhwb3J0cy5wYXJzZT1yZXF1aXJlKCcuL2RlY29kZScpO2V4cG9ydHMuZW5jb2RlPWV4cG9ydHMuc3RyaW5naWZ5PXJlcXVpcmUoJy4vZW5jb2RlJyk7fSx7XCIuL2RlY29kZVwiOjE5NCxcIi4vZW5jb2RlXCI6MTk1fV0sMTk3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovIC8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi92YXIgdXRpbD1yZXF1aXJlKCcuL3V0aWwnKTt2YXIgaGFzPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIGhhc05hdGl2ZU1hcD10eXBlb2YgTWFwIT09XCJ1bmRlZmluZWRcIjsvKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9mdW5jdGlvbiBBcnJheVNldCgpe3RoaXMuX2FycmF5PVtdO3RoaXMuX3NldD1oYXNOYXRpdmVNYXA/bmV3IE1hcCgpOk9iamVjdC5jcmVhdGUobnVsbCk7fS8qKlxuICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gKi9BcnJheVNldC5mcm9tQXJyYXk9ZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSxhQWxsb3dEdXBsaWNhdGVzKXt2YXIgc2V0PW5ldyBBcnJheVNldCgpO2Zvcih2YXIgaT0wLGxlbj1hQXJyYXkubGVuZ3RoO2k8bGVuO2krKyl7c2V0LmFkZChhQXJyYXlbaV0sYUFsbG93RHVwbGljYXRlcyk7fXJldHVybiBzZXQ7fTsvKipcbiAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAqXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL0FycmF5U2V0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKXtyZXR1cm4gaGFzTmF0aXZlTWFwP3RoaXMuX3NldC5zaXplOk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO307LyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL0FycmF5U2V0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsYUFsbG93RHVwbGljYXRlcyl7dmFyIHNTdHI9aGFzTmF0aXZlTWFwP2FTdHI6dXRpbC50b1NldFN0cmluZyhhU3RyKTt2YXIgaXNEdXBsaWNhdGU9aGFzTmF0aXZlTWFwP3RoaXMuaGFzKGFTdHIpOmhhcy5jYWxsKHRoaXMuX3NldCxzU3RyKTt2YXIgaWR4PXRoaXMuX2FycmF5Lmxlbmd0aDtpZighaXNEdXBsaWNhdGV8fGFBbGxvd0R1cGxpY2F0ZXMpe3RoaXMuX2FycmF5LnB1c2goYVN0cik7fWlmKCFpc0R1cGxpY2F0ZSl7aWYoaGFzTmF0aXZlTWFwKXt0aGlzLl9zZXQuc2V0KGFTdHIsaWR4KTt9ZWxzZXt0aGlzLl9zZXRbc1N0cl09aWR4O319fTsvKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9BcnJheVNldC5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKXtpZihoYXNOYXRpdmVNYXApe3JldHVybiB0aGlzLl9zZXQuaGFzKGFTdHIpO31lbHNle3ZhciBzU3RyPXV0aWwudG9TZXRTdHJpbmcoYVN0cik7cmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCxzU3RyKTt9fTsvKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKXtpZihoYXNOYXRpdmVNYXApe3ZhciBpZHg9dGhpcy5fc2V0LmdldChhU3RyKTtpZihpZHg+PTApe3JldHVybiBpZHg7fX1lbHNle3ZhciBzU3RyPXV0aWwudG9TZXRTdHJpbmcoYVN0cik7aWYoaGFzLmNhbGwodGhpcy5fc2V0LHNTdHIpKXtyZXR1cm4gdGhpcy5fc2V0W3NTdHJdO319dGhyb3cgbmV3IEVycm9yKCdcIicrYVN0cisnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7fTsvKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovQXJyYXlTZXQucHJvdG90eXBlLmF0PWZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpe2lmKGFJZHg+PTAmJmFJZHg8dGhpcy5fYXJyYXkubGVuZ3RoKXtyZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07fXRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcrYUlkeCk7fTsvKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL0FycmF5U2V0LnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKXtyZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTt9O2V4cG9ydHMuQXJyYXlTZXQ9QXJyYXlTZXQ7fSx7XCIuL3V0aWxcIjoyMDZ9XSwxOTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi8gLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL3ZhciBiYXNlNjQ9cmVxdWlyZSgnLi9iYXNlNjQnKTsvLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcbnZhciBWTFFfQkFTRV9TSElGVD01Oy8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0U9MTw8VkxRX0JBU0VfU0hJRlQ7Ly8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLPVZMUV9CQVNFLTE7Ly8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVD1WTFFfQkFTRTsvKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpe3JldHVybiBhVmFsdWU8MD8oLWFWYWx1ZTw8MSkrMTooYVZhbHVlPDwxKSswO30vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSl7dmFyIGlzTmVnYXRpdmU9KGFWYWx1ZSYxKT09PTE7dmFyIHNoaWZ0ZWQ9YVZhbHVlPj4xO3JldHVybiBpc05lZ2F0aXZlPy1zaGlmdGVkOnNoaWZ0ZWQ7fS8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL2V4cG9ydHMuZW5jb2RlPWZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKXt2YXIgZW5jb2RlZD1cIlwiO3ZhciBkaWdpdDt2YXIgdmxxPXRvVkxRU2lnbmVkKGFWYWx1ZSk7ZG97ZGlnaXQ9dmxxJlZMUV9CQVNFX01BU0s7dmxxPj4+PVZMUV9CQVNFX1NISUZUO2lmKHZscT4wKXsvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4vLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbmRpZ2l0fD1WTFFfQ09OVElOVUFUSU9OX0JJVDt9ZW5jb2RlZCs9YmFzZTY0LmVuY29kZShkaWdpdCk7fXdoaWxlKHZscT4wKTtyZXR1cm4gZW5jb2RlZDt9Oy8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9leHBvcnRzLmRlY29kZT1mdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsYUluZGV4LGFPdXRQYXJhbSl7dmFyIHN0ckxlbj1hU3RyLmxlbmd0aDt2YXIgcmVzdWx0PTA7dmFyIHNoaWZ0PTA7dmFyIGNvbnRpbnVhdGlvbixkaWdpdDtkb3tpZihhSW5kZXg+PXN0ckxlbil7dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO31kaWdpdD1iYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO2lmKGRpZ2l0PT09LTEpe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIithU3RyLmNoYXJBdChhSW5kZXgtMSkpO31jb250aW51YXRpb249ISEoZGlnaXQmVkxRX0NPTlRJTlVBVElPTl9CSVQpO2RpZ2l0Jj1WTFFfQkFTRV9NQVNLO3Jlc3VsdD1yZXN1bHQrKGRpZ2l0PDxzaGlmdCk7c2hpZnQrPVZMUV9CQVNFX1NISUZUO313aGlsZShjb250aW51YXRpb24pO2FPdXRQYXJhbS52YWx1ZT1mcm9tVkxRU2lnbmVkKHJlc3VsdCk7YU91dFBhcmFtLnJlc3Q9YUluZGV4O307fSx7XCIuL2Jhc2U2NFwiOjE5OX1dLDE5OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLyAvKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovdmFyIGludFRvQ2hhck1hcD0nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpOy8qKlxuICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAqL2V4cG9ydHMuZW5jb2RlPWZ1bmN0aW9uKG51bWJlcil7aWYoMDw9bnVtYmVyJiZudW1iZXI8aW50VG9DaGFyTWFwLmxlbmd0aCl7cmV0dXJuIGludFRvQ2hhck1hcFtudW1iZXJdO310aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIitudW1iZXIpO307LyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovZXhwb3J0cy5kZWNvZGU9ZnVuY3Rpb24oY2hhckNvZGUpe3ZhciBiaWdBPTY1Oy8vICdBJ1xudmFyIGJpZ1o9OTA7Ly8gJ1onXG52YXIgbGl0dGxlQT05NzsvLyAnYSdcbnZhciBsaXR0bGVaPTEyMjsvLyAneidcbnZhciB6ZXJvPTQ4Oy8vICcwJ1xudmFyIG5pbmU9NTc7Ly8gJzknXG52YXIgcGx1cz00MzsvLyAnKydcbnZhciBzbGFzaD00NzsvLyAnLydcbnZhciBsaXR0bGVPZmZzZXQ9MjY7dmFyIG51bWJlck9mZnNldD01MjsvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG5pZihiaWdBPD1jaGFyQ29kZSYmY2hhckNvZGU8PWJpZ1ope3JldHVybiBjaGFyQ29kZS1iaWdBO30vLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuaWYobGl0dGxlQTw9Y2hhckNvZGUmJmNoYXJDb2RlPD1saXR0bGVaKXtyZXR1cm4gY2hhckNvZGUtbGl0dGxlQStsaXR0bGVPZmZzZXQ7fS8vIDUyIC0gNjE6IDAxMjM0NTY3ODlcbmlmKHplcm88PWNoYXJDb2RlJiZjaGFyQ29kZTw9bmluZSl7cmV0dXJuIGNoYXJDb2RlLXplcm8rbnVtYmVyT2Zmc2V0O30vLyA2MjogK1xuaWYoY2hhckNvZGU9PXBsdXMpe3JldHVybiA2Mjt9Ly8gNjM6IC9cbmlmKGNoYXJDb2RlPT1zbGFzaCl7cmV0dXJuIDYzO30vLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbnJldHVybi0xO307fSx7fV0sMjAwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovIC8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9leHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EPTE7ZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORD0yOy8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csYUhpZ2gsYU5lZWRsZSxhSGF5c3RhY2ssYUNvbXBhcmUsYUJpYXMpey8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4vL1xuLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbi8vXG4vLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIGluZGV4IG9mXG4vLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbi8vXG4vLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxudmFyIG1pZD1NYXRoLmZsb29yKChhSGlnaC1hTG93KS8yKSthTG93O3ZhciBjbXA9YUNvbXBhcmUoYU5lZWRsZSxhSGF5c3RhY2tbbWlkXSx0cnVlKTtpZihjbXA9PT0wKXsvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG5yZXR1cm4gbWlkO31lbHNlIGlmKGNtcD4wKXsvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbmlmKGFIaWdoLW1pZD4xKXsvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbnJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLGFIaWdoLGFOZWVkbGUsYUhheXN0YWNrLGFDb21wYXJlLGFCaWFzKTt9Ly8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4vLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuaWYoYUJpYXM9PWV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpe3JldHVybiBhSGlnaDxhSGF5c3RhY2subGVuZ3RoP2FIaWdoOi0xO31lbHNle3JldHVybiBtaWQ7fX1lbHNley8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuaWYobWlkLWFMb3c+MSl7Ly8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG5yZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csbWlkLGFOZWVkbGUsYUhheXN0YWNrLGFDb21wYXJlLGFCaWFzKTt9Ly8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbmlmKGFCaWFzPT1leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKXtyZXR1cm4gbWlkO31lbHNle3JldHVybiBhTG93PDA/LTE6YUxvdzt9fX0vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL2V4cG9ydHMuc2VhcmNoPWZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLGFIYXlzdGFjayxhQ29tcGFyZSxhQmlhcyl7aWYoYUhheXN0YWNrLmxlbmd0aD09PTApe3JldHVybi0xO312YXIgaW5kZXg9cmVjdXJzaXZlU2VhcmNoKC0xLGFIYXlzdGFjay5sZW5ndGgsYU5lZWRsZSxhSGF5c3RhY2ssYUNvbXBhcmUsYUJpYXN8fGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO2lmKGluZGV4PDApe3JldHVybi0xO30vLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW5cbi8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbi8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbndoaWxlKGluZGV4LTE+PTApe2lmKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sYUhheXN0YWNrW2luZGV4LTFdLHRydWUpIT09MCl7YnJlYWs7fS0taW5kZXg7fXJldHVybiBpbmRleDt9O30se31dLDIwMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLyAvKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovdmFyIHV0aWw9cmVxdWlyZSgnLi91dGlsJyk7LyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL2Z1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsbWFwcGluZ0Ipey8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxudmFyIGxpbmVBPW1hcHBpbmdBLmdlbmVyYXRlZExpbmU7dmFyIGxpbmVCPW1hcHBpbmdCLmdlbmVyYXRlZExpbmU7dmFyIGNvbHVtbkE9bWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO3ZhciBjb2x1bW5CPW1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtyZXR1cm4gbGluZUI+bGluZUF8fGxpbmVCPT1saW5lQSYmY29sdW1uQj49Y29sdW1uQXx8dXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSxtYXBwaW5nQik8PTA7fS8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL2Z1bmN0aW9uIE1hcHBpbmdMaXN0KCl7dGhpcy5fYXJyYXk9W107dGhpcy5fc29ydGVkPXRydWU7Ly8gU2VydmVzIGFzIGluZmltdW1cbnRoaXMuX2xhc3Q9e2dlbmVyYXRlZExpbmU6LTEsZ2VuZXJhdGVkQ29sdW1uOjB9O30vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL01hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2g9ZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssYVRoaXNBcmcpe3RoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLGFUaGlzQXJnKTt9Oy8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZyl7aWYoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LGFNYXBwaW5nKSl7dGhpcy5fbGFzdD1hTWFwcGluZzt0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTt9ZWxzZXt0aGlzLl9zb3J0ZWQ9ZmFsc2U7dGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7fX07LyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpe2lmKCF0aGlzLl9zb3J0ZWQpe3RoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7dGhpcy5fc29ydGVkPXRydWU7fXJldHVybiB0aGlzLl9hcnJheTt9O2V4cG9ydHMuTWFwcGluZ0xpc3Q9TWFwcGluZ0xpc3Q7fSx7XCIuL3V0aWxcIjoyMDZ9XSwyMDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi8gLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqLyAvLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9mdW5jdGlvbiBzd2FwKGFyeSx4LHkpe3ZhciB0ZW1wPWFyeVt4XTthcnlbeF09YXJ5W3ldO2FyeVt5XT10ZW1wO30vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csaGlnaCl7cmV0dXJuIE1hdGgucm91bmQobG93K01hdGgucmFuZG9tKCkqKGhpZ2gtbG93KSk7fS8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LGNvbXBhcmF0b3IscCxyKXsvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbi8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbi8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cbmlmKHA8cil7Ly8gKDEpIFBhcnRpdGlvbmluZy5cbi8vXG4vLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbi8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4vLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4vLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4vLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cbi8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4vLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbnZhciBwaXZvdEluZGV4PXJhbmRvbUludEluUmFuZ2UocCxyKTt2YXIgaT1wLTE7c3dhcChhcnkscGl2b3RJbmRleCxyKTt2YXIgcGl2b3Q9YXJ5W3JdOy8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuLy8gdHJ1ZTpcbi8vXG4vLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4vL1xuLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbmZvcih2YXIgaj1wO2o8cjtqKyspe2lmKGNvbXBhcmF0b3IoYXJ5W2pdLHBpdm90KTw9MCl7aSs9MTtzd2FwKGFyeSxpLGopO319c3dhcChhcnksaSsxLGopO3ZhciBxPWkrMTsvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5kb1F1aWNrU29ydChhcnksY29tcGFyYXRvcixwLHEtMSk7ZG9RdWlja1NvcnQoYXJ5LGNvbXBhcmF0b3IscSsxLHIpO319LyoqXG4gKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICovZXhwb3J0cy5xdWlja1NvcnQ9ZnVuY3Rpb24oYXJ5LGNvbXBhcmF0b3Ipe2RvUXVpY2tTb3J0KGFyeSxjb21wYXJhdG9yLDAsYXJ5Lmxlbmd0aC0xKTt9O30se31dLDIwMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLyAvKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovdmFyIHV0aWw9cmVxdWlyZSgnLi91dGlsJyk7dmFyIGJpbmFyeVNlYXJjaD1yZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTt2YXIgQXJyYXlTZXQ9cmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDt2YXIgYmFzZTY0VkxRPXJlcXVpcmUoJy4vYmFzZTY0LXZscScpO3ZhciBxdWlja1NvcnQ9cmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O2Z1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsYVNvdXJjZU1hcFVSTCl7dmFyIHNvdXJjZU1hcD1hU291cmNlTWFwO2lmKHR5cGVvZiBhU291cmNlTWFwPT09J3N0cmluZycpe3NvdXJjZU1hcD11dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7fXJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMhPW51bGw/bmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsYVNvdXJjZU1hcFVSTCk6bmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLGFTb3VyY2VNYXBVUkwpO31Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwPWZ1bmN0aW9uKGFTb3VyY2VNYXAsYVNvdXJjZU1hcFVSTCl7cmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLGFTb3VyY2VNYXBVUkwpO307LyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb249MzsvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbi8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4vLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbi8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuLy9cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4vL1xuLy8gICAgIHtcbi8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbi8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4vLyAgICAgICAgICAgICBjb2RlLlxuLy8gICAgIH1cbi8vXG4vLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4vLyBgbnVsbGAuXG4vL1xuLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbi8vXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzPW51bGw7T2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwnX2dlbmVyYXRlZE1hcHBpbmdzJyx7Y29uZmlndXJhYmxlOnRydWUsZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbiBnZXQoKXtpZighdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKXt0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLHRoaXMuc291cmNlUm9vdCk7fXJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7fX0pO1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3M9bnVsbDtPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCdfb3JpZ2luYWxNYXBwaW5ncycse2NvbmZpZ3VyYWJsZTp0cnVlLGVudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7aWYoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKXt0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLHRoaXMuc291cmNlUm9vdCk7fXJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nczt9fSk7U291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0cixpbmRleCl7dmFyIGM9YVN0ci5jaGFyQXQoaW5kZXgpO3JldHVybiBjPT09XCI7XCJ8fGM9PT1cIixcIjt9Oy8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0cixhU291cmNlUm9vdCl7dGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTt9O1NvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUj0xO1NvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSPTI7U291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQ9MTtTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORD0yOy8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjayxhQ29udGV4dCxhT3JkZXIpe3ZhciBjb250ZXh0PWFDb250ZXh0fHxudWxsO3ZhciBvcmRlcj1hT3JkZXJ8fFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjt2YXIgbWFwcGluZ3M7c3dpdGNoKG9yZGVyKXtjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjptYXBwaW5ncz10aGlzLl9nZW5lcmF0ZWRNYXBwaW5nczticmVhaztjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOm1hcHBpbmdzPXRoaXMuX29yaWdpbmFsTWFwcGluZ3M7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7fXZhciBzb3VyY2VSb290PXRoaXMuc291cmNlUm9vdDttYXBwaW5ncy5tYXAoZnVuY3Rpb24obWFwcGluZyl7dmFyIHNvdXJjZT1tYXBwaW5nLnNvdXJjZT09PW51bGw/bnVsbDp0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtzb3VyY2U9dXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3Qsc291cmNlLHRoaXMuX3NvdXJjZU1hcFVSTCk7cmV0dXJue3NvdXJjZTpzb3VyY2UsZ2VuZXJhdGVkTGluZTptYXBwaW5nLmdlbmVyYXRlZExpbmUsZ2VuZXJhdGVkQ29sdW1uOm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLG9yaWdpbmFsTGluZTptYXBwaW5nLm9yaWdpbmFsTGluZSxvcmlnaW5hbENvbHVtbjptYXBwaW5nLm9yaWdpbmFsQ29sdW1uLG5hbWU6bWFwcGluZy5uYW1lPT09bnVsbD9udWxsOnRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSl9O30sdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssY29udGV4dCk7fTsvKipcbiAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gKlxuICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3I9ZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKXt2YXIgbGluZT11dGlsLmdldEFyZyhhQXJncywnbGluZScpOy8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbi8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbnZhciBuZWVkbGU9e3NvdXJjZTp1dGlsLmdldEFyZyhhQXJncywnc291cmNlJyksb3JpZ2luYWxMaW5lOmxpbmUsb3JpZ2luYWxDb2x1bW46dXRpbC5nZXRBcmcoYUFyZ3MsJ2NvbHVtbicsMCl9O25lZWRsZS5zb3VyY2U9dGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO2lmKG5lZWRsZS5zb3VyY2U8MCl7cmV0dXJuW107fXZhciBtYXBwaW5ncz1bXTt2YXIgaW5kZXg9dGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXCJvcmlnaW5hbExpbmVcIixcIm9yaWdpbmFsQ29sdW1uXCIsdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO2lmKGluZGV4Pj0wKXt2YXIgbWFwcGluZz10aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtpZihhQXJncy5jb2x1bW49PT11bmRlZmluZWQpe3ZhciBvcmlnaW5hbExpbmU9bWFwcGluZy5vcmlnaW5hbExpbmU7Ly8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbi8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4vLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4vLyB0aGUgbGluZSB3ZSBmb3VuZC5cbndoaWxlKG1hcHBpbmcmJm1hcHBpbmcub3JpZ2luYWxMaW5lPT09b3JpZ2luYWxMaW5lKXttYXBwaW5ncy5wdXNoKHtsaW5lOnV0aWwuZ2V0QXJnKG1hcHBpbmcsJ2dlbmVyYXRlZExpbmUnLG51bGwpLGNvbHVtbjp1dGlsLmdldEFyZyhtYXBwaW5nLCdnZW5lcmF0ZWRDb2x1bW4nLG51bGwpLGxhc3RDb2x1bW46dXRpbC5nZXRBcmcobWFwcGluZywnbGFzdEdlbmVyYXRlZENvbHVtbicsbnVsbCl9KTttYXBwaW5nPXRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07fX1lbHNle3ZhciBvcmlnaW5hbENvbHVtbj1tYXBwaW5nLm9yaWdpbmFsQ29sdW1uOy8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4vLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbi8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3Jcbi8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxud2hpbGUobWFwcGluZyYmbWFwcGluZy5vcmlnaW5hbExpbmU9PT1saW5lJiZtYXBwaW5nLm9yaWdpbmFsQ29sdW1uPT1vcmlnaW5hbENvbHVtbil7bWFwcGluZ3MucHVzaCh7bGluZTp1dGlsLmdldEFyZyhtYXBwaW5nLCdnZW5lcmF0ZWRMaW5lJyxudWxsKSxjb2x1bW46dXRpbC5nZXRBcmcobWFwcGluZywnZ2VuZXJhdGVkQ29sdW1uJyxudWxsKSxsYXN0Q29sdW1uOnV0aWwuZ2V0QXJnKG1hcHBpbmcsJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLG51bGwpfSk7bWFwcGluZz10aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO319fXJldHVybiBtYXBwaW5nczt9O2V4cG9ydHMuU291cmNlTWFwQ29uc3VtZXI9U291cmNlTWFwQ29uc3VtZXI7LyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gKlxuICogICAgIHtcbiAqICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAqICAgICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLGFTb3VyY2VNYXBVUkwpe3ZhciBzb3VyY2VNYXA9YVNvdXJjZU1hcDtpZih0eXBlb2YgYVNvdXJjZU1hcD09PSdzdHJpbmcnKXtzb3VyY2VNYXA9dXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO312YXIgdmVyc2lvbj11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3ZlcnNpb24nKTt2YXIgc291cmNlcz11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3NvdXJjZXMnKTsvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4vLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxudmFyIG5hbWVzPXV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwnbmFtZXMnLFtdKTt2YXIgc291cmNlUm9vdD11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3NvdXJjZVJvb3QnLG51bGwpO3ZhciBzb3VyY2VzQ29udGVudD11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3NvdXJjZXNDb250ZW50JyxudWxsKTt2YXIgbWFwcGluZ3M9dXRpbC5nZXRBcmcoc291cmNlTWFwLCdtYXBwaW5ncycpO3ZhciBmaWxlPXV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwnZmlsZScsbnVsbCk7Ly8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4vLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuaWYodmVyc2lvbiE9dGhpcy5fdmVyc2lvbil7dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnK3ZlcnNpb24pO31pZihzb3VyY2VSb290KXtzb3VyY2VSb290PXV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO31zb3VyY2VzPXNvdXJjZXMubWFwKFN0cmluZykvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2Zcbi8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuLm1hcCh1dGlsLm5vcm1hbGl6ZSkvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbi8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbi5tYXAoZnVuY3Rpb24oc291cmNlKXtyZXR1cm4gc291cmNlUm9vdCYmdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpJiZ1dGlsLmlzQWJzb2x1dGUoc291cmNlKT91dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3Qsc291cmNlKTpzb3VyY2U7fSk7Ly8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbi8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbi8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbnRoaXMuX25hbWVzPUFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSx0cnVlKTt0aGlzLl9zb3VyY2VzPUFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLHRydWUpO3RoaXMuX2Fic29sdXRlU291cmNlcz10aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24ocyl7cmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LHMsYVNvdXJjZU1hcFVSTCk7fSk7dGhpcy5zb3VyY2VSb290PXNvdXJjZVJvb3Q7dGhpcy5zb3VyY2VzQ29udGVudD1zb3VyY2VzQ29udGVudDt0aGlzLl9tYXBwaW5ncz1tYXBwaW5nczt0aGlzLl9zb3VyY2VNYXBVUkw9YVNvdXJjZU1hcFVSTDt0aGlzLmZpbGU9ZmlsZTt9QmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyPVNvdXJjZU1hcENvbnN1bWVyOy8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kU291cmNlSW5kZXg9ZnVuY3Rpb24oYVNvdXJjZSl7dmFyIHJlbGF0aXZlU291cmNlPWFTb3VyY2U7aWYodGhpcy5zb3VyY2VSb290IT1udWxsKXtyZWxhdGl2ZVNvdXJjZT11dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCxyZWxhdGl2ZVNvdXJjZSk7fWlmKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSl7cmV0dXJuIHRoaXMuX3NvdXJjZXMuaW5kZXhPZihyZWxhdGl2ZVNvdXJjZSk7fS8vIE1heWJlIGFTb3VyY2UgaXMgYW4gYWJzb2x1dGUgVVJMIGFzIHJldHVybmVkIGJ5IHxzb3VyY2VzfC4gIEluXG4vLyB0aGlzIGNhc2Ugd2UgY2FuJ3Qgc2ltcGx5IHVuZG8gdGhlIHRyYW5zZm9ybS5cbnZhciBpO2ZvcihpPTA7aTx0aGlzLl9hYnNvbHV0ZVNvdXJjZXMubGVuZ3RoOysraSl7aWYodGhpcy5fYWJzb2x1dGVTb3VyY2VzW2ldPT1hU291cmNlKXtyZXR1cm4gaTt9fXJldHVybi0xO307LyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHBhcmFtIFN0cmluZyBhU291cmNlTWFwVVJMXG4gKiAgICAgICAgVGhlIFVSTCBhdCB3aGljaCB0aGUgc291cmNlIG1hcCBjYW4gYmUgZm91bmQgKG9wdGlvbmFsKVxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCxhU291cmNlTWFwVVJMKXt2YXIgc21jPU9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO3ZhciBuYW1lcz1zbWMuX25hbWVzPUFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksdHJ1ZSk7dmFyIHNvdXJjZXM9c21jLl9zb3VyY2VzPUFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSx0cnVlKTtzbWMuc291cmNlUm9vdD1hU291cmNlTWFwLl9zb3VyY2VSb290O3NtYy5zb3VyY2VzQ29udGVudD1hU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksc21jLnNvdXJjZVJvb3QpO3NtYy5maWxlPWFTb3VyY2VNYXAuX2ZpbGU7c21jLl9zb3VyY2VNYXBVUkw9YVNvdXJjZU1hcFVSTDtzbWMuX2Fic29sdXRlU291cmNlcz1zbWMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbihzKXtyZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNtYy5zb3VyY2VSb290LHMsYVNvdXJjZU1hcFVSTCk7fSk7Ly8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2Vcbi8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbi8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cbnZhciBnZW5lcmF0ZWRNYXBwaW5ncz1hU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTt2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzPXNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzPVtdO3ZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncz1zbWMuX19vcmlnaW5hbE1hcHBpbmdzPVtdO2Zvcih2YXIgaT0wLGxlbmd0aD1nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7aTxsZW5ndGg7aSsrKXt2YXIgc3JjTWFwcGluZz1nZW5lcmF0ZWRNYXBwaW5nc1tpXTt2YXIgZGVzdE1hcHBpbmc9bmV3IE1hcHBpbmcoKTtkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lPXNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW49c3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47aWYoc3JjTWFwcGluZy5zb3VyY2Upe2Rlc3RNYXBwaW5nLnNvdXJjZT1zb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO2Rlc3RNYXBwaW5nLm9yaWdpbmFsTGluZT1zcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbj1zcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO2lmKHNyY01hcHBpbmcubmFtZSl7ZGVzdE1hcHBpbmcubmFtZT1uYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7fWRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO31kZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7fXF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO3JldHVybiBzbWM7fTsvKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uPTM7LyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCdzb3VyY2VzJyx7Z2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMuc2xpY2UoKTt9fSk7LyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9mdW5jdGlvbiBNYXBwaW5nKCl7dGhpcy5nZW5lcmF0ZWRMaW5lPTA7dGhpcy5nZW5lcmF0ZWRDb2x1bW49MDt0aGlzLnNvdXJjZT1udWxsO3RoaXMub3JpZ2luYWxMaW5lPW51bGw7dGhpcy5vcmlnaW5hbENvbHVtbj1udWxsO3RoaXMubmFtZT1udWxsO30vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0cixhU291cmNlUm9vdCl7dmFyIGdlbmVyYXRlZExpbmU9MTt2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW49MDt2YXIgcHJldmlvdXNPcmlnaW5hbExpbmU9MDt2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbj0wO3ZhciBwcmV2aW91c1NvdXJjZT0wO3ZhciBwcmV2aW91c05hbWU9MDt2YXIgbGVuZ3RoPWFTdHIubGVuZ3RoO3ZhciBpbmRleD0wO3ZhciBjYWNoZWRTZWdtZW50cz17fTt2YXIgdGVtcD17fTt2YXIgb3JpZ2luYWxNYXBwaW5ncz1bXTt2YXIgZ2VuZXJhdGVkTWFwcGluZ3M9W107dmFyIG1hcHBpbmcsc3RyLHNlZ21lbnQsZW5kLHZhbHVlO3doaWxlKGluZGV4PGxlbmd0aCl7aWYoYVN0ci5jaGFyQXQoaW5kZXgpPT09JzsnKXtnZW5lcmF0ZWRMaW5lKys7aW5kZXgrKztwcmV2aW91c0dlbmVyYXRlZENvbHVtbj0wO31lbHNlIGlmKGFTdHIuY2hhckF0KGluZGV4KT09PScsJyl7aW5kZXgrKzt9ZWxzZXttYXBwaW5nPW5ldyBNYXBwaW5nKCk7bWFwcGluZy5nZW5lcmF0ZWRMaW5lPWdlbmVyYXRlZExpbmU7Ly8gQmVjYXVzZSBlYWNoIG9mZnNldCBpcyBlbmNvZGVkIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4vLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbi8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuLy8gYWxsb3dpbmcgdXMgdG8gYXZvaWQgYSBzZWNvbmQgcGFyc2UgaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lXG4vLyBzZWdtZW50IGFnYWluLlxuZm9yKGVuZD1pbmRleDtlbmQ8bGVuZ3RoO2VuZCsrKXtpZih0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsZW5kKSl7YnJlYWs7fX1zdHI9YVN0ci5zbGljZShpbmRleCxlbmQpO3NlZ21lbnQ9Y2FjaGVkU2VnbWVudHNbc3RyXTtpZihzZWdtZW50KXtpbmRleCs9c3RyLmxlbmd0aDt9ZWxzZXtzZWdtZW50PVtdO3doaWxlKGluZGV4PGVuZCl7YmFzZTY0VkxRLmRlY29kZShhU3RyLGluZGV4LHRlbXApO3ZhbHVlPXRlbXAudmFsdWU7aW5kZXg9dGVtcC5yZXN0O3NlZ21lbnQucHVzaCh2YWx1ZSk7fWlmKHNlZ21lbnQubGVuZ3RoPT09Mil7dGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO31pZihzZWdtZW50Lmxlbmd0aD09PTMpe3Rocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTt9Y2FjaGVkU2VnbWVudHNbc3RyXT1zZWdtZW50O30vLyBHZW5lcmF0ZWQgY29sdW1uLlxubWFwcGluZy5nZW5lcmF0ZWRDb2x1bW49cHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4rc2VnbWVudFswXTtwcmV2aW91c0dlbmVyYXRlZENvbHVtbj1tYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtpZihzZWdtZW50Lmxlbmd0aD4xKXsvLyBPcmlnaW5hbCBzb3VyY2UuXG5tYXBwaW5nLnNvdXJjZT1wcmV2aW91c1NvdXJjZStzZWdtZW50WzFdO3ByZXZpb3VzU291cmNlKz1zZWdtZW50WzFdOy8vIE9yaWdpbmFsIGxpbmUuXG5tYXBwaW5nLm9yaWdpbmFsTGluZT1wcmV2aW91c09yaWdpbmFsTGluZStzZWdtZW50WzJdO3ByZXZpb3VzT3JpZ2luYWxMaW5lPW1hcHBpbmcub3JpZ2luYWxMaW5lOy8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxubWFwcGluZy5vcmlnaW5hbExpbmUrPTE7Ly8gT3JpZ2luYWwgY29sdW1uLlxubWFwcGluZy5vcmlnaW5hbENvbHVtbj1wcmV2aW91c09yaWdpbmFsQ29sdW1uK3NlZ21lbnRbM107cHJldmlvdXNPcmlnaW5hbENvbHVtbj1tYXBwaW5nLm9yaWdpbmFsQ29sdW1uO2lmKHNlZ21lbnQubGVuZ3RoPjQpey8vIE9yaWdpbmFsIG5hbWUuXG5tYXBwaW5nLm5hbWU9cHJldmlvdXNOYW1lK3NlZ21lbnRbNF07cHJldmlvdXNOYW1lKz1zZWdtZW50WzRdO319Z2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtpZih0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmU9PT0nbnVtYmVyJyl7b3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO319fXF1aWNrU29ydChnZW5lcmF0ZWRNYXBwaW5ncyx1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTt0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M9Z2VuZXJhdGVkTWFwcGluZ3M7cXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7dGhpcy5fX29yaWdpbmFsTWFwcGluZ3M9b3JpZ2luYWxNYXBwaW5nczt9Oy8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsYU1hcHBpbmdzLGFMaW5lTmFtZSxhQ29sdW1uTmFtZSxhQ29tcGFyYXRvcixhQmlhcyl7Ly8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbi8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4vLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5pZihhTmVlZGxlW2FMaW5lTmFtZV08PTApe3Rocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICcrYU5lZWRsZVthTGluZU5hbWVdKTt9aWYoYU5lZWRsZVthQ29sdW1uTmFtZV08MCl7dGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnK2FOZWVkbGVbYUNvbHVtbk5hbWVdKTt9cmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSxhTWFwcGluZ3MsYUNvbXBhcmF0b3IsYUJpYXMpO307LyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnM9ZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCl7Zm9yKHZhciBpbmRleD0wO2luZGV4PHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsrK2luZGV4KXt2YXIgbWFwcGluZz10aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07Ly8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4vLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbi8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4vLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbmlmKGluZGV4KzE8dGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKXt2YXIgbmV4dE1hcHBpbmc9dGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXgrMV07aWYobWFwcGluZy5nZW5lcmF0ZWRMaW5lPT09bmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSl7bWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uPW5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbi0xO2NvbnRpbnVlO319Ly8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbm1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbj1JbmZpbml0eTt9fTsvKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3Mpe3ZhciBuZWVkbGU9e2dlbmVyYXRlZExpbmU6dXRpbC5nZXRBcmcoYUFyZ3MsJ2xpbmUnKSxnZW5lcmF0ZWRDb2x1bW46dXRpbC5nZXRBcmcoYUFyZ3MsJ2NvbHVtbicpfTt2YXIgaW5kZXg9dGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFwiZ2VuZXJhdGVkTGluZVwiLFwiZ2VuZXJhdGVkQ29sdW1uXCIsdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCx1dGlsLmdldEFyZyhhQXJncywnYmlhcycsU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpKTtpZihpbmRleD49MCl7dmFyIG1hcHBpbmc9dGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO2lmKG1hcHBpbmcuZ2VuZXJhdGVkTGluZT09PW5lZWRsZS5nZW5lcmF0ZWRMaW5lKXt2YXIgc291cmNlPXV0aWwuZ2V0QXJnKG1hcHBpbmcsJ3NvdXJjZScsbnVsbCk7aWYoc291cmNlIT09bnVsbCl7c291cmNlPXRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtzb3VyY2U9dXRpbC5jb21wdXRlU291cmNlVVJMKHRoaXMuc291cmNlUm9vdCxzb3VyY2UsdGhpcy5fc291cmNlTWFwVVJMKTt9dmFyIG5hbWU9dXRpbC5nZXRBcmcobWFwcGluZywnbmFtZScsbnVsbCk7aWYobmFtZSE9PW51bGwpe25hbWU9dGhpcy5fbmFtZXMuYXQobmFtZSk7fXJldHVybntzb3VyY2U6c291cmNlLGxpbmU6dXRpbC5nZXRBcmcobWFwcGluZywnb3JpZ2luYWxMaW5lJyxudWxsKSxjb2x1bW46dXRpbC5nZXRBcmcobWFwcGluZywnb3JpZ2luYWxDb2x1bW4nLG51bGwpLG5hbWU6bmFtZX07fX1yZXR1cm57c291cmNlOm51bGwsbGluZTpudWxsLGNvbHVtbjpudWxsLG5hbWU6bnVsbH07fTsvKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcz1mdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCl7aWYoIXRoaXMuc291cmNlc0NvbnRlbnQpe3JldHVybiBmYWxzZTt9cmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoPj10aGlzLl9zb3VyY2VzLnNpemUoKSYmIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbihzYyl7cmV0dXJuIHNjPT1udWxsO30pO307LyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3I9ZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLG51bGxPbk1pc3Npbmcpe2lmKCF0aGlzLnNvdXJjZXNDb250ZW50KXtyZXR1cm4gbnVsbDt9dmFyIGluZGV4PXRoaXMuX2ZpbmRTb3VyY2VJbmRleChhU291cmNlKTtpZihpbmRleD49MCl7cmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdO312YXIgcmVsYXRpdmVTb3VyY2U9YVNvdXJjZTtpZih0aGlzLnNvdXJjZVJvb3QhPW51bGwpe3JlbGF0aXZlU291cmNlPXV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LHJlbGF0aXZlU291cmNlKTt9dmFyIHVybDtpZih0aGlzLnNvdXJjZVJvb3QhPW51bGwmJih1cmw9dXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSl7Ly8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3Jcbi8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4vLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbi8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbnZhciBmaWxlVXJpQWJzUGF0aD1yZWxhdGl2ZVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLFwiXCIpO2lmKHVybC5zY2hlbWU9PVwiZmlsZVwiJiZ0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpe3JldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldO31pZigoIXVybC5wYXRofHx1cmwucGF0aD09XCIvXCIpJiZ0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIityZWxhdGl2ZVNvdXJjZSkpe3JldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIityZWxhdGl2ZVNvdXJjZSldO319Ly8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbi8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbi8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG5pZihudWxsT25NaXNzaW5nKXtyZXR1cm4gbnVsbDt9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoJ1wiJytyZWxhdGl2ZVNvdXJjZSsnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7fX07LyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKXt2YXIgc291cmNlPXV0aWwuZ2V0QXJnKGFBcmdzLCdzb3VyY2UnKTtzb3VyY2U9dGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7aWYoc291cmNlPDApe3JldHVybntsaW5lOm51bGwsY29sdW1uOm51bGwsbGFzdENvbHVtbjpudWxsfTt9dmFyIG5lZWRsZT17c291cmNlOnNvdXJjZSxvcmlnaW5hbExpbmU6dXRpbC5nZXRBcmcoYUFyZ3MsJ2xpbmUnKSxvcmlnaW5hbENvbHVtbjp1dGlsLmdldEFyZyhhQXJncywnY29sdW1uJyl9O3ZhciBpbmRleD10aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcIm9yaWdpbmFsTGluZVwiLFwib3JpZ2luYWxDb2x1bW5cIix1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLHV0aWwuZ2V0QXJnKGFBcmdzLCdiaWFzJyxTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCkpO2lmKGluZGV4Pj0wKXt2YXIgbWFwcGluZz10aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtpZihtYXBwaW5nLnNvdXJjZT09PW5lZWRsZS5zb3VyY2Upe3JldHVybntsaW5lOnV0aWwuZ2V0QXJnKG1hcHBpbmcsJ2dlbmVyYXRlZExpbmUnLG51bGwpLGNvbHVtbjp1dGlsLmdldEFyZyhtYXBwaW5nLCdnZW5lcmF0ZWRDb2x1bW4nLG51bGwpLGxhc3RDb2x1bW46dXRpbC5nZXRBcmcobWFwcGluZywnbGFzdEdlbmVyYXRlZENvbHVtbicsbnVsbCl9O319cmV0dXJue2xpbmU6bnVsbCxjb2x1bW46bnVsbCxsYXN0Q29sdW1uOm51bGx9O307ZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyPUJhc2ljU291cmNlTWFwQ29uc3VtZXI7LyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsYVNvdXJjZU1hcFVSTCl7dmFyIHNvdXJjZU1hcD1hU291cmNlTWFwO2lmKHR5cGVvZiBhU291cmNlTWFwPT09J3N0cmluZycpe3NvdXJjZU1hcD11dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7fXZhciB2ZXJzaW9uPXV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwndmVyc2lvbicpO3ZhciBzZWN0aW9ucz11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3NlY3Rpb25zJyk7aWYodmVyc2lvbiE9dGhpcy5fdmVyc2lvbil7dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnK3ZlcnNpb24pO310aGlzLl9zb3VyY2VzPW5ldyBBcnJheVNldCgpO3RoaXMuX25hbWVzPW5ldyBBcnJheVNldCgpO3ZhciBsYXN0T2Zmc2V0PXtsaW5lOi0xLGNvbHVtbjowfTt0aGlzLl9zZWN0aW9ucz1zZWN0aW9ucy5tYXAoZnVuY3Rpb24ocyl7aWYocy51cmwpey8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG50aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7fXZhciBvZmZzZXQ9dXRpbC5nZXRBcmcocywnb2Zmc2V0Jyk7dmFyIG9mZnNldExpbmU9dXRpbC5nZXRBcmcob2Zmc2V0LCdsaW5lJyk7dmFyIG9mZnNldENvbHVtbj11dGlsLmdldEFyZyhvZmZzZXQsJ2NvbHVtbicpO2lmKG9mZnNldExpbmU8bGFzdE9mZnNldC5saW5lfHxvZmZzZXRMaW5lPT09bGFzdE9mZnNldC5saW5lJiZvZmZzZXRDb2x1bW48bGFzdE9mZnNldC5jb2x1bW4pe3Rocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO31sYXN0T2Zmc2V0PW9mZnNldDtyZXR1cm57Z2VuZXJhdGVkT2Zmc2V0OnsvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG5nZW5lcmF0ZWRMaW5lOm9mZnNldExpbmUrMSxnZW5lcmF0ZWRDb2x1bW46b2Zmc2V0Q29sdW1uKzF9LGNvbnN1bWVyOm5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCdtYXAnKSxhU291cmNlTWFwVVJMKX07fSk7fUluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO0luZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3I9U291cmNlTWFwQ29uc3VtZXI7LyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uPTM7LyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsJ3NvdXJjZXMnLHtnZXQ6ZnVuY3Rpb24gZ2V0KCl7dmFyIHNvdXJjZXM9W107Zm9yKHZhciBpPTA7aTx0aGlzLl9zZWN0aW9ucy5sZW5ndGg7aSsrKXtmb3IodmFyIGo9MDtqPHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoO2orKyl7c291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO319cmV0dXJuIHNvdXJjZXM7fX0pOy8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL0luZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvcj1mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncyl7dmFyIG5lZWRsZT17Z2VuZXJhdGVkTGluZTp1dGlsLmdldEFyZyhhQXJncywnbGluZScpLGdlbmVyYXRlZENvbHVtbjp1dGlsLmdldEFyZyhhQXJncywnY29sdW1uJyl9Oy8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbi8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxudmFyIHNlY3Rpb25JbmRleD1iaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSx0aGlzLl9zZWN0aW9ucyxmdW5jdGlvbihuZWVkbGUsc2VjdGlvbil7dmFyIGNtcD1uZWVkbGUuZ2VuZXJhdGVkTGluZS1zZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO2lmKGNtcCl7cmV0dXJuIGNtcDt9cmV0dXJuIG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4tc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uO30pO3ZhciBzZWN0aW9uPXRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07aWYoIXNlY3Rpb24pe3JldHVybntzb3VyY2U6bnVsbCxsaW5lOm51bGwsY29sdW1uOm51bGwsbmFtZTpudWxsfTt9cmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7bGluZTpuZWVkbGUuZ2VuZXJhdGVkTGluZS0oc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZS0xKSxjb2x1bW46bmVlZGxlLmdlbmVyYXRlZENvbHVtbi0oc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZT09PW5lZWRsZS5nZW5lcmF0ZWRMaW5lP3NlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbi0xOjApLGJpYXM6YUFyZ3MuYmlhc30pO307LyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcz1mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKXtyZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24ocyl7cmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTt9KTt9Oy8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3I9ZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSxudWxsT25NaXNzaW5nKXtmb3IodmFyIGk9MDtpPHRoaXMuX3NlY3Rpb25zLmxlbmd0aDtpKyspe3ZhciBzZWN0aW9uPXRoaXMuX3NlY3Rpb25zW2ldO3ZhciBjb250ZW50PXNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLHRydWUpO2lmKGNvbnRlbnQpe3JldHVybiBjb250ZW50O319aWYobnVsbE9uTWlzc2luZyl7cmV0dXJuIG51bGw7fWVsc2V7dGhyb3cgbmV3IEVycm9yKCdcIicrYVNvdXJjZSsnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7fX07LyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLiBcbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yPWZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyl7Zm9yKHZhciBpPTA7aTx0aGlzLl9zZWN0aW9ucy5sZW5ndGg7aSsrKXt2YXIgc2VjdGlvbj10aGlzLl9zZWN0aW9uc1tpXTsvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG5pZihzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsJ3NvdXJjZScpKT09PS0xKXtjb250aW51ZTt9dmFyIGdlbmVyYXRlZFBvc2l0aW9uPXNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO2lmKGdlbmVyYXRlZFBvc2l0aW9uKXt2YXIgcmV0PXtsaW5lOmdlbmVyYXRlZFBvc2l0aW9uLmxpbmUrKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUtMSksY29sdW1uOmdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbisoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZT09PWdlbmVyYXRlZFBvc2l0aW9uLmxpbmU/c2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uLTE6MCl9O3JldHVybiByZXQ7fX1yZXR1cm57bGluZTpudWxsLGNvbHVtbjpudWxsfTt9Oy8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncz1mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLGFTb3VyY2VSb290KXt0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M9W107dGhpcy5fX29yaWdpbmFsTWFwcGluZ3M9W107Zm9yKHZhciBpPTA7aTx0aGlzLl9zZWN0aW9ucy5sZW5ndGg7aSsrKXt2YXIgc2VjdGlvbj10aGlzLl9zZWN0aW9uc1tpXTt2YXIgc2VjdGlvbk1hcHBpbmdzPXNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO2Zvcih2YXIgaj0wO2o8c2VjdGlvbk1hcHBpbmdzLmxlbmd0aDtqKyspe3ZhciBtYXBwaW5nPXNlY3Rpb25NYXBwaW5nc1tqXTt2YXIgc291cmNlPXNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO3NvdXJjZT11dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LHNvdXJjZSx0aGlzLl9zb3VyY2VNYXBVUkwpO3RoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7c291cmNlPXRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO3ZhciBuYW1lPW51bGw7aWYobWFwcGluZy5uYW1lKXtuYW1lPXNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7dGhpcy5fbmFtZXMuYWRkKG5hbWUpO25hbWU9dGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTt9Ly8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4vLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4vLyBnZW5lcmF0ZWQgZmlsZS5cbnZhciBhZGp1c3RlZE1hcHBpbmc9e3NvdXJjZTpzb3VyY2UsZ2VuZXJhdGVkTGluZTptYXBwaW5nLmdlbmVyYXRlZExpbmUrKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUtMSksZ2VuZXJhdGVkQ29sdW1uOm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKyhzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lPT09bWFwcGluZy5nZW5lcmF0ZWRMaW5lP3NlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbi0xOjApLG9yaWdpbmFsTGluZTptYXBwaW5nLm9yaWdpbmFsTGluZSxvcmlnaW5hbENvbHVtbjptYXBwaW5nLm9yaWdpbmFsQ29sdW1uLG5hbWU6bmFtZX07dGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtpZih0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZT09PSdudW1iZXInKXt0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7fX19cXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyx1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7fTtleHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcj1JbmRleGVkU291cmNlTWFwQ29uc3VtZXI7fSx7XCIuL2FycmF5LXNldFwiOjE5NyxcIi4vYmFzZTY0LXZscVwiOjE5OCxcIi4vYmluYXJ5LXNlYXJjaFwiOjIwMCxcIi4vcXVpY2stc29ydFwiOjIwMixcIi4vdXRpbFwiOjIwNn1dLDIwNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLyAvKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovdmFyIGJhc2U2NFZMUT1yZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTt2YXIgdXRpbD1yZXF1aXJlKCcuL3V0aWwnKTt2YXIgQXJyYXlTZXQ9cmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDt2YXIgTWFwcGluZ0xpc3Q9cmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDsvKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3Mpe2lmKCFhQXJncyl7YUFyZ3M9e307fXRoaXMuX2ZpbGU9dXRpbC5nZXRBcmcoYUFyZ3MsJ2ZpbGUnLG51bGwpO3RoaXMuX3NvdXJjZVJvb3Q9dXRpbC5nZXRBcmcoYUFyZ3MsJ3NvdXJjZVJvb3QnLG51bGwpO3RoaXMuX3NraXBWYWxpZGF0aW9uPXV0aWwuZ2V0QXJnKGFBcmdzLCdza2lwVmFsaWRhdGlvbicsZmFsc2UpO3RoaXMuX3NvdXJjZXM9bmV3IEFycmF5U2V0KCk7dGhpcy5fbmFtZXM9bmV3IEFycmF5U2V0KCk7dGhpcy5fbWFwcGluZ3M9bmV3IE1hcHBpbmdMaXN0KCk7dGhpcy5fc291cmNlc0NvbnRlbnRzPW51bGw7fVNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb249MzsvKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcD1mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpe3ZhciBzb3VyY2VSb290PWFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O3ZhciBnZW5lcmF0b3I9bmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7ZmlsZTphU291cmNlTWFwQ29uc3VtZXIuZmlsZSxzb3VyY2VSb290OnNvdXJjZVJvb3R9KTthU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24obWFwcGluZyl7dmFyIG5ld01hcHBpbmc9e2dlbmVyYXRlZDp7bGluZTptYXBwaW5nLmdlbmVyYXRlZExpbmUsY29sdW1uOm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1ufX07aWYobWFwcGluZy5zb3VyY2UhPW51bGwpe25ld01hcHBpbmcuc291cmNlPW1hcHBpbmcuc291cmNlO2lmKHNvdXJjZVJvb3QhPW51bGwpe25ld01hcHBpbmcuc291cmNlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxuZXdNYXBwaW5nLnNvdXJjZSk7fW5ld01hcHBpbmcub3JpZ2luYWw9e2xpbmU6bWFwcGluZy5vcmlnaW5hbExpbmUsY29sdW1uOm1hcHBpbmcub3JpZ2luYWxDb2x1bW59O2lmKG1hcHBpbmcubmFtZSE9bnVsbCl7bmV3TWFwcGluZy5uYW1lPW1hcHBpbmcubmFtZTt9fWdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO30pO2FTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc291cmNlRmlsZSl7dmFyIHNvdXJjZVJlbGF0aXZlPXNvdXJjZUZpbGU7aWYoc291cmNlUm9vdCE9PW51bGwpe3NvdXJjZVJlbGF0aXZlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxzb3VyY2VGaWxlKTt9aWYoIWdlbmVyYXRvci5fc291cmNlcy5oYXMoc291cmNlUmVsYXRpdmUpKXtnZW5lcmF0b3IuX3NvdXJjZXMuYWRkKHNvdXJjZVJlbGF0aXZlKTt9dmFyIGNvbnRlbnQ9YVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7aWYoY29udGVudCE9bnVsbCl7Z2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSxjb250ZW50KTt9fSk7cmV0dXJuIGdlbmVyYXRvcjt9Oy8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmc9ZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3Mpe3ZhciBnZW5lcmF0ZWQ9dXRpbC5nZXRBcmcoYUFyZ3MsJ2dlbmVyYXRlZCcpO3ZhciBvcmlnaW5hbD11dGlsLmdldEFyZyhhQXJncywnb3JpZ2luYWwnLG51bGwpO3ZhciBzb3VyY2U9dXRpbC5nZXRBcmcoYUFyZ3MsJ3NvdXJjZScsbnVsbCk7dmFyIG5hbWU9dXRpbC5nZXRBcmcoYUFyZ3MsJ25hbWUnLG51bGwpO2lmKCF0aGlzLl9za2lwVmFsaWRhdGlvbil7dGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCxvcmlnaW5hbCxzb3VyY2UsbmFtZSk7fWlmKHNvdXJjZSE9bnVsbCl7c291cmNlPVN0cmluZyhzb3VyY2UpO2lmKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKXt0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO319aWYobmFtZSE9bnVsbCl7bmFtZT1TdHJpbmcobmFtZSk7aWYoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSl7dGhpcy5fbmFtZXMuYWRkKG5hbWUpO319dGhpcy5fbWFwcGluZ3MuYWRkKHtnZW5lcmF0ZWRMaW5lOmdlbmVyYXRlZC5saW5lLGdlbmVyYXRlZENvbHVtbjpnZW5lcmF0ZWQuY29sdW1uLG9yaWdpbmFsTGluZTpvcmlnaW5hbCE9bnVsbCYmb3JpZ2luYWwubGluZSxvcmlnaW5hbENvbHVtbjpvcmlnaW5hbCE9bnVsbCYmb3JpZ2luYWwuY29sdW1uLHNvdXJjZTpzb3VyY2UsbmFtZTpuYW1lfSk7fTsvKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQ9ZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsYVNvdXJjZUNvbnRlbnQpe3ZhciBzb3VyY2U9YVNvdXJjZUZpbGU7aWYodGhpcy5fc291cmNlUm9vdCE9bnVsbCl7c291cmNlPXV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCxzb3VyY2UpO31pZihhU291cmNlQ29udGVudCE9bnVsbCl7Ly8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4vLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG5pZighdGhpcy5fc291cmNlc0NvbnRlbnRzKXt0aGlzLl9zb3VyY2VzQ29udGVudHM9T2JqZWN0LmNyZWF0ZShudWxsKTt9dGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV09YVNvdXJjZUNvbnRlbnQ7fWVsc2UgaWYodGhpcy5fc291cmNlc0NvbnRlbnRzKXsvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG5kZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07aWYoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGg9PT0wKXt0aGlzLl9zb3VyY2VzQ29udGVudHM9bnVsbDt9fX07LyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsYVNvdXJjZUZpbGUsYVNvdXJjZU1hcFBhdGgpe3ZhciBzb3VyY2VGaWxlPWFTb3VyY2VGaWxlOy8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbmlmKGFTb3VyY2VGaWxlPT1udWxsKXtpZihhU291cmNlTWFwQ29uc3VtZXIuZmlsZT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJysnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nKTt9c291cmNlRmlsZT1hU291cmNlTWFwQ29uc3VtZXIuZmlsZTt9dmFyIHNvdXJjZVJvb3Q9dGhpcy5fc291cmNlUm9vdDsvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG5pZihzb3VyY2VSb290IT1udWxsKXtzb3VyY2VGaWxlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxzb3VyY2VGaWxlKTt9Ly8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbi8vIHRoZSBuYW1lcyBhcnJheS5cbnZhciBuZXdTb3VyY2VzPW5ldyBBcnJheVNldCgpO3ZhciBuZXdOYW1lcz1uZXcgQXJyYXlTZXQoKTsvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbnRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbihtYXBwaW5nKXtpZihtYXBwaW5nLnNvdXJjZT09PXNvdXJjZUZpbGUmJm1hcHBpbmcub3JpZ2luYWxMaW5lIT1udWxsKXsvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbnZhciBvcmlnaW5hbD1hU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7bGluZTptYXBwaW5nLm9yaWdpbmFsTGluZSxjb2x1bW46bWFwcGluZy5vcmlnaW5hbENvbHVtbn0pO2lmKG9yaWdpbmFsLnNvdXJjZSE9bnVsbCl7Ly8gQ29weSBtYXBwaW5nXG5tYXBwaW5nLnNvdXJjZT1vcmlnaW5hbC5zb3VyY2U7aWYoYVNvdXJjZU1hcFBhdGghPW51bGwpe21hcHBpbmcuc291cmNlPXV0aWwuam9pbihhU291cmNlTWFwUGF0aCxtYXBwaW5nLnNvdXJjZSk7fWlmKHNvdXJjZVJvb3QhPW51bGwpe21hcHBpbmcuc291cmNlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxtYXBwaW5nLnNvdXJjZSk7fW1hcHBpbmcub3JpZ2luYWxMaW5lPW9yaWdpbmFsLmxpbmU7bWFwcGluZy5vcmlnaW5hbENvbHVtbj1vcmlnaW5hbC5jb2x1bW47aWYob3JpZ2luYWwubmFtZSE9bnVsbCl7bWFwcGluZy5uYW1lPW9yaWdpbmFsLm5hbWU7fX19dmFyIHNvdXJjZT1tYXBwaW5nLnNvdXJjZTtpZihzb3VyY2UhPW51bGwmJiFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKXtuZXdTb3VyY2VzLmFkZChzb3VyY2UpO312YXIgbmFtZT1tYXBwaW5nLm5hbWU7aWYobmFtZSE9bnVsbCYmIW5ld05hbWVzLmhhcyhuYW1lKSl7bmV3TmFtZXMuYWRkKG5hbWUpO319LHRoaXMpO3RoaXMuX3NvdXJjZXM9bmV3U291cmNlczt0aGlzLl9uYW1lcz1uZXdOYW1lczsvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbmFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc291cmNlRmlsZSl7dmFyIGNvbnRlbnQ9YVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7aWYoY29udGVudCE9bnVsbCl7aWYoYVNvdXJjZU1hcFBhdGghPW51bGwpe3NvdXJjZUZpbGU9dXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLHNvdXJjZUZpbGUpO31pZihzb3VyY2VSb290IT1udWxsKXtzb3VyY2VGaWxlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxzb3VyY2VGaWxlKTt9dGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsY29udGVudCk7fX0sdGhpcyk7fTsvKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCxhT3JpZ2luYWwsYVNvdXJjZSxhTmFtZSl7Ly8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbi8vIGl0IGlzIG1vc3QgbGlrZWx5IGEgcHJvZ3JhbW1lciBlcnJvci4gSW4gdGhpcyBjYXNlIHdlIHRocm93IGEgdmVyeVxuLy8gc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSB0byB0cnkgdG8gZ3VpZGUgdGhlbSB0aGUgcmlnaHQgd2F5LlxuLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuaWYoYU9yaWdpbmFsJiZ0eXBlb2YgYU9yaWdpbmFsLmxpbmUhPT0nbnVtYmVyJyYmdHlwZW9mIGFPcmlnaW5hbC5jb2x1bW4hPT0nbnVtYmVyJyl7dGhyb3cgbmV3IEVycm9yKCdvcmlnaW5hbC5saW5lIGFuZCBvcmlnaW5hbC5jb2x1bW4gYXJlIG5vdCBudW1iZXJzIC0tIHlvdSBwcm9iYWJseSBtZWFudCB0byBvbWl0ICcrJ3RoZSBvcmlnaW5hbCBtYXBwaW5nIGVudGlyZWx5IGFuZCBvbmx5IG1hcCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLiBJZiBzbywgcGFzcyAnKydudWxsIGZvciB0aGUgb3JpZ2luYWwgbWFwcGluZyBpbnN0ZWFkIG9mIGFuIG9iamVjdCB3aXRoIGVtcHR5IG9yIG51bGwgdmFsdWVzLicpO31pZihhR2VuZXJhdGVkJiYnbGluZSdpbiBhR2VuZXJhdGVkJiYnY29sdW1uJ2luIGFHZW5lcmF0ZWQmJmFHZW5lcmF0ZWQubGluZT4wJiZhR2VuZXJhdGVkLmNvbHVtbj49MCYmIWFPcmlnaW5hbCYmIWFTb3VyY2UmJiFhTmFtZSl7Ly8gQ2FzZSAxLlxucmV0dXJuO31lbHNlIGlmKGFHZW5lcmF0ZWQmJidsaW5lJ2luIGFHZW5lcmF0ZWQmJidjb2x1bW4naW4gYUdlbmVyYXRlZCYmYU9yaWdpbmFsJiYnbGluZSdpbiBhT3JpZ2luYWwmJidjb2x1bW4naW4gYU9yaWdpbmFsJiZhR2VuZXJhdGVkLmxpbmU+MCYmYUdlbmVyYXRlZC5jb2x1bW4+PTAmJmFPcmlnaW5hbC5saW5lPjAmJmFPcmlnaW5hbC5jb2x1bW4+PTAmJmFTb3VyY2Upey8vIENhc2VzIDIgYW5kIDMuXG5yZXR1cm47fWVsc2V7dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcrSlNPTi5zdHJpbmdpZnkoe2dlbmVyYXRlZDphR2VuZXJhdGVkLHNvdXJjZTphU291cmNlLG9yaWdpbmFsOmFPcmlnaW5hbCxuYW1lOmFOYW1lfSkpO319Oy8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpe3ZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbj0wO3ZhciBwcmV2aW91c0dlbmVyYXRlZExpbmU9MTt2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbj0wO3ZhciBwcmV2aW91c09yaWdpbmFsTGluZT0wO3ZhciBwcmV2aW91c05hbWU9MDt2YXIgcHJldmlvdXNTb3VyY2U9MDt2YXIgcmVzdWx0PScnO3ZhciBuZXh0O3ZhciBtYXBwaW5nO3ZhciBuYW1lSWR4O3ZhciBzb3VyY2VJZHg7dmFyIG1hcHBpbmdzPXRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtmb3IodmFyIGk9MCxsZW49bWFwcGluZ3MubGVuZ3RoO2k8bGVuO2krKyl7bWFwcGluZz1tYXBwaW5nc1tpXTtuZXh0PScnO2lmKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSE9PXByZXZpb3VzR2VuZXJhdGVkTGluZSl7cHJldmlvdXNHZW5lcmF0ZWRDb2x1bW49MDt3aGlsZShtYXBwaW5nLmdlbmVyYXRlZExpbmUhPT1wcmV2aW91c0dlbmVyYXRlZExpbmUpe25leHQrPSc7JztwcmV2aW91c0dlbmVyYXRlZExpbmUrKzt9fWVsc2V7aWYoaT4wKXtpZighdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLG1hcHBpbmdzW2ktMV0pKXtjb250aW51ZTt9bmV4dCs9JywnO319bmV4dCs9YmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtbi1wcmV2aW91c0dlbmVyYXRlZENvbHVtbik7cHJldmlvdXNHZW5lcmF0ZWRDb2x1bW49bWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47aWYobWFwcGluZy5zb3VyY2UhPW51bGwpe3NvdXJjZUlkeD10aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO25leHQrPWJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4LXByZXZpb3VzU291cmNlKTtwcmV2aW91c1NvdXJjZT1zb3VyY2VJZHg7Ly8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xubmV4dCs9YmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZS0xLXByZXZpb3VzT3JpZ2luYWxMaW5lKTtwcmV2aW91c09yaWdpbmFsTGluZT1tYXBwaW5nLm9yaWdpbmFsTGluZS0xO25leHQrPWJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtbi1wcmV2aW91c09yaWdpbmFsQ29sdW1uKTtwcmV2aW91c09yaWdpbmFsQ29sdW1uPW1hcHBpbmcub3JpZ2luYWxDb2x1bW47aWYobWFwcGluZy5uYW1lIT1udWxsKXtuYW1lSWR4PXRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtuZXh0Kz1iYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHgtcHJldmlvdXNOYW1lKTtwcmV2aW91c05hbWU9bmFtZUlkeDt9fXJlc3VsdCs9bmV4dDt9cmV0dXJuIHJlc3VsdDt9O1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQ9ZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsYVNvdXJjZVJvb3Qpe3JldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24oc291cmNlKXtpZighdGhpcy5fc291cmNlc0NvbnRlbnRzKXtyZXR1cm4gbnVsbDt9aWYoYVNvdXJjZVJvb3QhPW51bGwpe3NvdXJjZT11dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LHNvdXJjZSk7fXZhciBrZXk9dXRpbC50b1NldFN0cmluZyhzb3VyY2UpO3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLGtleSk/dGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV06bnVsbDt9LHRoaXMpO307LyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKXt2YXIgbWFwPXt2ZXJzaW9uOnRoaXMuX3ZlcnNpb24sc291cmNlczp0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxuYW1lczp0aGlzLl9uYW1lcy50b0FycmF5KCksbWFwcGluZ3M6dGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKX07aWYodGhpcy5fZmlsZSE9bnVsbCl7bWFwLmZpbGU9dGhpcy5fZmlsZTt9aWYodGhpcy5fc291cmNlUm9vdCE9bnVsbCl7bWFwLnNvdXJjZVJvb3Q9dGhpcy5fc291cmNlUm9vdDt9aWYodGhpcy5fc291cmNlc0NvbnRlbnRzKXttYXAuc291cmNlc0NvbnRlbnQ9dGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcyxtYXAuc291cmNlUm9vdCk7fXJldHVybiBtYXA7fTsvKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpe3JldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTt9O2V4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yPVNvdXJjZU1hcEdlbmVyYXRvcjt9LHtcIi4vYXJyYXktc2V0XCI6MTk3LFwiLi9iYXNlNjQtdmxxXCI6MTk4LFwiLi9tYXBwaW5nLWxpc3RcIjoyMDEsXCIuL3V0aWxcIjoyMDZ9XSwyMDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi8gLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL3ZhciBTb3VyY2VNYXBHZW5lcmF0b3I9cmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjt2YXIgdXRpbD1yZXF1aXJlKCcuL3V0aWwnKTsvLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkU9LyhcXHI/XFxuKS87Ly8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFPTEwOy8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGU9XCIkJCRpc1NvdXJjZU5vZGUkJCRcIjsvKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL2Z1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsYUNvbHVtbixhU291cmNlLGFDaHVua3MsYU5hbWUpe3RoaXMuY2hpbGRyZW49W107dGhpcy5zb3VyY2VDb250ZW50cz17fTt0aGlzLmxpbmU9YUxpbmU9PW51bGw/bnVsbDphTGluZTt0aGlzLmNvbHVtbj1hQ29sdW1uPT1udWxsP251bGw6YUNvbHVtbjt0aGlzLnNvdXJjZT1hU291cmNlPT1udWxsP251bGw6YVNvdXJjZTt0aGlzLm5hbWU9YU5hbWU9PW51bGw/bnVsbDphTmFtZTt0aGlzW2lzU291cmNlTm9kZV09dHJ1ZTtpZihhQ2h1bmtzIT1udWxsKXRoaXMuYWRkKGFDaHVua3MpO30vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcD1mdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLGFTb3VyY2VNYXBDb25zdW1lcixhUmVsYXRpdmVQYXRoKXsvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbi8vIGFuZCB0aGUgU291cmNlTWFwXG52YXIgbm9kZT1uZXcgU291cmNlTm9kZSgpOy8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbi8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbi8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIGFjY2Vzc2VkIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxudmFyIHJlbWFpbmluZ0xpbmVzPWFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO3ZhciByZW1haW5pbmdMaW5lc0luZGV4PTA7dmFyIHNoaWZ0TmV4dExpbmU9ZnVuY3Rpb24gc2hpZnROZXh0TGluZSgpe3ZhciBsaW5lQ29udGVudHM9Z2V0TmV4dExpbmUoKTsvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG52YXIgbmV3TGluZT1nZXROZXh0TGluZSgpfHxcIlwiO3JldHVybiBsaW5lQ29udGVudHMrbmV3TGluZTtmdW5jdGlvbiBnZXROZXh0TGluZSgpe3JldHVybiByZW1haW5pbmdMaW5lc0luZGV4PHJlbWFpbmluZ0xpbmVzLmxlbmd0aD9yZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4KytdOnVuZGVmaW5lZDt9fTsvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbnZhciBsYXN0R2VuZXJhdGVkTGluZT0xLGxhc3RHZW5lcmF0ZWRDb2x1bW49MDsvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4vLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxudmFyIGxhc3RNYXBwaW5nPW51bGw7YVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uKG1hcHBpbmcpe2lmKGxhc3RNYXBwaW5nIT09bnVsbCl7Ly8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuaWYobGFzdEdlbmVyYXRlZExpbmU8bWFwcGluZy5nZW5lcmF0ZWRMaW5lKXsvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLHNoaWZ0TmV4dExpbmUoKSk7bGFzdEdlbmVyYXRlZExpbmUrKztsYXN0R2VuZXJhdGVkQ29sdW1uPTA7Ly8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xufWVsc2V7Ly8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbi8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG52YXIgbmV4dExpbmU9cmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF18fCcnO3ZhciBjb2RlPW5leHRMaW5lLnN1YnN0cigwLG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLWxhc3RHZW5lcmF0ZWRDb2x1bW4pO3JlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdPW5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbi1sYXN0R2VuZXJhdGVkQ29sdW1uKTtsYXN0R2VuZXJhdGVkQ29sdW1uPW1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO2FkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZyxjb2RlKTsvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxubGFzdE1hcHBpbmc9bWFwcGluZztyZXR1cm47fX0vLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4vLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbndoaWxlKGxhc3RHZW5lcmF0ZWRMaW5lPG1hcHBpbmcuZ2VuZXJhdGVkTGluZSl7bm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtsYXN0R2VuZXJhdGVkTGluZSsrO31pZihsYXN0R2VuZXJhdGVkQ29sdW1uPG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKXt2YXIgbmV4dExpbmU9cmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF18fCcnO25vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7cmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF09bmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtsYXN0R2VuZXJhdGVkQ29sdW1uPW1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO31sYXN0TWFwcGluZz1tYXBwaW5nO30sdGhpcyk7Ly8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuaWYocmVtYWluaW5nTGluZXNJbmRleDxyZW1haW5pbmdMaW5lcy5sZW5ndGgpe2lmKGxhc3RNYXBwaW5nKXsvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbmFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZyxzaGlmdE5leHRMaW5lKCkpO30vLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xubm9kZS5hZGQocmVtYWluaW5nTGluZXMuc3BsaWNlKHJlbWFpbmluZ0xpbmVzSW5kZXgpLmpvaW4oXCJcIikpO30vLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2VGaWxlKXt2YXIgY29udGVudD1hU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtpZihjb250ZW50IT1udWxsKXtpZihhUmVsYXRpdmVQYXRoIT1udWxsKXtzb3VyY2VGaWxlPXV0aWwuam9pbihhUmVsYXRpdmVQYXRoLHNvdXJjZUZpbGUpO31ub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSxjb250ZW50KTt9fSk7cmV0dXJuIG5vZGU7ZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsY29kZSl7aWYobWFwcGluZz09PW51bGx8fG1hcHBpbmcuc291cmNlPT09dW5kZWZpbmVkKXtub2RlLmFkZChjb2RlKTt9ZWxzZXt2YXIgc291cmNlPWFSZWxhdGl2ZVBhdGg/dXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsbWFwcGluZy5zb3VyY2UpOm1hcHBpbmcuc291cmNlO25vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sc291cmNlLGNvZGUsbWFwcGluZy5uYW1lKSk7fX19Oy8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1NvdXJjZU5vZGUucHJvdG90eXBlLmFkZD1mdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspe2lmKEFycmF5LmlzQXJyYXkoYUNodW5rKSl7YUNodW5rLmZvckVhY2goZnVuY3Rpb24oY2h1bmspe3RoaXMuYWRkKGNodW5rKTt9LHRoaXMpO31lbHNlIGlmKGFDaHVua1tpc1NvdXJjZU5vZGVdfHx0eXBlb2YgYUNodW5rPT09XCJzdHJpbmdcIil7aWYoYUNodW5rKXt0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTt9fWVsc2V7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiK2FDaHVuayk7fXJldHVybiB0aGlzO307LyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kPWZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspe2lmKEFycmF5LmlzQXJyYXkoYUNodW5rKSl7Zm9yKHZhciBpPWFDaHVuay5sZW5ndGgtMTtpPj0wO2ktLSl7dGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7fX1lbHNlIGlmKGFDaHVua1tpc1NvdXJjZU5vZGVdfHx0eXBlb2YgYUNodW5rPT09XCJzdHJpbmdcIil7dGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7fWVsc2V7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiK2FDaHVuayk7fXJldHVybiB0aGlzO307LyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1NvdXJjZU5vZGUucHJvdG90eXBlLndhbGs9ZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbil7dmFyIGNodW5rO2Zvcih2YXIgaT0wLGxlbj10aGlzLmNoaWxkcmVuLmxlbmd0aDtpPGxlbjtpKyspe2NodW5rPXRoaXMuY2hpbGRyZW5baV07aWYoY2h1bmtbaXNTb3VyY2VOb2RlXSl7Y2h1bmsud2FsayhhRm4pO31lbHNle2lmKGNodW5rIT09Jycpe2FGbihjaHVuayx7c291cmNlOnRoaXMuc291cmNlLGxpbmU6dGhpcy5saW5lLGNvbHVtbjp0aGlzLmNvbHVtbixuYW1lOnRoaXMubmFtZX0pO319fX07LyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luPWZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKXt2YXIgbmV3Q2hpbGRyZW47dmFyIGk7dmFyIGxlbj10aGlzLmNoaWxkcmVuLmxlbmd0aDtpZihsZW4+MCl7bmV3Q2hpbGRyZW49W107Zm9yKGk9MDtpPGxlbi0xO2krKyl7bmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtuZXdDaGlsZHJlbi5wdXNoKGFTZXApO31uZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO3RoaXMuY2hpbGRyZW49bmV3Q2hpbGRyZW47fXJldHVybiB0aGlzO307LyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQ9ZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sYVJlcGxhY2VtZW50KXt2YXIgbGFzdENoaWxkPXRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGgtMV07aWYobGFzdENoaWxkW2lzU291cmNlTm9kZV0pe2xhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sYVJlcGxhY2VtZW50KTt9ZWxzZSBpZih0eXBlb2YgbGFzdENoaWxkPT09J3N0cmluZycpe3RoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGgtMV09bGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sYVJlcGxhY2VtZW50KTt9ZWxzZXt0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybixhUmVwbGFjZW1lbnQpKTt9cmV0dXJuIHRoaXM7fTsvKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1NvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQ9ZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLGFTb3VyY2VDb250ZW50KXt0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXT1hU291cmNlQ29udGVudDt9Oy8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1NvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cz1mdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pe2Zvcih2YXIgaT0wLGxlbj10aGlzLmNoaWxkcmVuLmxlbmd0aDtpPGxlbjtpKyspe2lmKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSl7dGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTt9fXZhciBzb3VyY2VzPU9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO2Zvcih2YXIgaT0wLGxlbj1zb3VyY2VzLmxlbmd0aDtpPGxlbjtpKyspe2FGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7fX07LyoqXG4gKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICovU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpe3ZhciBzdHI9XCJcIjt0aGlzLndhbGsoZnVuY3Rpb24oY2h1bmspe3N0cis9Y2h1bms7fSk7cmV0dXJuIHN0cjt9Oy8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICogbWFwLlxuICovU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwPWZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKXt2YXIgZ2VuZXJhdGVkPXtjb2RlOlwiXCIsbGluZToxLGNvbHVtbjowfTt2YXIgbWFwPW5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO3ZhciBzb3VyY2VNYXBwaW5nQWN0aXZlPWZhbHNlO3ZhciBsYXN0T3JpZ2luYWxTb3VyY2U9bnVsbDt2YXIgbGFzdE9yaWdpbmFsTGluZT1udWxsO3ZhciBsYXN0T3JpZ2luYWxDb2x1bW49bnVsbDt2YXIgbGFzdE9yaWdpbmFsTmFtZT1udWxsO3RoaXMud2FsayhmdW5jdGlvbihjaHVuayxvcmlnaW5hbCl7Z2VuZXJhdGVkLmNvZGUrPWNodW5rO2lmKG9yaWdpbmFsLnNvdXJjZSE9PW51bGwmJm9yaWdpbmFsLmxpbmUhPT1udWxsJiZvcmlnaW5hbC5jb2x1bW4hPT1udWxsKXtpZihsYXN0T3JpZ2luYWxTb3VyY2UhPT1vcmlnaW5hbC5zb3VyY2V8fGxhc3RPcmlnaW5hbExpbmUhPT1vcmlnaW5hbC5saW5lfHxsYXN0T3JpZ2luYWxDb2x1bW4hPT1vcmlnaW5hbC5jb2x1bW58fGxhc3RPcmlnaW5hbE5hbWUhPT1vcmlnaW5hbC5uYW1lKXttYXAuYWRkTWFwcGluZyh7c291cmNlOm9yaWdpbmFsLnNvdXJjZSxvcmlnaW5hbDp7bGluZTpvcmlnaW5hbC5saW5lLGNvbHVtbjpvcmlnaW5hbC5jb2x1bW59LGdlbmVyYXRlZDp7bGluZTpnZW5lcmF0ZWQubGluZSxjb2x1bW46Z2VuZXJhdGVkLmNvbHVtbn0sbmFtZTpvcmlnaW5hbC5uYW1lfSk7fWxhc3RPcmlnaW5hbFNvdXJjZT1vcmlnaW5hbC5zb3VyY2U7bGFzdE9yaWdpbmFsTGluZT1vcmlnaW5hbC5saW5lO2xhc3RPcmlnaW5hbENvbHVtbj1vcmlnaW5hbC5jb2x1bW47bGFzdE9yaWdpbmFsTmFtZT1vcmlnaW5hbC5uYW1lO3NvdXJjZU1hcHBpbmdBY3RpdmU9dHJ1ZTt9ZWxzZSBpZihzb3VyY2VNYXBwaW5nQWN0aXZlKXttYXAuYWRkTWFwcGluZyh7Z2VuZXJhdGVkOntsaW5lOmdlbmVyYXRlZC5saW5lLGNvbHVtbjpnZW5lcmF0ZWQuY29sdW1ufX0pO2xhc3RPcmlnaW5hbFNvdXJjZT1udWxsO3NvdXJjZU1hcHBpbmdBY3RpdmU9ZmFsc2U7fWZvcih2YXIgaWR4PTAsbGVuZ3RoPWNodW5rLmxlbmd0aDtpZHg8bGVuZ3RoO2lkeCsrKXtpZihjaHVuay5jaGFyQ29kZUF0KGlkeCk9PT1ORVdMSU5FX0NPREUpe2dlbmVyYXRlZC5saW5lKys7Z2VuZXJhdGVkLmNvbHVtbj0wOy8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbmlmKGlkeCsxPT09bGVuZ3RoKXtsYXN0T3JpZ2luYWxTb3VyY2U9bnVsbDtzb3VyY2VNYXBwaW5nQWN0aXZlPWZhbHNlO31lbHNlIGlmKHNvdXJjZU1hcHBpbmdBY3RpdmUpe21hcC5hZGRNYXBwaW5nKHtzb3VyY2U6b3JpZ2luYWwuc291cmNlLG9yaWdpbmFsOntsaW5lOm9yaWdpbmFsLmxpbmUsY29sdW1uOm9yaWdpbmFsLmNvbHVtbn0sZ2VuZXJhdGVkOntsaW5lOmdlbmVyYXRlZC5saW5lLGNvbHVtbjpnZW5lcmF0ZWQuY29sdW1ufSxuYW1lOm9yaWdpbmFsLm5hbWV9KTt9fWVsc2V7Z2VuZXJhdGVkLmNvbHVtbisrO319fSk7dGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24oc291cmNlRmlsZSxzb3VyY2VDb250ZW50KXttYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLHNvdXJjZUNvbnRlbnQpO30pO3JldHVybntjb2RlOmdlbmVyYXRlZC5jb2RlLG1hcDptYXB9O307ZXhwb3J0cy5Tb3VyY2VOb2RlPVNvdXJjZU5vZGU7fSx7XCIuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yXCI6MjA0LFwiLi91dGlsXCI6MjA2fV0sMjA2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovIC8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi8gLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL2Z1bmN0aW9uIGdldEFyZyhhQXJncyxhTmFtZSxhRGVmYXVsdFZhbHVlKXtpZihhTmFtZSBpbiBhQXJncyl7cmV0dXJuIGFBcmdzW2FOYW1lXTt9ZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoPT09Myl7cmV0dXJuIGFEZWZhdWx0VmFsdWU7fWVsc2V7dGhyb3cgbmV3IEVycm9yKCdcIicrYU5hbWUrJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7fX1leHBvcnRzLmdldEFyZz1nZXRBcmc7dmFyIHVybFJlZ2V4cD0vXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Li1dKikoPzo6KFxcZCspKT8oLiopJC87dmFyIGRhdGFVcmxSZWdleHA9L15kYXRhOi4rXFwsLiskLztmdW5jdGlvbiB1cmxQYXJzZShhVXJsKXt2YXIgbWF0Y2g9YVVybC5tYXRjaCh1cmxSZWdleHApO2lmKCFtYXRjaCl7cmV0dXJuIG51bGw7fXJldHVybntzY2hlbWU6bWF0Y2hbMV0sYXV0aDptYXRjaFsyXSxob3N0Om1hdGNoWzNdLHBvcnQ6bWF0Y2hbNF0scGF0aDptYXRjaFs1XX07fWV4cG9ydHMudXJsUGFyc2U9dXJsUGFyc2U7ZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCl7dmFyIHVybD0nJztpZihhUGFyc2VkVXJsLnNjaGVtZSl7dXJsKz1hUGFyc2VkVXJsLnNjaGVtZSsnOic7fXVybCs9Jy8vJztpZihhUGFyc2VkVXJsLmF1dGgpe3VybCs9YVBhcnNlZFVybC5hdXRoKydAJzt9aWYoYVBhcnNlZFVybC5ob3N0KXt1cmwrPWFQYXJzZWRVcmwuaG9zdDt9aWYoYVBhcnNlZFVybC5wb3J0KXt1cmwrPVwiOlwiK2FQYXJzZWRVcmwucG9ydDt9aWYoYVBhcnNlZFVybC5wYXRoKXt1cmwrPWFQYXJzZWRVcmwucGF0aDt9cmV0dXJuIHVybDt9ZXhwb3J0cy51cmxHZW5lcmF0ZT11cmxHZW5lcmF0ZTsvKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL2Z1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCl7dmFyIHBhdGg9YVBhdGg7dmFyIHVybD11cmxQYXJzZShhUGF0aCk7aWYodXJsKXtpZighdXJsLnBhdGgpe3JldHVybiBhUGF0aDt9cGF0aD11cmwucGF0aDt9dmFyIGlzQWJzb2x1dGU9ZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO3ZhciBwYXJ0cz1wYXRoLnNwbGl0KC9cXC8rLyk7Zm9yKHZhciBwYXJ0LHVwPTAsaT1wYXJ0cy5sZW5ndGgtMTtpPj0wO2ktLSl7cGFydD1wYXJ0c1tpXTtpZihwYXJ0PT09Jy4nKXtwYXJ0cy5zcGxpY2UoaSwxKTt9ZWxzZSBpZihwYXJ0PT09Jy4uJyl7dXArKzt9ZWxzZSBpZih1cD4wKXtpZihwYXJ0PT09Jycpey8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbi8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4vLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbnBhcnRzLnNwbGljZShpKzEsdXApO3VwPTA7fWVsc2V7cGFydHMuc3BsaWNlKGksMik7dXAtLTt9fX1wYXRoPXBhcnRzLmpvaW4oJy8nKTtpZihwYXRoPT09Jycpe3BhdGg9aXNBYnNvbHV0ZT8nLyc6Jy4nO31pZih1cmwpe3VybC5wYXRoPXBhdGg7cmV0dXJuIHVybEdlbmVyYXRlKHVybCk7fXJldHVybiBwYXRoO31leHBvcnRzLm5vcm1hbGl6ZT1ub3JtYWxpemU7LyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovZnVuY3Rpb24gam9pbihhUm9vdCxhUGF0aCl7aWYoYVJvb3Q9PT1cIlwiKXthUm9vdD1cIi5cIjt9aWYoYVBhdGg9PT1cIlwiKXthUGF0aD1cIi5cIjt9dmFyIGFQYXRoVXJsPXVybFBhcnNlKGFQYXRoKTt2YXIgYVJvb3RVcmw9dXJsUGFyc2UoYVJvb3QpO2lmKGFSb290VXJsKXthUm9vdD1hUm9vdFVybC5wYXRofHwnLyc7fS8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG5pZihhUGF0aFVybCYmIWFQYXRoVXJsLnNjaGVtZSl7aWYoYVJvb3RVcmwpe2FQYXRoVXJsLnNjaGVtZT1hUm9vdFVybC5zY2hlbWU7fXJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7fWlmKGFQYXRoVXJsfHxhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSl7cmV0dXJuIGFQYXRoO30vLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbmlmKGFSb290VXJsJiYhYVJvb3RVcmwuaG9zdCYmIWFSb290VXJsLnBhdGgpe2FSb290VXJsLmhvc3Q9YVBhdGg7cmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTt9dmFyIGpvaW5lZD1hUGF0aC5jaGFyQXQoMCk9PT0nLyc/YVBhdGg6bm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywnJykrJy8nK2FQYXRoKTtpZihhUm9vdFVybCl7YVJvb3RVcmwucGF0aD1qb2luZWQ7cmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTt9cmV0dXJuIGpvaW5lZDt9ZXhwb3J0cy5qb2luPWpvaW47ZXhwb3J0cy5pc0Fic29sdXRlPWZ1bmN0aW9uKGFQYXRoKXtyZXR1cm4gYVBhdGguY2hhckF0KDApPT09Jy8nfHx1cmxSZWdleHAudGVzdChhUGF0aCk7fTsvKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCxhUGF0aCl7aWYoYVJvb3Q9PT1cIlwiKXthUm9vdD1cIi5cIjt9YVJvb3Q9YVJvb3QucmVwbGFjZSgvXFwvJC8sJycpOy8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbi8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2Vcbi8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxudmFyIGxldmVsPTA7d2hpbGUoYVBhdGguaW5kZXhPZihhUm9vdCsnLycpIT09MCl7dmFyIGluZGV4PWFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtpZihpbmRleDwwKXtyZXR1cm4gYVBhdGg7fS8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbi8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2Vcbi8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG5hUm9vdD1hUm9vdC5zbGljZSgwLGluZGV4KTtpZihhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSl7cmV0dXJuIGFQYXRoO30rK2xldmVsO30vLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxucmV0dXJuIEFycmF5KGxldmVsKzEpLmpvaW4oXCIuLi9cIikrYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCsxKTt9ZXhwb3J0cy5yZWxhdGl2ZT1yZWxhdGl2ZTt2YXIgc3VwcG9ydHNOdWxsUHJvdG89ZnVuY3Rpb24oKXt2YXIgb2JqPU9iamVjdC5jcmVhdGUobnVsbCk7cmV0dXJuISgnX19wcm90b19fJ2luIG9iaik7fSgpO2Z1bmN0aW9uIGlkZW50aXR5KHMpe3JldHVybiBzO30vKipcbiAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL2Z1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpe2lmKGlzUHJvdG9TdHJpbmcoYVN0cikpe3JldHVybickJythU3RyO31yZXR1cm4gYVN0cjt9ZXhwb3J0cy50b1NldFN0cmluZz1zdXBwb3J0c051bGxQcm90bz9pZGVudGl0eTp0b1NldFN0cmluZztmdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpe2lmKGlzUHJvdG9TdHJpbmcoYVN0cikpe3JldHVybiBhU3RyLnNsaWNlKDEpO31yZXR1cm4gYVN0cjt9ZXhwb3J0cy5mcm9tU2V0U3RyaW5nPXN1cHBvcnRzTnVsbFByb3RvP2lkZW50aXR5OmZyb21TZXRTdHJpbmc7ZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKXtpZighcyl7cmV0dXJuIGZhbHNlO312YXIgbGVuZ3RoPXMubGVuZ3RoO2lmKGxlbmd0aDw5LyogXCJfX3Byb3RvX19cIi5sZW5ndGggKi8pe3JldHVybiBmYWxzZTt9aWYocy5jaGFyQ29kZUF0KGxlbmd0aC0xKSE9PTk1LyogJ18nICovfHxzLmNoYXJDb2RlQXQobGVuZ3RoLTIpIT09OTUvKiAnXycgKi98fHMuY2hhckNvZGVBdChsZW5ndGgtMykhPT0xMTEvKiAnbycgKi98fHMuY2hhckNvZGVBdChsZW5ndGgtNCkhPT0xMTYvKiAndCcgKi98fHMuY2hhckNvZGVBdChsZW5ndGgtNSkhPT0xMTEvKiAnbycgKi98fHMuY2hhckNvZGVBdChsZW5ndGgtNikhPT0xMTQvKiAncicgKi98fHMuY2hhckNvZGVBdChsZW5ndGgtNykhPT0xMTIvKiAncCcgKi98fHMuY2hhckNvZGVBdChsZW5ndGgtOCkhPT05NS8qICdfJyAqL3x8cy5jaGFyQ29kZUF0KGxlbmd0aC05KSE9PTk1LyogJ18nICovKXtyZXR1cm4gZmFsc2U7fWZvcih2YXIgaT1sZW5ndGgtMTA7aT49MDtpLS0pe2lmKHMuY2hhckNvZGVBdChpKSE9PTM2LyogJyQnICovKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9LyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSxtYXBwaW5nQixvbmx5Q29tcGFyZU9yaWdpbmFsKXt2YXIgY21wPXN0cmNtcChtYXBwaW5nQS5zb3VyY2UsbWFwcGluZ0Iuc291cmNlKTtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31jbXA9bWFwcGluZ0Eub3JpZ2luYWxMaW5lLW1hcHBpbmdCLm9yaWdpbmFsTGluZTtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31jbXA9bWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4tbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47aWYoY21wIT09MHx8b25seUNvbXBhcmVPcmlnaW5hbCl7cmV0dXJuIGNtcDt9Y21wPW1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbi1tYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47aWYoY21wIT09MCl7cmV0dXJuIGNtcDt9Y21wPW1hcHBpbmdBLmdlbmVyYXRlZExpbmUtbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31yZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsbWFwcGluZ0IubmFtZSk7fWV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM9Y29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7LyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsbWFwcGluZ0Isb25seUNvbXBhcmVHZW5lcmF0ZWQpe3ZhciBjbXA9bWFwcGluZ0EuZ2VuZXJhdGVkTGluZS1tYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO2lmKGNtcCE9PTApe3JldHVybiBjbXA7fWNtcD1tYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4tbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO2lmKGNtcCE9PTB8fG9ubHlDb21wYXJlR2VuZXJhdGVkKXtyZXR1cm4gY21wO31jbXA9c3RyY21wKG1hcHBpbmdBLnNvdXJjZSxtYXBwaW5nQi5zb3VyY2UpO2lmKGNtcCE9PTApe3JldHVybiBjbXA7fWNtcD1tYXBwaW5nQS5vcmlnaW5hbExpbmUtbWFwcGluZ0Iub3JpZ2luYWxMaW5lO2lmKGNtcCE9PTApe3JldHVybiBjbXA7fWNtcD1tYXBwaW5nQS5vcmlnaW5hbENvbHVtbi1tYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31yZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsbWFwcGluZ0IubmFtZSk7fWV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ9Y29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7ZnVuY3Rpb24gc3RyY21wKGFTdHIxLGFTdHIyKXtpZihhU3RyMT09PWFTdHIyKXtyZXR1cm4gMDt9aWYoYVN0cjE9PT1udWxsKXtyZXR1cm4gMTsvLyBhU3RyMiAhPT0gbnVsbFxufWlmKGFTdHIyPT09bnVsbCl7cmV0dXJuLTE7Ly8gYVN0cjEgIT09IG51bGxcbn1pZihhU3RyMT5hU3RyMil7cmV0dXJuIDE7fXJldHVybi0xO30vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICovZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsbWFwcGluZ0Ipe3ZhciBjbXA9bWFwcGluZ0EuZ2VuZXJhdGVkTGluZS1tYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO2lmKGNtcCE9PTApe3JldHVybiBjbXA7fWNtcD1tYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4tbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO2lmKGNtcCE9PTApe3JldHVybiBjbXA7fWNtcD1zdHJjbXAobWFwcGluZ0Euc291cmNlLG1hcHBpbmdCLnNvdXJjZSk7aWYoY21wIT09MCl7cmV0dXJuIGNtcDt9Y21wPW1hcHBpbmdBLm9yaWdpbmFsTGluZS1tYXBwaW5nQi5vcmlnaW5hbExpbmU7aWYoY21wIT09MCl7cmV0dXJuIGNtcDt9Y21wPW1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uLW1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO2lmKGNtcCE9PTApe3JldHVybiBjbXA7fXJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSxtYXBwaW5nQi5uYW1lKTt9ZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZD1jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDsvKipcbiAqIFN0cmlwIGFueSBKU09OIFhTU0kgYXZvaWRhbmNlIHByZWZpeCBmcm9tIHRoZSBzdHJpbmcgKGFzIGRvY3VtZW50ZWRcbiAqIGluIHRoZSBzb3VyY2UgbWFwcyBzcGVjaWZpY2F0aW9uKSwgYW5kIHRoZW4gcGFyc2UgdGhlIHN0cmluZyBhc1xuICogSlNPTi5cbiAqL2Z1bmN0aW9uIHBhcnNlU291cmNlTWFwSW5wdXQoc3RyKXtyZXR1cm4gSlNPTi5wYXJzZShzdHIucmVwbGFjZSgvXlxcKV19J1teXFxuXSpcXG4vLCcnKSk7fWV4cG9ydHMucGFyc2VTb3VyY2VNYXBJbnB1dD1wYXJzZVNvdXJjZU1hcElucHV0Oy8qKlxuICogQ29tcHV0ZSB0aGUgVVJMIG9mIGEgc291cmNlIGdpdmVuIHRoZSB0aGUgc291cmNlIHJvb3QsIHRoZSBzb3VyY2Unc1xuICogVVJMLCBhbmQgdGhlIHNvdXJjZSBtYXAncyBVUkwuXG4gKi9mdW5jdGlvbiBjb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3Qsc291cmNlVVJMLHNvdXJjZU1hcFVSTCl7c291cmNlVVJMPXNvdXJjZVVSTHx8Jyc7aWYoc291cmNlUm9vdCl7Ly8gVGhpcyBmb2xsb3dzIHdoYXQgQ2hyb21lIGRvZXMuXG5pZihzb3VyY2VSb290W3NvdXJjZVJvb3QubGVuZ3RoLTFdIT09Jy8nJiZzb3VyY2VVUkxbMF0hPT0nLycpe3NvdXJjZVJvb3QrPScvJzt9Ly8gVGhlIHNwZWMgc2F5czpcbi8vICAgTGluZSA0OiBBbiBvcHRpb25hbCBzb3VyY2Ugcm9vdCwgdXNlZnVsIGZvciByZWxvY2F0aW5nIHNvdXJjZVxuLy8gICBmaWxlcyBvbiBhIHNlcnZlciBvciByZW1vdmluZyByZXBlYXRlZCB2YWx1ZXMgaW4gdGhlXG4vLyAgIOKAnHNvdXJjZXPigJ0gZW50cnkuICBUaGlzIHZhbHVlIGlzIHByZXBlbmRlZCB0byB0aGUgaW5kaXZpZHVhbFxuLy8gICBlbnRyaWVzIGluIHRoZSDigJxzb3VyY2XigJ0gZmllbGQuXG5zb3VyY2VVUkw9c291cmNlUm9vdCtzb3VyY2VVUkw7fS8vIEhpc3RvcmljYWxseSwgU291cmNlTWFwQ29uc3VtZXIgZGlkIG5vdCB0YWtlIHRoZSBzb3VyY2VNYXBVUkwgYXNcbi8vIGEgcGFyYW1ldGVyLiAgVGhpcyBtb2RlIGlzIHN0aWxsIHNvbWV3aGF0IHN1cHBvcnRlZCwgd2hpY2ggaXMgd2h5XG4vLyB0aGlzIGNvZGUgYmxvY2sgaXMgY29uZGl0aW9uYWwuICBIb3dldmVyLCBpdCdzIHByZWZlcmFibGUgdG8gcGFzc1xuLy8gdGhlIHNvdXJjZSBtYXAgVVJMIHRvIFNvdXJjZU1hcENvbnN1bWVyLCBzbyB0aGF0IHRoaXMgZnVuY3Rpb25cbi8vIGNhbiBpbXBsZW1lbnQgdGhlIHNvdXJjZSBVUkwgcmVzb2x1dGlvbiBhbGdvcml0aG0gYXMgb3V0bGluZWQgaW5cbi8vIHRoZSBzcGVjLiAgVGhpcyBibG9jayBpcyBiYXNpY2FsbHkgdGhlIGVxdWl2YWxlbnQgb2Y6XG4vLyAgICBuZXcgVVJMKHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKS50b1N0cmluZygpXG4vLyAuLi4gZXhjZXB0IGl0IGF2b2lkcyB1c2luZyBVUkwsIHdoaWNoIHdhc24ndCBhdmFpbGFibGUgaW4gdGhlXG4vLyBvbGRlciByZWxlYXNlcyBvZiBub2RlIHN0aWxsIHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnkuXG4vL1xuLy8gVGhlIHNwZWMgc2F5czpcbi8vICAgSWYgdGhlIHNvdXJjZXMgYXJlIG5vdCBhYnNvbHV0ZSBVUkxzIGFmdGVyIHByZXBlbmRpbmcgb2YgdGhlXG4vLyAgIOKAnHNvdXJjZVJvb3TigJ0sIHRoZSBzb3VyY2VzIGFyZSByZXNvbHZlZCByZWxhdGl2ZSB0byB0aGVcbi8vICAgU291cmNlTWFwIChsaWtlIHJlc29sdmluZyBzY3JpcHQgc3JjIGluIGEgaHRtbCBkb2N1bWVudCkuXG5pZihzb3VyY2VNYXBVUkwpe3ZhciBwYXJzZWQ9dXJsUGFyc2Uoc291cmNlTWFwVVJMKTtpZighcGFyc2VkKXt0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VNYXBVUkwgY291bGQgbm90IGJlIHBhcnNlZFwiKTt9aWYocGFyc2VkLnBhdGgpey8vIFN0cmlwIHRoZSBsYXN0IHBhdGggY29tcG9uZW50LCBidXQga2VlcCB0aGUgXCIvXCIuXG52YXIgaW5kZXg9cGFyc2VkLnBhdGgubGFzdEluZGV4T2YoJy8nKTtpZihpbmRleD49MCl7cGFyc2VkLnBhdGg9cGFyc2VkLnBhdGguc3Vic3RyaW5nKDAsaW5kZXgrMSk7fX1zb3VyY2VVUkw9am9pbih1cmxHZW5lcmF0ZShwYXJzZWQpLHNvdXJjZVVSTCk7fXJldHVybiBub3JtYWxpemUoc291cmNlVVJMKTt9ZXhwb3J0cy5jb21wdXRlU291cmNlVVJMPWNvbXB1dGVTb3VyY2VVUkw7fSx7fV0sMjA3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3I9cmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7ZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lcj1yZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7ZXhwb3J0cy5Tb3VyY2VOb2RlPXJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTt9LHtcIi4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXJcIjoyMDMsXCIuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvclwiOjIwNCxcIi4vbGliL3NvdXJjZS1ub2RlXCI6MjA1fV0sMjA4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsndXNlIHN0cmljdCc7dmFyIGludGVnZXJSZWdleD0vXlxcZCskLztmdW5jdGlvbiBkZWVwVW5pcXVlKGFycmF5KXtyZXR1cm4gYXJyYXkuc29ydCgpLmZpbHRlcihmdW5jdGlvbihlbGVtZW50LGluZGV4KXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZWxlbWVudCkhPT1KU09OLnN0cmluZ2lmeShhcnJheVtpbmRleC0xXSk7fSk7fWV4cG9ydHMucGFyc2U9ZnVuY3Rpb24oc3RyaW5nKXtyZXR1cm4gZGVlcFVuaXF1ZShzdHJpbmcuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24ocGFydCl7dmFyIHJlc3VsdD17fTtwYXJ0LnRyaW0oKS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCxpbmRleCl7aWYoaW5kZXg9PT0wKXtyZXN1bHQudXJsPWVsZW1lbnQ7cmV0dXJuO312YXIgdmFsdWU9ZWxlbWVudC5zbGljZSgwLGVsZW1lbnQubGVuZ3RoLTEpO3ZhciBwb3N0Zml4PWVsZW1lbnRbZWxlbWVudC5sZW5ndGgtMV07dmFyIGludGVnZXJWYWx1ZT1wYXJzZUludCh2YWx1ZSwxMCk7dmFyIGZsb2F0VmFsdWU9cGFyc2VGbG9hdCh2YWx1ZSk7aWYocG9zdGZpeD09PSd3JyYmaW50ZWdlclJlZ2V4LnRlc3QodmFsdWUpKXtyZXN1bHQud2lkdGg9aW50ZWdlclZhbHVlO31lbHNlIGlmKHBvc3RmaXg9PT0naCcmJmludGVnZXJSZWdleC50ZXN0KHZhbHVlKSl7cmVzdWx0LmhlaWdodD1pbnRlZ2VyVmFsdWU7fWVsc2UgaWYocG9zdGZpeD09PSd4JyYmIU51bWJlci5pc05hTihmbG9hdFZhbHVlKSl7cmVzdWx0LmRlbnNpdHk9ZmxvYXRWYWx1ZTt9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNyY3NldCBkZXNjcmlwdG9yOiBcIi5jb25jYXQoZWxlbWVudCkpO319KTtyZXR1cm4gcmVzdWx0O30pKTt9O2V4cG9ydHMuc3RyaW5naWZ5PWZ1bmN0aW9uKGFycmF5KXtyZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBTZXQoYXJyYXkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpe2lmKCFlbGVtZW50LnVybCl7dGhyb3cgbmV3IEVycm9yKCdVUkwgaXMgcmVxdWlyZWQnKTt9dmFyIHJlc3VsdD1bZWxlbWVudC51cmxdO2lmKGVsZW1lbnQud2lkdGgpe3Jlc3VsdC5wdXNoKFwiXCIuY29uY2F0KGVsZW1lbnQud2lkdGgsXCJ3XCIpKTt9aWYoZWxlbWVudC5oZWlnaHQpe3Jlc3VsdC5wdXNoKFwiXCIuY29uY2F0KGVsZW1lbnQuaGVpZ2h0LFwiaFwiKSk7fWlmKGVsZW1lbnQuZGVuc2l0eSl7cmVzdWx0LnB1c2goXCJcIi5jb25jYXQoZWxlbWVudC5kZW5zaXR5LFwieFwiKSk7fXJldHVybiByZXN1bHQuam9pbignICcpO30pKSkuam9pbignLCAnKTt9O30se31dLDIwOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7Ly8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7dmFyIHB1bnljb2RlPXJlcXVpcmUoJ3B1bnljb2RlJyk7dmFyIHV0aWw9cmVxdWlyZSgnLi91dGlsJyk7ZXhwb3J0cy5wYXJzZT11cmxQYXJzZTtleHBvcnRzLnJlc29sdmU9dXJsUmVzb2x2ZTtleHBvcnRzLnJlc29sdmVPYmplY3Q9dXJsUmVzb2x2ZU9iamVjdDtleHBvcnRzLmZvcm1hdD11cmxGb3JtYXQ7ZXhwb3J0cy5Vcmw9VXJsO2Z1bmN0aW9uIFVybCgpe3RoaXMucHJvdG9jb2w9bnVsbDt0aGlzLnNsYXNoZXM9bnVsbDt0aGlzLmF1dGg9bnVsbDt0aGlzLmhvc3Q9bnVsbDt0aGlzLnBvcnQ9bnVsbDt0aGlzLmhvc3RuYW1lPW51bGw7dGhpcy5oYXNoPW51bGw7dGhpcy5zZWFyY2g9bnVsbDt0aGlzLnF1ZXJ5PW51bGw7dGhpcy5wYXRobmFtZT1udWxsO3RoaXMucGF0aD1udWxsO3RoaXMuaHJlZj1udWxsO30vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm49L14oW2EtejAtOS4rLV0rOikvaSxwb3J0UGF0dGVybj0vOlswLTldKiQvLC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbnNpbXBsZVBhdGhQYXR0ZXJuPS9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbi8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG5kZWxpbXM9Wyc8JywnPicsJ1wiJywnYCcsJyAnLCdcXHInLCdcXG4nLCdcXHQnXSwvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxudW53aXNlPVsneycsJ30nLCd8JywnXFxcXCcsJ14nLCdgJ10uY29uY2F0KGRlbGltcyksLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuYXV0b0VzY2FwZT1bJ1xcJyddLmNvbmNhdCh1bndpc2UpLC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4vLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4vLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbi8vIHRoZW0uXG5ub25Ib3N0Q2hhcnM9WyclJywnLycsJz8nLCc7JywnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxob3N0RW5kaW5nQ2hhcnM9WycvJywnPycsJyMnXSxob3N0bmFtZU1heExlbj0yNTUsaG9zdG5hbWVQYXJ0UGF0dGVybj0vXlsrYS16MC05QS1aXy1dezAsNjN9JC8saG9zdG5hbWVQYXJ0U3RhcnQ9L14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxudW5zYWZlUHJvdG9jb2w9eydqYXZhc2NyaXB0Jzp0cnVlLCdqYXZhc2NyaXB0Oic6dHJ1ZX0sLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuaG9zdGxlc3NQcm90b2NvbD17J2phdmFzY3JpcHQnOnRydWUsJ2phdmFzY3JpcHQ6Jzp0cnVlfSwvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbnNsYXNoZWRQcm90b2NvbD17J2h0dHAnOnRydWUsJ2h0dHBzJzp0cnVlLCdmdHAnOnRydWUsJ2dvcGhlcic6dHJ1ZSwnZmlsZSc6dHJ1ZSwnaHR0cDonOnRydWUsJ2h0dHBzOic6dHJ1ZSwnZnRwOic6dHJ1ZSwnZ29waGVyOic6dHJ1ZSwnZmlsZTonOnRydWV9LHF1ZXJ5c3RyaW5nPXJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7ZnVuY3Rpb24gdXJsUGFyc2UodXJsLHBhcnNlUXVlcnlTdHJpbmcsc2xhc2hlc0Rlbm90ZUhvc3Qpe2lmKHVybCYmdXRpbC5pc09iamVjdCh1cmwpJiZ1cmwgaW5zdGFuY2VvZiBVcmwpcmV0dXJuIHVybDt2YXIgdT1uZXcgVXJsKCk7dS5wYXJzZSh1cmwscGFyc2VRdWVyeVN0cmluZyxzbGFzaGVzRGVub3RlSG9zdCk7cmV0dXJuIHU7fVVybC5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24odXJsLHBhcnNlUXVlcnlTdHJpbmcsc2xhc2hlc0Rlbm90ZUhvc3Qpe2lmKCF1dGlsLmlzU3RyaW5nKHVybCkpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiK190eXBlb2YodXJsKSk7fS8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4vLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxudmFyIHF1ZXJ5SW5kZXg9dXJsLmluZGV4T2YoJz8nKSxzcGxpdHRlcj1xdWVyeUluZGV4IT09LTEmJnF1ZXJ5SW5kZXg8dXJsLmluZGV4T2YoJyMnKT8nPyc6JyMnLHVTcGxpdD11cmwuc3BsaXQoc3BsaXR0ZXIpLHNsYXNoUmVnZXg9L1xcXFwvZzt1U3BsaXRbMF09dVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwnLycpO3VybD11U3BsaXQuam9pbihzcGxpdHRlcik7dmFyIHJlc3Q9dXJsOy8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4vLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG5yZXN0PXJlc3QudHJpbSgpO2lmKCFzbGFzaGVzRGVub3RlSG9zdCYmdXJsLnNwbGl0KCcjJykubGVuZ3RoPT09MSl7Ly8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbnZhciBzaW1wbGVQYXRoPXNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7aWYoc2ltcGxlUGF0aCl7dGhpcy5wYXRoPXJlc3Q7dGhpcy5ocmVmPXJlc3Q7dGhpcy5wYXRobmFtZT1zaW1wbGVQYXRoWzFdO2lmKHNpbXBsZVBhdGhbMl0pe3RoaXMuc2VhcmNoPXNpbXBsZVBhdGhbMl07aWYocGFyc2VRdWVyeVN0cmluZyl7dGhpcy5xdWVyeT1xdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO31lbHNle3RoaXMucXVlcnk9dGhpcy5zZWFyY2guc3Vic3RyKDEpO319ZWxzZSBpZihwYXJzZVF1ZXJ5U3RyaW5nKXt0aGlzLnNlYXJjaD0nJzt0aGlzLnF1ZXJ5PXt9O31yZXR1cm4gdGhpczt9fXZhciBwcm90bz1wcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtpZihwcm90byl7cHJvdG89cHJvdG9bMF07dmFyIGxvd2VyUHJvdG89cHJvdG8udG9Mb3dlckNhc2UoKTt0aGlzLnByb3RvY29sPWxvd2VyUHJvdG87cmVzdD1yZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO30vLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG5pZihzbGFzaGVzRGVub3RlSG9zdHx8cHJvdG98fHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKXt2YXIgc2xhc2hlcz1yZXN0LnN1YnN0cigwLDIpPT09Jy8vJztpZihzbGFzaGVzJiYhKHByb3RvJiZob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpe3Jlc3Q9cmVzdC5zdWJzdHIoMik7dGhpcy5zbGFzaGVzPXRydWU7fX1pZighaG9zdGxlc3NQcm90b2NvbFtwcm90b10mJihzbGFzaGVzfHxwcm90byYmIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKXsvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4vLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuLy9cbi8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbi8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4vLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuLy9cbi8vIGV4OlxuLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbi8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcbi8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbi8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG4vLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG52YXIgaG9zdEVuZD0tMTtmb3IodmFyIGk9MDtpPGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7aSsrKXt2YXIgaGVjPXJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO2lmKGhlYyE9PS0xJiYoaG9zdEVuZD09PS0xfHxoZWM8aG9zdEVuZCkpaG9zdEVuZD1oZWM7fS8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG52YXIgYXV0aCxhdFNpZ247aWYoaG9zdEVuZD09PS0xKXsvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuYXRTaWduPXJlc3QubGFzdEluZGV4T2YoJ0AnKTt9ZWxzZXsvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4vLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuYXRTaWduPXJlc3QubGFzdEluZGV4T2YoJ0AnLGhvc3RFbmQpO30vLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbi8vIFB1bGwgdGhhdCBvZmYuXG5pZihhdFNpZ24hPT0tMSl7YXV0aD1yZXN0LnNsaWNlKDAsYXRTaWduKTtyZXN0PXJlc3Quc2xpY2UoYXRTaWduKzEpO3RoaXMuYXV0aD1kZWNvZGVVUklDb21wb25lbnQoYXV0aCk7fS8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbmhvc3RFbmQ9LTE7Zm9yKHZhciBpPTA7aTxub25Ib3N0Q2hhcnMubGVuZ3RoO2krKyl7dmFyIGhlYz1yZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtpZihoZWMhPT0tMSYmKGhvc3RFbmQ9PT0tMXx8aGVjPGhvc3RFbmQpKWhvc3RFbmQ9aGVjO30vLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG5pZihob3N0RW5kPT09LTEpaG9zdEVuZD1yZXN0Lmxlbmd0aDt0aGlzLmhvc3Q9cmVzdC5zbGljZSgwLGhvc3RFbmQpO3Jlc3Q9cmVzdC5zbGljZShob3N0RW5kKTsvLyBwdWxsIG91dCBwb3J0LlxudGhpcy5wYXJzZUhvc3QoKTsvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbnRoaXMuaG9zdG5hbWU9dGhpcy5ob3N0bmFtZXx8Jyc7Ly8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbi8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxudmFyIGlwdjZIb3N0bmFtZT10aGlzLmhvc3RuYW1lWzBdPT09J1snJiZ0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoLTFdPT09J10nOy8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuaWYoIWlwdjZIb3N0bmFtZSl7dmFyIGhvc3RwYXJ0cz10aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtmb3IodmFyIGk9MCxsPWhvc3RwYXJ0cy5sZW5ndGg7aTxsO2krKyl7dmFyIHBhcnQ9aG9zdHBhcnRzW2ldO2lmKCFwYXJ0KWNvbnRpbnVlO2lmKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKXt2YXIgbmV3cGFydD0nJztmb3IodmFyIGo9MCxrPXBhcnQubGVuZ3RoO2o8aztqKyspe2lmKHBhcnQuY2hhckNvZGVBdChqKT4xMjcpey8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xubmV3cGFydCs9J3gnO31lbHNle25ld3BhcnQrPXBhcnRbal07fX0vLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG5pZighbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSl7dmFyIHZhbGlkUGFydHM9aG9zdHBhcnRzLnNsaWNlKDAsaSk7dmFyIG5vdEhvc3Q9aG9zdHBhcnRzLnNsaWNlKGkrMSk7dmFyIGJpdD1wYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtpZihiaXQpe3ZhbGlkUGFydHMucHVzaChiaXRbMV0pO25vdEhvc3QudW5zaGlmdChiaXRbMl0pO31pZihub3RIb3N0Lmxlbmd0aCl7cmVzdD0nLycrbm90SG9zdC5qb2luKCcuJykrcmVzdDt9dGhpcy5ob3N0bmFtZT12YWxpZFBhcnRzLmpvaW4oJy4nKTticmVhazt9fX19aWYodGhpcy5ob3N0bmFtZS5sZW5ndGg+aG9zdG5hbWVNYXhMZW4pe3RoaXMuaG9zdG5hbWU9Jyc7fWVsc2V7Ly8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbnRoaXMuaG9zdG5hbWU9dGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO31pZighaXB2Nkhvc3RuYW1lKXsvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbi8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbi8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbi8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG50aGlzLmhvc3RuYW1lPXB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7fXZhciBwPXRoaXMucG9ydD8nOicrdGhpcy5wb3J0OicnO3ZhciBoPXRoaXMuaG9zdG5hbWV8fCcnO3RoaXMuaG9zdD1oK3A7dGhpcy5ocmVmKz10aGlzLmhvc3Q7Ly8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbmlmKGlwdjZIb3N0bmFtZSl7dGhpcy5ob3N0bmFtZT10aGlzLmhvc3RuYW1lLnN1YnN0cigxLHRoaXMuaG9zdG5hbWUubGVuZ3RoLTIpO2lmKHJlc3RbMF0hPT0nLycpe3Jlc3Q9Jy8nK3Jlc3Q7fX19Ly8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4vLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG5pZighdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pey8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbi8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuLy8gbmVlZCB0byBiZS5cbmZvcih2YXIgaT0wLGw9YXV0b0VzY2FwZS5sZW5ndGg7aTxsO2krKyl7dmFyIGFlPWF1dG9Fc2NhcGVbaV07aWYocmVzdC5pbmRleE9mKGFlKT09PS0xKWNvbnRpbnVlO3ZhciBlc2M9ZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtpZihlc2M9PT1hZSl7ZXNjPWVzY2FwZShhZSk7fXJlc3Q9cmVzdC5zcGxpdChhZSkuam9pbihlc2MpO319Ly8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbnZhciBoYXNoPXJlc3QuaW5kZXhPZignIycpO2lmKGhhc2ghPT0tMSl7Ly8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxudGhpcy5oYXNoPXJlc3Quc3Vic3RyKGhhc2gpO3Jlc3Q9cmVzdC5zbGljZSgwLGhhc2gpO312YXIgcW09cmVzdC5pbmRleE9mKCc/Jyk7aWYocW0hPT0tMSl7dGhpcy5zZWFyY2g9cmVzdC5zdWJzdHIocW0pO3RoaXMucXVlcnk9cmVzdC5zdWJzdHIocW0rMSk7aWYocGFyc2VRdWVyeVN0cmluZyl7dGhpcy5xdWVyeT1xdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTt9cmVzdD1yZXN0LnNsaWNlKDAscW0pO31lbHNlIGlmKHBhcnNlUXVlcnlTdHJpbmcpey8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG50aGlzLnNlYXJjaD0nJzt0aGlzLnF1ZXJ5PXt9O31pZihyZXN0KXRoaXMucGF0aG5hbWU9cmVzdDtpZihzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10mJnRoaXMuaG9zdG5hbWUmJiF0aGlzLnBhdGhuYW1lKXt0aGlzLnBhdGhuYW1lPScvJzt9Ly90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuaWYodGhpcy5wYXRobmFtZXx8dGhpcy5zZWFyY2gpe3ZhciBwPXRoaXMucGF0aG5hbWV8fCcnO3ZhciBzPXRoaXMuc2VhcmNofHwnJzt0aGlzLnBhdGg9cCtzO30vLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbnRoaXMuaHJlZj10aGlzLmZvcm1hdCgpO3JldHVybiB0aGlzO307Ly8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iail7Ly8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbi8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4vLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4vLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuaWYodXRpbC5pc1N0cmluZyhvYmopKW9iaj11cmxQYXJzZShvYmopO2lmKCEob2JqIGluc3RhbmNlb2YgVXJsKSlyZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO3JldHVybiBvYmouZm9ybWF0KCk7fVVybC5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKCl7dmFyIGF1dGg9dGhpcy5hdXRofHwnJztpZihhdXRoKXthdXRoPWVuY29kZVVSSUNvbXBvbmVudChhdXRoKTthdXRoPWF1dGgucmVwbGFjZSgvJTNBL2ksJzonKTthdXRoKz0nQCc7fXZhciBwcm90b2NvbD10aGlzLnByb3RvY29sfHwnJyxwYXRobmFtZT10aGlzLnBhdGhuYW1lfHwnJyxoYXNoPXRoaXMuaGFzaHx8JycsaG9zdD1mYWxzZSxxdWVyeT0nJztpZih0aGlzLmhvc3Qpe2hvc3Q9YXV0aCt0aGlzLmhvc3Q7fWVsc2UgaWYodGhpcy5ob3N0bmFtZSl7aG9zdD1hdXRoKyh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKT09PS0xP3RoaXMuaG9zdG5hbWU6J1snK3RoaXMuaG9zdG5hbWUrJ10nKTtpZih0aGlzLnBvcnQpe2hvc3QrPSc6Jyt0aGlzLnBvcnQ7fX1pZih0aGlzLnF1ZXJ5JiZ1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpJiZPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpe3F1ZXJ5PXF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTt9dmFyIHNlYXJjaD10aGlzLnNlYXJjaHx8cXVlcnkmJic/JytxdWVyeXx8Jyc7aWYocHJvdG9jb2wmJnByb3RvY29sLnN1YnN0cigtMSkhPT0nOicpcHJvdG9jb2wrPSc6JzsvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbi8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG5pZih0aGlzLnNsYXNoZXN8fCghcHJvdG9jb2x8fHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pJiZob3N0IT09ZmFsc2Upe2hvc3Q9Jy8vJysoaG9zdHx8JycpO2lmKHBhdGhuYW1lJiZwYXRobmFtZS5jaGFyQXQoMCkhPT0nLycpcGF0aG5hbWU9Jy8nK3BhdGhuYW1lO31lbHNlIGlmKCFob3N0KXtob3N0PScnO31pZihoYXNoJiZoYXNoLmNoYXJBdCgwKSE9PScjJyloYXNoPScjJytoYXNoO2lmKHNlYXJjaCYmc2VhcmNoLmNoYXJBdCgwKSE9PSc/JylzZWFyY2g9Jz8nK3NlYXJjaDtwYXRobmFtZT1wYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csZnVuY3Rpb24obWF0Y2gpe3JldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO30pO3NlYXJjaD1zZWFyY2gucmVwbGFjZSgnIycsJyUyMycpO3JldHVybiBwcm90b2NvbCtob3N0K3BhdGhuYW1lK3NlYXJjaCtoYXNoO307ZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UscmVsYXRpdmUpe3JldHVybiB1cmxQYXJzZShzb3VyY2UsZmFsc2UsdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7fVVybC5wcm90b3R5cGUucmVzb2x2ZT1mdW5jdGlvbihyZWxhdGl2ZSl7cmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSxmYWxzZSx0cnVlKSkuZm9ybWF0KCk7fTtmdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSxyZWxhdGl2ZSl7aWYoIXNvdXJjZSlyZXR1cm4gcmVsYXRpdmU7cmV0dXJuIHVybFBhcnNlKHNvdXJjZSxmYWxzZSx0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTt9VXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0PWZ1bmN0aW9uKHJlbGF0aXZlKXtpZih1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSl7dmFyIHJlbD1uZXcgVXJsKCk7cmVsLnBhcnNlKHJlbGF0aXZlLGZhbHNlLHRydWUpO3JlbGF0aXZlPXJlbDt9dmFyIHJlc3VsdD1uZXcgVXJsKCk7dmFyIHRrZXlzPU9iamVjdC5rZXlzKHRoaXMpO2Zvcih2YXIgdGs9MDt0azx0a2V5cy5sZW5ndGg7dGsrKyl7dmFyIHRrZXk9dGtleXNbdGtdO3Jlc3VsdFt0a2V5XT10aGlzW3RrZXldO30vLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbi8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxucmVzdWx0Lmhhc2g9cmVsYXRpdmUuaGFzaDsvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG5pZihyZWxhdGl2ZS5ocmVmPT09Jycpe3Jlc3VsdC5ocmVmPXJlc3VsdC5mb3JtYXQoKTtyZXR1cm4gcmVzdWx0O30vLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbmlmKHJlbGF0aXZlLnNsYXNoZXMmJiFyZWxhdGl2ZS5wcm90b2NvbCl7Ly8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxudmFyIHJrZXlzPU9iamVjdC5rZXlzKHJlbGF0aXZlKTtmb3IodmFyIHJrPTA7cms8cmtleXMubGVuZ3RoO3JrKyspe3ZhciBya2V5PXJrZXlzW3JrXTtpZihya2V5IT09J3Byb3RvY29sJylyZXN1bHRbcmtleV09cmVsYXRpdmVbcmtleV07fS8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG5pZihzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSYmcmVzdWx0Lmhvc3RuYW1lJiYhcmVzdWx0LnBhdGhuYW1lKXtyZXN1bHQucGF0aD1yZXN1bHQucGF0aG5hbWU9Jy8nO31yZXN1bHQuaHJlZj1yZXN1bHQuZm9ybWF0KCk7cmV0dXJuIHJlc3VsdDt9aWYocmVsYXRpdmUucHJvdG9jb2wmJnJlbGF0aXZlLnByb3RvY29sIT09cmVzdWx0LnByb3RvY29sKXsvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4vLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3Ncbi8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbi8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbi8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4vLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbi8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbmlmKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKXt2YXIga2V5cz1PYmplY3Qua2V5cyhyZWxhdGl2ZSk7Zm9yKHZhciB2PTA7djxrZXlzLmxlbmd0aDt2Kyspe3ZhciBrPWtleXNbdl07cmVzdWx0W2tdPXJlbGF0aXZlW2tdO31yZXN1bHQuaHJlZj1yZXN1bHQuZm9ybWF0KCk7cmV0dXJuIHJlc3VsdDt9cmVzdWx0LnByb3RvY29sPXJlbGF0aXZlLnByb3RvY29sO2lmKCFyZWxhdGl2ZS5ob3N0JiYhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pe3ZhciByZWxQYXRoPShyZWxhdGl2ZS5wYXRobmFtZXx8JycpLnNwbGl0KCcvJyk7d2hpbGUocmVsUGF0aC5sZW5ndGgmJiEocmVsYXRpdmUuaG9zdD1yZWxQYXRoLnNoaWZ0KCkpKXs7fWlmKCFyZWxhdGl2ZS5ob3N0KXJlbGF0aXZlLmhvc3Q9Jyc7aWYoIXJlbGF0aXZlLmhvc3RuYW1lKXJlbGF0aXZlLmhvc3RuYW1lPScnO2lmKHJlbFBhdGhbMF0hPT0nJylyZWxQYXRoLnVuc2hpZnQoJycpO2lmKHJlbFBhdGgubGVuZ3RoPDIpcmVsUGF0aC51bnNoaWZ0KCcnKTtyZXN1bHQucGF0aG5hbWU9cmVsUGF0aC5qb2luKCcvJyk7fWVsc2V7cmVzdWx0LnBhdGhuYW1lPXJlbGF0aXZlLnBhdGhuYW1lO31yZXN1bHQuc2VhcmNoPXJlbGF0aXZlLnNlYXJjaDtyZXN1bHQucXVlcnk9cmVsYXRpdmUucXVlcnk7cmVzdWx0Lmhvc3Q9cmVsYXRpdmUuaG9zdHx8Jyc7cmVzdWx0LmF1dGg9cmVsYXRpdmUuYXV0aDtyZXN1bHQuaG9zdG5hbWU9cmVsYXRpdmUuaG9zdG5hbWV8fHJlbGF0aXZlLmhvc3Q7cmVzdWx0LnBvcnQ9cmVsYXRpdmUucG9ydDsvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuaWYocmVzdWx0LnBhdGhuYW1lfHxyZXN1bHQuc2VhcmNoKXt2YXIgcD1yZXN1bHQucGF0aG5hbWV8fCcnO3ZhciBzPXJlc3VsdC5zZWFyY2h8fCcnO3Jlc3VsdC5wYXRoPXArczt9cmVzdWx0LnNsYXNoZXM9cmVzdWx0LnNsYXNoZXN8fHJlbGF0aXZlLnNsYXNoZXM7cmVzdWx0LmhyZWY9cmVzdWx0LmZvcm1hdCgpO3JldHVybiByZXN1bHQ7fXZhciBpc1NvdXJjZUFicz1yZXN1bHQucGF0aG5hbWUmJnJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCk9PT0nLycsaXNSZWxBYnM9cmVsYXRpdmUuaG9zdHx8cmVsYXRpdmUucGF0aG5hbWUmJnJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKT09PScvJyxtdXN0RW5kQWJzPWlzUmVsQWJzfHxpc1NvdXJjZUFic3x8cmVzdWx0Lmhvc3QmJnJlbGF0aXZlLnBhdGhuYW1lLHJlbW92ZUFsbERvdHM9bXVzdEVuZEFicyxzcmNQYXRoPXJlc3VsdC5wYXRobmFtZSYmcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJyl8fFtdLHJlbFBhdGg9cmVsYXRpdmUucGF0aG5hbWUmJnJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJyl8fFtdLHBzeWNob3RpYz1yZXN1bHQucHJvdG9jb2wmJiFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTsvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4vLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4vLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4vLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG5pZihwc3ljaG90aWMpe3Jlc3VsdC5ob3N0bmFtZT0nJztyZXN1bHQucG9ydD1udWxsO2lmKHJlc3VsdC5ob3N0KXtpZihzcmNQYXRoWzBdPT09Jycpc3JjUGF0aFswXT1yZXN1bHQuaG9zdDtlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7fXJlc3VsdC5ob3N0PScnO2lmKHJlbGF0aXZlLnByb3RvY29sKXtyZWxhdGl2ZS5ob3N0bmFtZT1udWxsO3JlbGF0aXZlLnBvcnQ9bnVsbDtpZihyZWxhdGl2ZS5ob3N0KXtpZihyZWxQYXRoWzBdPT09JycpcmVsUGF0aFswXT1yZWxhdGl2ZS5ob3N0O2Vsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO31yZWxhdGl2ZS5ob3N0PW51bGw7fW11c3RFbmRBYnM9bXVzdEVuZEFicyYmKHJlbFBhdGhbMF09PT0nJ3x8c3JjUGF0aFswXT09PScnKTt9aWYoaXNSZWxBYnMpey8vIGl0J3MgYWJzb2x1dGUuXG5yZXN1bHQuaG9zdD1yZWxhdGl2ZS5ob3N0fHxyZWxhdGl2ZS5ob3N0PT09Jyc/cmVsYXRpdmUuaG9zdDpyZXN1bHQuaG9zdDtyZXN1bHQuaG9zdG5hbWU9cmVsYXRpdmUuaG9zdG5hbWV8fHJlbGF0aXZlLmhvc3RuYW1lPT09Jyc/cmVsYXRpdmUuaG9zdG5hbWU6cmVzdWx0Lmhvc3RuYW1lO3Jlc3VsdC5zZWFyY2g9cmVsYXRpdmUuc2VhcmNoO3Jlc3VsdC5xdWVyeT1yZWxhdGl2ZS5xdWVyeTtzcmNQYXRoPXJlbFBhdGg7Ly8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG59ZWxzZSBpZihyZWxQYXRoLmxlbmd0aCl7Ly8gaXQncyByZWxhdGl2ZVxuLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG5pZighc3JjUGF0aClzcmNQYXRoPVtdO3NyY1BhdGgucG9wKCk7c3JjUGF0aD1zcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtyZXN1bHQuc2VhcmNoPXJlbGF0aXZlLnNlYXJjaDtyZXN1bHQucXVlcnk9cmVsYXRpdmUucXVlcnk7fWVsc2UgaWYoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSl7Ly8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuLy8gbGlrZSBocmVmPSc/Zm9vJy5cbi8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuaWYocHN5Y2hvdGljKXtyZXN1bHQuaG9zdG5hbWU9cmVzdWx0Lmhvc3Q9c3JjUGF0aC5zaGlmdCgpOy8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3Rcbi8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbnZhciBhdXRoSW5Ib3N0PXJlc3VsdC5ob3N0JiZyZXN1bHQuaG9zdC5pbmRleE9mKCdAJyk+MD9yZXN1bHQuaG9zdC5zcGxpdCgnQCcpOmZhbHNlO2lmKGF1dGhJbkhvc3Qpe3Jlc3VsdC5hdXRoPWF1dGhJbkhvc3Quc2hpZnQoKTtyZXN1bHQuaG9zdD1yZXN1bHQuaG9zdG5hbWU9YXV0aEluSG9zdC5zaGlmdCgpO319cmVzdWx0LnNlYXJjaD1yZWxhdGl2ZS5zZWFyY2g7cmVzdWx0LnF1ZXJ5PXJlbGF0aXZlLnF1ZXJ5Oy8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbmlmKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpfHwhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpe3Jlc3VsdC5wYXRoPShyZXN1bHQucGF0aG5hbWU/cmVzdWx0LnBhdGhuYW1lOicnKSsocmVzdWx0LnNlYXJjaD9yZXN1bHQuc2VhcmNoOicnKTt9cmVzdWx0LmhyZWY9cmVzdWx0LmZvcm1hdCgpO3JldHVybiByZXN1bHQ7fWlmKCFzcmNQYXRoLmxlbmd0aCl7Ly8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbnJlc3VsdC5wYXRobmFtZT1udWxsOy8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbmlmKHJlc3VsdC5zZWFyY2gpe3Jlc3VsdC5wYXRoPScvJytyZXN1bHQuc2VhcmNoO31lbHNle3Jlc3VsdC5wYXRoPW51bGw7fXJlc3VsdC5ocmVmPXJlc3VsdC5mb3JtYXQoKTtyZXR1cm4gcmVzdWx0O30vLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbi8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbnZhciBsYXN0PXNyY1BhdGguc2xpY2UoLTEpWzBdO3ZhciBoYXNUcmFpbGluZ1NsYXNoPShyZXN1bHQuaG9zdHx8cmVsYXRpdmUuaG9zdHx8c3JjUGF0aC5sZW5ndGg+MSkmJihsYXN0PT09Jy4nfHxsYXN0PT09Jy4uJyl8fGxhc3Q9PT0nJzsvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4vLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxudmFyIHVwPTA7Zm9yKHZhciBpPXNyY1BhdGgubGVuZ3RoO2k+PTA7aS0tKXtsYXN0PXNyY1BhdGhbaV07aWYobGFzdD09PScuJyl7c3JjUGF0aC5zcGxpY2UoaSwxKTt9ZWxzZSBpZihsYXN0PT09Jy4uJyl7c3JjUGF0aC5zcGxpY2UoaSwxKTt1cCsrO31lbHNlIGlmKHVwKXtzcmNQYXRoLnNwbGljZShpLDEpO3VwLS07fX0vLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG5pZighbXVzdEVuZEFicyYmIXJlbW92ZUFsbERvdHMpe2Zvcig7dXAtLTt1cCl7c3JjUGF0aC51bnNoaWZ0KCcuLicpO319aWYobXVzdEVuZEFicyYmc3JjUGF0aFswXSE9PScnJiYoIXNyY1BhdGhbMF18fHNyY1BhdGhbMF0uY2hhckF0KDApIT09Jy8nKSl7c3JjUGF0aC51bnNoaWZ0KCcnKTt9aWYoaGFzVHJhaWxpbmdTbGFzaCYmc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSE9PScvJyl7c3JjUGF0aC5wdXNoKCcnKTt9dmFyIGlzQWJzb2x1dGU9c3JjUGF0aFswXT09PScnfHxzcmNQYXRoWzBdJiZzcmNQYXRoWzBdLmNoYXJBdCgwKT09PScvJzsvLyBwdXQgdGhlIGhvc3QgYmFja1xuaWYocHN5Y2hvdGljKXtyZXN1bHQuaG9zdG5hbWU9cmVzdWx0Lmhvc3Q9aXNBYnNvbHV0ZT8nJzpzcmNQYXRoLmxlbmd0aD9zcmNQYXRoLnNoaWZ0KCk6Jyc7Ly9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4vL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxudmFyIGF1dGhJbkhvc3Q9cmVzdWx0Lmhvc3QmJnJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKT4wP3Jlc3VsdC5ob3N0LnNwbGl0KCdAJyk6ZmFsc2U7aWYoYXV0aEluSG9zdCl7cmVzdWx0LmF1dGg9YXV0aEluSG9zdC5zaGlmdCgpO3Jlc3VsdC5ob3N0PXJlc3VsdC5ob3N0bmFtZT1hdXRoSW5Ib3N0LnNoaWZ0KCk7fX1tdXN0RW5kQWJzPW11c3RFbmRBYnN8fHJlc3VsdC5ob3N0JiZzcmNQYXRoLmxlbmd0aDtpZihtdXN0RW5kQWJzJiYhaXNBYnNvbHV0ZSl7c3JjUGF0aC51bnNoaWZ0KCcnKTt9aWYoIXNyY1BhdGgubGVuZ3RoKXtyZXN1bHQucGF0aG5hbWU9bnVsbDtyZXN1bHQucGF0aD1udWxsO31lbHNle3Jlc3VsdC5wYXRobmFtZT1zcmNQYXRoLmpvaW4oJy8nKTt9Ly90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuaWYoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSl8fCF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSl7cmVzdWx0LnBhdGg9KHJlc3VsdC5wYXRobmFtZT9yZXN1bHQucGF0aG5hbWU6JycpKyhyZXN1bHQuc2VhcmNoP3Jlc3VsdC5zZWFyY2g6JycpO31yZXN1bHQuYXV0aD1yZWxhdGl2ZS5hdXRofHxyZXN1bHQuYXV0aDtyZXN1bHQuc2xhc2hlcz1yZXN1bHQuc2xhc2hlc3x8cmVsYXRpdmUuc2xhc2hlcztyZXN1bHQuaHJlZj1yZXN1bHQuZm9ybWF0KCk7cmV0dXJuIHJlc3VsdDt9O1VybC5wcm90b3R5cGUucGFyc2VIb3N0PWZ1bmN0aW9uKCl7dmFyIGhvc3Q9dGhpcy5ob3N0O3ZhciBwb3J0PXBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7aWYocG9ydCl7cG9ydD1wb3J0WzBdO2lmKHBvcnQhPT0nOicpe3RoaXMucG9ydD1wb3J0LnN1YnN0cigxKTt9aG9zdD1ob3N0LnN1YnN0cigwLGhvc3QubGVuZ3RoLXBvcnQubGVuZ3RoKTt9aWYoaG9zdCl0aGlzLmhvc3RuYW1lPWhvc3Q7fTt9LHtcIi4vdXRpbFwiOjIxMCxcInB1bnljb2RlXCI6MTkzLFwicXVlcnlzdHJpbmdcIjoxOTZ9XSwyMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyd1c2Ugc3RyaWN0Jzttb2R1bGUuZXhwb3J0cz17aXNTdHJpbmc6ZnVuY3Rpb24gaXNTdHJpbmcoYXJnKXtyZXR1cm4gdHlwZW9mIGFyZz09PSdzdHJpbmcnO30saXNPYmplY3Q6ZnVuY3Rpb24gaXNPYmplY3QoYXJnKXtyZXR1cm4gX3R5cGVvZihhcmcpPT09J29iamVjdCcmJmFyZyE9PW51bGw7fSxpc051bGw6ZnVuY3Rpb24gaXNOdWxsKGFyZyl7cmV0dXJuIGFyZz09PW51bGw7fSxpc051bGxPclVuZGVmaW5lZDpmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpe3JldHVybiBhcmc9PW51bGw7fX07fSx7fV0sMjExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiBlc2xpbnQtZGlzYWJsZSBuby11c2VsZXNzLWVzY2FwZSAqL3ZhciBodG1scGFyc2VyPXJlcXVpcmUoJ2h0bWxwYXJzZXIyJyk7dmFyIHF1b3RlUmVnZXhwPXJlcXVpcmUoJ2xvZGFzaC9lc2NhcGVSZWdFeHAnKTt2YXIgY2xvbmVEZWVwPXJlcXVpcmUoJ2xvZGFzaC9jbG9uZURlZXAnKTt2YXIgbWVyZ2VXaXRoPXJlcXVpcmUoJ2xvZGFzaC9tZXJnZVdpdGgnKTt2YXIgaXNTdHJpbmc9cmVxdWlyZSgnbG9kYXNoL2lzU3RyaW5nJyk7dmFyIGlzUGxhaW5PYmplY3Q9cmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTt2YXIgc3Jjc2V0PXJlcXVpcmUoJ3NyY3NldCcpO3ZhciBwb3N0Y3NzPXJlcXVpcmUoJ3Bvc3Rjc3MnKTt2YXIgdXJsPXJlcXVpcmUoJ3VybCcpOy8vIFRhZ3MgdGhhdCBjYW4gY29uY2VpdmFibHkgcmVwcmVzZW50IHN0YW5kLWFsb25lIG1lZGlhLlxudmFyIG1lZGlhVGFncz1bJ2ltZycsJ2F1ZGlvJywndmlkZW8nLCdwaWN0dXJlJywnc3ZnJywnb2JqZWN0JywnbWFwJywnaWZyYW1lJywnZW1iZWQnXTsvLyBUYWdzIHRoYXQgYXJlIGluaGVyZW50bHkgdnVsbmVyYWJsZSB0byBiZWluZyB1c2VkIGluIFhTUyBhdHRhY2tzLlxudmFyIHZ1bG5lcmFibGVUYWdzPVsnc2NyaXB0Jywnc3R5bGUnXTtmdW5jdGlvbiBlYWNoKG9iaixjYil7aWYob2JqKXtPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24oa2V5KXtjYihvYmpba2V5XSxrZXkpO30pO319Ly8gQXZvaWQgZmFsc2UgcG9zaXRpdmVzIHdpdGggLl9fcHJvdG9fXywgLmhhc093blByb3BlcnR5LCBldGMuXG5mdW5jdGlvbiBoYXMob2JqLGtleSl7cmV0dXJue30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KTt9Ly8gUmV0dXJucyB0aG9zZSBlbGVtZW50cyBvZiBgYWAgZm9yIHdoaWNoIGBjYihhKWAgcmV0dXJucyB0cnV0aHlcbmZ1bmN0aW9uIGZpbHRlcihhLGNiKXt2YXIgbj1bXTtlYWNoKGEsZnVuY3Rpb24odil7aWYoY2Iodikpe24ucHVzaCh2KTt9fSk7cmV0dXJuIG47fWZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqKXtmb3IodmFyIGtleSBpbiBvYmope2lmKGhhcyhvYmosa2V5KSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fW1vZHVsZS5leHBvcnRzPXNhbml0aXplSHRtbDsvLyBBIHZhbGlkIGF0dHJpYnV0ZSBuYW1lLlxuLy8gV2UgdXNlIGEgdG9sZXJhbnQgZGVmaW5pdGlvbiBiYXNlZCBvbiB0aGUgc2V0IG9mIHN0cmluZ3MgZGVmaW5lZCBieVxuLy8gaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNiZWZvcmUtYXR0cmlidXRlLW5hbWUtc3RhdGVcbi8vIGFuZCBodG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI2F0dHJpYnV0ZS1uYW1lLXN0YXRlIC5cbi8vIFRoZSBjaGFyYWN0ZXJzIGFjY2VwdGVkIGFyZSBvbmVzIHdoaWNoIGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgYXR0cmlidXRlXG4vLyBuYW1lIGJ1ZmZlciB3aXRob3V0IHRyaWdnZXJpbmcgYSBwYXJzZSBlcnJvcjpcbi8vICAgKiB1bmV4cGVjdGVkLWVxdWFscy1zaWduLWJlZm9yZS1hdHRyaWJ1dGUtbmFtZVxuLy8gICAqIHVuZXhwZWN0ZWQtbnVsbC1jaGFyYWN0ZXJcbi8vICAgKiB1bmV4cGVjdGVkLWNoYXJhY3Rlci1pbi1hdHRyaWJ1dGUtbmFtZVxuLy8gV2UgZXhjbHVkZSB0aGUgZW1wdHkgc3RyaW5nIGJlY2F1c2UgaXQncyBpbXBvc3NpYmxlIHRvIGdldCB0byB0aGUgYWZ0ZXJcbi8vIGF0dHJpYnV0ZSBuYW1lIHN0YXRlIHdpdGggYW4gZW1wdHkgYXR0cmlidXRlIG5hbWUgYnVmZmVyLlxudmFyIFZBTElEX0hUTUxfQVRUUklCVVRFX05BTUU9L15bXlxcMFxcdFxcblxcZlxcciAvPD0+XSskLzsvLyBJZ25vcmUgdGhlIF9yZWN1cnNpbmcgZmxhZzsgaXQncyB0aGVyZSBmb3IgcmVjdXJzaXZlXG4vLyBpbnZvY2F0aW9uIGFzIGEgZ3VhcmQgYWdhaW5zdCB0aGlzIGV4cGxvaXQ6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmI1NS9odG1scGFyc2VyMi9pc3N1ZXMvMTA1XG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwoaHRtbCxvcHRpb25zLF9yZWN1cnNpbmcpe3ZhciByZXN1bHQ9Jyc7Ly8gVXNlZCBmb3IgaG90IHN3YXBwaW5nIHRoZSByZXN1bHQgdmFyaWFibGUgd2l0aCBhbiBlbXB0eSBzdHJpbmcgaW4gb3JkZXIgdG8gXCJjYXB0dXJlXCIgdGhlIHRleHQgd3JpdHRlbiB0byBpdC5cbnZhciB0ZW1wUmVzdWx0PScnO2Z1bmN0aW9uIEZyYW1lKHRhZyxhdHRyaWJzKXt2YXIgdGhhdD10aGlzO3RoaXMudGFnPXRhZzt0aGlzLmF0dHJpYnM9YXR0cmlic3x8e307dGhpcy50YWdQb3NpdGlvbj1yZXN1bHQubGVuZ3RoO3RoaXMudGV4dD0nJzsvLyBOb2RlIGlubmVyIHRleHRcbnRoaXMubWVkaWFDaGlsZHJlbj1bXTt0aGlzLnVwZGF0ZVBhcmVudE5vZGVUZXh0PWZ1bmN0aW9uKCl7aWYoc3RhY2subGVuZ3RoKXt2YXIgcGFyZW50RnJhbWU9c3RhY2tbc3RhY2subGVuZ3RoLTFdO3BhcmVudEZyYW1lLnRleHQrPXRoYXQudGV4dDt9fTt0aGlzLnVwZGF0ZVBhcmVudE5vZGVNZWRpYUNoaWxkcmVuPWZ1bmN0aW9uKCl7aWYoc3RhY2subGVuZ3RoJiZtZWRpYVRhZ3MuaW5jbHVkZXModGhpcy50YWcpKXt2YXIgcGFyZW50RnJhbWU9c3RhY2tbc3RhY2subGVuZ3RoLTFdO3BhcmVudEZyYW1lLm1lZGlhQ2hpbGRyZW4ucHVzaCh0aGlzLnRhZyk7fX07fWlmKCFvcHRpb25zKXtvcHRpb25zPXNhbml0aXplSHRtbC5kZWZhdWx0cztvcHRpb25zLnBhcnNlcj1odG1sUGFyc2VyRGVmYXVsdHM7fWVsc2V7b3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LHNhbml0aXplSHRtbC5kZWZhdWx0cyxvcHRpb25zKTtpZihvcHRpb25zLnBhcnNlcil7b3B0aW9ucy5wYXJzZXI9T2JqZWN0LmFzc2lnbih7fSxodG1sUGFyc2VyRGVmYXVsdHMsb3B0aW9ucy5wYXJzZXIpO31lbHNle29wdGlvbnMucGFyc2VyPWh0bWxQYXJzZXJEZWZhdWx0czt9fS8vIHZ1bG5lcmFibGVUYWdzXG52dWxuZXJhYmxlVGFncy5mb3JFYWNoKGZ1bmN0aW9uKHRhZyl7aWYob3B0aW9ucy5hbGxvd2VkVGFncyYmb3B0aW9ucy5hbGxvd2VkVGFncy5pbmNsdWRlcyh0YWcpJiYhb3B0aW9ucy5hbGxvd1Z1bG5lcmFibGVUYWdzKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuY29uc29sZS53YXJuKFwiXFxuXFxuXFx1MjZBMFxcdUZFMEYgWW91ciBgYWxsb3dlZFRhZ3NgIG9wdGlvbiBpbmNsdWRlcywgYFwiLmNvbmNhdCh0YWcsXCJgLCB3aGljaCBpcyBpbmhlcmVudGx5XFxudnVsbmVyYWJsZSB0byBYU1MgYXR0YWNrcy4gUGxlYXNlIHJlbW92ZSBpdCBmcm9tIGBhbGxvd2VkVGFnc2AuXFxuT3IsIHRvIGRpc2FibGUgdGhpcyB3YXJuaW5nLCBhZGQgdGhlIGBhbGxvd1Z1bG5lcmFibGVUYWdzYCBvcHRpb25cXG5hbmQgZW5zdXJlIHlvdSBhcmUgYWNjb3VudGluZyBmb3IgdGhpcyByaXNrLlxcblxcblwiKSk7fX0pOy8vIFRhZ3MgdGhhdCBjb250YWluIHNvbWV0aGluZyBvdGhlciB0aGFuIEhUTUwsIG9yIHdoZXJlIGRpc2NhcmRpbmdcbi8vIHRoZSB0ZXh0IHdoZW4gdGhlIHRhZyBpcyBkaXNhbGxvd2VkIG1ha2VzIHNlbnNlIGZvciBvdGhlciByZWFzb25zLlxuLy8gSWYgd2UgYXJlIG5vdCBhbGxvd2luZyB0aGVzZSB0YWdzLCB3ZSBzaG91bGQgZHJvcCB0aGVpciBjb250ZW50IHRvby5cbi8vIEZvciBvdGhlciB0YWdzIHlvdSB3b3VsZCBkcm9wIHRoZSB0YWcgYnV0IGtlZXAgaXRzIGNvbnRlbnQuXG52YXIgbm9uVGV4dFRhZ3NBcnJheT1vcHRpb25zLm5vblRleHRUYWdzfHxbJ3NjcmlwdCcsJ3N0eWxlJywndGV4dGFyZWEnLCdvcHRpb24nXTt2YXIgYWxsb3dlZEF0dHJpYnV0ZXNNYXA7dmFyIGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcDtpZihvcHRpb25zLmFsbG93ZWRBdHRyaWJ1dGVzKXthbGxvd2VkQXR0cmlidXRlc01hcD17fTthbGxvd2VkQXR0cmlidXRlc0dsb2JNYXA9e307ZWFjaChvcHRpb25zLmFsbG93ZWRBdHRyaWJ1dGVzLGZ1bmN0aW9uKGF0dHJpYnV0ZXMsdGFnKXthbGxvd2VkQXR0cmlidXRlc01hcFt0YWddPVtdO3ZhciBnbG9iUmVnZXg9W107YXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iail7aWYoaXNTdHJpbmcob2JqKSYmb2JqLmluZGV4T2YoJyonKT49MCl7Z2xvYlJlZ2V4LnB1c2gocXVvdGVSZWdleHAob2JqKS5yZXBsYWNlKC9cXFxcXFwqL2csJy4qJykpO31lbHNle2FsbG93ZWRBdHRyaWJ1dGVzTWFwW3RhZ10ucHVzaChvYmopO319KTthbGxvd2VkQXR0cmlidXRlc0dsb2JNYXBbdGFnXT1uZXcgUmVnRXhwKCdeKCcrZ2xvYlJlZ2V4LmpvaW4oJ3wnKSsnKSQnKTt9KTt9dmFyIGFsbG93ZWRDbGFzc2VzTWFwPXt9O2VhY2gob3B0aW9ucy5hbGxvd2VkQ2xhc3NlcyxmdW5jdGlvbihjbGFzc2VzLHRhZyl7Ly8gSW1wbGljaXRseSBhbGxvd3MgdGhlIGNsYXNzIGF0dHJpYnV0ZVxuaWYoYWxsb3dlZEF0dHJpYnV0ZXNNYXApe2lmKCFoYXMoYWxsb3dlZEF0dHJpYnV0ZXNNYXAsdGFnKSl7YWxsb3dlZEF0dHJpYnV0ZXNNYXBbdGFnXT1bXTt9YWxsb3dlZEF0dHJpYnV0ZXNNYXBbdGFnXS5wdXNoKCdjbGFzcycpO31hbGxvd2VkQ2xhc3Nlc01hcFt0YWddPWNsYXNzZXM7fSk7dmFyIHRyYW5zZm9ybVRhZ3NNYXA9e307dmFyIHRyYW5zZm9ybVRhZ3NBbGw7ZWFjaChvcHRpb25zLnRyYW5zZm9ybVRhZ3MsZnVuY3Rpb24odHJhbnNmb3JtLHRhZyl7dmFyIHRyYW5zRnVuO2lmKHR5cGVvZiB0cmFuc2Zvcm09PT0nZnVuY3Rpb24nKXt0cmFuc0Z1bj10cmFuc2Zvcm07fWVsc2UgaWYodHlwZW9mIHRyYW5zZm9ybT09PVwic3RyaW5nXCIpe3RyYW5zRnVuPXNhbml0aXplSHRtbC5zaW1wbGVUcmFuc2Zvcm0odHJhbnNmb3JtKTt9aWYodGFnPT09JyonKXt0cmFuc2Zvcm1UYWdzQWxsPXRyYW5zRnVuO31lbHNle3RyYW5zZm9ybVRhZ3NNYXBbdGFnXT10cmFuc0Z1bjt9fSk7dmFyIGRlcHRoO3ZhciBzdGFjazt2YXIgc2tpcE1hcDt2YXIgdHJhbnNmb3JtTWFwO3ZhciBza2lwVGV4dDt2YXIgc2tpcFRleHREZXB0aDtpbml0aWFsaXplU3RhdGUoKTt2YXIgcGFyc2VyPW5ldyBodG1scGFyc2VyLlBhcnNlcih7b25vcGVudGFnOmZ1bmN0aW9uIG9ub3BlbnRhZyhuYW1lLGF0dHJpYnMpey8vIElmIGBlbmZvcmNlSHRtbEJvdW5kYXJ5YCBpcyBgdHJ1ZWAgYW5kIHRoaXMgaGFzIGZvdW5kIHRoZSBvcGVuaW5nXG4vLyBgaHRtbGAgdGFnLCByZXNldCB0aGUgc3RhdGUuXG5pZihvcHRpb25zLmVuZm9yY2VIdG1sQm91bmRhcnkmJm5hbWU9PT0naHRtbCcpe2luaXRpYWxpemVTdGF0ZSgpO31pZihza2lwVGV4dCl7c2tpcFRleHREZXB0aCsrO3JldHVybjt9dmFyIGZyYW1lPW5ldyBGcmFtZShuYW1lLGF0dHJpYnMpO3N0YWNrLnB1c2goZnJhbWUpO3ZhciBza2lwPWZhbHNlO3ZhciBoYXNUZXh0PSEhZnJhbWUudGV4dDt2YXIgdHJhbnNmb3JtZWRUYWc7aWYoaGFzKHRyYW5zZm9ybVRhZ3NNYXAsbmFtZSkpe3RyYW5zZm9ybWVkVGFnPXRyYW5zZm9ybVRhZ3NNYXBbbmFtZV0obmFtZSxhdHRyaWJzKTtmcmFtZS5hdHRyaWJzPWF0dHJpYnM9dHJhbnNmb3JtZWRUYWcuYXR0cmlicztpZih0cmFuc2Zvcm1lZFRhZy50ZXh0IT09dW5kZWZpbmVkKXtmcmFtZS5pbm5lclRleHQ9dHJhbnNmb3JtZWRUYWcudGV4dDt9aWYobmFtZSE9PXRyYW5zZm9ybWVkVGFnLnRhZ05hbWUpe2ZyYW1lLm5hbWU9bmFtZT10cmFuc2Zvcm1lZFRhZy50YWdOYW1lO3RyYW5zZm9ybU1hcFtkZXB0aF09dHJhbnNmb3JtZWRUYWcudGFnTmFtZTt9fWlmKHRyYW5zZm9ybVRhZ3NBbGwpe3RyYW5zZm9ybWVkVGFnPXRyYW5zZm9ybVRhZ3NBbGwobmFtZSxhdHRyaWJzKTtmcmFtZS5hdHRyaWJzPWF0dHJpYnM9dHJhbnNmb3JtZWRUYWcuYXR0cmlicztpZihuYW1lIT09dHJhbnNmb3JtZWRUYWcudGFnTmFtZSl7ZnJhbWUubmFtZT1uYW1lPXRyYW5zZm9ybWVkVGFnLnRhZ05hbWU7dHJhbnNmb3JtTWFwW2RlcHRoXT10cmFuc2Zvcm1lZFRhZy50YWdOYW1lO319aWYob3B0aW9ucy5hbGxvd2VkVGFncyYmb3B0aW9ucy5hbGxvd2VkVGFncy5pbmRleE9mKG5hbWUpPT09LTF8fG9wdGlvbnMuZGlzYWxsb3dlZFRhZ3NNb2RlPT09J3JlY3Vyc2l2ZUVzY2FwZScmJiFpc0VtcHR5T2JqZWN0KHNraXBNYXApKXtza2lwPXRydWU7c2tpcE1hcFtkZXB0aF09dHJ1ZTtpZihvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZT09PSdkaXNjYXJkJyl7aWYobm9uVGV4dFRhZ3NBcnJheS5pbmRleE9mKG5hbWUpIT09LTEpe3NraXBUZXh0PXRydWU7c2tpcFRleHREZXB0aD0xO319c2tpcE1hcFtkZXB0aF09dHJ1ZTt9ZGVwdGgrKztpZihza2lwKXtpZihvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZT09PSdkaXNjYXJkJyl7Ly8gV2Ugd2FudCB0aGUgY29udGVudHMgYnV0IG5vdCB0aGlzIHRhZ1xucmV0dXJuO310ZW1wUmVzdWx0PXJlc3VsdDtyZXN1bHQ9Jyc7fXJlc3VsdCs9JzwnK25hbWU7aWYoIWFsbG93ZWRBdHRyaWJ1dGVzTWFwfHxoYXMoYWxsb3dlZEF0dHJpYnV0ZXNNYXAsbmFtZSl8fGFsbG93ZWRBdHRyaWJ1dGVzTWFwWycqJ10pe2VhY2goYXR0cmlicyxmdW5jdGlvbih2YWx1ZSxhKXtpZighVkFMSURfSFRNTF9BVFRSSUJVVEVfTkFNRS50ZXN0KGEpKXsvLyBUaGlzIHByZXZlbnRzIHBhcnQgb2YgYW4gYXR0cmlidXRlIG5hbWUgaW4gdGhlIG91dHB1dCBmcm9tIGJlaW5nXG4vLyBpbnRlcnByZXRlZCBhcyB0aGUgZW5kIG9mIGFuIGF0dHJpYnV0ZSwgb3IgZW5kIG9mIGEgdGFnLlxuZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07cmV0dXJuO312YXIgcGFyc2VkOy8vIGNoZWNrIGFsbG93ZWRBdHRyaWJ1dGVzTWFwIGZvciB0aGUgZWxlbWVudCBhbmQgYXR0cmlidXRlIGFuZCBtb2RpZnkgdGhlIHZhbHVlXG4vLyBhcyBuZWNlc3NhcnkgaWYgdGhlcmUgYXJlIHNwZWNpZmljIHZhbHVlcyBkZWZpbmVkLlxudmFyIHBhc3NlZEFsbG93ZWRBdHRyaWJ1dGVzTWFwQ2hlY2s9ZmFsc2U7aWYoIWFsbG93ZWRBdHRyaWJ1dGVzTWFwfHxoYXMoYWxsb3dlZEF0dHJpYnV0ZXNNYXAsbmFtZSkmJmFsbG93ZWRBdHRyaWJ1dGVzTWFwW25hbWVdLmluZGV4T2YoYSkhPT0tMXx8YWxsb3dlZEF0dHJpYnV0ZXNNYXBbJyonXSYmYWxsb3dlZEF0dHJpYnV0ZXNNYXBbJyonXS5pbmRleE9mKGEpIT09LTF8fGhhcyhhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXAsbmFtZSkmJmFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcFtuYW1lXS50ZXN0KGEpfHxhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXBbJyonXSYmYWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwWycqJ10udGVzdChhKSl7cGFzc2VkQWxsb3dlZEF0dHJpYnV0ZXNNYXBDaGVjaz10cnVlO31lbHNlIGlmKGFsbG93ZWRBdHRyaWJ1dGVzTWFwJiZhbGxvd2VkQXR0cmlidXRlc01hcFtuYW1lXSl7dmFyIF9pdGVyYXRvcjEwPV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGFsbG93ZWRBdHRyaWJ1dGVzTWFwW25hbWVdKSxfc3RlcDt0cnl7Zm9yKF9pdGVyYXRvcjEwLnMoKTshKF9zdGVwPV9pdGVyYXRvcjEwLm4oKSkuZG9uZTspe3ZhciBvPV9zdGVwLnZhbHVlO2lmKGlzUGxhaW5PYmplY3QobykmJm8ubmFtZSYmby5uYW1lPT09YSl7cGFzc2VkQWxsb3dlZEF0dHJpYnV0ZXNNYXBDaGVjaz10cnVlO3ZhciBuZXdWYWx1ZT0nJztpZihvLm11bHRpcGxlPT09dHJ1ZSl7Ly8gdmVyaWZ5IHRoZSB2YWx1ZXMgdGhhdCBhcmUgYWxsb3dlZFxudmFyIHNwbGl0U3RyQXJyYXk9dmFsdWUuc3BsaXQoJyAnKTt2YXIgX2l0ZXJhdG9yMTE9X2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3BsaXRTdHJBcnJheSksX3N0ZXAyO3RyeXtmb3IoX2l0ZXJhdG9yMTEucygpOyEoX3N0ZXAyPV9pdGVyYXRvcjExLm4oKSkuZG9uZTspe3ZhciBzPV9zdGVwMi52YWx1ZTtpZihvLnZhbHVlcy5pbmRleE9mKHMpIT09LTEpe2lmKG5ld1ZhbHVlPT09Jycpe25ld1ZhbHVlPXM7fWVsc2V7bmV3VmFsdWUrPScgJytzO319fX1jYXRjaChlcnIpe19pdGVyYXRvcjExLmUoZXJyKTt9ZmluYWxseXtfaXRlcmF0b3IxMS5mKCk7fX1lbHNlIGlmKG8udmFsdWVzLmluZGV4T2YodmFsdWUpPj0wKXsvLyB2ZXJpZmllZCBhbiBhbGxvd2VkIHZhbHVlIG1hdGNoZXMgdGhlIGVudGlyZSBhdHRyaWJ1dGUgdmFsdWVcbm5ld1ZhbHVlPXZhbHVlO312YWx1ZT1uZXdWYWx1ZTt9fX1jYXRjaChlcnIpe19pdGVyYXRvcjEwLmUoZXJyKTt9ZmluYWxseXtfaXRlcmF0b3IxMC5mKCk7fX1pZihwYXNzZWRBbGxvd2VkQXR0cmlidXRlc01hcENoZWNrKXtpZihvcHRpb25zLmFsbG93ZWRTY2hlbWVzQXBwbGllZFRvQXR0cmlidXRlcy5pbmRleE9mKGEpIT09LTEpe2lmKG5hdWdodHlIcmVmKG5hbWUsdmFsdWUpKXtkZWxldGUgZnJhbWUuYXR0cmlic1thXTtyZXR1cm47fX1pZihuYW1lPT09J2lmcmFtZScmJmE9PT0nc3JjJyl7dmFyIGFsbG93ZWQ9dHJ1ZTt0cnl7Ly8gbmF1Z2h0eUhyZWYgaXMgaW4gY2hhcmdlIG9mIHdoZXRoZXIgcHJvdG9jb2wgcmVsYXRpdmUgVVJMc1xuLy8gYXJlIGNvb2wuIFdlIHNob3VsZCBqdXN0IGFjY2VwdCB0aGVtXG5wYXJzZWQ9dXJsLnBhcnNlKHZhbHVlLGZhbHNlLHRydWUpO3ZhciBpc1JlbGF0aXZlVXJsPXBhcnNlZCYmcGFyc2VkLmhvc3Q9PT1udWxsJiZwYXJzZWQucHJvdG9jb2w9PT1udWxsO2lmKGlzUmVsYXRpdmVVcmwpey8vIGRlZmF1bHQgdmFsdWUgb2YgYWxsb3dJZnJhbWVSZWxhdGl2ZVVybHMgaXMgdHJ1ZVxuLy8gdW5sZXNzIGFsbG93ZWRJZnJhbWVIb3N0bmFtZXMgb3IgYWxsb3dlZElmcmFtZURvbWFpbnMgc3BlY2lmaWVkXG5hbGxvd2VkPWhhcyhvcHRpb25zLFwiYWxsb3dJZnJhbWVSZWxhdGl2ZVVybHNcIik/b3B0aW9ucy5hbGxvd0lmcmFtZVJlbGF0aXZlVXJsczohb3B0aW9ucy5hbGxvd2VkSWZyYW1lSG9zdG5hbWVzJiYhb3B0aW9ucy5hbGxvd2VkSWZyYW1lRG9tYWluczt9ZWxzZSBpZihvcHRpb25zLmFsbG93ZWRJZnJhbWVIb3N0bmFtZXN8fG9wdGlvbnMuYWxsb3dlZElmcmFtZURvbWFpbnMpe3ZhciBhbGxvd2VkSG9zdG5hbWU9KG9wdGlvbnMuYWxsb3dlZElmcmFtZUhvc3RuYW1lc3x8W10pLmZpbmQoZnVuY3Rpb24oaG9zdG5hbWUpe3JldHVybiBob3N0bmFtZT09PXBhcnNlZC5ob3N0bmFtZTt9KTt2YXIgYWxsb3dlZERvbWFpbj0ob3B0aW9ucy5hbGxvd2VkSWZyYW1lRG9tYWluc3x8W10pLmZpbmQoZnVuY3Rpb24oZG9tYWluKXtyZXR1cm4gcGFyc2VkLmhvc3RuYW1lPT09ZG9tYWlufHxwYXJzZWQuaG9zdG5hbWUuZW5kc1dpdGgoXCIuXCIuY29uY2F0KGRvbWFpbikpO30pO2FsbG93ZWQ9YWxsb3dlZEhvc3RuYW1lfHxhbGxvd2VkRG9tYWluO319Y2F0Y2goZSl7Ly8gVW5wYXJzZWFibGUgaWZyYW1lIHNyY1xuYWxsb3dlZD1mYWxzZTt9aWYoIWFsbG93ZWQpe2RlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO3JldHVybjt9fWlmKGE9PT0nc3Jjc2V0Jyl7dHJ5e3BhcnNlZD1zcmNzZXQucGFyc2UodmFsdWUpO2VhY2gocGFyc2VkLGZ1bmN0aW9uKHZhbHVlKXtpZihuYXVnaHR5SHJlZignc3Jjc2V0Jyx2YWx1ZS51cmwpKXt2YWx1ZS5ldmlsPXRydWU7fX0pO3BhcnNlZD1maWx0ZXIocGFyc2VkLGZ1bmN0aW9uKHYpe3JldHVybiF2LmV2aWw7fSk7aWYoIXBhcnNlZC5sZW5ndGgpe2RlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO3JldHVybjt9ZWxzZXt2YWx1ZT1zcmNzZXQuc3RyaW5naWZ5KGZpbHRlcihwYXJzZWQsZnVuY3Rpb24odil7cmV0dXJuIXYuZXZpbDt9KSk7ZnJhbWUuYXR0cmlic1thXT12YWx1ZTt9fWNhdGNoKGUpey8vIFVucGFyc2VhYmxlIHNyY3NldFxuZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07cmV0dXJuO319aWYoYT09PSdjbGFzcycpe3ZhbHVlPWZpbHRlckNsYXNzZXModmFsdWUsYWxsb3dlZENsYXNzZXNNYXBbbmFtZV0pO2lmKCF2YWx1ZS5sZW5ndGgpe2RlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO3JldHVybjt9fWlmKGE9PT0nc3R5bGUnKXt0cnl7dmFyIGFic3RyYWN0U3ludGF4VHJlZT1wb3N0Y3NzLnBhcnNlKG5hbWUrXCIge1wiK3ZhbHVlK1wifVwiKTt2YXIgZmlsdGVyZWRBU1Q9ZmlsdGVyQ3NzKGFic3RyYWN0U3ludGF4VHJlZSxvcHRpb25zLmFsbG93ZWRTdHlsZXMpO3ZhbHVlPXN0cmluZ2lmeVN0eWxlQXR0cmlidXRlcyhmaWx0ZXJlZEFTVCk7aWYodmFsdWUubGVuZ3RoPT09MCl7ZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07cmV0dXJuO319Y2F0Y2goZSl7ZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07cmV0dXJuO319cmVzdWx0Kz0nICcrYTtpZih2YWx1ZSYmdmFsdWUubGVuZ3RoKXtyZXN1bHQrPSc9XCInK2VzY2FwZUh0bWwodmFsdWUsdHJ1ZSkrJ1wiJzt9fWVsc2V7ZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07fX0pO31pZihvcHRpb25zLnNlbGZDbG9zaW5nLmluZGV4T2YobmFtZSkhPT0tMSl7cmVzdWx0Kz1cIiAvPlwiO31lbHNle3Jlc3VsdCs9XCI+XCI7aWYoZnJhbWUuaW5uZXJUZXh0JiYhaGFzVGV4dCYmIW9wdGlvbnMudGV4dEZpbHRlcil7cmVzdWx0Kz1mcmFtZS5pbm5lclRleHQ7fX1pZihza2lwKXtyZXN1bHQ9dGVtcFJlc3VsdCtlc2NhcGVIdG1sKHJlc3VsdCk7dGVtcFJlc3VsdD0nJzt9fSxvbnRleHQ6ZnVuY3Rpb24gb250ZXh0KHRleHQpe2lmKHNraXBUZXh0KXtyZXR1cm47fXZhciBsYXN0RnJhbWU9c3RhY2tbc3RhY2subGVuZ3RoLTFdO3ZhciB0YWc7aWYobGFzdEZyYW1lKXt0YWc9bGFzdEZyYW1lLnRhZzsvLyBJZiBpbm5lciB0ZXh0IHdhcyBzZXQgYnkgdHJhbnNmb3JtIGZ1bmN0aW9uIHRoZW4gbGV0J3MgdXNlIGl0XG50ZXh0PWxhc3RGcmFtZS5pbm5lclRleHQhPT11bmRlZmluZWQ/bGFzdEZyYW1lLmlubmVyVGV4dDp0ZXh0O31pZihvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZT09PSdkaXNjYXJkJyYmKHRhZz09PSdzY3JpcHQnfHx0YWc9PT0nc3R5bGUnKSl7Ly8gaHRtbHBhcnNlcjIgZ2l2ZXMgdXMgdGhlc2UgYXMtaXMuIEVzY2FwaW5nIHRoZW0gcnVpbnMgdGhlIGNvbnRlbnQuIEFsbG93aW5nXG4vLyBzY3JpcHQgdGFncyBpcywgYnkgZGVmaW5pdGlvbiwgZ2FtZSBvdmVyIGZvciBYU1MgcHJvdGVjdGlvbiwgc28gaWYgdGhhdCdzXG4vLyB5b3VyIGNvbmNlcm4sIGRvbid0IGFsbG93IHRoZW0uIFRoZSBzYW1lIGlzIGVzc2VudGlhbGx5IHRydWUgZm9yIHN0eWxlIHRhZ3Ncbi8vIHdoaWNoIGhhdmUgdGhlaXIgb3duIGNvbGxlY3Rpb24gb2YgWFNTIHZlY3RvcnMuXG5yZXN1bHQrPXRleHQ7fWVsc2V7dmFyIGVzY2FwZWQ9ZXNjYXBlSHRtbCh0ZXh0LGZhbHNlKTtpZihvcHRpb25zLnRleHRGaWx0ZXIpe3Jlc3VsdCs9b3B0aW9ucy50ZXh0RmlsdGVyKGVzY2FwZWQsdGFnKTt9ZWxzZXtyZXN1bHQrPWVzY2FwZWQ7fX1pZihzdGFjay5sZW5ndGgpe3ZhciBmcmFtZT1zdGFja1tzdGFjay5sZW5ndGgtMV07ZnJhbWUudGV4dCs9dGV4dDt9fSxvbmNsb3NldGFnOmZ1bmN0aW9uIG9uY2xvc2V0YWcobmFtZSl7aWYoc2tpcFRleHQpe3NraXBUZXh0RGVwdGgtLTtpZighc2tpcFRleHREZXB0aCl7c2tpcFRleHQ9ZmFsc2U7fWVsc2V7cmV0dXJuO319dmFyIGZyYW1lPXN0YWNrLnBvcCgpO2lmKCFmcmFtZSl7Ly8gRG8gbm90IGNyYXNoIG9uIGJhZCBtYXJrdXBcbnJldHVybjt9c2tpcFRleHQ9b3B0aW9ucy5lbmZvcmNlSHRtbEJvdW5kYXJ5P25hbWU9PT0naHRtbCc6ZmFsc2U7ZGVwdGgtLTt2YXIgc2tpcD1za2lwTWFwW2RlcHRoXTtpZihza2lwKXtkZWxldGUgc2tpcE1hcFtkZXB0aF07aWYob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGU9PT0nZGlzY2FyZCcpe2ZyYW1lLnVwZGF0ZVBhcmVudE5vZGVUZXh0KCk7cmV0dXJuO310ZW1wUmVzdWx0PXJlc3VsdDtyZXN1bHQ9Jyc7fWlmKHRyYW5zZm9ybU1hcFtkZXB0aF0pe25hbWU9dHJhbnNmb3JtTWFwW2RlcHRoXTtkZWxldGUgdHJhbnNmb3JtTWFwW2RlcHRoXTt9aWYob3B0aW9ucy5leGNsdXNpdmVGaWx0ZXImJm9wdGlvbnMuZXhjbHVzaXZlRmlsdGVyKGZyYW1lKSl7cmVzdWx0PXJlc3VsdC5zdWJzdHIoMCxmcmFtZS50YWdQb3NpdGlvbik7cmV0dXJuO31mcmFtZS51cGRhdGVQYXJlbnROb2RlTWVkaWFDaGlsZHJlbigpO2ZyYW1lLnVwZGF0ZVBhcmVudE5vZGVUZXh0KCk7aWYob3B0aW9ucy5zZWxmQ2xvc2luZy5pbmRleE9mKG5hbWUpIT09LTEpey8vIEFscmVhZHkgb3V0cHV0IC8+XG5pZihza2lwKXtyZXN1bHQ9dGVtcFJlc3VsdDt0ZW1wUmVzdWx0PScnO31yZXR1cm47fXJlc3VsdCs9XCI8L1wiK25hbWUrXCI+XCI7aWYoc2tpcCl7cmVzdWx0PXRlbXBSZXN1bHQrZXNjYXBlSHRtbChyZXN1bHQpO3RlbXBSZXN1bHQ9Jyc7fX19LG9wdGlvbnMucGFyc2VyKTtwYXJzZXIud3JpdGUoaHRtbCk7cGFyc2VyLmVuZCgpO3JldHVybiByZXN1bHQ7ZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCl7cmVzdWx0PScnO2RlcHRoPTA7c3RhY2s9W107c2tpcE1hcD17fTt0cmFuc2Zvcm1NYXA9e307c2tpcFRleHQ9ZmFsc2U7c2tpcFRleHREZXB0aD0wO31mdW5jdGlvbiBlc2NhcGVIdG1sKHMscXVvdGUpe2lmKHR5cGVvZiBzIT09J3N0cmluZycpe3M9cysnJzt9aWYob3B0aW9ucy5wYXJzZXIuZGVjb2RlRW50aXRpZXMpe3M9cy5yZXBsYWNlKC8mL2csJyZhbXA7JykucmVwbGFjZSgvPC9nLCcmbHQ7JykucmVwbGFjZSgvXFw+L2csJyZndDsnKTtpZihxdW90ZSl7cz1zLnJlcGxhY2UoL1xcXCIvZywnJnF1b3Q7Jyk7fX0vLyBUT0RPOiB0aGlzIGlzIGluYWRlcXVhdGUgYmVjYXVzZSBpdCB3aWxsIHBhc3MgYCYwO2AuIFRoaXMgYXBwcm9hY2hcbi8vIHdpbGwgbm90IHdvcmssIGVhY2ggJiBtdXN0IGJlIGNvbnNpZGVyZWQgd2l0aCByZWdhcmQgdG8gd2hldGhlciBpdFxuLy8gaXMgZm9sbG93ZWQgYnkgYSAxMDAlIHN5bnRhY3RpY2FsbHkgdmFsaWQgZW50aXR5IG9yIG5vdCwgYW5kIGVzY2FwZWRcbi8vIGlmIGl0IGlzIG5vdC4gSWYgdGhpcyBib3RoZXJzIHlvdSwgZG9uJ3Qgc2V0IHBhcnNlci5kZWNvZGVFbnRpdGllc1xuLy8gdG8gZmFsc2UuIChUaGUgZGVmYXVsdCBpcyB0cnVlLilcbnM9cy5yZXBsYWNlKC8mKD8hW2EtekEtWjAtOSNdezEsMjB9OykvZywnJmFtcDsnKS8vIE1hdGNoIGFtcGVyc2FuZHMgbm90IHBhcnQgb2YgZXhpc3RpbmcgSFRNTCBlbnRpdHlcbi5yZXBsYWNlKC88L2csJyZsdDsnKS5yZXBsYWNlKC9cXD4vZywnJmd0OycpO2lmKHF1b3RlKXtzPXMucmVwbGFjZSgvXFxcIi9nLCcmcXVvdDsnKTt9cmV0dXJuIHM7fWZ1bmN0aW9uIG5hdWdodHlIcmVmKG5hbWUsaHJlZil7Ly8gQnJvd3NlcnMgaWdub3JlIGNoYXJhY3RlciBjb2RlcyBvZiAzMiAoc3BhY2UpIGFuZCBiZWxvdyBpbiBhIHN1cnByaXNpbmdcbi8vIG51bWJlciBvZiBzaXR1YXRpb25zLiBTdGFydCByZWFkaW5nIGhlcmU6XG4vLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldCNFbWJlZGRlZF90YWJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5ocmVmPWhyZWYucmVwbGFjZSgvW1xceDAwLVxceDIwXSsvZywnJyk7Ly8gQ2xvYmJlciBhbnkgY29tbWVudHMgaW4gVVJMcywgd2hpY2ggdGhlIGJyb3dzZXIgbWlnaHRcbi8vIGludGVycHJldCBpbnNpZGUgYW4gWE1MIGRhdGEgaXNsYW5kLCBhbGxvd2luZ1xuLy8gYSBqYXZhc2NyaXB0OiBVUkwgdG8gYmUgc251Y2sgdGhyb3VnaFxuaHJlZj1ocmVmLnJlcGxhY2UoLzxcXCFcXC1cXC0uKj9cXC1cXC1cXD4vZywnJyk7Ly8gQ2FzZSBpbnNlbnNpdGl2ZSBzbyB3ZSBkb24ndCBnZXQgZmFrZWQgb3V0IGJ5IEpBVkFTQ1JJUFQgIzFcbnZhciBtYXRjaGVzPWhyZWYubWF0Y2goL14oW2EtekEtWl0rKVxcOi8pO2lmKCFtYXRjaGVzKXsvLyBQcm90b2NvbC1yZWxhdGl2ZSBVUkwgc3RhcnRpbmcgd2l0aCBhbnkgY29tYmluYXRpb24gb2YgJy8nIGFuZCAnXFwnXG5pZihocmVmLm1hdGNoKC9eW1xcL1xcXFxdezJ9Lykpe3JldHVybiFvcHRpb25zLmFsbG93UHJvdG9jb2xSZWxhdGl2ZTt9Ly8gTm8gc2NoZW1lXG5yZXR1cm4gZmFsc2U7fXZhciBzY2hlbWU9bWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO2lmKGhhcyhvcHRpb25zLmFsbG93ZWRTY2hlbWVzQnlUYWcsbmFtZSkpe3JldHVybiBvcHRpb25zLmFsbG93ZWRTY2hlbWVzQnlUYWdbbmFtZV0uaW5kZXhPZihzY2hlbWUpPT09LTE7fXJldHVybiFvcHRpb25zLmFsbG93ZWRTY2hlbWVzfHxvcHRpb25zLmFsbG93ZWRTY2hlbWVzLmluZGV4T2Yoc2NoZW1lKT09PS0xO30vKipcbiAgICogRmlsdGVycyB1c2VyIGlucHV0IGNzcyBwcm9wZXJ0aWVzIGJ5IHdoaXRlbGlzdGVkIHJlZ2V4IGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhYnN0cmFjdFN5bnRheFRyZWUgIC0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIENTUyBhdHRyaWJ1dGVzLlxuICAgKiBAcHJvcGVydHkge2FycmF5W0RlY2xhcmF0aW9uXX0gYWJzdHJhY3RTeW50YXhUcmVlLm5vZGVzWzBdIC0gRWFjaCBvYmplY3QgY29pbnRhaW5zIHByb3AgYW5kIHZhbHVlIGtleSwgaS5lIHsgcHJvcDogJ2NvbG9yJywgdmFsdWU6ICdyZWQnIH0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxvd2VkU3R5bGVzICAgICAgIC0gS2V5cyBhcmUgcHJvcGVydGllcyAoaS5lIGNvbG9yKSwgdmFsdWUgaXMgbGlzdCBvZiBwZXJtaXR0ZWQgcmVnZXggcnVsZXMgKGkuZSAvZ3JlZW4vaSkuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICAgIC0gQWJzdHJhY3QgU3ludGF4IFRyZWUgd2l0aCBmaWx0ZXJlZCBzdHlsZSBhdHRyaWJ1dGVzLlxuICAgKi9mdW5jdGlvbiBmaWx0ZXJDc3MoYWJzdHJhY3RTeW50YXhUcmVlLGFsbG93ZWRTdHlsZXMpe2lmKCFhbGxvd2VkU3R5bGVzKXtyZXR1cm4gYWJzdHJhY3RTeW50YXhUcmVlO312YXIgZmlsdGVyZWRBU1Q9Y2xvbmVEZWVwKGFic3RyYWN0U3ludGF4VHJlZSk7dmFyIGFzdFJ1bGVzPWFic3RyYWN0U3ludGF4VHJlZS5ub2Rlc1swXTt2YXIgc2VsZWN0ZWRSdWxlOy8vIE1lcmdlIGdsb2JhbCBhbmQgdGFnLXNwZWNpZmljIHN0eWxlcyBpbnRvIG5ldyBBU1QuXG5pZihhbGxvd2VkU3R5bGVzW2FzdFJ1bGVzLnNlbGVjdG9yXSYmYWxsb3dlZFN0eWxlc1snKiddKXtzZWxlY3RlZFJ1bGU9bWVyZ2VXaXRoKGNsb25lRGVlcChhbGxvd2VkU3R5bGVzW2FzdFJ1bGVzLnNlbGVjdG9yXSksYWxsb3dlZFN0eWxlc1snKiddLGZ1bmN0aW9uKG9ialZhbHVlLHNyY1ZhbHVlKXtpZihBcnJheS5pc0FycmF5KG9ialZhbHVlKSl7cmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7fX0pO31lbHNle3NlbGVjdGVkUnVsZT1hbGxvd2VkU3R5bGVzW2FzdFJ1bGVzLnNlbGVjdG9yXXx8YWxsb3dlZFN0eWxlc1snKiddO31pZihzZWxlY3RlZFJ1bGUpe2ZpbHRlcmVkQVNULm5vZGVzWzBdLm5vZGVzPWFzdFJ1bGVzLm5vZGVzLnJlZHVjZShmaWx0ZXJEZWNsYXJhdGlvbnMoc2VsZWN0ZWRSdWxlKSxbXSk7fXJldHVybiBmaWx0ZXJlZEFTVDt9LyoqXG4gICAqIEV4dHJhY3RzIHRoZSBzdHlsZSBhdHRyaWJ1ZXMgZnJvbSBhbiBBYnN0cmFjdFN5bnRheFRyZWUgYW5kIGZvcm1hdHMgdGhvc2VcbiAgICogdmFsdWVzIGluIHRoZSBpbmxpbmUgc3R5bGUgYXR0cmlidXRlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtICB7QWJzdHJhY3RTeW50YXhUcmVlfSBmaWx0ZXJlZEFTVFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgIC0gRXhhbXBsZTogXCJjb2xvcjp5ZWxsb3c7dGV4dC1hbGlnbjpjZW50ZXI7Zm9udC1mYW1pbHk6aGVsdmV0aWNhO1wiXG4gICAqL2Z1bmN0aW9uIHN0cmluZ2lmeVN0eWxlQXR0cmlidXRlcyhmaWx0ZXJlZEFTVCl7cmV0dXJuIGZpbHRlcmVkQVNULm5vZGVzWzBdLm5vZGVzLnJlZHVjZShmdW5jdGlvbihleHRyYWN0ZWRBdHRyaWJ1dGVzLGF0dHJpYnV0ZU9iamVjdCl7ZXh0cmFjdGVkQXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZU9iamVjdC5wcm9wKyc6JythdHRyaWJ1dGVPYmplY3QudmFsdWUpO3JldHVybiBleHRyYWN0ZWRBdHRyaWJ1dGVzO30sW10pLmpvaW4oJzsnKTt9LyoqXG4gICAgKiBGaWx0ZXJzIHRoZSBleGlzdGluZyBhdHRyaWJ1dGVzIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuIERpc2NhcmRzIGFueSBhdHRyaWJ1dGVzXG4gICAgKiB3aGljaCBkb24ndCBtYXRjaCB0aGUgd2hpdGVsaXN0LlxuICAgICpcbiAgICAqIEBwYXJhbSAge29iamVjdH0gc2VsZWN0ZWRSdWxlICAgICAgICAgICAgIC0gRXhhbXBsZTogeyBjb2xvcjogcmVkLCBmb250LWZhbWlseTogaGVsdmV0aWNhIH1cbiAgICAqIEBwYXJhbSAge2FycmF5fSBhbGxvd2VkRGVjbGFyYXRpb25zTGlzdCAgIC0gTGlzdCBvZiBkZWNsYXJhdGlvbnMgd2hpY2ggcGFzcyB3aGl0ZWxpc3RpbmcuXG4gICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZU9iamVjdCAgICAgICAgICAtIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgY3NzIHByb3BlcnR5LlxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHJpYnV0ZU9iamVjdC50eXBlICAgLSBUeXBpY2FsbHkgJ2RlY2xhcmF0aW9uJy5cbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyaWJ1dGVPYmplY3QucHJvcCAgIC0gVGhlIENTUyBwcm9wZXJ0eSwgaS5lICdjb2xvcicuXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gYXR0cmlidXRlT2JqZWN0LnZhbHVlICAtIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHRvIHRoZSBjc3MgcHJvcGVydHksIGkuZSAncmVkJy5cbiAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSAgICAgICAgICAgICAgICAgICAgICAgIC0gV2hlbiB1c2VkIGluIEFycmF5LnJlZHVjZSwgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgRGVjbGFyYXRpb24gb2JqZWN0c1xuICAgICovZnVuY3Rpb24gZmlsdGVyRGVjbGFyYXRpb25zKHNlbGVjdGVkUnVsZSl7cmV0dXJuIGZ1bmN0aW9uKGFsbG93ZWREZWNsYXJhdGlvbnNMaXN0LGF0dHJpYnV0ZU9iamVjdCl7Ly8gSWYgdGhpcyBwcm9wZXJ0eSBpcyB3aGl0ZWxpc3RlZC4uLlxuaWYoc2VsZWN0ZWRSdWxlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU9iamVjdC5wcm9wKSl7dmFyIG1hdGNoZXNSZWdleD1zZWxlY3RlZFJ1bGVbYXR0cmlidXRlT2JqZWN0LnByb3BdLnNvbWUoZnVuY3Rpb24ocmVndWxhckV4cHJlc3Npb24pe3JldHVybiByZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGF0dHJpYnV0ZU9iamVjdC52YWx1ZSk7fSk7aWYobWF0Y2hlc1JlZ2V4KXthbGxvd2VkRGVjbGFyYXRpb25zTGlzdC5wdXNoKGF0dHJpYnV0ZU9iamVjdCk7fX1yZXR1cm4gYWxsb3dlZERlY2xhcmF0aW9uc0xpc3Q7fTt9ZnVuY3Rpb24gZmlsdGVyQ2xhc3NlcyhjbGFzc2VzLGFsbG93ZWQpe2lmKCFhbGxvd2VkKXsvLyBUaGUgY2xhc3MgYXR0cmlidXRlIGlzIGFsbG93ZWQgd2l0aG91dCBmaWx0ZXJpbmcgb24gdGhpcyB0YWdcbnJldHVybiBjbGFzc2VzO31jbGFzc2VzPWNsYXNzZXMuc3BsaXQoL1xccysvKTtyZXR1cm4gY2xhc3Nlcy5maWx0ZXIoZnVuY3Rpb24oY2xzcyl7cmV0dXJuIGFsbG93ZWQuaW5kZXhPZihjbHNzKSE9PS0xO30pLmpvaW4oJyAnKTt9fS8vIERlZmF1bHRzIGFyZSBhY2Nlc3NpYmxlIHRvIHlvdSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoZW0gYXMgYSBzdGFydGluZyBwb2ludFxuLy8gcHJvZ3JhbW1hdGljYWxseSBpZiB5b3Ugd2lzaFxudmFyIGh0bWxQYXJzZXJEZWZhdWx0cz17ZGVjb2RlRW50aXRpZXM6dHJ1ZX07c2FuaXRpemVIdG1sLmRlZmF1bHRzPXthbGxvd2VkVGFnczpbJ2gzJywnaDQnLCdoNScsJ2g2JywnYmxvY2txdW90ZScsJ3AnLCdhJywndWwnLCdvbCcsJ25sJywnbGknLCdiJywnaScsJ3N0cm9uZycsJ2VtJywnc3RyaWtlJywnYWJicicsJ2NvZGUnLCdocicsJ2JyJywnZGl2JywndGFibGUnLCd0aGVhZCcsJ2NhcHRpb24nLCd0Ym9keScsJ3RyJywndGgnLCd0ZCcsJ3ByZScsJ2lmcmFtZSddLGRpc2FsbG93ZWRUYWdzTW9kZTonZGlzY2FyZCcsYWxsb3dlZEF0dHJpYnV0ZXM6e2E6WydocmVmJywnbmFtZScsJ3RhcmdldCddLC8vIFdlIGRvbid0IGN1cnJlbnRseSBhbGxvdyBpbWcgaXRzZWxmIGJ5IGRlZmF1bHQsIGJ1dCB0aGlzXG4vLyB3b3VsZCBtYWtlIHNlbnNlIGlmIHdlIGRpZC4gWW91IGNvdWxkIGFkZCBzcmNzZXQgaGVyZSxcbi8vIGFuZCBpZiB5b3UgZG8gdGhlIFVSTCBpcyBjaGVja2VkIGZvciBzYWZldHlcbmltZzpbJ3NyYyddfSwvLyBMb3RzIG9mIHRoZXNlIHdvbid0IGNvbWUgdXAgYnkgZGVmYXVsdCBiZWNhdXNlIHdlIGRvbid0IGFsbG93IHRoZW1cbnNlbGZDbG9zaW5nOlsnaW1nJywnYnInLCdocicsJ2FyZWEnLCdiYXNlJywnYmFzZWZvbnQnLCdpbnB1dCcsJ2xpbmsnLCdtZXRhJ10sLy8gVVJMIHNjaGVtZXMgd2UgcGVybWl0XG5hbGxvd2VkU2NoZW1lczpbJ2h0dHAnLCdodHRwcycsJ2Z0cCcsJ21haWx0byddLGFsbG93ZWRTY2hlbWVzQnlUYWc6e30sYWxsb3dlZFNjaGVtZXNBcHBsaWVkVG9BdHRyaWJ1dGVzOlsnaHJlZicsJ3NyYycsJ2NpdGUnXSxhbGxvd1Byb3RvY29sUmVsYXRpdmU6dHJ1ZSxlbmZvcmNlSHRtbEJvdW5kYXJ5OmZhbHNlfTtzYW5pdGl6ZUh0bWwuc2ltcGxlVHJhbnNmb3JtPWZ1bmN0aW9uKG5ld1RhZ05hbWUsbmV3QXR0cmlicyxtZXJnZSl7bWVyZ2U9bWVyZ2U9PT11bmRlZmluZWQ/dHJ1ZTptZXJnZTtuZXdBdHRyaWJzPW5ld0F0dHJpYnN8fHt9O3JldHVybiBmdW5jdGlvbih0YWdOYW1lLGF0dHJpYnMpe3ZhciBhdHRyaWI7aWYobWVyZ2Upe2ZvcihhdHRyaWIgaW4gbmV3QXR0cmlicyl7YXR0cmlic1thdHRyaWJdPW5ld0F0dHJpYnNbYXR0cmliXTt9fWVsc2V7YXR0cmlicz1uZXdBdHRyaWJzO31yZXR1cm57dGFnTmFtZTpuZXdUYWdOYW1lLGF0dHJpYnM6YXR0cmlic307fTt9O30se1wiaHRtbHBhcnNlcjJcIjozMSxcImxvZGFzaC9jbG9uZURlZXBcIjoxNDAsXCJsb2Rhc2gvZXNjYXBlUmVnRXhwXCI6MTQzLFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIjoxNTUsXCJsb2Rhc2gvaXNTdHJpbmdcIjoxNTcsXCJsb2Rhc2gvbWVyZ2VXaXRoXCI6MTYyLFwicG9zdGNzc1wiOjE4MCxcInNyY3NldFwiOjIwOCxcInVybFwiOjIwOX1dfSx7fSxbMjExXSkoMjExKTt9KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sanitize-html/dist/sanitize-html.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./platform/packages/menu/resources/assets/js/menu.js":
/*!************************************************************!*\
  !*** ./platform/packages/menu/resources/assets/js/menu.js ***!
  \************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var sanitize_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sanitize-html */ \"./node_modules/sanitize-html/dist/sanitize-html.js\");\n/* harmony import */ var sanitize_html__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sanitize_html__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar MenuNestable = /*#__PURE__*/function () {\n  function MenuNestable() {\n    _classCallCheck(this, MenuNestable);\n\n    this.$nestable = $('#nestable');\n  }\n\n  _createClass(MenuNestable, [{\n    key: \"setDataItem\",\n    value: function setDataItem(target) {\n      target.each(function (index, el) {\n        var current = $(el);\n        current.data('id', current.attr('data-id'));\n        current.data('title', current.attr('data-title'));\n        current.data('reference-id', current.attr('data-reference-id'));\n        current.data('reference-type', current.attr('data-reference-type'));\n        current.data('custom-url', current.attr('data-custom-url'));\n        current.data('class', current.attr('data-class'));\n        current.data('target', current.attr('data-target'));\n      });\n    }\n  }, {\n    key: \"updatePositionForSerializedObj\",\n    value: function updatePositionForSerializedObj(arrayObject) {\n      var result = arrayObject;\n      var that = this;\n      $.each(result, function (index, val) {\n        val.position = index;\n\n        if (typeof val.children == 'undefined') {\n          val.children = [];\n        }\n\n        that.updatePositionForSerializedObj(val.children);\n      });\n      return result;\n    } // Main function to initiate the module\n\n  }, {\n    key: \"init\",\n    value: function init() {\n      var depth = parseInt(this.$nestable.attr('data-depth'));\n\n      if (depth < 1) {\n        depth = 5;\n      }\n\n      $('.nestable-menu').nestable({\n        group: 1,\n        maxDepth: depth,\n        expandBtnHTML: '',\n        collapseBtnHTML: ''\n      });\n      this.handleNestableMenu();\n    }\n  }, {\n    key: \"handleNestableMenu\",\n    value: function handleNestableMenu() {\n      var that = this; // Show node details\n\n      $(document).on('click', '.dd-item .dd3-content a.show-item-details', function (event) {\n        event.preventDefault();\n        var parent = $(event.currentTarget).parent().parent();\n        $(event.currentTarget).toggleClass('active');\n        parent.toggleClass('active');\n      }); // Edit attributes\n\n      $(document).on('change blur keyup', '.nestable-menu .item-details input[type=\"text\"], .nestable-menu .item-details select', function (event) {\n        event.preventDefault();\n        var current = $(event.currentTarget);\n        var parent = current.closest('li.dd-item');\n        var value = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()(current.val());\n        var name = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()(current.attr('name'));\n        var old = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()(current.attr('data-old'));\n        parent.attr('data-' + name, value);\n        parent.data(name, value);\n        parent.find('> .dd3-content .text[data-update=\"' + name + '\"]').text(value);\n\n        if (value.trim() === '') {\n          parent.find('> .dd3-content .text[data-update=\"' + name + '\"]').text(old);\n        }\n\n        that.setDataItem(that.$nestable.find('> ol.dd-list li.dd-item'));\n      }); // Add nodes\n\n      $(document).on('click', '.box-links-for-menu .btn-add-to-menu', function (event) {\n        event.preventDefault();\n        var current = $(event.currentTarget);\n        var parent = current.parents('.the-box');\n        var html = '';\n\n        if (parent.attr('id') === 'external_link') {\n          var data_type = 'custom-link';\n          var data_reference_id = 0;\n          var data_title = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()($('#node-title').val());\n          var data_url = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()($('#node-url').val());\n          var data_css_class = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()($('#node-css').val());\n          var data_font_icon = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()($('#node-icon').val());\n          var data_target = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()($('#target').find('option:selected').val());\n          var url_html = '<label class=\"pad-bot-5\"><span class=\"text pad-top-5 dis-inline-block\" data-update=\"custom-url\">Url</span><input type=\"text\" data-old=\"' + data_url + '\" value=\"' + data_url + '\" name=\"custom-url\"></label>';\n          html += '<li data-reference-type=\"' + data_type + '\" data-reference-id=\"' + data_reference_id + '\" data-title=\"' + data_title + '\" data-class=\"' + data_css_class + '\" data-id=\"0\" data-custom-url=\"' + data_url + '\" data-icon-font=\"' + data_font_icon + '\" data-target=\"' + data_target + '\" class=\"dd-item dd3-item\">';\n          html += '<div class=\"dd-handle dd3-handle\"></div>';\n          html += '<div class=\"dd3-content\">';\n          html += '<span class=\"text float-left\" data-update=\"title\">' + data_title + '</span>';\n          html += '<span class=\"text float-right\">' + data_type + '</span>';\n          html += '<a href=\"#\" class=\"show-item-details\"><i class=\"fa fa-angle-down\"></i></a>';\n          html += '<div class=\"clearfix\"></div>';\n          html += '</div>';\n          html += '<div class=\"item-details\">';\n          html += '<label class=\"pad-bot-5\">';\n          html += '<span class=\"text pad-top-5 dis-inline-block\" data-update=\"title\">Title</span>';\n          html += '<input type=\"text\" data-old=\"' + data_title + '\" value=\"' + data_title + '\" name=\"title\" class=\"form-control\">';\n          html += '</label>';\n          html += url_html;\n          html += '<label class=\"pad-bot-5 dis-inline-block\"><span class=\"text pad-top-5\" data-update=\"icon-font\">Icon - font</span><input type=\"text\" name=\"icon-font\" value=\"' + data_font_icon + '\" data-old=\"' + data_font_icon + '\" class=\"form-control\"></label>';\n          html += '<label class=\"pad-bot-10\">';\n          html += '<span class=\"text pad-top-5 dis-inline-block\" data-update=\"class\">CSS class</span>';\n          html += '<input type=\"text\" data-old=\"' + data_css_class + '\" value=\"' + data_css_class + '\" name=\"class\" class=\"form-control\">';\n          html += '</label>';\n          html += '<label class=\"pad-bot-10\">';\n          html += '<span class=\"text pad-top-5 dis-inline-block\" data-update=\"target\">Target</span>';\n          html += '<div style=\"width: 228px; display: inline-block\"><select name=\"target\" id=\"target\" data-old=\"' + data_target + '\" class=\"form-control select-full\">';\n          html += '<option value=\"_self\">Open link directly</option>';\n          html += '<option value=\"_blank\" ' + (data_target === '_blank' ? 'selected=\"selected\"' : '') + '>Open link in new tab</option>';\n          html += '</select></div>';\n          html += '</label>';\n          html += '<div class=\"text-right\">';\n          html += '<a class=\"btn red btn-remove\" href=\"#\">Remove</a>';\n          html += '<a class=\"btn blue btn-cancel\" href=\"#\">Cancel</a>';\n          html += '</div>';\n          html += '</div>';\n          html += '<div class=\"clearfix\"></div>';\n          html += '</li>';\n          parent.find('input[type=\"text\"]').val('');\n        } else {\n          parent.find('.list-item li.active').each(function (index, el) {\n            var find_in = $(el).find('> label');\n            var data_type = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()(find_in.attr('data-reference-type'));\n            var data_reference_id = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()(find_in.attr('data-reference-id'));\n            var data_title = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()(find_in.attr('data-title'));\n            html += '<li data-reference-type=\"' + data_type + '\" data-reference-id=\"' + data_reference_id + '\" data-title=\"' + data_title + '\" data-id=\"0\" data-target=\"_self\" class=\"dd-item dd3-item\">';\n            html += '<div class=\"dd-handle dd3-handle\"></div>';\n            html += '<div class=\"dd3-content\">';\n            html += '<span class=\"text float-left\" data-update=\"title\">' + data_title + '</span>';\n            html += '<span class=\"text float-right\">' + data_type + '</span>';\n            html += '<a href=\"#\" class=\"show-item-details\"><i class=\"fa fa-angle-down\"></i></a>';\n            html += '<div class=\"clearfix\"></div>';\n            html += '</div>';\n            html += '<div class=\"item-details\">';\n            html += '<label class=\"pad-bot-5\">';\n            html += '<span class=\"text pad-top-5 dis-inline-block\" data-update=\"title\">Title</span>';\n            html += '<input type=\"text\" data-old=\"' + data_title + '\" value=\"' + data_title + '\" name=\"title\" class=\"form-control\">';\n            html += '</label>';\n            html += '<label class=\"pad-bot-5 dis-inline-block\"><span class=\"text pad-top-5\" data-update=\"icon-font\">Icon - font</span><input type=\"text\" name=\"icon-font\" class=\"form-control\"></label>';\n            html += '<label class=\"pad-bot-10\">';\n            html += '<span class=\"text pad-top-5 dis-inline-block\" data-update=\"class\">CSS class</span>';\n            html += '<input type=\"text\" name=\"class\" class=\"form-control\">';\n            html += '</label>';\n            html += '<label class=\"pad-bot-10\">';\n            html += '<span class=\"text pad-top-5 dis-inline-block\" data-update=\"target\">Target</span>';\n            html += '<div style=\"width: 228px; display: inline-block\"><select name=\"target\" id=\"target\" class=\"form-control select-full\">';\n            html += '<option value=\"_self\">Open link directly</option>';\n            html += '<option value=\"_blank\">Open link in new tab</option>';\n            html += '</select></div>';\n            html += '</label>';\n            html += '<div class=\"text-right\">';\n            html += '<a class=\"btn red btn-remove\" href=\"#\">Remove</a>';\n            html += '<a class=\"btn blue btn-cancel\" href=\"#\">Cancel</a>';\n            html += '</div>';\n            html += '</div>';\n            html += '<div class=\"clearfix\"></div>';\n            html += '</li>';\n            $(el).find('input[type=checkbox]').prop('checked', false);\n          });\n        }\n\n        $('.nestable-menu > ol.dd-list').append(html.replace('<script>', '').replace('<\\\\/script>', ''));\n        $('.nestable-menu').find('.select-full').select2({\n          width: '100%',\n          minimumResultsForSearch: -1\n        }); // Change json\n\n        that.setDataItem(that.$nestable.find('> ol.dd-list li.dd-item'));\n        parent.find('.list-item li.active').removeClass('active');\n      }); // Remove nodes\n\n      $('.form-save-menu input[name=\"deleted_nodes\"]').val('');\n      $(document).on('click', '.nestable-menu .item-details .btn-remove', function (event) {\n        event.preventDefault();\n        var current = $(event.currentTarget);\n        var dd_item = current.parents('.item-details').parent();\n        var $elm = $('.form-save-menu input[name=\"deleted_nodes\"]'); // Add id of deleted nodes to delete in controller\n\n        $elm.val($elm.val() + ' ' + dd_item.attr('data-id'));\n        var children = dd_item.find('> .dd-list').html();\n\n        if (children !== '' && children != null) {\n          dd_item.before(children.replace('<script>', '').replace('<\\\\/script>', ''));\n        }\n\n        dd_item.remove();\n      });\n      $(document).on('click', '.nestable-menu .item-details .btn-cancel', function (event) {\n        event.preventDefault();\n        var current_pa = $(event.currentTarget);\n        var parent = current_pa.parents('.item-details').parent();\n        parent.find('input[type=\"text\"]').each(function (index, el) {\n          $(el).val($(el).attr('data-old'));\n        });\n        parent.find('select').each(function (index, el) {\n          $(el).val($(el).val());\n        });\n        parent.find('input[type=\"text\"]').trigger('change');\n        parent.find('select').trigger('change');\n        parent.removeClass('active');\n      });\n      $(document).on('change', '.box-links-for-menu .list-item li input[type=checkbox]', function (event) {\n        $(event.currentTarget).closest('li').toggleClass('active');\n      });\n      $(document).on('submit', '.form-save-menu', function () {\n        if (that.$nestable.length < 1) {\n          $('#nestable-output').val('[]');\n        } else {\n          var nestable_obj_returned = that.$nestable.nestable('serialize');\n          var the_obj = that.updatePositionForSerializedObj(nestable_obj_returned);\n          $('#nestable-output').val(JSON.stringify(the_obj));\n        }\n      });\n      var accordion = $('#accordion');\n\n      var toggleChevron = function toggleChevron(event) {\n        $(event.target).prev('.widget-heading').find('.narrow-icon').toggleClass('fa-angle-down fa-angle-up');\n      };\n\n      accordion.on('hidden.bs.collapse', toggleChevron);\n      accordion.on('shown.bs.collapse', toggleChevron);\n      ZHXCore.callScroll($('.list-item'));\n    }\n  }]);\n\n  return MenuNestable;\n}();\n\n$(window).on('load', function () {\n  new MenuNestable().init();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wbGF0Zm9ybS9wYWNrYWdlcy9tZW51L3Jlc291cmNlcy9hc3NldHMvanMvbWVudS5qcz9jMGYzIl0sIm5hbWVzIjpbIk1lbnVOZXN0YWJsZSIsIiRuZXN0YWJsZSIsIiQiLCJ0YXJnZXQiLCJlYWNoIiwiaW5kZXgiLCJlbCIsImN1cnJlbnQiLCJkYXRhIiwiYXR0ciIsImFycmF5T2JqZWN0IiwicmVzdWx0IiwidGhhdCIsInZhbCIsInBvc2l0aW9uIiwiY2hpbGRyZW4iLCJ1cGRhdGVQb3NpdGlvbkZvclNlcmlhbGl6ZWRPYmoiLCJkZXB0aCIsInBhcnNlSW50IiwibmVzdGFibGUiLCJncm91cCIsIm1heERlcHRoIiwiZXhwYW5kQnRuSFRNTCIsImNvbGxhcHNlQnRuSFRNTCIsImhhbmRsZU5lc3RhYmxlTWVudSIsImRvY3VtZW50Iiwib24iLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwicGFyZW50IiwiY3VycmVudFRhcmdldCIsInRvZ2dsZUNsYXNzIiwiY2xvc2VzdCIsInZhbHVlIiwic2FuaXRpemVIVE1MIiwibmFtZSIsIm9sZCIsImZpbmQiLCJ0ZXh0IiwidHJpbSIsInNldERhdGFJdGVtIiwicGFyZW50cyIsImh0bWwiLCJkYXRhX3R5cGUiLCJkYXRhX3JlZmVyZW5jZV9pZCIsImRhdGFfdGl0bGUiLCJkYXRhX3VybCIsImRhdGFfY3NzX2NsYXNzIiwiZGF0YV9mb250X2ljb24iLCJkYXRhX3RhcmdldCIsInVybF9odG1sIiwiZmluZF9pbiIsInByb3AiLCJhcHBlbmQiLCJyZXBsYWNlIiwic2VsZWN0MiIsIndpZHRoIiwibWluaW11bVJlc3VsdHNGb3JTZWFyY2giLCJyZW1vdmVDbGFzcyIsImRkX2l0ZW0iLCIkZWxtIiwiYmVmb3JlIiwicmVtb3ZlIiwiY3VycmVudF9wYSIsInRyaWdnZXIiLCJsZW5ndGgiLCJuZXN0YWJsZV9vYmpfcmV0dXJuZWQiLCJ0aGVfb2JqIiwiSlNPTiIsInN0cmluZ2lmeSIsImFjY29yZGlvbiIsInRvZ2dsZUNoZXZyb24iLCJwcmV2IiwiWkhYQ29yZSIsImNhbGxTY3JvbGwiLCJ3aW5kb3ciLCJpbml0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7SUFFTUEsWTtBQUNGLDBCQUFjO0FBQUE7O0FBQ1YsU0FBS0MsU0FBTCxHQUFpQkMsQ0FBQyxDQUFDLFdBQUQsQ0FBbEI7QUFDSDs7OztnQ0FFV0MsTSxFQUFRO0FBQ2hCQSxZQUFNLENBQUNDLElBQVAsQ0FBWSxVQUFDQyxLQUFELEVBQVFDLEVBQVIsRUFBZTtBQUN2QixZQUFJQyxPQUFPLEdBQUdMLENBQUMsQ0FBQ0ksRUFBRCxDQUFmO0FBQ0FDLGVBQU8sQ0FBQ0MsSUFBUixDQUFhLElBQWIsRUFBbUJELE9BQU8sQ0FBQ0UsSUFBUixDQUFhLFNBQWIsQ0FBbkI7QUFDQUYsZUFBTyxDQUFDQyxJQUFSLENBQWEsT0FBYixFQUFzQkQsT0FBTyxDQUFDRSxJQUFSLENBQWEsWUFBYixDQUF0QjtBQUNBRixlQUFPLENBQUNDLElBQVIsQ0FBYSxjQUFiLEVBQTZCRCxPQUFPLENBQUNFLElBQVIsQ0FBYSxtQkFBYixDQUE3QjtBQUNBRixlQUFPLENBQUNDLElBQVIsQ0FBYSxnQkFBYixFQUErQkQsT0FBTyxDQUFDRSxJQUFSLENBQWEscUJBQWIsQ0FBL0I7QUFDQUYsZUFBTyxDQUFDQyxJQUFSLENBQWEsWUFBYixFQUEyQkQsT0FBTyxDQUFDRSxJQUFSLENBQWEsaUJBQWIsQ0FBM0I7QUFDQUYsZUFBTyxDQUFDQyxJQUFSLENBQWEsT0FBYixFQUFzQkQsT0FBTyxDQUFDRSxJQUFSLENBQWEsWUFBYixDQUF0QjtBQUNBRixlQUFPLENBQUNDLElBQVIsQ0FBYSxRQUFiLEVBQXVCRCxPQUFPLENBQUNFLElBQVIsQ0FBYSxhQUFiLENBQXZCO0FBQ0gsT0FURDtBQVVIOzs7bURBRThCQyxXLEVBQWE7QUFDeEMsVUFBSUMsTUFBTSxHQUFHRCxXQUFiO0FBQ0EsVUFBSUUsSUFBSSxHQUFHLElBQVg7QUFDQVYsT0FBQyxDQUFDRSxJQUFGLENBQU9PLE1B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O0FBRUFFLGFBQU8sQ0FBQ0MsVUFBUixDQUFtQnhFLENBQUMsQ0FBQyxZQUFELENBQXBCO0FBQ0g7Ozs7OztBQUdMQSxDQUFDLENBQUN5RSxNQUFELENBQUQsQ0FBVWpELEVBQVYsQ0FBYSxNQUFiLEVBQXFCLFlBQU07QUFDdkIsTUFBSTFCLFlBQUosR0FBbUI0RSxJQUFuQjtBQUNILENBRkQiLCJmaWxlIjoiLi9wbGF0Zm9ybS9wYWNrYWdlcy9tZW51L3Jlc291cmNlcy9hc3NldHMvanMvbWVudS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzYW5pdGl6ZUhUTUwgZnJvbSAnc2FuaXRpemUtaHRtbCc7XHJcblxyXG5jbGFzcyBNZW51TmVzdGFibGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy4kbmVzdGFibGUgPSAkKCcjbmVzdGFibGUnKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXREYXRhSXRlbSh0YXJnZXQpIHtcclxuICAgICAgICB0YXJnZXQuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gJChlbCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQuZGF0YSgnaWQnLCBjdXJyZW50LmF0dHIoJ2RhdGEtaWQnKSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQuZGF0YSgndGl0bGUnLCBjdXJyZW50LmF0dHIoJ2RhdGEtdGl0bGUnKSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQuZGF0YSgncmVmZXJlbmNlLWlkJywgY3VycmVudC5hdHRyKCdkYXRhLXJlZmVyZW5jZS1pZCcpKTtcclxuICAgICAgICAgICAgY3VycmVudC5kYXRhKCdyZWZlcmVuY2UtdHlwZScsIGN1cnJlbnQuYXR0cignZGF0YS1yZWZlcmVuY2UtdHlwZScpKTtcclxuICAgICAgICAgICAgY3VycmVudC5kYXRhKCdjdXN0b20tdXJsJywgY3VycmVudC5hdHRyKCdkYXRhLWN1c3RvbS11cmwnKSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQuZGF0YSgnY2xhc3MnLCBjdXJyZW50LmF0dHIoJ2RhdGEtY2xhc3MnKSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQuZGF0YSgndGFyZ2V0JywgY3VycmVudC5hdHRyKCdkYXRhLXRhcmdldCcpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVQb3NpdGlvbkZvclNlcmlhbGl6ZWRPYmooYXJyYXlPYmplY3QpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gYXJyYXlPYmplY3Q7XHJcbiAgICAgICAgbGV0IHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICQuZWFjaChyZXN1bHQsIChpbmRleCwgdmFsKSA9PiB7XHJcbiAgICAgICAgICAgIHZhbC5wb3NpdGlvbiA9IGluZGV4O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5jaGlsZHJlbiA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmFsLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC51cGRhdGVQb3NpdGlvbkZvclNlcmlhbGl6ZWRPYmoodmFsLmNoaWxkcmVuKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1haW4gZnVuY3Rpb24gdG8gaW5pdGlhdGUgdGhlIG1vZHVsZVxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICBsZXQgZGVwdGggPSBwYXJzZUludCh0aGlzLiRuZXN0YWJsZS5hdHRyKCdkYXRhLWRlcHRoJykpO1xyXG4gICAgICAgIGlmIChkZXB0aCA8IDEpIHtcclxuICAgICAgICAgICAgZGVwdGggPSA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICAkKCcubmVzdGFibGUtbWVudScpLm5lc3RhYmxlKHtcclxuICAgICAgICAgICAgZ3JvdXA6IDEsXHJcbiAgICAgICAgICAgIG1heERlcHRoOiBkZXB0aCxcclxuICAgICAgICAgICAgZXhwYW5kQnRuSFRNTDogJycsXHJcbiAgICAgICAgICAgIGNvbGxhcHNlQnRuSFRNTDogJydcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVOZXN0YWJsZU1lbnUoKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVOZXN0YWJsZU1lbnUoKSB7XHJcbiAgICAgICAgbGV0IHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIC8vIFNob3cgbm9kZSBkZXRhaWxzXHJcbiAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5kZC1pdGVtIC5kZDMtY29udGVudCBhLnNob3ctaXRlbS1kZXRhaWxzJywgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5wYXJlbnQoKS5wYXJlbnQoKTtcclxuICAgICAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIHBhcmVudC50b2dnbGVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEVkaXQgYXR0cmlidXRlc1xyXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjaGFuZ2UgYmx1ciBrZXl1cCcsICcubmVzdGFibGUtbWVudSAuaXRlbS1kZXRhaWxzIGlucHV0W3R5cGU9XCJ0ZXh0XCJdLCAubmVzdGFibGUtbWVudSAuaXRlbS1kZXRhaWxzIHNlbGVjdCcsIGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gY3VycmVudC5jbG9zZXN0KCdsaS5kZC1pdGVtJyk7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHNhbml0aXplSFRNTChjdXJyZW50LnZhbCgpKTtcclxuICAgICAgICAgICAgbGV0IG5hbWUgPSBzYW5pdGl6ZUhUTUwoY3VycmVudC5hdHRyKCduYW1lJykpO1xyXG4gICAgICAgICAgICBsZXQgb2xkID0gc2FuaXRpemVIVE1MKGN1cnJlbnQuYXR0cignZGF0YS1vbGQnKSk7XHJcbiAgICAgICAgICAgIHBhcmVudC5hdHRyKCdkYXRhLScgKyBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHBhcmVudC5kYXRhKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgcGFyZW50LmZpbmQoJz4gLmRkMy1jb250ZW50IC50ZXh0W2RhdGEtdXBkYXRlPVwiJyArIG5hbWUgKyAnXCJdJykudGV4dCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuZmluZCgnPiAuZGQzLWNvbnRlbnQgLnRleHRbZGF0YS11cGRhdGU9XCInICsgbmFtZSArICdcIl0nKS50ZXh0KG9sZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5zZXREYXRhSXRlbSh0aGF0LiRuZXN0YWJsZS5maW5kKCc+IG9sLmRkLWxpc3QgbGkuZGQtaXRlbScpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQWRkIG5vZGVzXHJcbiAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5ib3gtbGlua3MtZm9yLW1lbnUgLmJ0bi1hZGQtdG8tbWVudScsIGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gY3VycmVudC5wYXJlbnRzKCcudGhlLWJveCcpO1xyXG4gICAgICAgICAgICBsZXQgaHRtbCA9ICcnO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LmF0dHIoJ2lkJykgPT09ICdleHRlcm5hbF9saW5rJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFfdHlwZSA9ICdjdXN0b20tbGluayc7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YV9yZWZlcmVuY2VfaWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFfdGl0bGUgPSBzYW5pdGl6ZUhUTUwoJCgnI25vZGUtdGl0bGUnKS52YWwoKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YV91cmwgPSBzYW5pdGl6ZUhUTUwoJCgnI25vZGUtdXJsJykudmFsKCkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFfY3NzX2NsYXNzID0gc2FuaXRpemVIVE1MKCQoJyNub2RlLWNzcycpLnZhbCgpKTtcclxuICAgICAgICAgICAgICAgIGxldCBkYXRhX2ZvbnRfaWNvbiA9IHNhbml0aXplSFRNTCgkKCcjbm9kZS1pY29uJykudmFsKCkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFfdGFyZ2V0ID0gc2FuaXRpemVIVE1MKCQoJyN0YXJnZXQnKS5maW5kKCdvcHRpb246c2VsZWN0ZWQnKS52YWwoKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdXJsX2h0bWwgPSAnPGxhYmVsIGNsYXNzPVwicGFkLWJvdC01XCI+PHNwYW4gY2xhc3M9XCJ0ZXh0IHBhZC10b3AtNSBkaXMtaW5saW5lLWJsb2NrXCIgZGF0YS11cGRhdGU9XCJjdXN0b20tdXJsXCI+VXJsPC9zcGFuPjxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtb2xkPVwiJyArIGRhdGFfdXJsICsgJ1wiIHZhbHVlPVwiJyArIGRhdGFfdXJsICsgJ1wiIG5hbWU9XCJjdXN0b20tdXJsXCI+PC9sYWJlbD4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGxpIGRhdGEtcmVmZXJlbmNlLXR5cGU9XCInICsgZGF0YV90eXBlICsgJ1wiIGRhdGEtcmVmZXJlbmNlLWlkPVwiJyArIGRhdGFfcmVmZXJlbmNlX2lkICsgJ1wiIGRhdGEtdGl0bGU9XCInICsgZGF0YV90aXRsZSArICdcIiBkYXRhLWNsYXNzPVwiJyArIGRhdGFfY3NzX2NsYXNzICsgJ1wiIGRhdGEtaWQ9XCIwXCIgZGF0YS1jdXN0b20tdXJsPVwiJyArIGRhdGFfdXJsICsgJ1wiIGRhdGEtaWNvbi1mb250PVwiJyArIGRhdGFfZm9udF9pY29uICsgJ1wiIGRhdGEtdGFyZ2V0PVwiJyArIGRhdGFfdGFyZ2V0ICsgJ1wiIGNsYXNzPVwiZGQtaXRlbSBkZDMtaXRlbVwiPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwiZGQtaGFuZGxlIGRkMy1oYW5kbGVcIj48L2Rpdj4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cImRkMy1jb250ZW50XCI+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwidGV4dCBmbG9hdC1sZWZ0XCIgZGF0YS11cGRhdGU9XCJ0aXRsZVwiPicgKyBkYXRhX3RpdGxlICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCJ0ZXh0IGZsb2F0LXJpZ2h0XCI+JyArIGRhdGFfdHlwZSArICc8L3NwYW4+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJzaG93LWl0ZW0tZGV0YWlsc1wiPjxpIGNsYXNzPVwiZmEgZmEtYW5nbGUtZG93blwiPjwvaT48L2E+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJjbGVhcmZpeFwiPjwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIml0ZW0tZGV0YWlsc1wiPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8bGFiZWwgY2xhc3M9XCJwYWQtYm90LTVcIj4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCJ0ZXh0IHBhZC10b3AtNSBkaXMtaW5saW5lLWJsb2NrXCIgZGF0YS11cGRhdGU9XCJ0aXRsZVwiPlRpdGxlPC9zcGFuPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLW9sZD1cIicgKyBkYXRhX3RpdGxlICsgJ1wiIHZhbHVlPVwiJyArIGRhdGFfdGl0bGUgKyAnXCIgbmFtZT1cInRpdGxlXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIj4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPC9sYWJlbD4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSB1cmxfaHRtbDtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxsYWJlbCBjbGFzcz1cInBhZC1ib3QtNSBkaXMtaW5saW5lLWJsb2NrXCI+PHNwYW4gY2xhc3M9XCJ0ZXh0IHBhZC10b3AtNVwiIGRhdGEtdXBkYXRlPVwiaWNvbi1mb250XCI+SWNvbiAtIGZvbnQ8L3NwYW4+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImljb24tZm9udFwiIHZhbHVlPVwiJyArIGRhdGFfZm9udF9pY29uICsgJ1wiIGRhdGEtb2xkPVwiJyArIGRhdGFfZm9udF9pY29uICsgJ1wiIGNsYXNzPVwiZm9ybS1jb250cm9sXCI+PC9sYWJlbD4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGxhYmVsIGNsYXNzPVwicGFkLWJvdC0xMFwiPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8c3BhbiBjbGFzcz1cInRleHQgcGFkLXRvcC01IGRpcy1pbmxpbmUtYmxvY2tcIiBkYXRhLXVwZGF0ZT1cImNsYXNzXCI+Q1NTIGNsYXNzPC9zcGFuPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLW9sZD1cIicgKyBkYXRhX2Nzc19jbGFzcyArICdcIiB2YWx1ZT1cIicgKyBkYXRhX2Nzc19jbGFzcyArICdcIiBuYW1lPVwiY2xhc3NcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8L2xhYmVsPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8bGFiZWwgY2xhc3M9XCJwYWQtYm90LTEwXCI+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwidGV4dCBwYWQtdG9wLTUgZGlzLWlubGluZS1ibG9ja1wiIGRhdGEtdXBkYXRlPVwidGFyZ2V0XCI+VGFyZ2V0PC9zcGFuPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDIyOHB4OyBkaXNwbGF5OiBpbmxpbmUtYmxvY2tcIj48c2VsZWN0IG5hbWU9XCJ0YXJnZXRcIiBpZD1cInRhcmdldFwiIGRhdGEtb2xkPVwiJyArIGRhdGFfdGFyZ2V0ICsgJ1wiIGNsYXNzPVwiZm9ybS1jb250cm9sIHNlbGVjdC1mdWxsXCI+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJfc2VsZlwiPk9wZW4gbGluayBkaXJlY3RseTwvb3B0aW9uPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiX2JsYW5rXCIgJyArIChkYXRhX3RhcmdldCA9PT0gJ19ibGFuaycgPyAnc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyA6ICcnKSArICc+T3BlbiBsaW5rIGluIG5ldyB0YWI8L29wdGlvbj4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPC9zZWxlY3Q+PC9kaXY+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvbGFiZWw+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJ0ZXh0LXJpZ2h0XCI+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxhIGNsYXNzPVwiYnRuIHJlZCBidG4tcmVtb3ZlXCIgaHJlZj1cIiNcIj5SZW1vdmU8L2E+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxhIGNsYXNzPVwiYnRuIGJsdWUgYnRuLWNhbmNlbFwiIGhyZWY9XCIjXCI+Q2FuY2VsPC9hPic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJjbGVhcmZpeFwiPjwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8L2xpPic7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuZmluZCgnaW5wdXRbdHlwZT1cInRleHRcIl0nKS52YWwoJycpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmZpbmQoJy5saXN0LWl0ZW0gbGkuYWN0aXZlJykuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmRfaW4gPSAkKGVsKS5maW5kKCc+IGxhYmVsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFfdHlwZSA9IHNhbml0aXplSFRNTChmaW5kX2luLmF0dHIoJ2RhdGEtcmVmZXJlbmNlLXR5cGUnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFfcmVmZXJlbmNlX2lkID0gc2FuaXRpemVIVE1MKGZpbmRfaW4uYXR0cignZGF0YS1yZWZlcmVuY2UtaWQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFfdGl0bGUgPSBzYW5pdGl6ZUhUTUwoZmluZF9pbi5hdHRyKCdkYXRhLXRpdGxlJykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8bGkgZGF0YS1yZWZlcmVuY2UtdHlwZT1cIicgKyBkYXRhX3R5cGUgKyAnXCIgZGF0YS1yZWZlcmVuY2UtaWQ9XCInICsgZGF0YV9yZWZlcmVuY2VfaWQgKyAnXCIgZGF0YS10aXRsZT1cIicgKyBkYXRhX3RpdGxlICsgJ1wiIGRhdGEtaWQ9XCIwXCIgZGF0YS10YXJnZXQ9XCJfc2VsZlwiIGNsYXNzPVwiZGQtaXRlbSBkZDMtaXRlbVwiPic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cImRkLWhhbmRsZSBkZDMtaGFuZGxlXCI+PC9kaXY+JztcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwiZGQzLWNvbnRlbnRcIj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwidGV4dCBmbG9hdC1sZWZ0XCIgZGF0YS11cGRhdGU9XCJ0aXRsZVwiPicgKyBkYXRhX3RpdGxlICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwidGV4dCBmbG9hdC1yaWdodFwiPicgKyBkYXRhX3R5cGUgKyAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cInNob3ctaXRlbS1kZXRhaWxzXCI+PGkgY2xhc3M9XCJmYSBmYS1hbmdsZS1kb3duXCI+PC9pPjwvYT4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJjbGVhcmZpeFwiPjwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwiaXRlbS1kZXRhaWxzXCI+JztcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8bGFiZWwgY2xhc3M9XCJwYWQtYm90LTVcIj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwidGV4dCBwYWQtdG9wLTUgZGlzLWlubGluZS1ibG9ja1wiIGRhdGEtdXBkYXRlPVwidGl0bGVcIj5UaXRsZTwvc3Bhbj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtb2xkPVwiJyArIGRhdGFfdGl0bGUgKyAnXCIgdmFsdWU9XCInICsgZGF0YV90aXRsZSArICdcIiBuYW1lPVwidGl0bGVcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiPic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPC9sYWJlbD4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxsYWJlbCBjbGFzcz1cInBhZC1ib3QtNSBkaXMtaW5saW5lLWJsb2NrXCI+PHNwYW4gY2xhc3M9XCJ0ZXh0IHBhZC10b3AtNVwiIGRhdGEtdXBkYXRlPVwiaWNvbi1mb250XCI+SWNvbiAtIGZvbnQ8L3NwYW4+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImljb24tZm9udFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCI+PC9sYWJlbD4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxsYWJlbCBjbGFzcz1cInBhZC1ib3QtMTBcIj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwidGV4dCBwYWQtdG9wLTUgZGlzLWlubGluZS1ibG9ja1wiIGRhdGEtdXBkYXRlPVwiY2xhc3NcIj5DU1MgY2xhc3M8L3NwYW4+JztcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiY2xhc3NcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiPic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPC9sYWJlbD4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxsYWJlbCBjbGFzcz1cInBhZC1ib3QtMTBcIj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwidGV4dCBwYWQtdG9wLTUgZGlzLWlubGluZS1ibG9ja1wiIGRhdGEtdXBkYXRlPVwidGFyZ2V0XCI+VGFyZ2V0PC9zcGFuPic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBzdHlsZT1cIndpZHRoOiAyMjhweDsgZGlzcGxheTogaW5saW5lLWJsb2NrXCI+PHNlbGVjdCBuYW1lPVwidGFyZ2V0XCIgaWQ9XCJ0YXJnZXRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBzZWxlY3QtZnVsbFwiPic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIl9zZWxmXCI+T3BlbiBsaW5rIGRpcmVjdGx5PC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiX2JsYW5rXCI+T3BlbiBsaW5rIGluIG5ldyB0YWI8L29wdGlvbj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvc2VsZWN0PjwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPC9sYWJlbD4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJ0ZXh0LXJpZ2h0XCI+JztcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8YSBjbGFzcz1cImJ0biByZWQgYnRuLXJlbW92ZVwiIGhyZWY9XCIjXCI+UmVtb3ZlPC9hPic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPGEgY2xhc3M9XCJidG4gYmx1ZSBidG4tY2FuY2VsXCIgaHJlZj1cIiNcIj5DYW5jZWw8L2E+JztcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cImNsZWFyZml4XCI+PC9kaXY+JztcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8L2xpPic7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICQoZWwpLmZpbmQoJ2lucHV0W3R5cGU9Y2hlY2tib3hdJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAkKCcubmVzdGFibGUtbWVudSA+IG9sLmRkLWxpc3QnKS5hcHBlbmQoaHRtbC5yZXBsYWNlKCc8c2NyaXB0PicsICcnKS5yZXBsYWNlKCc8XFxcXC9zY3JpcHQ+JywgJycpKTtcclxuXHJcbiAgICAgICAgICAgICQoJy5uZXN0YWJsZS1tZW51JykuZmluZCgnLnNlbGVjdC1mdWxsJykuc2VsZWN0Mih7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICAgICAgbWluaW11bVJlc3VsdHNGb3JTZWFyY2g6IC0xXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hhbmdlIGpzb25cclxuICAgICAgICAgICAgdGhhdC5zZXREYXRhSXRlbSh0aGF0LiRuZXN0YWJsZS5maW5kKCc+IG9sLmRkLWxpc3QgbGkuZGQtaXRlbScpKTtcclxuICAgICAgICAgICAgcGFyZW50LmZpbmQoJy5saXN0LWl0ZW0gbGkuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbm9kZXNcclxuICAgICAgICAkKCcuZm9ybS1zYXZlLW1lbnUgaW5wdXRbbmFtZT1cImRlbGV0ZWRfbm9kZXNcIl0nKS52YWwoJycpO1xyXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcubmVzdGFibGUtbWVudSAuaXRlbS1kZXRhaWxzIC5idG4tcmVtb3ZlJywgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIGxldCBkZF9pdGVtID0gY3VycmVudC5wYXJlbnRzKCcuaXRlbS1kZXRhaWxzJykucGFyZW50KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgJGVsbSA9ICQoJy5mb3JtLXNhdmUtbWVudSBpbnB1dFtuYW1lPVwiZGVsZXRlZF9ub2Rlc1wiXScpO1xyXG4gICAgICAgICAgICAvLyBBZGQgaWQgb2YgZGVsZXRlZCBub2RlcyB0byBkZWxldGUgaW4gY29udHJvbGxlclxyXG4gICAgICAgICAgICAkZWxtLnZhbCgkZWxtLnZhbCgpICsgJyAnICsgZGRfaXRlbS5hdHRyKCdkYXRhLWlkJykpO1xyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBkZF9pdGVtLmZpbmQoJz4gLmRkLWxpc3QnKS5odG1sKCk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiAhPT0gJycgJiYgY2hpbGRyZW4gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGRfaXRlbS5iZWZvcmUoY2hpbGRyZW4ucmVwbGFjZSgnPHNjcmlwdD4nLCAnJykucmVwbGFjZSgnPFxcXFwvc2NyaXB0PicsICcnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGRfaXRlbS5yZW1vdmUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5uZXN0YWJsZS1tZW51IC5pdGVtLWRldGFpbHMgLmJ0bi1jYW5jZWwnLCBldmVudCA9PiB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50X3BhID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnRfcGEucGFyZW50cygnLml0ZW0tZGV0YWlscycpLnBhcmVudCgpO1xyXG4gICAgICAgICAgICBwYXJlbnQuZmluZCgnaW5wdXRbdHlwZT1cInRleHRcIl0nKS5lYWNoKChpbmRleCwgZWwpID0+IHtcclxuICAgICAgICAgICAgICAgICQoZWwpLnZhbCgkKGVsKS5hdHRyKCdkYXRhLW9sZCcpKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBwYXJlbnQuZmluZCgnc2VsZWN0JykuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAkKGVsKS52YWwoJChlbCkudmFsKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHBhcmVudC5maW5kKCdpbnB1dFt0eXBlPVwidGV4dFwiXScpLnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgICAgICBwYXJlbnQuZmluZCgnc2VsZWN0JykudHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjaGFuZ2UnLCAnLmJveC1saW5rcy1mb3ItbWVudSAubGlzdC1pdGVtIGxpIGlucHV0W3R5cGU9Y2hlY2tib3hdJywgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoJ2xpJykudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkKGRvY3VtZW50KS5vbignc3VibWl0JywgJy5mb3JtLXNhdmUtbWVudScsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoYXQuJG5lc3RhYmxlLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgICAgICQoJyNuZXN0YWJsZS1vdXRwdXQnKS52YWwoJ1tdJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmVzdGFibGVfb2JqX3JldHVybmVkID0gdGhhdC4kbmVzdGFibGUubmVzdGFibGUoJ3NlcmlhbGl6ZScpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRoZV9vYmogPSB0aGF0LnVwZGF0ZVBvc2l0aW9uRm9yU2VyaWFsaXplZE9iaihuZXN0YWJsZV9vYmpfcmV0dXJuZWQpO1xyXG4gICAgICAgICAgICAgICAgJCgnI25lc3RhYmxlLW91dHB1dCcpLnZhbChKU09OLnN0cmluZ2lmeSh0aGVfb2JqKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IGFjY29yZGlvbiA9ICQoJyNhY2NvcmRpb24nKTtcclxuXHJcbiAgICAgICAgbGV0IHRvZ2dsZUNoZXZyb24gPSBldmVudCA9PiB7XHJcbiAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5wcmV2KCcud2lkZ2V0LWhlYWRpbmcnKS5maW5kKCcubmFycm93LWljb24nKS50b2dnbGVDbGFzcygnZmEtYW5nbGUtZG93biBmYS1hbmdsZS11cCcpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGFjY29yZGlvbi5vbignaGlkZGVuLmJzLmNvbGxhcHNlJywgdG9nZ2xlQ2hldnJvbik7XHJcbiAgICAgICAgYWNjb3JkaW9uLm9uKCdzaG93bi5icy5jb2xsYXBzZScsIHRvZ2dsZUNoZXZyb24pO1xyXG5cclxuICAgICAgICBaSFhDb3JlLmNhbGxTY3JvbGwoJCgnLmxpc3QtaXRlbScpKTtcclxuICAgIH1cclxufVxyXG5cclxuJCh3aW5kb3cpLm9uKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgbmV3IE1lbnVOZXN0YWJsZSgpLmluaXQoKTtcclxufSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./platform/packages/menu/resources/assets/js/menu.js\n");

/***/ }),

/***/ 166:
/*!******************************************************************!*\
  !*** multi ./platform/packages/menu/resources/assets/js/menu.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! E:\Jaydeep Mor\Work\Evolution IT Solutions\zhxcore\zhxcore_admin\platform\packages\menu\resources\assets\js\menu.js */"./platform/packages/menu/resources/assets/js/menu.js");


/***/ })

/******/ });